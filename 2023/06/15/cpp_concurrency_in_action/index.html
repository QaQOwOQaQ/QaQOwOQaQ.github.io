<!DOCTYPE HTML>
<html lang="cn">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="C++ concurrency programming, cs">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>C++ concurrency programming | jyyyyyyyyyx</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">jyyyyyyyyyx</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>Contact</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">jyyyyyyyyyx</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			About
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/7.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">C++ concurrency programming</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">No tag</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/C/" class="post-category">
                                C++
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2023-06-15
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="C-Concurrency-In-Action"><a href="#C-Concurrency-In-Action" class="headerlink" title="C++ Concurrency In Action"></a>C++ Concurrency In Action</h1><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/Cpp_Concurrency_In_Action/README.md#C++%20Concurrency%20In%20Action">Book开源处,感觉翻译很烂</a></p>
<p>关于异常：</p>
<blockquote>
<p><strong>出现异常并不意味着程序本身出了问题，而是程序外部的输入无法让正常业务继续执行，这时应该执行的是异常业务，而异常就是这两种业务转接的桥梁——它提供一种机制，使得程序员在遵守一定规则之下，这个异常业务能够正确完成。</strong></p>
<p>异常安全的三个级别：noexcept,  basic, strong</p>
<p><a target="_blank" rel="noopener" href="https://01io.tech/error-handling-cpp-exception-safety/">ref</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/how-to-design-for-exception-safety?view=msvc-170">ref</a></p>
</blockquote>
<h2 id="P0-English"><a href="#P0-English" class="headerlink" title="P0 English"></a>P0 English</h2><p>spin：自旋转</p>
<p>unary predicate：一元谓词s</p>
<p>binary predicate：二元谓词</p>
<p>predicate：谓词</p>
<p>snapshot：快照</p>
<p>nice-to-have：可有可无</p>
<p>parallelism: 并行</p>
<p>serialization：串形</p>
<p>RAII: Resource Acqusition Is Initialization，资源获取即初始化</p>
<p>Abstraction penalty：抽象代价</p>
<p>daemon thread: 守护线程</p>
<p>invariants:不变量</p>
<p>race condition：条件竞争</p>
<p>grammar：语法</p>
<p>semantics：语义</p>
<p>malicious_function：恶意函数</p>
<p>hierarchical: 分层的</p>
<p>granularity: 粒度</p>
<p>idiom：惯用法</p>
<p>nest: 嵌套</p>
<p>recursive：互斥</p>
<p>synchronization：同步</p>
<p>condition variable：条件变量</p>
<p>future：期望</p>
<p>spurious wakeup：伪唤醒</p>
<p>asynchronization：异步</p>
<p>pivot：枢纽</p>
<p>chrono：时间</p>
<h2 id="P1-Hello-concurrency"><a href="#P1-Hello-concurrency" class="headerlink" title="P1 Hello, concurrency"></a>P1 Hello, concurrency</h2><p><strong>contest switch</strong></p>
<blockquote>
<p>save cpu state and instruction pointer, calculate which task should we switched, and load new cpu state. then, cpu will load the instruction and data in cache</p>
</blockquote>
<p><strong>hardware concurrency</strong></p>
<blockquote>
<p>truly concurrency</p>
</blockquote>
<p><strong>the way of concurrency</strong></p>
<blockquote>
<ol>
<li><p>Multiprocessing concurrency: need to IPC, so more complex and more slowly, but it has good isolation and more safety</p>
</li>
<li><p>Multithreading concurrency: need to solve concurrency problem carefully</p>
</li>
</ol>
</blockquote>
<p>**Warning: **this book base on multiply thread concurrency</p>
<p><strong>why need to concurrency:</strong> only one for code <strong>ioslation</strong> and other for <strong>prefomance</strong></p>
<p><strong>test code:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, Concurrency!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(hello)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="P2-Thread-management"><a href="#P2-Thread-management" class="headerlink" title="P2 Thread management"></a>P2 Thread management</h2><h3 id="2-1-preface"><a href="#2-1-preface" class="headerlink" title="2.1 preface"></a>2.1 preface</h3><h4 id="2-1-1-generalize"><a href="#2-1-1-generalize" class="headerlink" title="2.1.1 generalize"></a>2.1.1 generalize</h4><blockquote>
<ol>
<li>create and run a new thread</li>
<li>join or detain thread</li>
<li>unique identify of thread</li>
</ol>
</blockquote>
<h4 id="2-1-2-start-thread"><a href="#2-1-2-start-thread" class="headerlink" title="2.1.2 start thread"></a>2.1.2 start thread</h4><p>thread run when you create a object of <code>std::thread</code></p>
<p><code>std::thread</code> can create a object by <code>function object</code>, like this example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, Concurrency!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">background_task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Hello, I am a new thread!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// do something else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Good bye~&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    background_task f;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(f)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>But, if you want to pass a tempate object to <code>std::thread</code>, in this way:<code>thread my_t(background_task());</code></p>
<p>You will found this run with error: <code>my_t is a declaration of funtion</code></p>
<p>This is because C++’s <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Most_vexing_parse">most vexing parse</a>, in that declaration, my_t will be parsed in a funtion but a object, you can solve this by following way:</p>
<ol>
<li>use of an extra parenthesis: <code>thread t(( background_task() ));</code></li>
<li>use C++11 initialization: <code>thread t&#123; background_task() &#125;;</code></li>
<li>use C++11 lambda:</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread <span class="title">t</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    cout &lt;&lt; <span class="string">&quot;Hello, this is a thread!&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    cout &lt;&lt; <span class="string">&quot;byt~&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>If you doesn’t decide join or detain your thread, then it will call dtor(<code>std::terminate()</code>).</p>
<h4 id="2-1-2-join-thread"><a href="#2-1-2-join-thread" class="headerlink" title="2.1.2 join thread"></a>2.1.2 join thread</h4><p>If you detach a thread like this way:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> &amp;i;</span><br><span class="line">    <span class="built_in">func</span>(<span class="type">int</span> &amp;_i) : <span class="built_in">i</span>(_i) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">1024</span> * <span class="number">1024</span>; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; j &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;-Hello,World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oops</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> local_state = <span class="number">1024</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(local_state)</span></span>;</span><br><span class="line">    <span class="built_in">my_func</span>();</span><br><span class="line">    <span class="function">thread <span class="title">my_thread</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    my_thread.<span class="built_in">detach</span>(); <span class="comment">// wrong!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">oops</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>In <code>std::thread my_thread</code>, we pass by value of <code>my_func</code> and access local object in <code>func::operator()</code> , if funtion <code>oops</code> exit before thread <code>my_thread</code> exit, then <code>my_thread</code> will access local value which is destoryed, and the behaviour when it happened is UB. </p>
<blockquote>
<p>so it is important to choose a valid way to wait you thread.</p>
<p>and a programming habit is <strong>do not create a thread which can access local object</strong></p>
</blockquote>
<p>A easy and rude way to wait a thread until exit is <code>join</code></p>
<p>if you call <code>join</code>, the resoures about thread will clean automatilly, and you cant call <code>join</code> double times and more.</p>
<p>you can call <code>joinable()</code> to get if you can join, it return false if you haved joined </p>
<h4 id="2-1-3-join-in-special-condition"><a href="#2-1-3-join-in-special-condition" class="headerlink" title="2.1.3 join in special condition"></a>2.1.3 join in special condition</h4><p>Look the next code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(thread &amp;<span class="type">_t</span>)</span> : t(_t) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">thread_guard</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~ thread_guard&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(t.<span class="built_in">joinable</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~ end&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">thread_guard</span>(thread_guard <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    thread_guard&amp; <span class="keyword">operator</span>=(thread_guard <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    thread &amp;t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;function f() do something here..&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span>(<span class="built_in">string</span>(<span class="string">&quot;No reason exception&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> local_state = <span class="number">1024</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(local_state)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">    <span class="comment">// if do_something() throw exception</span></span><br><span class="line">    <span class="comment">// then t.join will be skiped and t would call terminate</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(string &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch in main: &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>In function <code>f()</code>, if <code>do_something()</code> throw exception, and not catched, then <code>f()</code> wiil exit and skiped <code>join()</code></p>
<p>A solution is followings:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;function f() do something here..&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span>(<span class="built_in">string</span>(<span class="string">&quot;No reason exception&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> local_state = <span class="number">1024</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(local_state)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">do_something</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(string &amp;e) <span class="comment">// (1)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch in f: &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(string &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch in main: &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>But, a better way is in RAII</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">thread_guard</span>(thread&amp; <span class="type">_t</span>) : <span class="built_in">t</span>(<span class="type">_t</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">thread_guard</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~thread_guard&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(t.<span class="built_in">joinable</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~thread_guard end&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">thread_guard</span>(<span class="type">const</span> thread&amp; <span class="type">_t</span>)=<span class="keyword">delete</span>;</span><br><span class="line">    thread_guard&amp; <span class="keyword">operator</span>=(<span class="type">const</span> thread&amp; <span class="type">_t</span>) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    thread &amp;t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;function f() do something here..&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span>(<span class="built_in">string</span>(<span class="string">&quot;No reason exception&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> local_state = <span class="number">1024</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(local_state)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="function">thread_guard <span class="title">g</span><span class="params">(t)</span></span>;</span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">    <span class="comment">// the next will skiped if do_something() throw exception</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;f() end&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(string &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch in main: &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this way, although <code>do_something()</code> will throw exception and skip <code>join</code>, the object <code>g</code> will call <code>dtor</code> to <code>join</code> the thread he managed</p>
<h4 id="2-1-4-detach-thread"><a href="#2-1-4-detach-thread" class="headerlink" title="2.1.4 detach thread"></a>2.1.4 detach thread</h4><h3 id="2-2-pass-value"><a href="#2-2-pass-value" class="headerlink" title="2.2 pass value"></a>2.2 pass value</h3><p>Whaterver the parameters type you set(reference or value), thread will <strong>copy</strong> always! Just copy all arguments in the memory space itself.</p>
<p>In the following code, function <code>f()</code> receive a int pass by value and a string pass by reference</p>
<p>And because we detach the thread <code>t</code>, so we would can’t receiver it’s output.</p>
<blockquote>
<p>在下面的代码中，函数 f 打印的 s 可能会乱码，这是因为函数 buf 实际上是一个指针变量，它指向局部变量。</p>
<p>并且它的类型是 <code>const char *</code>，当我们把它传递给 <code>string</code> 时，会执行一个隐式类型转换。</p>
<p>但是，我们无法确保隐式类型转换与 thread 传递参数时进行 copy 的执行顺序问题， 也就是说，有可能传递给 string 的事转换前的变量（buf 只想的指针）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i, string <span class="type">const</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;string: &quot;</span> &lt;&lt; s &lt;&lt; endl; <span class="comment">// string s will chaos</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;value = %i&quot;</span>, value);</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(f, value, buf)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func end&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So, the solution is easy, explicit call type convention</p>
<p><code>thread t(f, value, string(buf));</code></p>
<hr>
<p>But, sometimes, we actually want to pass by refernece, the solution is use <code>std::ref</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread: &quot;</span> &lt;&lt; &amp;i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1024</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func: &quot;</span> &lt;&lt; &amp;value &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(f, ref(value))</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func end&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Also, you can pass class funtion and it’s this object</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;val: &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X x;</span><br><span class="line">    x.val = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// pass pointer </span></span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(&amp;X::do_work, &amp;x)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func end&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>But, for some type, the operator assignment or operator copy is deleted, like <code>unique_ptr&lt;&gt;</code>, so should <code>move</code> but copy.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(unique_ptr&lt;<span class="type">int</span>&gt; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(f, move(q))</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func() end&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It would CE If you not use <code>std::move</code>.</p>
<blockquote>
<p>Thread cant copt too.</p>
</blockquote>
<h3 id="2-3-transfer-possessiveness"><a href="#2-3-transfer-possessiveness" class="headerlink" title="2.3 transfer possessiveness"></a>2.3 transfer possessiveness</h3><h4 id="2-3-1-preface"><a href="#2-3-1-preface" class="headerlink" title="2.3.1 preface"></a>2.3.1 preface</h4><p>你不能通过赋新值操作来“丢弃”一个线程，即：你不能将一个线程 move 到一个已经分配了任务的线程。</p>
<p>你也不可以将一个线程 copy 到另一个线程，但是你可以将一个线程 move 到另一个空线程。</p>
<p>对于下面的形式（1）是合法的，因为 <code>thread(f)</code> 是一个临时对象 – 移动操作会隐式的调用，如果是一个 <code>具名对象</code>， 就需要显示的调用 <code>move</code>，如 (2) 所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">thread t;</span><br><span class="line">t = <span class="built_in">thread</span>(f); <span class="comment">// (1)</span></span><br><span class="line">thread t2 = <span class="built_in">move</span>(f); <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure>

<p>但是对于 (3) 所示就会 CE：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread t;</span><br><span class="line">t = <span class="built_in">thread</span>(f);</span><br><span class="line">thread t2 = <span class="built_in">move</span>(t);</span><br><span class="line">t = <span class="built_in">thread</span>(f);</span><br><span class="line">t2 = <span class="built_in">move</span>(t);   <span class="comment">// (3) t2 已经被分配</span></span><br><span class="line">t2.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>



<h4 id="2-3-2-scoped-thread"><a href="#2-3-2-scoped-thread" class="headerlink" title="2.3.2 scoped_thread"></a>2.3.2 scoped_thread</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">scoped_thread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_thread</span><span class="params">(std::thread <span class="type">_t</span>)</span> </span></span><br><span class="line"><span class="function">        : t(std::move(_t)) </span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="keyword">if</span>(!t.<span class="built_in">joinable</span>())</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;No thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">scoped_thread</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scoped_thread</span>(<span class="type">const</span> scoped_thread&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    scoped_thread&amp; <span class="keyword">operator</span>=(<span class="type">const</span> scoped_thread&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    thread t;   <span class="comment">// 不能是引用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> local_value = <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">// 下面药多加一对括号，否则会被认定为函数的声明</span></span><br><span class="line">    <span class="comment">// 通过 move，我们就无需创建具名对象来创建 thread</span></span><br><span class="line">    <span class="function">scoped_thread <span class="title">t</span><span class="params">((std::thread(func(local_value))))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func() end&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>疑问？</p>
<p>为啥不把 ctor 里的 t 设置为右值引用呢？</p>
</blockquote>
<h4 id="2-3-3-jpthread"><a href="#2-3-3-jpthread" class="headerlink" title="2.3.3 jpthread"></a>2.3.3 jpthread</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">scoped_thread</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">joining_thread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">joining_thread</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>; <span class="comment">// ??</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">joining_thread</span><span class="params">(Callable &amp;&amp;func, Args&amp;&amp; ...args)</span></span></span><br><span class="line"><span class="function">        :t(std::forward&lt;Callable&gt;(func), std::forward&lt;Args&gt;(args) ...) // ???</span></span><br><span class="line"><span class="function">        &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">joining_thread</span>(joining_thread &amp;&amp;other) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">t</span>(std::<span class="built_in">move</span>(other.t))</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">joining_thread</span>(thread <span class="type">_t</span>) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">t</span>(std::<span class="built_in">move</span>(<span class="type">_t</span>))</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">    joining_thread&amp; <span class="keyword">operator</span>=(joining_thread &amp;&amp;other) <span class="keyword">noexcept</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">joinable</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        t = std::<span class="built_in">move</span>(other.t);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为啥不是 thread &amp;&amp;t</span></span><br><span class="line">    joining_thread&amp; <span class="keyword">operator</span>=(thread t) <span class="keyword">noexcept</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">joinable</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        t = std::<span class="built_in">move</span>(t);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">joining_thread</span>() <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">joinable</span>())</span><br><span class="line">            <span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(joining_thread &amp;other)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        t.<span class="built_in">swap</span>(other.t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="function">thread::id <span class="title">get_id</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">get_id</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">joinable</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">joinable</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::thread&amp; <span class="title">as_thread</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread&amp; <span class="title">as_thread</span><span class="params">()</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 将 const thread&amp; 的 const 属性去掉</span></span><br><span class="line">        <span class="comment">// 去掉 const 属性必须用 const_cast</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;thread&amp;&gt;(</span><br><span class="line">            <span class="comment">// 将 &amp;this 转换为 const 类型</span></span><br><span class="line">            <span class="comment">// 加上 const 属性用 static_cast</span></span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">const</span> joining_thread&amp;&gt;(*<span class="keyword">this</span>).<span class="built_in">as_thread</span>()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::thread t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>疑问？</p>
<p>为啥不把 ctor 中的 <code>thread t</code> 改为 <code>thread &amp;&amp;t</code> 呢？</p>
</blockquote>
<h3 id="2-4-determin-count-of-thread"><a href="#2-4-determin-count-of-thread" class="headerlink" title="2.4 determin count of thread"></a>2.4 determin count of thread</h3><p><code>thread::hardware_concurrency()</code> ：返回并发线程的数量。</p>
<p>并行版的 <code>std::accumulate</code></p>
<blockquote>
<p>因为数据范围并不大，因此得出的时间消耗意义不大！</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========================*/</span></span><br><span class="line"><span class="comment">/*      std::accumulate      */</span></span><br><span class="line"><span class="comment">/*    concurrency version    */</span></span><br><span class="line"><span class="comment">/*===========================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// just the warpped function of std::accumulate</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">accumulate_block</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator first, Iterator last, T&amp; result)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        result = std::<span class="built_in">accumulate</span>(first, last, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">parallel_accumulate</span><span class="params">(Iterator first, Iterator last, T init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">cul_t</span> = <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">ul_t</span> = <span class="type">unsigned</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">cul_t</span> length = std::<span class="built_in">distance</span>(first, last);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// special check</span></span><br><span class="line">    <span class="keyword">if</span>(!length)</span><br><span class="line">        <span class="keyword">return</span> init;</span><br><span class="line"></span><br><span class="line">    <span class="type">cul_t</span> min_pre_thread = <span class="number">25</span>; <span class="comment">// 一个线程至少处理 25 个任务</span></span><br><span class="line">    <span class="comment">// 最大线程数为：任务总数 / 每个线程处理的任务数量，上取整</span></span><br><span class="line">    <span class="type">cul_t</span> max_threads = (length + min_pre_thread - <span class="number">1</span>) / min_pre_thread;</span><br><span class="line">    </span><br><span class="line">    <span class="type">cul_t</span> hardware_thread = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为上下文切换的成本也很高，因此和系统真正的并发量取 min</span></span><br><span class="line">    <span class="type">cul_t</span> num_threads = std::<span class="built_in">min</span>(hardware_thread != <span class="number">0</span> ? hardware_thread : <span class="number">2</span>, max_threads);</span><br><span class="line">    <span class="comment">// 每个线程处理一个任务块</span></span><br><span class="line">    <span class="type">cul_t</span> block_size = length / num_threads;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;T&gt; <span class="title">results</span><span class="params">(num_threads)</span></span>; <span class="comment">// result[num_threads-1] uesed to save finally result</span></span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(num_threads - <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分块 </span></span><br><span class="line">    Iterator block_start = first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">ul_t</span> i = <span class="number">0</span>; i &lt; num_threads - <span class="number">1</span>; ++ i )</span><br><span class="line">    &#123;</span><br><span class="line">        Iterator block_end = block_start;</span><br><span class="line">        std::<span class="built_in">advance</span>(block_end, block_size);</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(</span><br><span class="line">            <span class="built_in">accumulate_block</span>&lt;Iterator, T&gt;(),</span><br><span class="line">            block_start, block_end, std::<span class="built_in">ref</span>(results[i])</span><br><span class="line">        );</span><br><span class="line">        block_start = block_end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最终可能不满一个整块，即可能不能切好分为一个块</span></span><br><span class="line">    <span class="built_in">accumulate_block</span>&lt;Iterator, T&gt;()(</span><br><span class="line">        block_start, last, results[num_threads - <span class="number">1</span>]</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计最终结果</span></span><br><span class="line">    for_each(threads.<span class="built_in">begin</span>(), threads.<span class="built_in">end</span>(), <span class="built_in">mem_fn</span>(&amp;thread::join));</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(results.<span class="built_in">begin</span>(), results.<span class="built_in">end</span>(), init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    vector&lt;ull&gt; num;</span><br><span class="line">    ull sum;</span><br><span class="line">    <span class="type">clock_t</span> cur;</span><br><span class="line">    <span class="type">const</span> ull MAX_REP = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span>(ull i = <span class="number">0</span>; i &lt; MAX_REP; i ++ )</span><br><span class="line">        num.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test std::accumulate</span></span><br><span class="line">    cur = <span class="built_in">clock</span>();</span><br><span class="line">    sum = <span class="built_in">accumulate</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>(), (ull)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;time = %.4lf\n&quot;</span>, (<span class="built_in">clock</span>()-cur) * <span class="number">1.0</span> / CLOCKS_PER_SEC);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sum: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// test concurrency accumulate</span></span><br><span class="line">    cur = <span class="built_in">clock</span>();</span><br><span class="line">    sum = <span class="built_in">parallel_accumulate</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>(), (ull)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;time = %.4lf\n&quot;</span>, (<span class="built_in">clock</span>()-cur) * <span class="number">1.0</span> / CLOCKS_PER_SEC);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sum: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="2-5-thread-id"><a href="#2-5-thread-id" class="headerlink" title="2.5 thread id"></a>2.5 thread id</h3><p><code>thread::get_id()</code>：如果线程没有执行，会打印：<code>thread::id of a non-executing thread</code></p>
<p><code>this_thread::get_id()</code> ： 返回当前线程的 id</p>
<p>线程标识符可以用来比较，排序，哈希等。</p>
<p>通过线程标识符可以实现不同的线程执行不同的任务。</p>
<p><code>get_id()</code> 的输出是依赖于实现的，但是C++ 标准规定相同 ID 的线程必须有相同的输出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line">thread::id master_thread_id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(this_thread::<span class="built_in">get_id</span>() == master_thread_id)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am master&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am slaver&quot;</span> &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    vector&lt;thread&gt; threads;</span><br><span class="line">    <span class="comment">// create master</span></span><br><span class="line">    <span class="function">thread <span class="title">master</span><span class="params">(fun, <span class="number">0</span>)</span></span>;</span><br><span class="line">    master_thread_id = master.<span class="built_in">get_id</span>();</span><br><span class="line">    threads.<span class="built_in">push_back</span>(<span class="built_in">move</span>(master));    <span class="comment">// must add move!</span></span><br><span class="line">    <span class="comment">// create slaver</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ )    threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(fun, i + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// join</span></span><br><span class="line">    for_each(threads.<span class="built_in">begin</span>(), threads.<span class="built_in">end</span>(), <span class="built_in">mem_fn</span>(&amp;thread::join));</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="P3-data-share"><a href="#P3-data-share" class="headerlink" title="P3 data share"></a>P3 data share</h2><h3 id="3-1-problems"><a href="#3-1-problems" class="headerlink" title="3.1 problems"></a>3.1 problems</h3><h4 id="3-1-1-race-condition"><a href="#3-1-1-race-condition" class="headerlink" title="3.1.1 race condition"></a>3.1.1 race condition</h4><p>条件竞争分为恶性条件竞争和良性条件竞争，良性条件竞争不会对系统有什么影响。</p>
<p>避免恶性条件竞争的方法：</p>
<ol>
<li>对数据结构采用某种保护机制，例如：mutex</li>
<li>无锁数据结构</li>
<li>事务</li>
</ol>
<h4 id="3-1-2-use-mutex-to-avoid-RC"><a href="#3-1-2-use-mutex-to-avoid-RC" class="headerlink" title="3.1.2 use mutex to avoid RC"></a>3.1.2 use mutex to avoid RC</h4><p>C++ 为我们提供了互斥量用来避免恶性条件竞争，我们可以通过实例化 <code>std::mutex</code> 创建互斥量，并通过 <code>lock()</code> 和 <code>unlock()</code> 进行上锁和解锁，但并不推荐你这么做，认为人总会犯错 😭</p>
<p>所以，类似智能指针，C++ 标准库为互斥量提供了一个 RAII 语法的模板类 <code>std::lock_guard</code>，其会在构造的时候自动上锁，并在析构的时候自动解锁。</p>
<p>他们都在 <code>&lt;mutex&gt;</code> 头文件当中。</p>
<p>示例程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========================*/</span></span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt; L; <span class="comment">// shared data</span></span><br><span class="line">mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_list</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">guard</span><span class="params">(m)</span></span>;</span><br><span class="line">    L.<span class="built_in">push_back</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">list_contains</span><span class="params">(<span class="type">int</span> value_to_find)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">guard</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(L.<span class="built_in">begin</span>(), L.<span class="built_in">end</span>(), value_to_find) != L.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )    L.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">list_contains</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但互斥量也不总是安全的，例如我们在一个类中返回了被保护数据的指针或引用时，会破坏对数据的保护，并且不会被互斥锁限制。</p>
<p>因此，对接口的设计需要相当谨慎，要确保互斥量能锁住任何对保护数据的访问，并且“不留后门”。</p>
<p>例如，在下面的程序当中，我们通过引用把被保护数据传递到互斥锁作用于之外，从而造成一个潜在的陷阱：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">some_data</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    string b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;You are a fool man😄...\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">data_wrapper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    some_data data;</span><br><span class="line">    std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">process_data</span><span class="params">(Function func)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">l</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="built_in">func</span>(data); <span class="comment">// 传递“保护”数据给用户函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">some_data *unprotected;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">malicious_function</span><span class="params">(some_data&amp; protected_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unprotected = &amp;protected_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data_wrapper x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.<span class="built_in">process_data</span>(malicious_function);</span><br><span class="line">    <span class="comment">// 现在，我么将一个被保护的数据拿出来了，并且可以随意处理</span></span><br><span class="line">    unprotected-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">Foo</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-mutex"><a href="#3-2-mutex" class="headerlink" title="3.2 mutex"></a>3.2 mutex</h3><h4 id="3-2-1-RC-between-interface"><a href="#3-2-1-RC-between-interface" class="headerlink" title="3.2.1 RC between interface"></a>3.2.1 RC between interface</h4><p>使用互斥量对数据进行保护并不能万事大吉。</p>
<p>例一：删除双链表中的一个节点</p>
<blockquote>
<p>当我们要删除双链表中的节点 <code>P</code> 时，仅仅对 P 添加互斥量是不行的，还需要对 <code>P-&gt;next</code>, <code>P-&gt;prev</code> 同时添加互斥锁。</p>
</blockquote>
<p>例二：堆栈</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s.<span class="built_in">empty</span>()) <span class="comment">// (1)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> value = s.<span class="built_in">top</span>(); <span class="comment">// (2)</span></span><br><span class="line">        s.<span class="built_in">pop</span>();             <span class="comment">// (3)</span></span><br><span class="line">        <span class="built_in">do_something</span>(value); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，当堆栈非空时，我们希望从中取出栈顶素，再调用 <code>pop()</code>，但其实 (1) 和 (2) 之间是有竞争条件的，也就是说，可能存在一个线程在 (1) 与 (2) 之间也掉用了 <code>pop()</code>。</p>
<p>另一个潜在的竞争条件发正在 (2) 和 (3) 之间，可能有两个线程先后执行了 <code>top()</code>，但没有执行 <code>pop()</code>，此时两个线程处理后 <code>value</code> 的值可能是相同的，这种错误很难定位，因为程序没有出错，出错的是你的逻辑。</p>
<blockquote>
<p>这就需要接口设计上有较大的改动，提议之一就是使用同一互斥量来保护 top()和 pop()。Tom Cargill[1]指出当一个对象的拷贝构造函数在栈中抛出一个异常，这样的处理方式就会有问题。在 Herb Sutter[2]看来，这个问题可以从“异常安全”的角度完美解决，不过潜在的条件竞争，可能会组成一些新的组合。</p>
</blockquote>
<p>一个很有意思的事情是，我们可能不得不面临例二中的竞争条件。在堆栈的 pop 操作中（有返回值），如果我们直接把容器元素 ”移动“ 到目标位置，可能会因为 <code>bad_alloc</code> 异常，也就是内存不足而导致数据没有拷贝出去，并且栈中的数据也杯破坏了。</p>
<p>因此，设计人员通常把这个操作操作分为两部分：</p>
<ol>
<li>top()</li>
<li>pop()</li>
</ol>
<p>由此来确保数据不会在内存不足时出错，但我们之前讨论过了，在 1 和 2 之间，有竞争条件。</p>
<p>但幸好，我们还有其它选项，尽管他们也不是完美的。</p>
<p><strong>solution1：将变量的引用作为参数，传入 pop() 函数中取得想要的”弹出值“</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; stk;</span><br><span class="line"><span class="comment">/*------------------------*/</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">stk.<span class="built_in">pop</span>(result);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种方法有明显的缺点：</p>
<ol>
<li>需要构造出一个栈中类型的实例用于接受目标值，这会导致空间和空间的额外开销等</li>
<li>要求类型必须支持赋值操作，很多类型即使支持移动构造和拷贝构造，可能也不支持赋值</li>
</ol>
</blockquote>
<p><strong>solution2：无异常抛出的拷贝构造函数或移动构造函数</strong></p>
<p><strong>solution3：返回指向弹出值的指针</strong></p>
<p><strong>solution4：“选项1 + 选项2”或 “选项1 + 选项3”</strong></p>
<p><strong>Example： thread safe stack</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">empty_stack</span> : exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[Error] empty stack!&quot;</span>; <span class="comment">// 不要添加格式控制符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsaft_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsaft_stack</span>() : <span class="built_in">data</span>(std::<span class="built_in">stack</span>&lt;T&gt;()) &#123;&#125;</span><br><span class="line">    <span class="built_in">threadsaft_stack</span>(<span class="type">const</span> threadsaft_stack &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在函数体而不是成员初始化列表中copy可以确保数据的正确性</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;</span><br><span class="line">        data = other.m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不提供太多接口</span></span><br><span class="line">    threadsaft_stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsaft_stack &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        data.<span class="built_in">push</span>(new_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>())    <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();    <span class="comment">// 检查是否为空</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在修改的堆栈前，分配出返回值</span></span><br><span class="line">        <span class="function"><span class="type">const</span> std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(std::make_shared&lt;T&gt;(data.top())))</span></span>;</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>())    <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">        <span class="comment">// 注意下面调用的都是 stack 的内置函数</span></span><br><span class="line">        value = data.<span class="built_in">top</span>();</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;T&gt; data;</span><br><span class="line">    std::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    threadsaft_stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++ )  s.<span class="built_in">push</span>(i);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;push done&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    s.<span class="built_in">pop</span>(x);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">Foo</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实本质上就是将原本的两个函数（top 和 pop）实现的操作集成到一个函数（pop）当中，这样就可以通过互斥量完成数据的保护。</p>
<p>通过一个函数修改我们的参数，很自然的有两种方式，一是返回值，而是传引用。</p>
<p>在返回值这种方式中，return 一个引用是危险的，这我们前面提到过。直接 return 值的话开销可能很大，因此我们考虑传出一个动态对象，而手动 new&#x2F;delete 不安全，因此使用智能指针。</p>
</blockquote>
<h4 id="3-2-2-deadlock"><a href="#3-2-2-deadlock" class="headerlink" title="3.2.2 deadlock"></a>3.2.2 deadlock</h4><p>避免死锁的方法：</p>
<ol>
<li>指定获得锁的顺序</li>
<li>一次性加全部锁</li>
<li>…</li>
</ol>
<p>C++ 标准库的 <code>std::lock</code> 可以一次性锁住多个互斥量并且没有死锁风险。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bank_account</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">bank_account</span><span class="params">(<span class="type">int</span> _balance)</span> : balance(_balance) &#123;</span>&#125;</span><br><span class="line">    <span class="type">int</span> balance;</span><br><span class="line">    std::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less_amount</span> : std::exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Too little money in your amount ^ ^ !&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transfer</span><span class="params">(bank_account &amp;from, bank_account &amp;to, <span class="type">int</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;from == &amp;to)    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(from.balance &lt; amount)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span>(<span class="built_in">less_amount</span>());</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">lock</span>(from.m, to.m);</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock1</span><span class="params">(from.m, std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock2</span><span class="params">(to.m, std::adopt_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    from.balance -= amount;</span><br><span class="line">    to.balance += amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">bank_account <span class="title">my_account</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">bank_account <span class="title">your_account</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(transfer, std::ref(my_account), std::ref(your_account), <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(transfer, std::ref(your_account), std::ref(my_account), <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(transfer, std::ref(my_account), std::ref(my_account), <span class="number">100</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;my_account.balance = &quot;</span> &lt;&lt; my_account.balance &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;your_account.balance = &quot;</span> &lt;&lt; your_account.balance &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然规定一个获得锁的顺序可以避免死锁，但他不是万能的，甚至说，会起到适得其反的效果，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bank_account</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">bank_account</span><span class="params">(<span class="type">int</span> _balance)</span> : balance(_balance) &#123;</span>&#125;</span><br><span class="line">    <span class="type">int</span> balance;</span><br><span class="line">    std::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less_amount</span> : std::exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Too little money in your amount ^ ^ !&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bank_swap</span><span class="params">(bank_account &amp;from, bank_account &amp;to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;from == &amp;to)    <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::lock(from.m, to.m);</span></span><br><span class="line">    from.m.<span class="built_in">lock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I get From, balance: &quot;</span> &lt;&lt; from.balance &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);   </span><br><span class="line">    </span><br><span class="line">    to.m.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock1</span><span class="params">(from.m, std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock2</span><span class="params">(to.m, std::adopt_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(from.balance, to.balance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">bank_account <span class="title">my_account</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">bank_account <span class="title">your_account</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(bank_swap, std::ref(my_account), std::ref(your_account))</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(bank_swap, std::ref(your_account), std::ref(my_account))</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;my_account.balance = &quot;</span> &lt;&lt; my_account.balance &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;your_account.balance = &quot;</span> &lt;&lt; your_account.balance &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们虽然在 <code>swap()</code> 中规定了获得锁的顺序，但是如果我们交换了 <code>swap()</code> 的参数顺序，那么结果就很可怕了！</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/lock_tag">std::defer_lock, std::try_to_lock, std::adopt_lock</a></p>
<table>
<thead>
<tr>
<th><code>defer_lock_t</code></th>
<th>不获得互斥的所有权</th>
</tr>
</thead>
<tbody><tr>
<td>try_to_lock_t</td>
<td>尝试获得互斥的所有权而不阻塞</td>
</tr>
<tr>
<td>adopt_lock_t</td>
<td>假设调用方线程已拥有互斥的所有权</td>
</tr>
</tbody></table>
</blockquote>
<p><strong>Advise to avoid deadlock：</strong></p>
<ol>
<li>避免嵌套锁，尽量只使用一个锁</li>
<li>避免在持有锁时调用用户提供的代码</li>
<li>使用固定顺序获取锁</li>
<li>使用层级锁</li>
</ol>
<h4 id="3-2-3-hierarchical-mutex"><a href="#3-2-3-hierarchical-mutex" class="headerlink" title="3.2.3 hierarchical_mutex"></a>3.2.3 hierarchical_mutex</h4><blockquote>
<p> <a target="_blank" rel="noopener" href="https://mysteriouspreserve.com/blog/2021/09/15/Hierarchical-Mutex/">reference</a></p>
</blockquote>
<p>层级锁的意义在于：在运行时约定是否进行检查，这个建议需要对应用层进行分层，并且识别在给定层上所有互斥量。</p>
<p>层级锁的核心就是：每个互斥量有一个层级值，线程只能以层级值递减的顺序获取锁，由此实现顺序性。</p>
<p>**Sample complement: **</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hierarchical_mutex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">hierarchical_mutex</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> value)</span></span></span><br><span class="line"><span class="function">        : hierarchichy_value(value), </span></span><br><span class="line"><span class="function">          previous_hierarchichy_value(<span class="number">0</span>)</span></span><br><span class="line"><span class="function">        &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">        internal_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">// 备份层级值</span></span><br><span class="line">        <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 恢复层级值</span></span><br><span class="line">        this_thread_hierarchy_value = previous_hierarchichy_value;</span><br><span class="line">        internal_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">        <span class="keyword">if</span>(!internal_mutex.<span class="built_in">try_lock</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex internal_mutex;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 需要构造的锁的层级值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hierarchichy_value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this_thread_hierarchy_value 的备份</span></span><br><span class="line">    <span class="comment">// 因为在 unlock 之后需要恢复上一次的值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> previous_hierarchichy_value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前的层级值，第二个锁的层级值必须小于该值</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">long</span> this_thread_hierarchy_value; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_for_hierarchy_violation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 如果需要构造的锁的层级值大于等于当前锁的层级值，不合法</span></span><br><span class="line">        <span class="keyword">if</span>(this_thread_hierarchy_value &lt;= hierarchichy_value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;mutex hierarchy violated&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update_hierarchy_value</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 更新当前锁的层级值</span></span><br><span class="line">        previous_hierarchichy_value = this_thread_hierarchy_value;</span><br><span class="line">        this_thread_hierarchy_value = hierarchichy_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能加 static</span></span><br><span class="line"><span class="function"><span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title">hierarchical_mutex::this_thread_hierarchy_value</span><span class="params">(ULONG_MAX)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">m1</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">m2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;F2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">lock_guard&lt;hierarchical_mutex&gt; <span class="title">lock</span><span class="params">(m1)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;F1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">lock_guard&lt;hierarchical_mutex&gt; <span class="title">lock</span><span class="params">(m2)</span></span>;</span><br><span class="line">    <span class="built_in">f2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">f1</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>初始化 static 成员时不能加 static，避免与 class 之外的 static 变量混淆</li>
<li>为什么将 this_thread_hierarchy_value 设置为 thread_local static ? 只有这样才能实现动态更新层级，当我们更新了 this_thread_hierarchy_value 的值之后，下一个创建的 hierarchical_mutex 对象使用的是更新之后的值。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Foo::x</span><span class="params">(<span class="number">1024</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo f;</span><br><span class="line">    cout &lt;&lt; f.x &lt;&lt; endl;    <span class="comment">// 1024</span></span><br><span class="line">    f.x = <span class="number">233</span>;</span><br><span class="line">    cout &lt;&lt; f.x&lt;&lt; endl;     <span class="comment">// 233</span></span><br><span class="line">    Foo g;</span><br><span class="line">    cout &lt;&lt; g.x &lt;&lt; endl;    <span class="comment">// 233</span></span><br><span class="line">    cout &lt;&lt; Foo::x &lt;&lt; endl; <span class="comment">// 233</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="3-2-4-std-uniqie-lock"><a href="#3-2-4-std-uniqie-lock" class="headerlink" title="3.2.4 std::uniqie_lock"></a>3.2.4 std::uniqie_lock</h4><p>对 swap 函数的改写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bank_account</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">bank_account</span><span class="params">(<span class="type">int</span> balance)</span> : balance&#123;</span>balance&#125; &#123;&#125;</span><br><span class="line">    <span class="type">int</span> balance;</span><br><span class="line">    std::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_swap</span><span class="params">(bank_account &amp;from, bank_account &amp;to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;from == &amp;to) <span class="keyword">return</span>; <span class="comment">// avoid deadlock in case of self transfer</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将互斥量传入 unique 表示该互斥量应该保持解锁状态（不应该再被其他线程上锁）</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(from.m, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock_b</span><span class="params">(to.m, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="comment">// std::defer_lock 留下未上锁的互斥量</span></span><br><span class="line">    std::<span class="built_in">lock</span>(lock_a, lock_b);</span><br><span class="line">    std::<span class="built_in">swap</span>(from.balance, to.balance);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bank_account my_account&#123;<span class="number">100</span>&#125;;</span><br><span class="line">    bank_account your_account&#123;<span class="number">50</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    std::thread t1&#123;my_swap, std::<span class="built_in">ref</span>(my_account), std::<span class="built_in">ref</span>(your_account)&#125;;</span><br><span class="line">    std::thread t2&#123;my_swap, std::<span class="built_in">ref</span>(your_account), std::<span class="built_in">ref</span>(my_account)&#125;;</span><br><span class="line">    std::thread t3&#123;my_swap, std::<span class="built_in">ref</span>(my_account), std::<span class="built_in">ref</span>(your_account)&#125;;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;my_account.balance = &quot;</span> &lt;&lt; my_account.balance &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;your_account.balance = &quot;</span> &lt;&lt; your_account.balance &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="3-2-5-Passing-of-mutex-ownership-in-different-domains"><a href="#3-2-5-Passing-of-mutex-ownership-in-different-domains" class="headerlink" title="3.2.5  Passing of mutex ownership in different domains"></a>3.2.5  Passing of mutex ownership in different domains</h4><p><code>std::unique_lock</code> 实例没有与自身相关的互斥量，互斥量的所有权可以通过<strong>移动操作</strong>， 在不同的实例间传递。</p>
<p>… 看不懂在干啥 😭</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">get_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> std::mutex some_mutex;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(some_mutex)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;get_lock()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> lock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(get_lock())</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;process_data()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(process_data)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="3-2-5-Lock-Granularity"><a href="#3-2-5-Lock-Granularity" class="headerlink" title="3.2.5 Lock Granularity"></a>3.2.5 Lock Granularity</h4><p>锁的粒度用来描述通过一个锁保护着的数据量大小。一个细粒度锁(a fine-grained lock) 能够保护较小的数据量，一个粗粒度锁(a coarse-grained lock)能保护较多的数据量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// private:</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> some_detail;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_detail</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> some_detail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Y</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Y</span>(<span class="type">int</span> _sd) : <span class="built_in">some_detail</span>(_sd) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Y &amp;lhs, <span class="type">const</span> Y &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(&amp;lhs == &amp;rhs)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> lhs_value = lhs.<span class="built_in">get_detail</span>(); <span class="comment">// (1)</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I get lhs value:&quot;</span> &lt;&lt; lhs_value &lt;&lt; endl;;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 锁的粒度小，在得到lhs_value之后</span></span><br><span class="line">        <span class="comment">// rhs_value可能不是获取lhs_value瞬间的值</span></span><br><span class="line">        <span class="comment">// 他的值可能被修改</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> rhs_value = rhs.<span class="built_in">get_detail</span>();  <span class="comment">// (2)</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I get rhs value!: &quot;</span> &lt;&lt; rhs_value &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> lhs_value == rhs_value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::thread::id master_id;</span><br><span class="line"></span><br><span class="line">Y a[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(this_thread::<span class="built_in">get_id</span>() == master_id) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]I am master!: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; (a[<span class="number">0</span>] == a[<span class="number">1</span>] ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]I am slaver: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">            a[id].some_detail = <span class="built_in">rand</span>() % <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    a[<span class="number">0</span>].some_detail = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>].some_detail = <span class="number">2</span>;</span><br><span class="line">    <span class="function">thread <span class="title">master</span><span class="params">(process, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    master_id = master.<span class="built_in">get_id</span>();</span><br><span class="line">    cout &lt;&lt; master.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    thread slaver[<span class="number">2</span>];</span><br><span class="line">    slaver[<span class="number">0</span>] = <span class="built_in">thread</span>(process, <span class="number">0</span>);</span><br><span class="line">    slaver[<span class="number">1</span>] = <span class="built_in">thread</span>(process, <span class="number">1</span>);</span><br><span class="line">    master.<span class="built_in">join</span>();</span><br><span class="line">    slaver[<span class="number">0</span>].<span class="built_in">join</span>();</span><br><span class="line">    slaver[<span class="number">1</span>].<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-3-subsititute-of-shared-data-protect"><a href="#3-3-subsititute-of-shared-data-protect" class="headerlink" title="3.3 subsititute of shared data protect"></a>3.3 subsititute of shared data protect</h3><h4 id="3-3-1-protect-initialization-process-of-data"><a href="#3-3-1-protect-initialization-process-of-data" class="headerlink" title="3.3.1 protect initialization process of data"></a>3.3.1 protect initialization process of data</h4><p>假设我们有一个共享源，构建代价很昂贵，他可能会打开一个数据库连接或分配出很多的资源。</p>
<p>Lazy Initialization 在单线程代码中很常见 —— 没一个操作都需要对源进行检查，了解数据是否被初始化，然后在其使用前决定，数据是否需要初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">some_resources</span>;</span><br><span class="line">std::shared_ptr&lt;some_resources&gt; resources_ptr;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!resources_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// lazy initialization</span></span><br><span class="line">        resources_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resources);</span><br><span class="line">    &#125;</span><br><span class="line">    resources_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多线程中，一种大粒度锁方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">some_resources</span>;</span><br><span class="line">std::shared_ptr&lt;some_resources&gt; resources_ptr;</span><br><span class="line">std::mutex resource_mutex;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(resource_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!resources_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        resources_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resources);</span><br><span class="line">    &#125;</span><br><span class="line">    resources_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声名狼藉的“双重检查锁模式”:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resources&gt; resources_ptr;</span><br><span class="line">std::mutex resource_mutex;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!resources_ptr)	<span class="comment">// 第一次检查</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在 if 与加锁之间，resources_ptr 可能被修改了</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(resource_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(!resources_ptr) <span class="comment">// 第二次检查</span></span><br><span class="line">        &#123;</span><br><span class="line">            resources_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resources); <span class="comment">// (1)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resources_ptr-&gt;<span class="built_in">do_something</span>(); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个模式声名狼藉的原因在于，存在潜在的条件竞争。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf">具体的可以参考这里</a></p>
</blockquote>
<p>论文太长，我粗略的看了一下，我们知道，new 是分为两步的：</p>
<ol>
<li>operator new(size_of_object)</li>
<li>ctor</li>
<li>assign</li>
</ol>
<p>文章给出代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Singleton *<span class="title">Singleton::instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pInstance == <span class="number">0</span>) &#123;</span><br><span class="line">        Lock lock;</span><br><span class="line">        <span class="keyword">if</span> (pInstance == <span class="number">0</span>) &#123;</span><br><span class="line">            pInstance =               <span class="comment">// Step 3</span></span><br><span class="line">            <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(Singleton)); <span class="comment">// Step 1</span></span><br><span class="line">            <span class="keyword">new</span> (pInstance) Singleton;    <span class="comment">// Step 2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文章的意思应该是，在 ctor 之前，对象还没被构建，此时指向它的指针为空，即使 ctor 完成了，我们还需要将其地址赋值给指向它的指针，而在ctor与assign之间，指针依然为空。</p>
<p>指针为空就意味着，第二次检查不一定是有效的，也即，仍然可能有多个线程进入 (1) 从而破坏数据，并且行为是未定义的！</p>
<hr>
<p>为了解决这种条件竞争，C++ 标准库提供了 <code>std::once_flag</code> 和 <code>std::call_once</code> ，并且使用 <code>std::call_one</code> 比使用互斥量消耗的资源更少。</p>
<blockquote>
<p><code>std::call_once</code> : 顾名思义，可以准确执行一次 callable object，其通过 <code>std::once_flag</code> 来判断是否被执行过，如果多次调用，会抛出异常。</p>
<p>call_one 分为:</p>
<ol>
<li>active call：第一次调用</li>
<li>passive call：后序调用</li>
<li>exceptional call：抛出异常的调用，不会修改 once_flag</li>
</ol>
</blockquote>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::once_flag flag1, flag2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simple_do_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(flag1, []()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Simple example: call one\n&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">may_throw_function</span><span class="params">(<span class="type">bool</span> do_throw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(do_throw)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;throw: call once will retry\n&quot;</span>;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Do no throw: call once will not attempt retry\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_once</span><span class="params">(<span class="type">bool</span> do_throw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">call_once</span>(flag2, may_throw_function, do_throw);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;get exception\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">st1</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">st2</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">st3</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">st4</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    st1.<span class="built_in">join</span>();</span><br><span class="line">    st2.<span class="built_in">join</span>();</span><br><span class="line">    st3.<span class="built_in">join</span>();</span><br><span class="line">    st4.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(do_once, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t4</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Foo</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此，可以将上面的例子修改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr;</span><br><span class="line">std::once_flag resource_flag;  <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_resource</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	resource_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::<span class="built_in">call_once</span>(resource_flag,init_resource); <span class="comment">// 可以完整的进行一次初始化</span></span><br><span class="line">	resource_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    std::once_flag flag;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;do once&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        std::<span class="built_in">call_once</span>(flag, &amp;X::do_once, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f2&quot;</span> &lt;&lt; endl;</span><br><span class="line">        std::<span class="built_in">call_once</span>(flag, &amp;X::do_once, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X x;</span><br><span class="line">    x.<span class="built_in">f1</span>();</span><br><span class="line">    x.<span class="built_in">f2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Foo</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1</span><br><span class="line">do once</span><br><span class="line">f2</span><br></pre></td></tr></table></figure>

<hr>
<p>局部 static 变量的线程安全的初始化方式（<code>std::call_once</code> 的替代方案）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span>;</span><br><span class="line"><span class="function">my_class&amp; <span class="title">get_my_class_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> my_class instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化和定义完全在一个线程中发生，并且没有其他线程可在初始化完成前对其进行处理。</p>
<p>其实这个就是例子设计模式(<strong>Singleton</strong>)的思路，让 static 变量在函数内部完成初始化，从而使得调用该对象时，该对象一定被初始化。</p>
<p>但是为什么呢？</p>
<p>其实主要是因为<strong>“C++只能保证在同一个文件中声明的static变量的初始化顺序与其变量声明的顺序一致。但是不能保证不同的文件中的static变量的初始化顺序。”</strong></p>
<p>然后对于单例模式而言，不同的单例对象之间进行调用也是常见的场景。比如我有一个单例，存储了程序启动时加载的配置文件的内容。另外有一个单例，掌管着一个全局的日志管理器。在日志管理初始化的时候，要通过配置文件的单例对象来获取到某个配置项，实现日志打印。</p>
<p>这时候两个单例在不同文件中各自实现，很有可能在日志管理器的单例使用配置文件单例的时候，配置文件的单例对象是没有被初始化的。这个未初始化可能产生的风险指的是C++变量的未初始化，而不是说配置文件未加载的之类业务逻辑上的未初始化导致的问题。</p>
<p>而<code>Meyers&#39; Singleton</code>写法中，单例对象是次访问的时候（也就是次调用<code>getInstance()</code>函数的时候）才初始化的，但也是恰恰因为如此，因而能保证如果没有初始化，在该函数调用的时候，是能完成初始化的。所以先<code>getInstance()</code>再访问 这种形式的单例 其关键并不是在于这个形式。而是在于其内容，局部static变量能保证通过函数来获取static变量的时候，该函数返回的对象是肯定完成了初始化的！</p>
<p>另外，该写法需要 C++11 的支持，因为在 C++11 之后，static 变量的初始化是线程安全的。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://z.itpub.net/article/detail/DC3250F681713244F01A546413CC2828">「详细信息参考这里—reference」</a></p>
</blockquote>
<h4 id="3-3-2-protect-data-struct-which-updatelessly"><a href="#3-3-2-protect-data-struct-which-updatelessly" class="headerlink" title="3.3.2 protect data struct which updatelessly"></a>3.3.2 protect data struct which updatelessly</h4><p>对于更新比较少，读取频繁的数据结构，使用 <code>std::mutex</code> 显得有些反应过激了，因为在没有修改时，它将削弱并发读取数据的可能性，因此，这里需要一种不同的互斥量 – 读写锁：一个“写”线程独立访问，多个 “读” 线程并发访问。</p>
<p>C++ 标准库暂时没有提供“读者-写者锁”，但是 Boost 库提供了支持 <code>boost::shared_lock</code> (读写锁)，通常用于读操作比较频繁的，而写操作比较少的情况。</p>
<p>读写锁比起mutex具有更高的适用性，具有更高的并行性，可以有多个线程同时占用读模式的读写锁，但是只能有一个线程占用写模式的读写锁，读写锁的基本规则可以总结为<strong>“write first，read shared，cross mutex(交叉互斥)”</strong>，具体表现为读写锁的三种状态：</p>
<ol>
<li>当读写锁是写加锁状态时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞。（交叉互斥）</li>
<li>当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是以写模式对它进行加锁的线程将会被阻塞。（读共享，交叉互斥）</li>
<li>当读写锁在读模式的锁状态时，如果有另外的线程试图以写模式加锁，读写锁通常会阻塞随后的读模式锁的请求，这样可以避免读模式锁长期占用，而等待的写模式锁请求则长期阻塞。（写优先）</li>
</ol>
<p>注：其实在读者-写者问题中，有读者优先和写者优先两种模式，只是在 <strong>shared_mutex which in boost library default complement in writing first</strong>，这其实也是有道理的，<strong>because we always want to read the least data</strong>，这就得保证写者优先。</p>
<p>例子：模拟 dns 缓存的修改和查询</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/thread/shared_mutex.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dns_entry</span></span><br><span class="line">&#123;</span><br><span class="line">    string domain;</span><br><span class="line">    string ip_addr;</span><br><span class="line">    <span class="comment">/*....*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dns_cache</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;std::string, dns_entry&gt; entries;   <span class="comment">// 缓存 dns 数据</span></span><br><span class="line">    <span class="keyword">mutable</span> boost::shared_mutex entry_mutex;    <span class="comment">// 对数据进行保护</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// from domin name to IP addr</span></span><br><span class="line">    <span class="function">dns_entry <span class="title">find_entry</span><span class="params">(<span class="type">const</span> std::string &amp;domain)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">boost::shared_lock&lt;boost::shared_mutex&gt; <span class="title">lk</span><span class="params">(entry_mutex)</span></span>; <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">auto</span> it = entries.<span class="built_in">find</span>(domain);</span><br><span class="line">        <span class="keyword">return</span> (it == entries.<span class="built_in">end</span>()) ? <span class="built_in">dns_entry</span>() : it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update_or_addr_entry</span><span class="params">(<span class="type">const</span> std::string &amp;domain, <span class="type">const</span> dns_entry &amp;dns_details)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;boost::shared_mutex&gt; <span class="title">lock</span><span class="params">(entry_mutex)</span></span>; <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="comment">// or add unique_lock&lt;boost::shared_mutex&gt;</span></span><br><span class="line">        entries[domain] = dns_details;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="3-3-3-nested-lock"><a href="#3-3-3-nested-lock" class="headerlink" title="3.3.3 nested lock"></a>3.3.3 nested lock</h4><p><code>std::recursive_mutex</code></p>
<h2 id="P4-synchronization"><a href="#P4-synchronization" class="headerlink" title="P4 synchronization"></a>P4 synchronization</h2><p>单单将数据保护起来并不能满足我们的需求。通常情况下，我们还想对单独的线程进行同步。例如，某个线程作为另一个线程的输入。</p>
<p>通过条件变量(<strong>condition variables</strong>)和期望(<strong>futures</strong>)实现线程之间的同步。</p>
<h3 id="4-1-wait-event-or-condition"><a href="#4-1-wait-event-or-condition" class="headerlink" title="4.1 wait event or condition"></a>4.1 wait event or condition</h3><h4 id="4-1-1-introduce"><a href="#4-1-1-introduce" class="headerlink" title="4.1.1 introduce"></a>4.1.1 introduce</h4><p>情景：我们需要等待一个事件。</p>
<p>最笨的方法是一直加锁，然后时间来临之后，处理事件，解锁。但是这种方法是很低效的，因为等待事件时我们持有锁但什么也不做。</p>
<p>进步的方法是下面这种（<code>std::this_thread::sleep_for()</code>），每隔一段时间就进行一次检查，但是这种方法的问题是，很难确定中间间隔的时间，太短或者太长了都不好！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/thread/shared_mutex.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag;</span><br><span class="line">std::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait_for_flag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(!flag)</span><br><span class="line">    &#123;</span><br><span class="line">        lk.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));    <span class="comment">// 100ms</span></span><br><span class="line">        lk.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">wait_for_flag</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好的办法就是使用条件变量，当时间发生时，广播“条件达成”的信息，由此出发等待该事件的线程。</p>
<h4 id="4-1-2-condition-variable"><a href="#4-1-2-condition-variable" class="headerlink" title="4.1.2 condition variable"></a>4.1.2 condition variable</h4><p>C++标准库对条件变量有两套实现：<code>std::condition_variable</code>和<code>std::condition_variable_any</code>。这两个实现都包含在<code>&lt;condition_variable&gt;</code>头文件的声明中。两者都需要与一个互斥量一起才能工作(互斥量是为了同步)；前者仅限于与<code>std::mutex</code>一起工作，而后者可以和任何满足最低标准的互斥量一起工作，从而加上了*_any*的后缀。因为<code>std::condition_variable_any</code>更加通用，这就可能从体积、性能，以及系统资源的使用方面产生额外的开销，所以<code>std::condition_variable</code>一般作为首选的类型，当对灵活性有硬性要求时，我们才会去考虑<code>std::condition_variable_any</code>。</p>
<p>下面是使用 <code>std::condition_variable</code> 处理等待数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">data_chunk</span> &#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">more_data_to_prepare</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> data_chunk&amp; <span class="title">prepare_data</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_last_chunk</span><span class="params">(<span class="type">const</span> data_chunk&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(data_chunk&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">std::mutex mut;</span><br><span class="line">std::queue&lt;data_chunk&gt; data_queue;</span><br><span class="line">std::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">more_data_to_prepare</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> data_chunk data = <span class="built_in">prepare_data</span>();</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(data);</span><br><span class="line">        data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">data_preocessing_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lock, []&#123; <span class="comment">// (1) 在这上锁 类似 try_lock</span></span><br><span class="line">            <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        data_chunk data = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        lock.<span class="built_in">unlock</span>();	<span class="comment">// (2) 记得解锁</span></span><br><span class="line">        <span class="built_in">process</span>(data);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">is_last_chunk</span>(data))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 (1) 中，如果条件不满足(<code>lambda</code> 返回 <code>false</code>)，<code>wait()</code> 函数将解锁互斥量，并将这个线程置于阻塞或等待状态。</p>
<p>当在 <code>data_preparation_thread</code> 中调用 <code>notify_one</code> 通知条件变量之后，处理数据的线程从睡眠状态中苏醒，重新获得互斥锁，并且对条件再次检查，当条件不满足时，线程将对互斥量解锁，并且重新开始等待，当条件满足时，从 <code>wait()</code> 返回并继续持有锁。</p>
<blockquote>
<p>注意在唤醒之后需要再次检查条件，因为可能还有其他线程也被唤醒，此时会有竞争。这就是所谓的**伪唤醒(spurious wakeup)**，</p>
</blockquote>
<p>这也是为甚么要使用 <code>std::unique_lock</code> 而不是 <code>std::lock_guard</code> 的原因 —— 等待中的线程必须在等待期间解锁互斥量，并在这之后对互斥量再次上锁，而 <code>std::lock_guard</code> 没有这么灵活。</p>
<blockquote>
<p>其实这也说明了 <code>std::unique_lock</code> 的主要用途 —— 和 <code>std::condition_variable</code> 配合使用，做到多次 <code>lock()</code> 和 <code>unlock()</code>。</p>
</blockquote>
<h4 id="4-1-3-thread-safety-queue"><a href="#4-1-3-thread-safety-queue" class="headerlink" title="4.1.3 thread safety queue"></a>4.1.3 thread safety queue</h4><p><code>std::queue</code> 接口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Container</span> = std::deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">queue</span>(<span class="type">const</span> Container&amp;);</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">queue</span><span class="params">(Container&amp;&amp; = Container())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="function"><span class="keyword">explicit</span> <span class="title">queue</span><span class="params">(<span class="type">const</span> Alloc&amp;)</span></span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="built_in">queue</span>(<span class="type">const</span> Container&amp;, <span class="type">const</span> Alloc&amp;);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="built_in">queue</span>(Container&amp;&amp;, <span class="type">const</span> Alloc&amp;);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="built_in">queue</span>(queue&amp;&amp;, <span class="type">const</span> Alloc&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(queue &amp;q)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T&amp;&amp; x)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt; <span class="type">void</span> <span class="title">emplace</span><span class="params">(Args&amp;&amp;... args)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>线程安全的队列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mut; <span class="comment">// 互斥量必须是可变的</span></span><br><span class="line">    std::queue&lt;T&gt; data_queue;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_queue</span>(<span class="type">const</span> threadsafe_queue&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;std::mutex&gt; <span class="title">my_lock</span><span class="params">(mut)</span></span>;    <span class="comment">// 为什么不对自己上锁呢？</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.mut)</span></span>;</span><br><span class="line">        data_queue = other.data_queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_queue</span>(threadsafe_queue&amp;&amp; other) <span class="comment">// 自己写的，可能有误？</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;std::mutex&gt; <span class="title">my_lock</span><span class="params">(mut)</span></span>;    <span class="comment">// 为什么不对自己上锁呢？</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.mut)</span></span>;</span><br><span class="line">        data_queue = <span class="built_in">move</span>(other.data_queue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    threadsafe_queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_queue&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(new_value);</span><br><span class="line">        data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T &amp;value)</span> <span class="comment">// 通过传引用获得 front 并 pop</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 防止 front-pop 接口之间存在的竞争条件</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = data_queue.<span class="built_in">front</span>(); <span class="comment">// get value</span></span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();    <span class="comment">// NULL</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        value = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        std::shared_ptr&lt;T&gt; res = (std::<span class="built_in">make_shared</span>&lt;T&gt;(data_queue.<span class="built_in">front</span>()));</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data_queue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line"></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同之前提到的一样，当我们执行 <code>front()-pop()</code> 时，会有接口之间的条件竞争，因此我们需要将这两个函数放到同一个函数中。</p>
<h3 id="4-2-future"><a href="#4-2-future" class="headerlink" title="4.2 future"></a>4.2 future</h3><h4 id="4-2-1-introdece"><a href="#4-2-1-introdece" class="headerlink" title="4.2.1 introdece"></a>4.2.1 introdece</h4><p>C++ 标准库模型将这种一次性事件成为**期望(future)**。当事件发生时，这个“期望”就不能被重置。</p>
<p>在C++标准库中，有两种“期望”，使用两种类型模板实现，声明在头文件中: 唯一<em>期望</em>(unique futures)(<code>std::future&lt;&gt;</code>)和<em>共享期望</em>(shared futures)(<code>std::shared_future&lt;&gt;</code>)。这是仿照<code>std::unique_ptr</code>和<code>std::shared_ptr</code>。<code>std::future</code>的实例只能与一个指定事件相关联，而<code>std::shared_future</code>的实例就能关联多个事件。后者的实现中，所有实例会在同时变为就绪状态，并且他们可以访问与事件相关的任何数据。这种数据关联与模板有关，比如<code>std::unique_ptr</code> 和<code>std::shared_ptr</code>的模板参数就是相关联的数据类型。在与数据无关的地方，可以使用<code>std::future&lt;void&gt;</code>与<code>std::shared_future&lt;void&gt;</code>的特化模板。虽然，我希望用于线程间的通讯，但是“期望”对象本身并不提供同步访问。当多个线程需要访问一个独立“期望”对象时，他们必须使用互斥量或类似同步机制对访问进行保护，如在第3章提到的那样。不过，在你将要阅读到的4.2.5节中，多个线程会对一个<code>std::shared_future&lt;&gt;</code>实例的副本进行访问，而不需要期望同步，即使他们是同一个异步结果。</p>
<p>最基本的一次性事件，就是一个后台运行出的计算结果。在第2章中，你已经了解了<code>std::thread</code> 执行的任务不能有返回值，并且我能保证，这个问题将在使用“期望”后解决——现在就来看看是怎么解决的。</p>
<h4 id="4-2-2-background-task-with-return-value-—-async"><a href="#4-2-2-background-task-with-return-value-—-async" class="headerlink" title="4.2.2 background task with return value — async"></a>4.2.2 background task with return value — async</h4><p>假设，你现在有一个需要长时间的运算，你需要能计算出一个有效的值，但是你现在并不迫切需要这个值。因为 <code>std::thread</code> 并不提供接受返回值的机制，这里就需要 <code>std::async</code> 函数模板（也就是在 <code>&lt;future&gt;</code> 中声明）</p>
<p>当不着急得到任务的结果时，你可以使用 <code>std::async</code> 启动一个<strong>异步</strong>任务，与 <code>std::thread</code> 对象等待的方式不同，<code>std::async</code> 会返回一个 <code>std::future</code> 对象，这个对象持有最终计算出来的结果，你只需要调用这个对象的 <code>get()</code> 成员函数；并且会阻塞线程直到“期望”状态未就绪为止。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_the_answer_to_ltuae</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; the_answer = std::<span class="built_in">async</span>(find_the_answer_to_ltuae);</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The answer is &quot;</span> &lt;&lt; the_answer.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>std::thread</code> 方式一样，<code>std::async</code> 允许通过添加额外的调用参数，想函数传递额外的参数。</p>
<p>例如，第一个参数是指向成员函数的指针，第二个参数是提供这个函数成员类的具体对象。</p>
<p>和 <code>std::thread</code> 一样，当参数是右值时，拷贝操作将使用移动的方式转移原始数据。</p>
<p>我们还可以在调用之前向 <code>std::async</code> 传递一个额外参数，这个参数的类型是 <code>std::launch</code>，它提供了两种策略可供选择：</p>
<ul>
<li><code>std::launch::async</code> ：在调用 <code>std::async</code> 之后就开始创建线程</li>
<li><code>std::launch::deferred</code> ： 延迟加载方式创建线程。调用 <code>std::async</code> 不创建线程，直到调用了 <code>future</code> 的 <code>get()</code> 或者 <code>wait()</code> 时才创建线程。（<strong>lazy calculate</strong>）</li>
</ul>
<p>默认策略是 <code>std::launch::async | std::launch::deferred</code></p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> std::string&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        i ++ ;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;] id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">bar</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;] id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f1 和 f2 可能在 main 结束之后才执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过指向 x 的指针调用 foo</span></span><br><span class="line"><span class="keyword">auto</span> f1 = std::<span class="built_in">async</span>(&amp;X::foo, &amp;x, <span class="number">42</span>, <span class="string">&quot;f1&quot;</span>);</span><br><span class="line"><span class="comment">// 通过 x 的拷贝调用 bar</span></span><br><span class="line"><span class="keyword">auto</span> f2 = std::<span class="built_in">async</span>(&amp;X::bar, x, <span class="string">&quot;f2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=============================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; d &lt;&lt; std::endl;</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;] id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 y 的移动构造函数调用 operator()</span></span><br><span class="line"><span class="keyword">auto</span> f3 = std::<span class="built_in">async</span>(<span class="built_in">Y</span>(), <span class="string">&quot;f3&quot;</span>);</span><br><span class="line"><span class="comment">// 通过 y 的引用调用 operator()</span></span><br><span class="line"><span class="keyword">auto</span> f4 = std::<span class="built_in">async</span>(std::<span class="built_in">ref</span>(y), <span class="string">&quot;f4&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=============================================*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">move_only</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">move_only</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">move_only</span>(move_only&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">move_only</span>(<span class="type">const</span> move_only&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    move_only&amp; <span class="keyword">operator</span>=(move_only&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    move_only&amp; <span class="keyword">operator</span>=(<span class="type">const</span> move_only&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string s)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;] id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move only!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f5 = std::<span class="built_in">async</span>(<span class="built_in">move_only</span>(), <span class="string">&quot;f5&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=============================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在新线程上执行</span></span><br><span class="line"><span class="keyword">auto</span> f6 = std::<span class="built_in">async</span>(std::launch::async, <span class="built_in">Y</span>(), <span class="string">&quot;f6&quot;</span>);</span><br><span class="line"><span class="comment">// 在 wait() 或 get() 调用时执行</span></span><br><span class="line"><span class="keyword">auto</span> f7 = std::<span class="built_in">async</span>(std::launch::deferred, &amp;X::bar, std::<span class="built_in">ref</span>(x), <span class="string">&quot;f7&quot;</span>);</span><br><span class="line"><span class="comment">// 实现选择执行方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std::string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;] id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> f8 = std::<span class="built_in">async</span>(std::launch::deferred | std::launch::async, f, <span class="string">&quot;f8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">// f7.wait();</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; hex &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// f8.get();</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::future</code> 有三种状态：</p>
<ul>
<li><code>future_status::deferred</code>：异步操作还未完成</li>
<li><code>future_status::ready</code> ：异步操作已经完成</li>
<li><code>future_status::timeout</code> ：异步操作超时，主要用于 <code>std::future&lt;T&gt;.wait_for()</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;step1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;step2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;step3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    std::future_status status;</span><br><span class="line">    <span class="keyword">auto</span> f = std::<span class="built_in">async</span>(std::launch::deferred ,process);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        status = f.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(status == std::future_status::deferred) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;deferred&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// f.wait();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(status == std::future_status::timeout) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;timeout&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(status == std::future_status::ready) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;ready&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(status != std::future_status::ready);</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039083151">reference</a></p>
</blockquote>
<h4 id="4-2-3-task-and-future"><a href="#4-2-3-task-and-future" class="headerlink" title="4.2.3 task and future"></a>4.2.3 task and future</h4><p><code>std::packaged_task&lt;&gt;</code> 会将 <code>future</code> 与函数或可调用对象进行绑定。当调用 <code>package_task&lt;&gt;</code> 时，就会调用相关函数或可调用对象，当 <code>future</code> 状态未就绪时，会存储返回值。</p>
<p><code>std::packaged_task&lt;&gt;</code> 的模板参数是一个函数签名。我们传入对象的签名可以与模板参数中指定的签名不一致，但是必须能隐式转换到目标类型。</p>
<p>例如，一种便特化的 <code>packaged_task</code> 的意义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">packaged_task</span>&lt;std::<span class="built_in">string</span>(std::vector&lt;<span class="type">char</span>*&gt;, <span class="type">int</span>)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">packaged_task</span><span class="params">(Callable &amp;&amp;f)</span></span>;</span><br><span class="line">    <span class="function">std::future&lt;std::string&gt; <span class="title">get_future</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::vector&lt;<span class="type">char</span>*&gt;, <span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>std::packaged_task</code> 是一个可调用对象，可以封装在 <code>std::function</code> 对象中，从而作为汉城函数传递到 <code>std::thread</code> 对象中，或作为可调用物对象传递到另一个函数中或直接调用。</p>
<p>例子1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line">std::mutex m;</span><br><span class="line">std::deque&lt;std::packaged_task&lt;<span class="type">void</span>()&gt; &gt; tasks;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">gui_shutdown_message_received</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_and_process_gui_message</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gui_thread</span><span class="params">()</span>  <span class="comment">// 1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">gui_shutdown_message_received</span>())  <span class="comment">// 2</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">get_and_process_gui_message</span>();  <span class="comment">// 3</span></span><br><span class="line">    std::packaged_task&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">      <span class="keyword">if</span>(tasks.<span class="built_in">empty</span>())  <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      task=std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());  <span class="comment">// 5</span></span><br><span class="line">      tasks.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">task</span>();  <span class="comment">// 6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">gui_bg_thread</span><span class="params">(gui_thread)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function">std::future&lt;<span class="type">void</span>&gt; <span class="title">post_task_for_gui_thread</span><span class="params">(Func f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::packaged_task&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(f)</span></span>;  <span class="comment">// 7</span></span><br><span class="line">  std::future&lt;<span class="type">void</span>&gt; res=task.<span class="built_in">get_future</span>();  <span class="comment">// 8</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;  <span class="comment">// 9</span></span><br><span class="line">  tasks.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(task));  <span class="comment">// 10</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c++ reference 上的例子 2：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task_lambda</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">([](<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">return</span> a + b;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; res = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="built_in">task</span>(<span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;task_lambda: &quot;</span> &lt;&lt; res.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task_bind</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意下面packaged_task的函数签名对应的参数要与bind对应 </span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(std::bind(my_add, <span class="number">2</span>, <span class="number">11</span>))</span></span>;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; res = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="built_in">task</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;task_bind: &quot;</span> &lt;&lt; res.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(my_add)</span></span>;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; res = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="comment">// move 到线程当中</span></span><br><span class="line">    <span class="function">std::thread <span class="title">task_td</span><span class="params">(std::move(task), <span class="number">2</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">    task_td.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;task_thread: &quot;</span> &lt;&lt; res.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">task_lambda</span>();</span><br><span class="line">    <span class="built_in">task_lambda</span>();</span><br><span class="line">    <span class="built_in">task_thread</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释一下：<code>std::future&lt;int&gt; result = task.get_future();</code> 这条语句并不会导致 <code>task</code> 封装的可调用对象的执行，它仅仅是将 <code>task</code> 的返回值存储到 <code>result</code> 这个对象当中。</p>
<blockquote>
<p>参考： </p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/611029683">Zhihu</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/thread/packaged_task">Cpp-reference</a></p>
</blockquote>
<h4 id="4-2-4-std-promises"><a href="#4-2-4-std-promises" class="headerlink" title="4.2.4 std::promises"></a>4.2.4 std::promises</h4><p>cppreference 例1:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">accumulate</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;::iterator first, std::vector&lt;<span class="type">int</span>&gt;::iterator last, </span></span></span><br><span class="line"><span class="params"><span class="function">                std::promise&lt;<span class="type">int</span>&gt; accumulate_promise)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = std::<span class="built_in">accumulate</span>(first, last, <span class="number">0</span>);</span><br><span class="line">    accumulate_promise.<span class="built_in">set_value</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_work</span><span class="params">(std::promise&lt;<span class="type">void</span>&gt; barrier)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    barrier.<span class="built_in">set_value</span>(); <span class="comment">// 注释掉改行不会阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; accumulate_promise;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; accumulate_future = accumulate_promise.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="comment">// 加上 :: ，防止识别为 std::accumulate</span></span><br><span class="line">    <span class="function">std::thread <span class="title">work_thread</span><span class="params">(::accumulate, numbers.begin(), numbers.end(), std::move(accumulate_promise))</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// future::get() 将等待直至该 future 拥有合法结果并取得它</span></span><br><span class="line">    <span class="comment">// 无需在 get() 前调用 wait()</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; accumulate_future.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    work_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 primise&lt;void&gt; 在线程间对状态发信号</span></span><br><span class="line">    std::promise&lt;<span class="type">void</span>&gt; barrier;</span><br><span class="line">    std::future&lt;<span class="type">void</span>&gt; barrier_future = barrier.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">new_work_thread</span><span class="params">(do_work, std::move(barrier))</span></span>;</span><br><span class="line">    barrier_future.<span class="built_in">wait</span>();</span><br><span class="line">    new_work_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例2: 线程等待另一个线程的数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promise = std::<span class="built_in">promise</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> t1 = std::<span class="built_in">thread</span>([&amp;promise]&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread running\n&quot;</span>;</span><br><span class="line">        <span class="comment">// do something ~</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// write data and invoke the threads which are waiting for that</span></span><br><span class="line">        promise.<span class="built_in">set_value</span>(<span class="number">42</span>);	<span class="comment">// 注释掉改行会阻塞</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread end\n&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// block until get value</span></span><br><span class="line">    cout &lt;&lt; promise.<span class="built_in">get_future</span>().<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>[TODO]</strong></p>
<p>在这里我发现了一个神奇的事情，如果是按照上面的形式（例2）即，lambda 表达式的形式创建线程，如果不 set_value() 的话，future::wait() 会一直等待，而使用显式的函数则不会（例1），为什么呢？</p>
</blockquote>
<blockquote>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6300e02d0625#">JianShu</a></p>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/promise">Cpp-reference</a></p>
</blockquote>
<h4 id="4-2-5-exception-and-future"><a href="#4-2-5-exception-and-future" class="headerlink" title="4.2.5 exception and future"></a>4.2.5 exception and future</h4><p>如果我们抛出一个异常，那么这个异常会存储到 <code>future</code> 中，然后 <code>future</code> 的状态设置为 <code>ready</code>，之后调用 <code>get()</code> 会抛出已存储的异常。</p>
<blockquote>
<p>注意！标准并未规定重新抛出的这个异常是原对象还是一份拷贝，这取决于山西i安</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">my_sqrt</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;out of range ^ ^\n&quot;</span>;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;x &lt; 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将 promise 与 future 绑定起来</span></span><br><span class="line">    std::promise&lt;<span class="type">double</span>&gt; promise;</span><br><span class="line">    std::future&lt;<span class="type">double</span>&gt; future = promise.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pls input a number: &quot;</span>;</span><br><span class="line">        <span class="type">double</span> x;       </span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        promise.<span class="built_in">set_value</span>(<span class="built_in">my_sqrt</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(<span class="type">const</span> exception &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// promise.set_exception(current_exception());</span></span><br><span class="line">        promise.<span class="built_in">set_exception</span>(std::<span class="built_in">make_exception_ptr</span>(<span class="built_in">logic_error</span>(<span class="string">&quot;sqrt() error ^ ^&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; future.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="4-2-6-waiting-of-multiple-thread"><a href="#4-2-6-waiting-of-multiple-thread" class="headerlink" title="4.2.6 waiting of multiple thread"></a>4.2.6 waiting of multiple thread</h4><p>如果并行代码没办法让多个线程等待同一个事件， <code>std::shared_future </code>可以帮你解决这个问题。因为<code>future</code>是只 <strong>move</strong> 的，所以其所有权可以在不同的实例中互相传递，但只有一个实例可以获得特定的同步结果，而 <code>std::shared_future</code>实例是可 <strong>copy</strong> 的，所以多个对象可以引用同一关联期望值的结果。</p>
<p>例: std::shared_future</p>
<p><code>std::shared_future</code> 顾名思义，就是多个线程共享一个 <code>std::shared_future</code>。可用在一个线程传递数据给多个线程的时候，多个线程在自身的线程空间内通过 <code>std::shared_future</code> 共享一个 <code>future</code>，这是线程安全的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line">    <span class="keyword">auto</span> promise = std::<span class="built_in">promise</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> t1 = std::<span class="built_in">thread</span>([&amp;promise]&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread 1 running\n&quot;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">4</span>));</span><br><span class="line">        <span class="comment">// 写入数据，这回唤醒那些正在等待数据的线程</span></span><br><span class="line">        promise.<span class="built_in">set_value</span>(<span class="number">42</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread 1 end\n&quot;</span>; </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> shared_future = std::<span class="built_in">shared_future</span>&lt;<span class="type">int</span>&gt;(promise.<span class="built_in">get_future</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> t2 = std::<span class="built_in">thread</span>([shared_future]&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread 2 running\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取数据，如果数据还没准备好就会阻塞</span></span><br><span class="line">        <span class="comment">// 这里使用 std::printf 而不是 std::cout 是为了保证输出在同一行</span></span><br><span class="line">        std::<span class="built_in">printf</span>(<span class="string">&quot;thread: 2 %d\n&quot;</span>, shared_future.<span class="built_in">get</span>());</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread 2 end\n&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::<span class="built_in">printf</span>(<span class="string">&quot;Test: %d\n&quot;</span>, shared_future.<span class="built_in">get</span>());</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>std::shared_future::get</code> 可以无限次调用，而 <code>std::future::get</code> 仅能调用一次。</p>
<p><code>std::shared_future::get</code> 返回的一定是引用（模板参数是 <code>void</code> 的除外）</p>
</blockquote>
<p>在每一个<code>std::shared_future</code>的独立对象上成员函数调用返回的结果还是不同步的，所以为了在多个线程访问一个独立对象时，避免数据竞争，必须使用锁来对访问进行保护。优先使用的办法：为了替代只有一个拷贝对象的情况，可以让每个线程都拥有自己对应的拷贝对象。这样，当每个线程都通过自己拥有的<code>std::shared_future</code>对象获取结果，那么多个线程访问共享同步结果就是安全的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line">    <span class="comment">// 注意 promise 只能 set 一次</span></span><br><span class="line">    <span class="keyword">auto</span> promise = std::<span class="built_in">promise</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="keyword">auto</span> shared_future = std::<span class="built_in">shared_future</span>&lt;<span class="type">int</span>&gt;(promise.<span class="built_in">get_future</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;promise, shared_future](<span class="type">int</span> x)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; running\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(x)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; shared_future.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            promise.<span class="built_in">set_value</span>(x);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; end\n&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = std::<span class="built_in">thread</span>(f, i);</span><br><span class="line">        threads.<span class="built_in">push_back</span>(<span class="built_in">move</span>(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">printf</span>(<span class="string">&quot;Test: %d\n&quot;</span>, shared_future.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t : threads)  t.<span class="built_in">join</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-time-limited-wait"><a href="#4-3-time-limited-wait" class="headerlink" title="4.3 time limited wait"></a>4.3 time limited wait</h3><h4 id="4-3-1-introduce"><a href="#4-3-1-introduce" class="headerlink" title="4.3.1 introduce"></a>4.3.1 introduce</h4><p>Sometimes, it is needed to limited the wating time of the wait thread.</p>
<p>There are two ways to signated if timeout:</p>
<ol>
<li>time duration(relative): you are expected to signated a duration of time like: 30s</li>
<li>time point(absolute): you are expected to signated a concrete  time like: <code>[UTC] 17:40:15.034583458</code>, <code>2011-11-30</code></li>
</ol>
<p>The variable which used for relative time  suffixed by <code>_for</code>, and other used for absolute time suffixed by <code>_until</code></p>
<p>Before observe the usage of timeout funtion, let’s check the way to signated the time in C++</p>
<h4 id="4-3-2-clock"><a href="#4-3-2-clock" class="headerlink" title="4.3.2 clock"></a>4.3.2 clock</h4><p><code>#include &lt;chrono&gt;</code></p>
<p>对于 C++ 来说，时钟就是时间信息源。并且，时钟是一个 <code>class</code>，提供了四种不同的信息：</p>
<ol>
<li>当前时间：<code>std::chrono::system_clock::now()</code> 会返回系统的当前时间，它属于 <code>time point</code>.</li>
<li>时间类型</li>
<li>时钟节拍：<code>std::chrono::high_resolution_clock</code> 可能是标准库中提供的具有最小节拍周期（因此具有最高的精度）的时钟。</li>
<li>稳定时钟：<code>std::chrono::steady_clock</code></li>
</ol>
<h4 id="4-3-3-ratio"><a href="#4-3-3-ratio" class="headerlink" title="4.3.3 ratio"></a>4.3.3 ratio</h4><p>先介绍一下 <code>std::ratio</code>，他定义在 <code>&lt;ratio&gt;</code> 头文件当中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">intmax_t</span> N, <span class="type">intmax_t</span> D = <span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">class</span> ratio &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> ratio&lt;num, den&gt; type;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">intmax_t</span> num;  <span class="comment">// 分子</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">intmax_t</span> den;  <span class="comment">// 分母</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>具体的可以参考 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/header/ratio">cppreference</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span> <span class="comment">// !</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="keyword">using</span> two_third = std::ratio&lt;<span class="number">2</span>, <span class="number">3</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> one_six   = std::ratio&lt;<span class="number">1</span>, <span class="number">6</span>&gt;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">using</span> sum = std::ratio_add&lt;two_third, one_six&gt;;</span><br><span class="line">    <span class="comment">// exppect print 5/6</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2/3 + 1/6 = &quot;</span> &lt;&lt; sum::num &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; sum::den &lt;&lt; endl;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-4-literal"><a href="#4-3-4-literal" class="headerlink" title="4.3.4 literal"></a>4.3.4 literal</h4><p>在 C++14 中的 <code>namespace std::chrono_literals</code> 中预定义了许多后缀操作符用来表示时长中的常用单位来简化代码。同样，还用用于表示字符串的 <code>namespace std::string_literals</code> 等。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// d 和 y 是 C++20 提供的</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> string_literals;</span><br><span class="line">    <span class="keyword">auto</span> one_day = <span class="number">24</span>h;</span><br><span class="line">    <span class="keyword">auto</span> half_an_hour = <span class="number">30</span>min;</span><br><span class="line">    <span class="keyword">auto</span> half_a_minuter = <span class="number">30</span>s;</span><br><span class="line">    <span class="comment">// 不常用的还有 ms（微秒）, us（微秒）, nm（纳秒）, </span></span><br><span class="line">    <span class="comment">// 1s = 1e3ms(毫秒) = 1e6us(微秒) = 1e9ns(纳秒) = 1e12ps(皮秒)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// auto 的类型是：</span></span><br><span class="line">    std::chrono::milliseconds ms = <span class="number">1</span>s;</span><br><span class="line">    cout &lt;&lt; ms.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> chrono_literals;</span><br><span class="line">    string s = <span class="string">&quot;hello&quot;</span>s; <span class="comment">// suffix by x</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test1</span>();</span><br><span class="line">    <span class="built_in">Test2</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-5-time-duration"><a href="#4-3-5-time-duration" class="headerlink" title="4.3.5 time duration"></a>4.3.5 time duration</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span> = std::ratio&lt;<span class="number">1</span>&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> duration;</span><br><span class="line"><span class="comment">// Rep: 表示计数的算数类型</span></span><br><span class="line"><span class="comment">// Period：表示计次周期的 std::ratio(即每秒的次数)</span></span><br></pre></td></tr></table></figure>

<p>通俗来讲，<code>Period</code> 指定的是 <code>duration</code> 的单位，默认是 <code>1s</code>,例如，如果 <code>Period</code> 指定的是 <code>ratio&lt;3600,1&gt;</code> ，那么单位就相当于 <code>h</code>，那么 <code>10</code> 个 <code>duration</code> 就是 <code>10h</code><br><code>Rep</code> 参数指定了传入的时间单位的类型，可以为 <code>float</code>, <code>int</code>, <code>int64</code> 等，如果为 <code>float</code> 则可以表示传入时间单位的“一部分”，比如传入 <code>1.2</code> 表示 <code>1.2</code> 倍个时间单位。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::chrono::duration;</span><br><span class="line">    <span class="keyword">using</span> std::chrono::duration_cast;</span><br><span class="line">    <span class="keyword">using</span> std::ratio;</span><br><span class="line"> </span><br><span class="line">    duration&lt;<span class="type">long</span> <span class="type">long</span>, ratio&lt;<span class="number">1</span>, <span class="number">1</span>&gt;&gt; tick_s&#123;<span class="number">15</span>&#125;; <span class="comment">// 15s</span></span><br><span class="line">    duration&lt;<span class="type">long</span> <span class="type">long</span>, ratio&lt;<span class="number">1</span>, <span class="number">1000</span>&gt;&gt; tick_ms&#123;<span class="number">15</span>&#125;; <span class="comment">// 1500ms</span></span><br><span class="line">    duration&lt;<span class="type">long</span> <span class="type">long</span>, ratio&lt;<span class="number">60</span>&gt;&gt; tick_min&#123;<span class="number">15</span>&#125;; <span class="comment">// 15min</span></span><br><span class="line">    duration&lt;<span class="type">float</span>, ratio&lt;<span class="number">3600</span>&gt;&gt; tick_h&#123;<span class="number">1.5</span>&#125;; <span class="comment">// 1.5h</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// count()方法可以返回我们设置的数值</span></span><br><span class="line">    cout &lt;&lt; tick_h.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;h&quot;</span> &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; tick_min.<span class="built_in">count</span>() &lt;&lt;  <span class="string">&quot;min&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// duration_cast </span></span><br><span class="line">    <span class="keyword">auto</span> min = <span class="built_in">duration_cast</span>&lt;std::chrono::minutes&gt;(tick_h);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1.5h = &quot;</span> &lt;&lt; min.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;min&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以隐式类型转换</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;15min = &quot;</span> &lt;&lt; chrono::<span class="built_in">seconds</span>(tick_min).<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以自定义转换类型</span></span><br><span class="line">    <span class="keyword">using</span> _day = duration&lt;<span class="type">double</span>, ratio&lt;<span class="number">24</span> * <span class="number">3600</span>&gt;&gt;;</span><br><span class="line">    <span class="keyword">auto</span> hour = duration&lt;<span class="type">long</span> <span class="type">long</span>, ratio&lt;<span class="number">3600</span>&gt;&gt;&#123;<span class="number">8</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;8h = &quot;</span> &lt;&lt; <span class="built_in">duration_cast</span>&lt;_day&gt;(hour).<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;day&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// duration 还可以支持算数运算和比较运算</span></span><br><span class="line">    <span class="comment">// 这里就不展示了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>例如：等待 <code>future</code> 状态变为就绪需要 35ms</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">task</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">40</span>ms);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f = std::<span class="built_in">async</span>(task);</span><br><span class="line">    <span class="keyword">if</span>(f.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">35</span>ms)) == std::future_status::ready)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ready&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;deferred&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-3-4-time-point"><a href="#4-3-4-time-point" class="headerlink" title="4.3.4 time point"></a>4.3.4 time point</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span> = <span class="keyword">typename</span> Clock::duration&gt;</span><br><span class="line"><span class="keyword">class</span> time_point;</span><br><span class="line"><span class="comment">// time_point 表示时间中的一个点</span></span><br><span class="line"><span class="comment">// Clock 表示时钟的类型</span></span><br><span class="line"><span class="comment">// Duration 存储一个自 Clock 的纪元起开始的时间间隔</span></span><br><span class="line"><span class="comment">// Unix 的纪元为 1970/1/1/00/00/00（epoch）</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slow_motion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">do</span>&#123;&#125; <span class="comment">// 生成 12! 个排列</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(a, a + <span class="number">12</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Test 1 */</span></span><br><span class="line">    <span class="type">const</span> time_point&lt;system_clock&gt; now = system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">time_t</span> t_c = system_clock::<span class="built_in">to_time_t</span>(now - <span class="number">24</span>h);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;24 hour ago, the time was &quot;</span> &lt;&lt; <span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;t_c), <span class="string">&quot;%F %T.\n&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Test 2 */</span></span><br><span class="line">    <span class="type">const</span> time_point&lt;steady_clock&gt; start = steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">slow_motion</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> end = steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Slow calculation took &quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(end - start).<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;us = &quot;</span></span><br><span class="line">         &lt;&lt; (end - start) / <span class="number">1</span>ms &lt;&lt; <span class="string">&quot;ms = &quot;</span></span><br><span class="line">         &lt;&lt; (end - start) / <span class="number">1</span>s &lt;&lt; <span class="string">&quot;s.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例2: 等待条件变量满足条件 —— 有超时功能</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> chrono_literals;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> done;</span><br><span class="line">std::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait_loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wait_loop running\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(<span class="number">100</span>ms);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wait loop sleep done.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> timeout = <span class="comment">// now + xms</span></span><br><span class="line">        std::chrono::steady_clock::<span class="built_in">now</span>() </span><br><span class="line">        + std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>);   </span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(!done)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cv.<span class="built_in">wait_until</span>(lock, timeout) == std::cv_status::timeout)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;timeout.\n&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do something or done = true</span></span><br><span class="line">        <span class="comment">// done = true;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wait_loop end\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread running.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(<span class="number">1000</span>ms);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread sleep done.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread end.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function">thread <span class="title">tl</span><span class="params">(wait_loop)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(signal)</span></span>;</span><br><span class="line">    tl.<span class="built_in">join</span>();</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">if</span>(done)    cout &lt;&lt; <span class="string">&quot;done.\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-3-5-use-timeout"><a href="#4-3-5-use-timeout" class="headerlink" title="4.3.5 use timeout"></a>4.3.5 use timeout</h4><p>使用超时机制的函数</p>
<table>
<thead>
<tr>
<th>类型&#x2F;命名空间</th>
<th>函数</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>std::this_thread[namespace]</td>
<td>sleep_for(duration)</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>sleep_until(time_point)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>std::condition_variable 或 std::condition_variable_any</td>
<td>wait_for(lock, duration)</td>
<td>std::cv_status::time_out 或 std::cv_status::no_timeout</td>
</tr>
<tr>
<td>wait_until(lock, time_point)</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>wait_for(lock, duration, predicate)</td>
<td>bool —— 当唤醒时，返回谓词的结果</td>
</tr>
<tr>
<td>wait_until(lock, duration, predicate)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>std::timed_mutex 或 std::recursive_timed_mutex</td>
<td>try_lock_for(duration)</td>
<td>bool —— 获取锁时返回true，否则返回fasle</td>
</tr>
<tr>
<td>try_lock_until(time_point)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>std::unique_lock<TimedLockable></td>
<td>unique_lock(lockable, duration)</td>
<td>N&#x2F;A —— 对新构建的对象调用owns_lock();</td>
</tr>
<tr>
<td>unique_lock(lockable, time_point)</td>
<td>当获取锁时返回true，否则返回false</td>
<td></td>
</tr>
<tr>
<td></td>
<td>try_lock_for(duration)</td>
<td>bool —— 当获取锁时返回true，否则返回false</td>
</tr>
<tr>
<td>try_lock_until(time_point)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>std::future<ValueType>或std::shared_future<ValueType></td>
<td>wait_for(duration)</td>
<td>当等待超时，返回std::future_status::timeout</td>
</tr>
<tr>
<td>wait_until(time_point)</td>
<td>当“期望”准备就绪时，返回std::future_status::ready</td>
<td></td>
</tr>
<tr>
<td>当“期望”持有一个为启动的延迟函数，返回std::future_status::deferred</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>现在，我们讨论的机制有：<strong>condition variable</strong>、“<strong>future</strong>”、“<strong>promise</strong>”还有 <strong>packaged_task</strong>。是时候从更高的角度去看待这些机制，怎么样使用这些机制，简化线程的同步操作。</p>
<h3 id="4-4-simplify-code"><a href="#4-4-simplify-code" class="headerlink" title="4.4 simplify code"></a>4.4 simplify code</h3><p>同步工具在本章成为“构建块”。</p>
<p>比起在多个线程间共享数据，每个任务最好拥有自己的数据，并且其他线程可以通过使用 <code>future</code> 获取运行结果。</p>
<h4 id="4-4-1-funtional-programming-by-future"><a href="#4-4-1-funtional-programming-by-future" class="headerlink" title="4.4.1 funtional programming by future"></a>4.4.1 funtional programming by future</h4><blockquote>
<p><strong>functional programming(FP)</strong> is a programming way which the function_return_value only depend on the arguments and you will get the same result always if you pass the same arguments</p>
</blockquote>
<p>串形版针对 <code>list</code> 的 <code>qsort</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">std::list&lt;T&gt; <span class="title">sequential_quick_sort</span><span class="params">(std::list&lt;T&gt; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(input.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">    std::list&lt;T&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::list::splice 实现将元素从一个list转移到另一个list</span></span><br><span class="line">    <span class="comment">// 并且仅仅通过 pointer move 实现，而不 copy or move elements</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// splice(const_iterator pos, list &amp;other, const_iterator it)</span></span><br><span class="line">    <span class="comment">// 从 other 转移 it 所指向的元素到 [*this](calleer) 当中，元素被插入到 pos 所指向的元素之前</span></span><br><span class="line">    <span class="comment">// 即，将 input 的第一个元素转移到 reesult 的 begin 之前</span></span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(), input, input.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="comment">// 选取一个“中间元素”</span></span><br><span class="line">    <span class="type">const</span> T&amp; pivot = *result.<span class="built_in">begin</span>();   <span class="comment">// pivot: 枢纽</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// paration 返回第一个不满足条件的元素的迭代器，正好是开区间</span></span><br><span class="line">    <span class="comment">// 方便 [) 的设计</span></span><br><span class="line">    <span class="comment">// 根据“中间元素”划分为左右去见</span></span><br><span class="line">    <span class="keyword">auto</span> divide_point = std::<span class="built_in">partition</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(),</span><br><span class="line">        [&amp;](<span class="type">const</span> T&amp; t)&#123;<span class="keyword">return</span> t &lt; pivot;&#125; <span class="comment">// 以 t&lt;pivot 划分元素，input左侧都是小于pivot，右侧大于pivot</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    std::list&lt;T&gt; lower_part;</span><br><span class="line">    lower_part.<span class="built_in">splice</span>(lower_part.<span class="built_in">end</span>(), input, input.<span class="built_in">begin</span>(), divide_point);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursion</span></span><br><span class="line">    <span class="comment">// 分别对左右区间的元素递归sort</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">new_lower</span><span class="params">(sequential_quick_sort(std::move(lower_part)))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">new_higher</span><span class="params">(sequential_quick_sort(std::move(input)))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// left, middle(privot), right</span></span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">end</span>(), new_higher);</span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(), new_lower);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; l&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    l = <span class="built_in">sequential_quick_sort</span>(l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;val : l)</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>qsort —— FP pattern with thread strongthen（并行版本）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">parallel_quick_sort</span><span class="params">(std::list&lt;T&gt; input)</span> -&gt; <span class="keyword">auto</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(input.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    </span><br><span class="line">    std::list&lt;T&gt; result;</span><br><span class="line">    </span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(), input, input.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="type">const</span> T&amp; pivot = *result.<span class="built_in">begin</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> divide_point = std::<span class="built_in">partition</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), </span><br><span class="line">        [&amp;](<span class="type">const</span> T&amp; t)&#123;</span><br><span class="line">            <span class="keyword">return</span> t &lt; pivot;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::list&lt;T&gt; lower_part;</span><br><span class="line">    lower_part.<span class="built_in">splice</span>(lower_part.<span class="built_in">end</span>(), input, </span><br><span class="line">        input.<span class="built_in">begin</span>(), divide_point);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的线程进行排序</span></span><br><span class="line">    std::future&lt;std::list&lt;T&gt;&gt; <span class="built_in">new_lower</span>(</span><br><span class="line">        std::<span class="built_in">async</span>(&amp;parallel_quick_sort&lt;T&gt;, std::<span class="built_in">move</span>(lower_part))</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 在当前线程中执行，无需一个新的线程</span></span><br><span class="line">    <span class="keyword">auto</span> new_higher = (</span><br><span class="line">        <span class="built_in">parallel_quick_sort</span>(std::<span class="built_in">move</span>(input))</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">end</span>(), new_higher);;</span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(), new_lower.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; l&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    l = <span class="built_in">parallel_quick_sort</span>(l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;val : l)</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，每调用一次 <code>parallel_quich_sort</code>，我们便创建一个新的线程，由于递归执行的缘故，线程的创建是指数级别的，也就是说，如果递归执行 10 次，那么就会创建 1024 个线程！但创建太多线程显然是不好的，因此 <code>async()</code> 会自动执行某些操作，避免创建太多线程。这也符合 <code>async()</code> 的策略（既可立马创建新线程，也可以以延迟加载的方式创建线程）。</p>
<p>其实，如果 <code>async()</code> 以延迟加载的方式执行，也就是直到在 <code>std::async()</code> 返回的 <code>future</code> 对象调用 <code>get()</code> 或者 <code>wait()</code> 时才执行。</p>
<p>然鹅，当调用 <code>get/wait</code> 时，函数会同步执行，即调用者会阻塞直到函数运行结束，如果 <code>get/wait</code> 没有被调用，函数就绝对不会执行。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039083151">ref here</a></p>
</blockquote>
<p>比起使用<code>std::async()</code>，你可以写一个spawn_task()函数对<code>std::packaged_task</code>和<code>std::thread</code>做简单的包装，如下面代码所示；你需要为函数结果创建一个<code>std::packaged_task</code>对象， 可以从这个对象中获取“期望”，或在线程中执行它，返回“期望”。</p>
<p>其本身并不提供太多的好处(并且事实上会造成大规模的超额任务)，但是它会为转型成一个更复杂的实现铺平道路，将会实现向一个队列添加任务，而后使用线程池的方式来运行它们。我们将在第9章再讨论线程池。使用<code>std::async</code>更适合于当你知道你在干什么，并且要完全控制在线程池中构建或执行过任务的线程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> A&gt;</span><br><span class="line">std::future&lt;std::result_of&lt;<span class="built_in">F</span>(A&amp;&amp;)&gt;::type&gt; <span class="built_in">spawn_task</span>(F &amp;&amp;f, A &amp;&amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::result_of&lt;<span class="built_in">F</span>(A&amp;&amp;)&gt;::type result_type;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">result_type</span><span class="params">(A&amp;&amp;)</span>&gt; <span class="title">task</span><span class="params">(std::move(f))</span></span>;</span><br><span class="line">    <span class="function">std::future&lt;result_type&gt; <span class="title">res</span><span class="params">(task.get_future())</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task), std::move(a))</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-2-synchronization-by-message-passing"><a href="#4-4-2-synchronization-by-message-passing" class="headerlink" title="4.4.2 synchronization by message passing"></a>4.4.2 synchronization by message passing</h4><blockquote>
<p> <strong>MPI：</strong>Message Passing Interface，消息传递接口</p>
<p><strong>CSP：</strong>Communicating Sequentiasl Processer，通讯顺序进程</p>
</blockquote>
<p><font color=blue>???????  THIS SECTION AND NEXT SECTION TODO</font></p>
<p>TODO …</p>
<h3 id="4-5-summary"><a href="#4-5-summary" class="headerlink" title="4.5 summary"></a>4.5 summary</h3><p>同步操作对于使用并发编写一款多线程应用来说，是很重要的一部分：如果没有同步，线程基本上就是独立的，也可写成单独的应用，因其任务之间的相关性，它们可作为一个群体直接执行。</p>
<p>本章，我们讨论了各式各样的同步操作，从基本的<strong>条件变量，到“期望”、“承诺”，再到打包任务</strong>。</p>
<p>我们也讨论了替代同步的解决方案：<strong>函数化模式编程，完全独立执行的函数，不会受到外部环境的影响；还有，消息传递模式，以消息子系统为中介，向线程异步的发送消息。</strong></p>
<h2 id="P5-memory-model-and-atomatic-operation"><a href="#P5-memory-model-and-atomatic-operation" class="headerlink" title="P5 memory model and atomatic operation"></a>P5 memory model and atomatic operation</h2><h2 id="P6-data-struct-with-mutex"><a href="#P6-data-struct-with-mutex" class="headerlink" title="P6 data struct with mutex"></a>P6 data struct with mutex</h2><p>本章主要内容：</p>
<ul>
<li>设计并发数据结构</li>
<li>如何设计</li>
<li>实现数据结构</li>
</ul>
<p>设计并发数据结构时，可以使用多线程中的构建块，比如：<code>condition_variable</code> 和 <code>mutex</code>。当然也要保证并发块在并发环境下的线程安全。</p>
<h3 id="6-1-the-significance-of-concurrency-design"><a href="#6-1-the-significance-of-concurrency-design" class="headerlink" title="6.1 the significance of concurrency design"></a>6.1 the significance of concurrency design</h3><p>设计并发数据结构是为了让多线程并发访问，并且线程可对数据结构做相同或不同的操作。</p>
<p>多线程环境下，无数据丢失和损坏，苏哟偶的数据都维持原样，且无竞争条件的数据结构，称之为“线程安全”的数据结构。</p>
<p>实际上，我们要通过设计线程安全的数据结构为线程提供并发访问数据结构的机会。因为就本质来说，互斥量为了保护数据，会显示阻止线程对数据的并发访问。</p>
<h4 id="6-1-1-guideline-of-desiging-the-concurrency-DB"><a href="#6-1-1-guideline-of-desiging-the-concurrency-DB" class="headerlink" title="6.1.1 guideline of desiging the concurrency DB"></a>6.1.1 guideline of desiging the concurrency DB</h4><p>设计并发数据结构时，需要两方面的考量：</p>
<ol>
<li>确保访问安全</li>
<li>真正并发访问</li>
</ol>
<p>第三章已经对如何保证数据安全做过简单的描述：</p>
<ul>
<li>确保无线程能够看到“不变量”变化时的状态</li>
<li>小心会引起条件竞争的接口，提供完整操作的函数，而非操作步骤（top-pop）</li>
<li>注意数据结构的行为是否会产生异常，从而确保“不变量”的状态</li>
<li>将死锁的概率降到最低。限制锁的范围，避免嵌套锁等</li>
</ul>
<p><strong>还需要考虑数据结构对于使用者有什么限制</strong>，当线程通过特殊的函数对数据结构进行访问时，其他的线程还有哪些函数能安全调用?</p>
<p>这是一个很重要的问题，普通的构造函数和析构函数需要独立访问数据结构，所以用户使用时，就不能在构造函数完成前或析构函数完成后对数据结构进行访问。当数据结构支持赋值操作swap()或拷贝构造时，作为 数据结构的设计者，即使线程操纵数据结构中有大量的函数，也需要保证这些操作在并发下是安全的(或确保 这些操作能够独立访问)，以保证并发访问时不会出错。</p>
<p>第二个方面是确保真正的并发，需要考虑一下问题：</p>
<ol>
<li>操作在锁的范围中进行，是否允许在锁外执行？</li>
<li>数据结构中不同的互斥能否保护不同的区域？</li>
<li>所有操作都需要同级互斥量的保护吗？</li>
<li>能否对数据结构进行简单的修改，增加并发访问的概率？</li>
</ol>
<p>这些问题都源于一个指导思想:<strong>如何让序列化访问最小化，让真实并发最大化?😊？？😭</strong></p>
<p>允许线程并发读取的数据结构并不少见，但修改必须是单线程的，这种结构类似于 <code>std::shared_mutex</code> 。同样，这种数据结构也很常见—— 支持多线程的不同操作时，也能串行执行相同的操作。</p>
<p>最简单的线程安全结构通常会对数据使用互斥量或锁。虽然，这么做还有问题，不过这样做相对简单，并且能保证只有一个线程在同一时间对数据结构进行独立访问。为了更轻松的设计线程安全的数据结构，接下来了解一下基于锁的数据结构。</p>
<h3 id="6-2-DS-based-on-mutex"><a href="#6-2-DS-based-on-mutex" class="headerlink" title="6.2 DS based on mutex"></a>6.2 DS based on mutex</h3><p>基于锁的并发数据结构确保访问线程持有锁的时间最短；对于只有一个互斥量的数据结构，需要锁之外的操作不能访问数据；使用多个互斥量保护数据结构不同的区域时要避免死锁。</p>
<h4 id="6-2-1-threadsafe-stack"><a href="#6-2-1-threadsafe-stack" class="headerlink" title="6.2.1 threadsafe stack"></a>6.2.1 threadsafe stack</h4><p>在 push() 操作中，无论如何都无法避免新数据的创建，除非你直接 move 原来的数据（右值引用 + move），但是直接 move 原来的数据有一个问题，那就是如果内存不足，move 一半异常了，那么原来的数据就会被破坏，因此，使用传值的方式拷贝初始数据，在 move 到容器中，更为稳妥。</p>
<p>这里的 “异常 - 安全” 好恶心😭</p>
<p>另外，这里的代码是可能发生死锁的;</p>
<p>用户要对栈负责，当栈未对一个数据进行拷贝或分配时，用户就不能想当然的将其添加到栈中。</p>
<p>所有成员函数都使用 std::lock_guard&lt;&gt; 保护数据，所以栈成员函数才是“线程安全”的。当然，构造与析构函数不是“线程安全”的，但构造与析构只有一次。调用不完全构造对象或是已销毁对象的成员函数，无论在哪种编程方式下都不可取。所以，用户就要保证在栈对象完成构造前，其他线程无法对其进行访问。并且，要保证在栈对象销毁后，停止所有线程的访问操作。</p>
<p>串形化的线程会隐性的限制程序性能。例如我们需要 pop 一个元素，那么当栈为空时我们只能等待，但这种等待时无意义的，我们希望它不这么闲着等，而是去做一些其他事，因此，这需要用户编写等待和提示的代码（例如：条件变量）。下面的队列就是如此。</p>
<h4 id="6-2-2-threadsafe-queue-–-mutex-amp-amp-condition-variable"><a href="#6-2-2-threadsafe-queue-–-mutex-amp-amp-condition-variable" class="headerlink" title="6.2.2 threadsafe queue – mutex &amp;&amp; condition_variable"></a>6.2.2 threadsafe queue – mutex &amp;&amp; condition_variable</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mut;</span><br><span class="line">    std::queue&lt;T&gt; data_queue;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; mut;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(std::<span class="built_in">move</span>(data));</span><br><span class="line">        data_cond.<span class="built_in">notify_one</span>(); <span class="comment">// 不为空，通知等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 因为wait可能假唤醒，因此这里需要多次lock&amp;&amp;unlock</span></span><br><span class="line">        <span class="comment">// 因此unique_lock用来搭配condition_variable是更好的选择</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        value = std::<span class="built_in">move</span>(data_queue.<span class="built_in">top</span>());</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* [TOOD]</span></span><br><span class="line"><span class="comment">    * 感觉这里可以把两个pop中判断queue是否为空的部分拿出来</span></span><br><span class="line"><span class="comment">    * 放到一个单独的函数里面，这样岂不是更好？</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T &amp;value)</span></span></span><br><span class="line"><span class="function">   </span>&#123;    </span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的代码在有一个问题，就是当 push() 执行 notice_one() 之后，如果唤醒的那个线程发生了异常死了，例如构造新的 shared_ptr 对象时发生异常，那么所有线程都将永眠，因为此时没有其它条件能将他们唤醒，解放方案有如下几种：</p>
<ol>
<li>notice_all()，但是这么做的开销太大了，因为往往只有一个线程最终唤醒，而其他线程仍然需要沉睡</li>
<li>当唤醒的线程异常时，调用 notice_one() 去唤醒另一个线程</li>
<li>将<code>std::shared_ptr&lt;&gt;</code>的初始化过程移到push()中，并且存储<code>std::shared_ptr&lt;&gt;</code>实例，而非直接使用数据的值。将<code>std::shared_ptr&lt;&gt;</code>拷贝到内部<code>std::queue&lt;&gt;</code>中，就不会抛出异常了，这样wait_and_pop()又是安全的了。</li>
</ol>
<p>下面是使用第三种方案修改后的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mut;</span><br><span class="line">    std::queue&lt;std::shared_ptr&lt;T&gt;&gt; data_queue;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 这样即使发生了异常也不会导致所有线程沉睡</span></span><br><span class="line">        <span class="comment">// 因为构造对象并不涉及对共享对象的访问</span></span><br><span class="line">        <span class="comment">// 因此它实际上不需要加锁</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">data</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(new_value))</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">        <span class="comment">// 分配完才加锁，减少锁持有的时间，提高并发能力</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(data);</span><br><span class="line">        data_cond.<span class="built_in">notify_one</span>(); <span class="comment">// 不为空，通知等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        value = std::<span class="built_in">move</span>(*data_queue.<span class="built_in">top</span>());</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        std::shared_ptr&lt;T&gt; res = data_queue.<span class="built_in">front</span>(); <span class="comment">// 改为赋值而不是创建</span></span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* [TOOD]</span></span><br><span class="line"><span class="comment">    * 感觉这里可以把两个pop中判断queue是否为空的部分拿出来</span></span><br><span class="line"><span class="comment">    * 放到一个单独的函数里面，这样岂不是更好？</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T &amp;value)</span></span></span><br><span class="line"><span class="function">   </span>&#123;    </span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = std::<span class="built_in">move</span>(*data_queue.<span class="built_in">front</span>());</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line">        std::shared_ptr&lt;T&gt; res = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-2-3-threadsaft-queue-small-granularity-amp-amp-condition-variable"><a href="#6-2-3-threadsaft-queue-small-granularity-amp-amp-condition-variable" class="headerlink" title="6.2.3 threadsaft queue -  small granularity &amp;&amp; condition_variable"></a>6.2.3 threadsaft queue -  small granularity &amp;&amp; condition_variable</h4><p>下面是一个单线程环境下简单队列的实现，它是一个有头尾节点的单链表，当链表为空时，头尾指针为空。</p>
<blockquote>
<p>头节点 !&#x3D; 头指针</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">    &#123;</span><br><span class="line">        T data;</span><br><span class="line">        std::unique_ptr&lt;node&gt; next; <span class="comment">//  使用智能指针</span></span><br><span class="line">        <span class="built_in">node</span>(T _data) : <span class="built_in">data</span>(<span class="built_in">move</span>(_data)) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::unique_ptr&lt;node&gt; head;</span><br><span class="line">    node *tail; <span class="comment">// 因为这里的tail并不从堆上分配内存，他只是指向一个地址，因此不需要使用智能指针代替</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Queue</span>(<span class="type">const</span> Queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回节点并删除</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">/* 这里的const是顶层const，指定res不能再指向别的东西了，但是数据仍然可以修改</span></span><br><span class="line"><span class="comment">        * 你可能疑惑，既然res不能修改，但是接受返回值的变量不一定有这个限制的，他是可以修改的，没错，可以修改，但要记住了，shared_ptr 是有引用计数的，你修改了指向，其实就相当于在修改引用计数（创建了一个新指针），这并不会修改原来的指针，顶多导致她引用计数为0从而被销毁了。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分别取得头节点的数据和next指针</span></span><br><span class="line">        <span class="function"><span class="type">const</span> std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(head-&gt;data))</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">        <span class="type">const</span> std::unique_ptr&lt;node&gt; old_head = std::<span class="built_in">move</span>(head);</span><br><span class="line">        <span class="comment">// 头指针指向下一个节点</span></span><br><span class="line">        head = std::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建新节点</span></span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node(std::move(new_value)))</span></span>;</span><br><span class="line">        <span class="type">const</span> node* new_tail = p.<span class="built_in">get</span>();</span><br><span class="line">        <span class="comment">// 2. 让尾节点的next指向新节点</span></span><br><span class="line">        <span class="keyword">if</span>(tail)</span><br><span class="line">            tail-&gt;next = std::<span class="built_in">move</span>(p);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            head = std::<span class="built_in">move</span>(p);</span><br><span class="line">        <span class="comment">// 3. 更新尾节为当前节点</span></span><br><span class="line">        tail = new_tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码在单线程下没问题，但是在多线程下问题就太多了！</p>
<p>因为在给定的实现中有两个数据项(head①和tail②)；即使，使用两个互斥量，来保护头指针和尾指针，也会出现问题。</p>
<p>显而易见的问题就是push()可以同时修改头指针⑤和尾指针⑥，所以push()函数会同时获取两个互斥量。虽然会将两个互斥量都上锁，但这还不是太糟糕的问题。糟糕的问题是push()和pop()都能访问next指针指向的节点：push()可更新tail-&gt;next④，而后try_pop()读取head-&gt;next③。当队列中只有一个元素时，head&#x3D;&#x3D;tail，所以head-&gt;next和tail-&gt;next是同一个对象，并且这个对象需要保护。不过，“在同一个对象在未被head和tail同时访问时，push()和try_pop()锁住的是同一个锁”，就不对了。所以，你就没有比之间实现更好的选择了。这里会“柳暗花明又一村”吗？</p>
<p>可以通过<strong>分离数据</strong>实现并发。</p>
<p>通过“预分配虚拟节点（无数据）”，确保这个节点永远在队列的最后，用来分离头尾指针能访问的节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;T&gt; data;</span><br><span class="line">        std::unique_ptr&lt;node&gt; next; <span class="comment">//  使用智能指针</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;node&gt; head;</span><br><span class="line">    node *tail; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>() <span class="comment">// 预分配一个虚拟节点</span></span><br><span class="line">    : <span class="built_in">head</span>(<span class="keyword">new</span> node), <span class="built_in">tail</span>(head.<span class="built_in">get</span>()) </span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    initialization: </span></span><br><span class="line"><span class="comment">        [head(taial)] -&gt; NULL </span></span><br><span class="line"><span class="comment">    push value a</span></span><br><span class="line"><span class="comment">        [head] -&gt; [a(tail)] -&gt; NULL</span></span><br><span class="line"><span class="comment">    push value b</span></span><br><span class="line"><span class="comment">        [head] -&gt; [a] -&gt; [b(tail)] -&gt; NULL</span></span><br><span class="line"><span class="comment">    pop value</span></span><br><span class="line"><span class="comment">        [head] -&gt; [a(tail)] -&gt; NULL</span></span><br><span class="line"><span class="comment">    这样，除了队列为空状态下 head-&gt;next == tail-&gt;next == NULL</span></span><br><span class="line"><span class="comment">    任何时候他们不会为同一个元素，而队列为空时，不会同时发生 push 和 pop</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">Queue</span>(<span class="type">const</span> Queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.<span class="built_in">get</span>() == tail) <span class="comment">// head与tail指向同一元素，队列为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 队列不为空，先 front() 再 pop()</span></span><br><span class="line">        <span class="function"><span class="type">const</span> std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(head-&gt;data)</span></span>; <span class="comment">// shared_ptr 不需要 move</span></span><br><span class="line">        <span class="type">const</span> std::unique_ptr&lt;node&gt; old_head = std::<span class="built_in">move</span>(head);</span><br><span class="line">        head = std::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 因为 tail 是我们预分配的节点，因此直接修改 tail 的 dat 即可</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">new_data</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(new_value))</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>; </span><br><span class="line">        tail-&gt;data = new_data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们已经把上次预分配的使用了，因此需要重新预分配并作为尾节点</span></span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node)</span></span>; </span><br><span class="line">        <span class="type">const</span> node* new_tail = p.<span class="built_in">get</span>();</span><br><span class="line">        tail-&gt;next = std::<span class="built_in">move</span>(p);</span><br><span class="line">        tail = new_tail;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过修改之后，push 便只需要访问 tail，而原来还需要访问 head，try_pop 需要访问 head 和 tail，但是 head 只在开始时用了一下，所以存在的时间很短。</p>
<p>不过，最重大的提升在于，try_pop 和 push 不能对同一节点进行操作，也就不需要互斥了。因此，现在只需要一个互斥量来保护 head 和 tail 就行了。</p>
<p>那么，该如何加锁呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsaft_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;T&gt; data;</span><br><span class="line">        std::unique_ptr&lt;node&gt; next;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::mutex head_mutex, tail_mutex;</span><br><span class="line">    std::unique_ptr&lt;node&gt; head;</span><br><span class="line">    node *tail;</span><br><span class="line"></span><br><span class="line">    <span class="function">node* <span class="title">get_tail</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">pop_head</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(head.<span class="built_in">get</span>() == <span class="built_in">get_tail</span>()) <span class="comment">// 队列为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::unique_ptr&lt;node&gt; old_head = std::<span class="built_in">move</span>(head_mutex);</span><br><span class="line">        <span class="comment">// move 掉 next 也是个好事，用户想得到的应该只是数据而不是 next 指针</span></span><br><span class="line">        head = std::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> old_head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsaft_queue</span>(): <span class="built_in">head</span>(<span class="keyword">new</span> node), <span class="built_in">tail</span>(head.<span class="built_in">get</span>()) &#123;&#125;</span><br><span class="line">    <span class="built_in">threadsaft_queue</span>(<span class="type">const</span> threadsaft_queue&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    threadsaft_queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsaft_queue&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::unique_ptr&lt;node&gt; old_head = <span class="built_in">pop_head</span>();</span><br><span class="line">        <span class="keyword">return</span> old_head ? old_head-&gt;data : std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">new_data</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(new_value))</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node)</span></span>;</span><br><span class="line">        <span class="type">const</span> node *new_tail = p.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">        tail-&gt;data = new_data;</span><br><span class="line">        tail-&gt;next = std::<span class="built_in">move</span>(p);</span><br><span class="line">        tail = new_tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>多线程环境下，节点及数据的分配时“并发安全”的。</p>
</blockquote>
<p>下面是可上锁和等待的线程安全队列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsaft_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;T&gt; data;</span><br><span class="line">        std::unique_ptr&lt;node&gt; next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex head_mutex, tail_mutex;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line">    std::unique_ptr&lt;node&gt; head;</span><br><span class="line">    node *tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">node* <span class="title">get_tail</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">pop_head</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">wait_for_data</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">wait_pop_head</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">wait_pop_head</span><span class="params">(T &amp;value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">try_pop_head</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">try_pop_head</span><span class="params">(T&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T &amp;value)</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T &amp;value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*====================*</span></span><br><span class="line"><span class="comment">*       function      *</span></span><br><span class="line"><span class="comment">*=====================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; threadsaft_queue&lt;T&gt;::<span class="built_in">try_pop</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_ptr&lt;node&gt; old_head = <span class="built_in">try_pop_head</span>();</span><br><span class="line">    <span class="keyword">return</span> old_head ? old_head-&gt;data : std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> threadsaft_queue&lt;T&gt;::<span class="built_in">try_pop</span>(T &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_ptr&lt;node&gt; old_head = <span class="built_in">try_pop_head</span>();</span><br><span class="line">    <span class="keyword">return</span> old_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; threadsaft_queue&lt;T&gt;::<span class="built_in">wait_and_pop</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> std::unique_ptr&lt;node&gt; old_head = <span class="built_in">wait_pop_head</span>();</span><br><span class="line">    <span class="keyword">return</span> old_head-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> threadsaft_queue&lt;T&gt;::<span class="built_in">wait_and_pop</span>(T &amp;new_value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> std::unique_ptr&lt;node&gt; old_head = <span class="built_in">wait_and_pop</span>(new_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> threadsaft_queue&lt;T&gt;::<span class="built_in">push</span>(T new_value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">new_data</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        std::make_shared&lt;T&gt;(std::move(new_value))</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node)</span></span>;</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// use &#123;&#125; to unlock early </span></span><br><span class="line">        <span class="type">const</span> node *new_tail = p.<span class="built_in">get</span>();</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">        tail-&gt;data = new_data;</span><br><span class="line">        tail-&gt;next = std::<span class="built_in">move</span>(p);</span><br><span class="line">        tail = new_tail;</span><br><span class="line">    &#125;</span><br><span class="line">    data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> threadsaft_queue&lt;T&gt;::<span class="built_in">empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> (head.<span class="built_in">get</span>() == <span class="built_in">get_tail</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*====================*</span></span><br><span class="line"><span class="comment">*   helper function   *</span></span><br><span class="line"><span class="comment">*=====================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> threadsaft_queue&lt;T&gt;::node* </span><br><span class="line">threadsaft_queue&lt;T&gt;::<span class="built_in">get_tail</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execute within head mutex</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::unique_ptr&lt;<span class="keyword">typename</span> threadsaft_queue&lt;T&gt;::node&gt; </span><br><span class="line">threadsaft_queue&lt;T&gt;::<span class="built_in">pop_head</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_ptr&lt;node&gt; old_head = std::<span class="built_in">move</span>(head);</span><br><span class="line">    head = std::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> old_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::unique_lock&lt;std::mutex&gt; </span><br><span class="line">threadsaft_queue&lt;T&gt;::<span class="built_in">wait_for_data</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 因为获取了 head_lock，所以下面调用 head.get() 并发安全</span></span><br><span class="line">    data_cond.<span class="built_in">wait</span>(head_lock, [&amp;]&#123;</span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">get</span>() != <span class="built_in">get_tail</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(head_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::unique_ptr&lt;<span class="keyword">typename</span> threadsaft_queue&lt;T&gt;::node&gt; </span><br><span class="line">threadsaft_queue&lt;T&gt;::<span class="built_in">wait_pop_head</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. [wait] until queue is not empty</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(wait_for_data())</span></span>;</span><br><span class="line">    <span class="comment">// 2. [pop] head</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::unique_ptr&lt;<span class="keyword">typename</span> threadsaft_queue&lt;T&gt;::node&gt; </span><br><span class="line">threadsaft_queue&lt;T&gt;::<span class="built_in">wait_pop_head</span>(T &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. [wait] until queue is not empty</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(wait_for_data())</span></span>;</span><br><span class="line">    <span class="comment">// get data</span></span><br><span class="line">    value = std::<span class="built_in">move</span>(*head-&gt;data);</span><br><span class="line">    <span class="comment">// 2. [pop] head</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::unique_ptr&lt;<span class="keyword">typename</span> threadsaft_queue&lt;T&gt;::node&gt; </span><br><span class="line">threadsaft_queue&lt;T&gt;::<span class="built_in">try_pop_head</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(head.<span class="built_in">get</span>() == <span class="built_in">get_tail</span>())</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;node&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::unique_ptr&lt;<span class="keyword">typename</span> threadsaft_queue&lt;T&gt;::node&gt; </span><br><span class="line">threadsaft_queue&lt;T&gt;::<span class="built_in">try_pop_head</span>(T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(head.<span class="built_in">get</span>() == <span class="built_in">get_tail</span>())</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;node&gt;();</span><br><span class="line">    value = std::<span class="built_in">move</span>(*head-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-3-design-more-complex-DS"><a href="#6-3-design-more-complex-DS" class="headerlink" title="6.3 design more complex DS"></a>6.3 design more complex DS</h3><p>栈和队列的设计太 easy 啦（然而我也招架不住😭），下面来点大的。😠😠😠</p>
<h4 id="6-3-1-threadsafe-dictionary"><a href="#6-3-1-threadsafe-dictionary" class="headerlink" title="6.3.1 threadsafe dictionary"></a>6.3.1 threadsafe dictionary</h4><p>和栈和队列一样，标准容器的接口不适合多线程进行并发访问，因为这些接口都存在固有的条件竞争，所以这些接口需要砍掉或者重新修订。</p>
<p>并发访问时，<code>std::map&lt;&gt;</code> 最大的问题在于 —— 迭代器。例如当迭代器引用的元素被其它线程删除时，迭代器就会失效，但我们不知道。</p>
<p>查询表（字典）基本操作：</p>
<ol>
<li>（增）添加 key-value</li>
<li>（删）删除 key-value</li>
<li>（改）修改指定 key 所对应的 value</li>
<li>（查）查询指定 key 所对应的 value</li>
<li>so on…</li>
</ol>
<p>如果你坚持之前的线程安全指导意见，例如：<strong>不要返回一个引用</strong>，并且用一个简单的互斥锁对每一个成员函数进行上锁，以确保每一个函数线程安全。最有可能的条件竞争在于，当一对“键值-数据”加入时；当两个线程都添加一个数据，那么肯定一个先一个后。一种方式是合并“添加”和“修改”操作为一个成员函数，就像清单3.13对域名系统缓存所做的那样。</p>
<p>区别多线程环境下一下容器的并发能力：</p>
<ol>
<li>二叉树，比如：红黑树</li>
<li>有序数组</li>
<li>哈希表</li>
</ol>
<p>其中哈希表并发性能最好，因为哈希表可以设计为同 bucket+list(或有序数组)，而每一个 bucket 可以独立加锁，bucket 与 bucket 之间独立</p>
<p>下面是基于哈希表，使用读写锁，线程安全的，字典：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [TODO] separate bucket_t from threadsafe_lookup_table</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> threadsafe_lookup_table </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="type">bucket_t</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">/* [BUG]</span></span><br><span class="line"><span class="comment">            if you don&#x27;t add this, in the function of get_map()</span></span><br><span class="line"><span class="comment">            you cant access the number of data typed bucket_data</span></span><br><span class="line"><span class="comment">            .... </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> threadsafe_lookup_table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">typedef</span> std::pair&lt;Key,Value&gt;                 bucket_value;</span><br><span class="line">        <span class="keyword">typedef</span> std::list&lt;bucket_value&gt;              bucket_data;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> bucket_data::iterator       bucket_iterator;</span><br><span class="line">        <span class="comment">/* [BUG]</span></span><br><span class="line"><span class="comment">            author use iterator, but it is go CE</span></span><br><span class="line"><span class="comment">            we should use const_iterator</span></span><br><span class="line"><span class="comment">            ... ?</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> bucket_data::const_iterator bucket_const_iterator;</span><br><span class="line"></span><br><span class="line">        bucket_data data;</span><br><span class="line">        <span class="keyword">mutable</span> std::shared_mutex mutex;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// helper function</span></span><br><span class="line">        <span class="function">bucket_const_iterator <span class="title">find_entry_for</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">/* [BUG]</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">find_if</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), </span><br><span class="line">                [&amp;](<span class="type">const</span> bucket_value &amp;items)&#123;</span><br><span class="line">                    <span class="keyword">return</span> items.first == key;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// Advise: do not return by reference</span></span><br><span class="line">        <span class="comment">// this function return the value which mapped to the key</span></span><br><span class="line">        <span class="comment">// if ther is no item match, then return default value</span></span><br><span class="line">        <span class="comment">// and the default value is designated by the caller</span></span><br><span class="line">        <span class="function">Value <span class="title">value_for</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> Value &amp;default_value)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>; <span class="comment">// read lock</span></span><br><span class="line">            bucket_const_iterator found_entry = <span class="built_in">find_entry_for</span>(key);</span><br><span class="line">            <span class="keyword">return</span> (found_entry == data.<span class="built_in">end</span>()) ? </span><br><span class="line">                default_value : found_entry-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update if this key is existed otherwise add this K-V</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">add_or_update_mapping</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> Value &amp;value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>; <span class="comment">// write lock</span></span><br><span class="line">            bucket_const_iterator found_entry = <span class="built_in">find_entry_for</span>(key);</span><br><span class="line">            <span class="keyword">if</span>(found_entry == data.<span class="built_in">end</span>())</span><br><span class="line">                data.<span class="built_in">push_back</span>(<span class="built_in">bucket_value</span>(key, value));</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* [BUG]</span></span><br><span class="line"><span class="comment">                    because we use the const_iterator(lower const for the data which pointed on)</span></span><br><span class="line"><span class="comment">                    so we cant&#x27;t modify the data</span></span><br><span class="line"><span class="comment">                    otherwise ust the type convertion</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">auto</span> &amp;data = <span class="built_in">const_cast</span>&lt;bucket_value&amp;&gt;(*found_entry);</span><br><span class="line">                data.second = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">reomove_mapping</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>; <span class="comment">// write lock</span></span><br><span class="line">            bucket_const_iterator found_entry = <span class="built_in">find_entry_for</span>(key);</span><br><span class="line">            <span class="keyword">if</span>(found_entry != data.<span class="built_in">end</span>())</span><br><span class="line">                data.<span class="built_in">erase</span>(found_entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;<span class="type">bucket_t</span>&gt;&gt; buckets;</span><br><span class="line">    Hash hasher;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bucket_t</span>&amp; <span class="title">get_bucket</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">const</span> std::<span class="type">size_t</span> bucket_index = <span class="built_in">hasher</span>(key) % buckets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// buckets[idx] is a object of unique_ptr </span></span><br><span class="line">        <span class="comment">// so use operator* to get the object which ptr pointed on</span></span><br><span class="line">        <span class="keyword">return</span> *buckets[bucket_index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key   key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value mapped_type;    </span><br><span class="line">    <span class="keyword">typedef</span> Hash  hash_type;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;Key, Value&gt; value_type;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_lookup_table</span>(</span><br><span class="line">        <span class="comment">// the _num_bucket should be a prime so that it will have the best performance</span></span><br><span class="line">        <span class="type">unsigned</span> _num_buckets = <span class="number">19</span>, <span class="type">const</span> Hash &amp;_hasher = <span class="built_in">Hash</span>()</span><br><span class="line">    ) : <span class="built_in">buckets</span>(_num_buckets), <span class="built_in">hasher</span>(_hasher) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; _num_buckets; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            buckets[i].<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="type">bucket_t</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_lookup_table</span>(<span class="type">const</span> threadsafe_lookup_table&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    threadsafe_lookup_table&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_lookup_table&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*        DO NOT NEED MUTEX</span></span><br><span class="line"><span class="comment">    *  because the count of buckets can&#x27;t changed</span></span><br><span class="line"><span class="comment">    *  so it is needn&#x27;t to lock in the following functions </span></span><br><span class="line"><span class="comment">    *  -- when they call get_bucket() </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// caller, should designated the default value</span></span><br><span class="line">    <span class="function">Value <span class="title">value_for</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> Value &amp;default_value = Value())</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_bucket</span>(key).<span class="built_in">value_for</span>(key, default_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_or_update_mapping</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> Value &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">get_bucket</span>(key).<span class="built_in">add_or_update_mapping</span>(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove_mapping</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">get_bucket</span>(key).<span class="built_in">reomove_mapping</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// snapshot, return the backup in std::map</span></span><br><span class="line">    <span class="comment">// because we need to lock all buckets</span></span><br><span class="line">    <span class="comment">// if we add unique_lock, it would much wasty</span></span><br><span class="line">    <span class="comment">// so a bettery way is to use shared_mutex(read-lock)</span></span><br><span class="line">    <span class="comment">// so that other threads can also read meanwhile when we have locked a bucket</span></span><br><span class="line">    <span class="comment">// and then, we want to get the current state</span></span><br><span class="line">    <span class="comment">// so we should lock all buckets at one time</span></span><br><span class="line">    <span class="comment">// it is bad to lock and copy bucket one by one</span></span><br><span class="line">    <span class="comment">// because eg. when we lock A, and B will be modified</span></span><br><span class="line">    <span class="comment">// so the state is not consistency</span></span><br><span class="line">    <span class="function">std::map&lt;Key,Value&gt; <span class="title">get_map</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::vector&lt;std::unique_lock&lt;std::shared_mutex&gt;&gt; locks;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            locks.<span class="built_in">push_back</span>(</span><br><span class="line">                std::<span class="built_in">unique_lock</span>&lt;std::shared_mutex&gt;(buckets[i]-&gt;mutex)</span><br><span class="line">            );</span><br><span class="line">        &#125;   </span><br><span class="line">        std::map&lt;Key,Value&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;map_item : buckets[i]-&gt;data)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">insert</span>(map_item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">using</span> _map = threadsafe_lookup_table&lt;Key, Value&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _map&lt;<span class="type">int</span>,string&gt; table;</span><br><span class="line">    table.<span class="built_in">add_or_update_mapping</span>(<span class="number">1</span>, <span class="string">&quot;jyyyx&quot;</span>);</span><br><span class="line">    cout &lt;&lt; table.<span class="built_in">value_for</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    table.<span class="built_in">add_or_update_mapping</span>(<span class="number">2</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    cout &lt;&lt; table.<span class="built_in">value_for</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    table.<span class="built_in">add_or_update_mapping</span>(<span class="number">1</span>, <span class="string">&quot;sbg&quot;</span>);</span><br><span class="line">    cout &lt;&lt; table.<span class="built_in">value_for</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        table.<span class="built_in">add_or_update_mapping</span>(i, <span class="string">&quot;jyyyx: &quot;</span> + <span class="built_in">to_string</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> mp = table.<span class="built_in">get_map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : mp)</span><br><span class="line">        cout &lt;&lt; x.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⚠️⚠️⚠️    <strong>[BUG]</strong>    ⚠️⚠️⚠️</p>
</blockquote>
<p>在上面的代码中出现了很恶心的 bug（也可能是我太蠢了）， 导致我排查了好长好长时间，其实错误原因很简单。</p>
<p>在成员函数中，如果我们添加了 const 函数修饰符，那么如果我们返回一个迭代器的话，其实返回的是 const_iterator 而不是 iterator，const_iterator 有底层修饰，不能修改指向的对象。</p>
<p>例如下面的代码会报错：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> list&lt;PII&gt; L;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> L::iterator       L_iterator;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> L::const_iterator L_const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    L l;</span><br><span class="line">    <span class="function">L_iterator <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> <span class="comment">// (1)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">find_if</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> PII &amp;it)&#123;</span><br><span class="line">            <span class="keyword">return</span> it.first == x;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_val</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        L_iterator entry = <span class="built_in">get</span>(x);</span><br><span class="line">        <span class="keyword">return</span> entry-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo f;</span><br><span class="line">    L &amp;l = f.l; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )   l.<span class="built_in">push_back</span>(&#123;i, i + <span class="number">10</span>&#125;);</span><br><span class="line">    L_iterator it = f.<span class="built_in">get</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    it-&gt;second = <span class="number">1000</span>;</span><br><span class="line">    cout &lt;&lt; f.<span class="built_in">get_val</span>(<span class="number">2</span>) &lt;&lt; endl;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="built_in">test</span>();&#125;</span><br></pre></td></tr></table></figure>

<p>报错信息主要内容如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> std::<span class="built_in">find_if</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> PII &amp;it)&#123;</span><br><span class="line">      |                ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">      |                            |</span><br><span class="line">      |                            std::_List_const_iterator&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;</span><br><span class="line">   <span class="number">20</span> |             <span class="keyword">return</span> it.first == x;</span><br><span class="line">      |             ~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">   <span class="number">21</span> |         &#125;);</span><br><span class="line">      |         ~~</span><br></pre></td></tr></table></figure>

<p>很明显的发现，编译器提示我们，我们的返回值是一个 <code>list::const_iterator</code> 类型，而不是 <code>list::iterator</code>。</p>
<p>那你可能会说，如果我们不希望返回 const_ierator 的话，把 (1) 处的 const 去掉不久行了？</p>
<p>那你就得好好看了，下面的错误更隐蔽和恶心，去掉 (1) 处的 const 之后，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a.cpp: In member function <span class="string">&#x27;int Foo::get_val(int) const&#x27;</span>:</span><br><span class="line">a.cpp:<span class="number">25</span>:<span class="number">33</span>: error: passing <span class="string">&#x27;const Foo&#x27;</span> as <span class="string">&#x27;this&#x27;</span> argument discards qualifiers [-fpermissive]</span><br><span class="line">   <span class="number">25</span> |         L_iterator entry = <span class="built_in">get</span>(x);</span><br><span class="line">      |                                 ^</span><br><span class="line">a.cpp:<span class="number">17</span>:<span class="number">16</span>: note:   in call to <span class="string">&#x27;L_iterator Foo::get(int)&#x27;</span></span><br><span class="line">   <span class="number">17</span> |     <span class="function">L_iterator <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// (1)</span></span></span><br><span class="line"><span class="function">      |                ^~~</span></span><br></pre></td></tr></table></figure>

<p>上面的报错信息不认真看，理解着看的话，有可能不知道他说的是什么意思！其实这种错误在 《Effective C++》 系列都是强调过的！由此可见，光理论，不实践，掌握的知识不牢固，容易忘！</p>
<p>其实人话来说，就是 get_val() 是一个 const 成员函数，所以，在这个函数中， **this 指针是 this *const(底层 const)**，想必如果你很敏感的话，那么你应该知道错在哪了！我们把一个 this *const 传入到一个非 const 的成员函数 get() 当中，那么在 get() 当中就可能修改我们的 this，从而间接的破坏了 get_val() 的 const 属性！</p>
<blockquote>
<p>实际上，上面的 bug 正是 《effective STL》的一条 item:</p>
<p>“const_iterator fist!”</p>
</blockquote>
<p>那么，作者为什么会写出如此不严谨的代码呢？是选，有意思的一点是，如果不进行测试，上面的代码是没有问题的！那么，到底是作者写这本时的 C++ 和编译器的版本问题，还是作者偷懒没有进行测试呢？大概是前者吧！😊</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangdamingll/article/details/107086966">最终在这篇博客找到了 bug 的解决方案，感恩！</a></p>
</blockquote>
<p>最后，给出使用 iterator 的版本，只需要把所有 const 成员函数修饰去掉就行了。</p>
<blockquote>
<p>解决问题的方法就是不让问题产生 😭</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key,<span class="keyword">typename</span> Value,<span class="keyword">typename</span> Hash=std::hash&lt;Key&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> threadsafe_lookup_table</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">class</span> bucket_type</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::pair&lt;Key,Value&gt; bucket_value;</span><br><span class="line">    <span class="keyword">typedef</span> std::list&lt;bucket_value&gt; bucket_data;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> bucket_data::iterator bucket_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> bucket_data::const_iterator bucket_const_iterator;</span><br><span class="line">    </span><br><span class="line">    bucket_data data;</span><br><span class="line">    <span class="keyword">mutable</span> shared_mutex mutex;  <span class="comment">// 1</span></span><br><span class="line">    <span class="function">bucket_iterator <span class="title">find_entry_for</span><span class="params">(Key <span class="type">const</span>&amp; key)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">find_if</span>(data.<span class="built_in">begin</span>(),data.<span class="built_in">end</span>(),</span><br><span class="line">      [&amp;](bucket_value <span class="type">const</span>&amp; item)</span><br><span class="line">      &#123;<span class="keyword">return</span> item.first==key;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Value <span class="title">value_for</span><span class="params">(Key <span class="type">const</span>&amp; key,Value <span class="type">const</span>&amp; default_value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="function">shared_lock&lt;shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;  <span class="comment">// 3</span></span><br><span class="line">      bucket_iterator <span class="type">const</span> found_entry=<span class="built_in">find_entry_for</span>(key);</span><br><span class="line">      <span class="keyword">return</span> (found_entry==data.<span class="built_in">end</span>())?</span><br><span class="line">        default_value:found_entry-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_or_update_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key,Value <span class="type">const</span>&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;  <span class="comment">// 4</span></span><br><span class="line">      bucket_iterator <span class="type">const</span> found_entry=<span class="built_in">find_entry_for</span>(key);</span><br><span class="line">      <span class="keyword">if</span>(found_entry==data.<span class="built_in">end</span>())</span><br><span class="line">      &#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(<span class="built_in">bucket_value</span>(key,value));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        found_entry-&gt;second=value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;  <span class="comment">// 5</span></span><br><span class="line">      bucket_iterator <span class="type">const</span> found_entry=<span class="built_in">find_entry_for</span>(key);</span><br><span class="line">      <span class="keyword">if</span>(found_entry!=data.<span class="built_in">end</span>())</span><br><span class="line">      &#123;</span><br><span class="line">        data.<span class="built_in">erase</span>(found_entry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;bucket_type&gt; &gt; buckets;  <span class="comment">// 6</span></span><br><span class="line">  Hash hasher;</span><br><span class="line">  <span class="function">bucket_type&amp; <span class="title">get_bucket</span><span class="params">(Key <span class="type">const</span>&amp; key)</span>   <span class="comment">// 7</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::<span class="type">size_t</span> <span class="type">const</span> bucket_index=<span class="built_in">hasher</span>(key)%buckets.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> *buckets[bucket_index];</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">  <span class="keyword">typedef</span> Value mapped_type;</span><br><span class="line">  <span class="keyword">typedef</span> Hash hash_type;</span><br><span class="line">  <span class="built_in">threadsafe_lookup_table</span>(</span><br><span class="line">    <span class="type">unsigned</span> num_buckets=<span class="number">19</span>,Hash <span class="type">const</span>&amp; hasher_=<span class="built_in">Hash</span>()):</span><br><span class="line">    <span class="built_in">buckets</span>(num_buckets),<span class="built_in">hasher</span>(hasher_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> i=<span class="number">0</span>;i&lt;num_buckets;++i)</span><br><span class="line">    &#123;</span><br><span class="line">      buckets[i].<span class="built_in">reset</span>(<span class="keyword">new</span> bucket_type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">threadsafe_lookup_table</span>(threadsafe_lookup_table <span class="type">const</span>&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  threadsafe_lookup_table&amp; <span class="keyword">operator</span>=(</span><br><span class="line">    threadsafe_lookup_table <span class="type">const</span>&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  <span class="function">Value <span class="title">value_for</span><span class="params">(Key <span class="type">const</span>&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                  Value <span class="type">const</span>&amp; default_value=Value())</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_bucket</span>(key).<span class="built_in">value_for</span>(key,default_value);  <span class="comment">// 8</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add_or_update_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key,Value <span class="type">const</span>&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_bucket</span>(key).<span class="built_in">add_or_update_mapping</span>(key,value);  <span class="comment">// 9</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_bucket</span>(key).<span class="built_in">remove_mapping</span>(key);  <span class="comment">// 10</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    threadsafe_lookup_table&lt;<span class="type">int</span>,string&gt; table;</span><br><span class="line">    table.<span class="built_in">add_or_update_mapping</span>(<span class="number">1</span>, <span class="string">&quot;jyyyx&quot;</span>);</span><br><span class="line">    cout &lt;&lt; table.<span class="built_in">value_for</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    table.<span class="built_in">add_or_update_mapping</span>(<span class="number">2</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    cout &lt;&lt; table.<span class="built_in">value_for</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    table.<span class="built_in">add_or_update_mapping</span>(<span class="number">1</span>, <span class="string">&quot;sbg&quot;</span>);</span><br><span class="line">    cout &lt;&lt; table.<span class="built_in">value_for</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-3-2-threadsafe-list"><a href="#6-3-2-threadsafe-list" class="headerlink" title="6.3.2 threadsafe list"></a>6.3.2 threadsafe list</h4><p>同上面谈到的，容器中的迭代器在并发时会产生麻烦，除非让迭代器持有锁，但这是个很槽糕的做法。因此这意味着迭代器受限于锁，而不是容器。</p>
<p>替代方案是使用迭代函数，例如：将 for_each 作为容器本身的一部分。这就能让容器对迭代的部分进行负责和锁定。</p>
<p>。。。</p>
<p>链表应该提供的操作：（增删改查）</p>
<ul>
<li>向列表添加一个元素</li>
<li>当某个条件满足时，就从链表中删除某个元素</li>
<li>当某个条件满足时，从链表中查找某个元素</li>
<li>当某个条件满足时，更新链表中的某个元素</li>
<li>（more）将当前容器中链表中的每个元素，复制到另一个容器中</li>
<li>（more）插入元素到某个指定的位置</li>
</ul>
<p>使用细粒度锁最初的想法，是为了<strong>让链表每个节点都拥有一个互斥量</strong>。当链表很长时，那么就会有很多的互斥量!这样的好处是对于链表中每一个独立的部分，都能实现真实的并发：其真正感兴趣的是对持有的节点群进行上锁，并且在移动到下一个节点的时，对当前节点进行释放。下面的清单中将展示这样的一个链表实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a list with head-node</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_list</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">    &#123;</span><br><span class="line">        std::mutex m;</span><br><span class="line">        std::shared_ptr&lt;T&gt; data;</span><br><span class="line">        std::unique_ptr&lt;node&gt; next;</span><br><span class="line">        <span class="built_in">node</span>() : <span class="built_in">next</span>() &#123;&#125; <span class="comment">// default NULL</span></span><br><span class="line">        <span class="built_in">node</span>(<span class="type">const</span> T &amp;value) : <span class="built_in">data</span>(std::<span class="built_in">make_shared</span>&lt;T&gt;(value)) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    node head; <span class="comment">// default head node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_list</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">threadsafe_list</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">remove_if</span>([](<span class="type">const</span> node&amp;)&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_list</span>(<span class="type">const</span> threadsafe_list&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    threadsafe_list&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_list&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// the construction of new node neeedn&#x27;t to lock</span></span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">new_node</span><span class="params">(<span class="keyword">new</span> node(value))</span></span>;</span><br><span class="line">        <span class="comment">// lock head</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(head.m)</span></span>;</span><br><span class="line">        new_node-&gt;next = std::<span class="built_in">move</span>(head.next);</span><br><span class="line">        head.next = std::<span class="built_in">move</span>(new_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">for_each</span><span class="params">(Function f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// the node of head is a fixed and virtual node</span></span><br><span class="line">        <span class="comment">// it means no one can change it, so there is no &quot;race condition&quot;</span></span><br><span class="line">        <span class="comment">// -- when multiple threads execute the follow sentense</span></span><br><span class="line">        node *current = &amp;head; </span><br><span class="line">        <span class="comment">// because we need do unlock by self, so unique_lock does</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(head.m)</span></span>; </span><br><span class="line">        <span class="keyword">while</span>(node *next = current-&gt;next.<span class="built_in">get</span>()) <span class="comment">// declare a local variable </span></span><br><span class="line">                            <span class="comment">// -- next in the while&#x27;s check ????</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// lock the next first and unlock the past succession</span></span><br><span class="line">            <span class="comment">// there is a beautiful name for this process: hand to hand lock ^_^</span></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">next_lock</span><span class="params">(next-&gt;m)</span></span>;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="comment">// because head is a virtual node(no data)</span></span><br><span class="line">            <span class="comment">// we should call funtion start at head-&gt;next</span></span><br><span class="line">            <span class="built_in">f</span>(*next-&gt;data);</span><br><span class="line">            current = next;</span><br><span class="line">            lock = std::<span class="built_in">move</span>(next_lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expect for unary Predicate</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</span></span><br><span class="line"><span class="function">    std::shared_ptr&lt;T&gt; <span class="title">find_first_if</span><span class="params">(Predicate p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node *current = &amp;head;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(head.m)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(node *next = current-&gt;next.<span class="built_in">get</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">next_lock</span><span class="params">(next-&gt;m)</span></span>;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">p</span>(*next-&gt;data))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> next-&gt;data;</span><br><span class="line">            &#125;</span><br><span class="line">            current = next;</span><br><span class="line">            lock = std::<span class="built_in">move</span>(next_lock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">remove_if</span><span class="params">(Predicate p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node *current = &amp;head;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(head.m)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(node *next = current-&gt;next.<span class="built_in">get</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">next_lock</span><span class="params">(next-&gt;m)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">p</span>(*next-&gt;data))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// usage of smart_ptr and move() can avoid to execute big copy</span></span><br><span class="line">                std::unique_ptr&lt;node&gt; old_next = std::<span class="built_in">move</span>(current-&gt;next);</span><br><span class="line">                current-&gt;next = std::<span class="built_in">move</span>(next-&gt;next);</span><br><span class="line">                next_lock.<span class="built_in">unlock</span>();</span><br><span class="line">                <span class="comment">// needn&#x27;t to move current to next node</span></span><br><span class="line">                <span class="comment">// because the new next node will satisfiy Predicate, too</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                lock.<span class="built_in">unlock</span>();</span><br><span class="line">                current = next;</span><br><span class="line">                lock = std::<span class="built_in">move</span>(next_lock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    threadsafe_list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )   </span><br><span class="line">        L.<span class="built_in">push_front</span>(i % <span class="number">5</span>);</span><br><span class="line">    L.for_each([](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    L.<span class="built_in">remove_if</span>([](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;<span class="keyword">return</span> x == <span class="number">4</span>;&#125;);</span><br><span class="line">    L.for_each([](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> it = L.<span class="built_in">find_first_if</span>([](<span class="type">const</span> <span class="type">int</span> x)&#123;<span class="keyword">return</span> x == <span class="number">1</span>;&#125;);</span><br><span class="line">    *it = <span class="number">1024</span>;</span><br><span class="line">    L.for_each([](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    it = L.<span class="built_in">find_first_if</span>([](<span class="type">const</span> <span class="type">int</span> x)&#123;<span class="keyword">return</span> x == <span class="number">1</span>;&#125;);</span><br><span class="line">    *it = <span class="number">666</span>;</span><br><span class="line">    L.for_each([](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    L.<span class="built_in">remove_if</span>([](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;<span class="keyword">return</span> x == <span class="number">1</span>;&#125;);</span><br><span class="line">    L.for_each([](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>学到了个新东西</p>
</blockquote>
<p>可以在 while 的条件判断里面声名一个局部变量，并且可以在 while body 里面使用，但是有个限制，就是只能使用默认比价方式（0，nullptr），如果你想使用特殊的比较方式，例如：<code>while((int y = x + 1) != 3)</code>，那么局部变量 y 的作用域实际上是 <code>(int y = x + 1)</code> 这个括号里面，除了括号就死了，因此在 while body 里面也就无法使用，这时候，就得在 while 外面声明这个变量了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="type">int</span> y = x + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        x ++ ;</span><br><span class="line">        <span class="keyword">if</span>(y &gt; <span class="number">10</span>)  <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="P7-data-struct-without-mutex"><a href="#P7-data-struct-without-mutex" class="headerlink" title="P7 data struct without mutex"></a>P7 data struct without mutex</h2><p><font color=blue> TODO</font></p>
<h2 id="P8-concurrency-design"><a href="#P8-concurrency-design" class="headerlink" title="P8 concurrency design"></a>P8 concurrency design</h2><p><font color=blue> TODO</font></p>
<p>文章主要内容包括：</p>
<ul>
<li>线程间划分数据的技术</li>
<li>影响并发代码性能的因素</li>
<li>性能因素是如何影响数据结构的设计</li>
<li>多线程代码中的异常安全</li>
<li>可拓展性</li>
<li>并行算法的实现</li>
</ul>
<h3 id="8-1-divide-work-among-threads"><a href="#8-1-divide-work-among-threads" class="headerlink" title="8.1 divide work among threads"></a>8.1 divide work among threads</h3><p> 最直白的，对于一个线程，是让他充当一个“全能”线程来完成所有工作，还是充当一个“专业”线程完成一件事情，还是两者混合。等等。诸如此类的选择至关重要。</p>
<h4 id="8-1-1-prepare-divide"><a href="#8-1-1-prepare-divide" class="headerlink" title="8.1.1 prepare divide"></a>8.1.1 prepare divide</h4><p>思想很简单，就是在创建线程之前，把多个任务分为一组，一个线程处理一组任务。</p>
<p>但是这样做仍然有一个不太好的地方，如代码2.8 所示，最后一步仍然是串行的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">accumulate_block</span>&lt;Iterator,T&gt;()</span><br><span class="line">(block_start,last,results[num_threads<span class="number">-1</span>]); </span><br></pre></td></tr></table></figure>

<p>不过，accumulate 实际上是一个递减操作（即任务的个数是逐渐减少的），因此当线程数量大于一个线程上最小处理项时，可以对函数递归调用，这样就可以最大化并行的程度。</p>
<blockquote>
<p>原本递归是等一个子函数执行完，再执行另一个子函数。但是通过线程，我们可以同时递归执行多个子函数，自函数再递归执行多个自函数，每个子函数占用一个线程。</p>
<p>可以发现，这对线程数量的要求比较高！</p>
</blockquote>
<h4 id="8-1-2-recursion-divide"><a href="#8-1-2-recursion-divide" class="headerlink" title="8.1.2 recursion divide"></a>8.1.2 recursion divide</h4><p>快速排序就用到了递归！</p>
<p>下面是 list 的快速排序算法的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO</span></span><br></pre></td></tr></table></figure>



<h4 id="8-1-3-work-divide"><a href="#8-1-3-work-divide" class="headerlink" title="8.1.3 work divide"></a>8.1.3 work divide</h4><p>多线程下有两个危险需要分离。</p>
<ol>
<li>第一个是对错误的担忧（主要表现为线程间共享着很多的数据）</li>
<li>第二个是不同的线程需要相互等待。</li>
</ol>
<p>这两种情况都是因为线程间很密切的交互。如果这种情况发生，就需要看一下为什么发生这么多交互。当所有交互都有相同的问题，就应该使用但线程来解决，并将引用同一源的线程提取出来。或者当有两个线程需要频繁的交流，在没有其它线程时，就可以将这两个线程合为一个线程。</p>
<p>当任务会应用到相同的任务序列，去处理独立的数据项时，就可以使用 pipeline 系统进行并发。</p>
<p>使用这种方式划分工作，可以为流水线中的每一阶段操作创建一个独立线程。</p>
<h3 id="8-2-performance-of-concurrency"><a href="#8-2-performance-of-concurrency" class="headerlink" title="8.2 performance of concurrency"></a>8.2 performance of concurrency</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34074740/article/details/92960920">关于cpu的核和芯</a></p>
<p>原生多核，封装多芯</p>
<p>作者说，四核两芯的cpu可以有16个线程，是因为超线程吗？</p>
</blockquote>
<h4 id="8-2-1-cpu-count"><a href="#8-2-1-cpu-count" class="headerlink" title="8.2.1 cpu count"></a>8.2.1 cpu count</h4><p>为了拓展线程的数量，且与硬件所支持的并发线程数一致，C++ 标准库提供了 <code>std::thread::hardware_concurrency()</code>，使用这个函数可以知道在给定硬件上可以拓展的线程数量。</p>
<blockquote>
<p>我的 MacBook M1 Air 才是 8</p>
</blockquote>
<p>使用的线程个数不是越多越好，太多线程进行切换会导致 oversubscription(超额请求)</p>
<h4 id="8-2-2-race-data-and-cache-ping-pong"><a href="#8-2-2-race-data-and-cache-ping-pong" class="headerlink" title="8.2.2 race data and cache ping-pong"></a>8.2.2 race data and cache ping-pong</h4><p>当多个线程在不同的处理器上时，对数据的读取通常不会有问题，因为数据会拷贝到每个线程的缓存中，并让多个处理器同时处理。然鹅，当有线程对数据进行修改，并且需要同步到其它核心的缓存时，需要浪费一定的时间。这样的修改可能会让其它处理情停下来，等待硬件内存更新缓存的数据。并且，根据 cpu 指令，这是一个特别慢的操作。</p>
<blockquote>
<p><strong>high contention</strong>：处理器之间经常需要等待数据的更改</p>
<p><strong>low contention</strong>：处理器之间很少需要相互等待</p>
<p><strong>cache ping-pong</strong>：在多个处理器的缓存之间来回传递的数据</p>
</blockquote>
<p>避免 cache ping-pong 的方法就是减少两个线程对同一个内存为止的竞争</p>
<h4 id="8-2-3-false-sharing"><a href="#8-2-3-false-sharing" class="headerlink" title="8.2.3 false sharing"></a>8.2.3 false sharing</h4><p>cache line sharing</p>
<p>其实就是减少缓存的刷新次数，降低数据伪共享缓存的概率。</p>
<h4 id="…"><a href="#…" class="headerlink" title="…."></a>….</h4><h3 id="8-3-design-data-struct-for-multiple-thread-environment"><a href="#8-3-design-data-struct-for-multiple-thread-environment" class="headerlink" title="8.3 design data struct for multiple thread environment"></a>8.3 design data struct for multiple thread environment</h3><p>当为多线程设计数据结构时，需要考虑：contention, false sharing, data proximity(数据临近)，这些对性能都有重大影响。</p>
<h2 id="P9-advance-thread-management"><a href="#P9-advance-thread-management" class="headerlink" title="P9 advance thread management"></a>P9 advance thread management</h2><h2 id="P10-parallel-algorithm"><a href="#P10-parallel-algorithm" class="headerlink" title="P10 parallel algorithm"></a>P10 parallel algorithm</h2><h2 id="P11-test-and-debug-in-multiple-thread-environment"><a href="#P11-test-and-debug-in-multiple-thread-environment" class="headerlink" title="P11 test and debug in multiple thread environment"></a>P11 test and debug in multiple thread environment</h2><p><strong>[TODO]</strong></p>
<h2 id="A-Myheader"><a href="#A-Myheader" class="headerlink" title="A Myheader"></a>A Myheader</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">@copyright jyyyx</span></span><br><span class="line"><span class="comment">    __</span></span><br><span class="line"><span class="comment">.__(.)&lt; (qaq ~~~)</span></span><br><span class="line"><span class="comment">\____)</span></span><br><span class="line"><span class="comment">~~~~~~~~~~~~~~~~~--&gt;</span></span><br><span class="line"><span class="comment">When I write this, only god and me konw what the program mean</span></span><br><span class="line"><span class="comment">Now, only god konws QAQ</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_HEADER_GUARD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_HEADER_GUARD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span> <span class="comment">// std::shared_mutex</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// for_each</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span>    <span class="comment">// class ratio</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// unique_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// result_of</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">// accumulate</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>   <span class="comment">// mem_fn</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>   <span class="comment">// std::chrono, time point, time duration</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span>    <span class="comment">// copy_exception renamed to make_exception_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span>   <span class="comment">// put_time</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*================ header ================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN std::cout &lt;&lt; <span class="string">&quot;|------ begin ------|&quot;</span> &lt;&lt; std::endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   std::cout &lt;&lt; <span class="string">&quot;|------- end -------|&quot;</span> &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::mutex some_mutex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>



<h2 id="B-std-atomic"><a href="#B-std-atomic" class="headerlink" title="B std::atomic"></a>B std::atomic</h2><h3 id="0-reference"><a href="#0-reference" class="headerlink" title="0. reference"></a>0. reference</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7086226046931959838">ref1</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/haippy/p/3284540.html">ref2</a></p>
<p><a target="_blank" rel="noopener" href="https://subingwen.cn/cpp/atomic/">ref3</a></p>
<h3 id="1-introduce"><a href="#1-introduce" class="headerlink" title="1. introduce"></a>1. introduce</h3><p><code>#include &lt;atomic&gt;</code></p>
<p>原子类型(<code>std::atoimic&lt;T&gt;</code>)是封装了一个值的类型，它的访问保证不会导致数据的竞争，并且可以用于在不同的线程之间同步内存访问。</p>
<p>原子类型主要用于避免加锁解锁时的程序开销，从而提高性能。(互斥量加锁一般针对的是一个代码段，而原子操作针对的一般是一个变量)。</p>
<p>原子类型是“指令”层面上的支持，因此它的性能相比锁和消息传递会好很多。</p>
<p>std::atomic 内部使用了 CAS(compare and swap) 自旋锁：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CompareAndSwap</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> expceted, <span class="type">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> actual = *ptr;</span><br><span class="line">    <span class="keyword">if</span>(actual == expected) *ptr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> *actual;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*===================================*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">CompareAndSwap</span>(&amp;lock-&gt;flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>) </span><br><span class="line">        	; <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-std-atomic-flag"><a href="#2-std-atomic-flag" class="headerlink" title="2. std::atomic_flag"></a>2. std::atomic_flag</h3><p><code>std::atomic_flag</code>是原子布尔类型，它保证是免锁（lock-free）的。只支持两种操作：<code>test-andset</code> 和 <code>clear</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须使用 ATOMIC_FLAG_INIT 初始化，否则值是 UB</span></span><br><span class="line"><span class="comment">// 即，既不是 set 也不是 clear</span></span><br><span class="line"><span class="comment">// 该宏将使得 atomic_flag 处于 clear 状态</span></span><br><span class="line">std::atomic_flag alock = ATOMIC_FLAG_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(alock.<span class="built_in">test_and_set</span>(std::memory_order_acquire)) <span class="comment">// 获得锁</span></span><br><span class="line">            ;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Output from thread &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        alock.<span class="built_in">clear</span>(std::memory_order_release);  <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    std::vector&lt;std::thread&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(f, i); <span class="comment">// 通过 emplace 传入线程和参数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it : v)   </span><br><span class="line">        it.<span class="built_in">join</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>自旋锁</p>
<blockquote>
<p>自旋锁是<strong>计算机科学用于多线程同步的一种锁</strong>，线程反复检查锁变量是否可用。 由于线程在这一过程中保持执行，因此是一种<strong>忙等待</strong>。 一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。 自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。</p>
</blockquote>
<p>C++ 是系统级别的编程语言，标准委员会的目标是不需要比C++还要底层的高级语言。C++ 应该向程序员提供足够的灵活性，无障碍的去做他们想要做的事情。需要时，也可以“接触硬件”。原子类型和原子操作就可以<strong>“接触硬件”</strong>，并提供底层同步操作，通常会将指令数缩减到 1～2 个CPU指令。</p>
<p><font color = blue> TODO ⌛️⌛️⌛️ </font></p>
<p>一个简单的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread_pool_cpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_COUNT 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> </span><br><span class="line">&#123;</span><br><span class="line">    mutex m;</span><br><span class="line">    <span class="comment">// int value;</span></span><br><span class="line">    atomic&lt;<span class="type">int</span>&gt; value;</span><br><span class="line">    <span class="built_in">Counter</span>(<span class="type">int</span> _value = <span class="number">0</span>) : <span class="built_in">value</span>(_value) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_COUNT; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            value ++ ;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;increment number: &quot; &lt;&lt; value </span></span><br><span class="line">            <span class="comment">//     &lt;&lt; &quot;, threadID: &quot; &lt;&lt; hex &lt;&lt; this_thread::get_id() &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">            <span class="comment">// this_thread::sleep_for(chrono::milliseconds(100));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">consume</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_COUNT; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            value -- ;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;decrement number: &quot; &lt;&lt; value </span></span><br><span class="line">            <span class="comment">//     &lt;&lt; &quot;, threadID: &quot; &lt;&lt; hex &lt;&lt; this_thread::get_id() &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">            <span class="comment">// this_thread::sleep_for(chrono::milliseconds(100));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Counter <span class="title">c</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> increment = <span class="built_in">bind</span>(&amp;Counter::produce, &amp;c);</span><br><span class="line">    <span class="keyword">auto</span> decrement = <span class="built_in">bind</span>(&amp;Counter::consume, &amp;c);</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(decrement)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t4</span><span class="params">(decrement)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; c.value &lt;&lt; endl;</span><br><span class="line">;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h1 id="C-thread-pool"><a href="#C-thread-pool" class="headerlink" title="C:thread_pool"></a>C:thread_pool</h1><h2 id="站在巨人的肩膀上"><a href="#站在巨人的肩膀上" class="headerlink" title="站在巨人的肩膀上"></a>站在巨人的肩膀上</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://subingwen.cn/categories/Linux/">document</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1sv41177e4/?p=19">multiple thread</a>    <a target="_blank" rel="noopener" href="https://subingwen.cn/linux/threadpool/#1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86">document</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jV411J795/?spm_id_from=333.999.0.0&vd_source=38033fe3a1f136728a1d6f8acf710b51">thread pool in C</a></p>
</blockquote>
<h2 id="一、-多线程"><a href="#一、-多线程" class="headerlink" title="一、 多线程"></a>一、 多线程</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><blockquote>
<p>可以通过sleep稍微控制线程的执行顺序。。。</p>
</blockquote>
<p>一个线程就是一个“任务”，当我们创建一个线程时，它就开始执行这个任务。</p>
<h3 id="2-创建线程"><a href="#2-创建线程" class="headerlink" title="2. 创建线程"></a>2. 创建线程</h3><p>我们创建的线程一般称为子线程，为啥不是主线程呢？因为主线程一般是默认存在的！当我们在一个进程中创建线程时，主进程会变成主线程。</p>
<p>因此，当主线程退出时，也就意味着主进程结束了，也就意味着分配的虚拟内存空间要释放，因此其余线程也要销毁。</p>
<p>但是，我们可以通过调用相关API，使得主线程退出后，子线程也可以正常运行。</p>
<p><code>pthread_create();</code></p>
<h3 id="3-线程退出"><a href="#3-线程退出" class="headerlink" title="3. 线程退出"></a>3. 线程退出</h3><p>在上面提到，如果主线程退出，子线程没执行完也会结束。我们也提到，只需要使用（线程退出函数）就可以让当前线程“马上退出”，并且不会影响其他线程的正常运行。</p>
<p>如果所有线程都使用了线程退出函数，那么当所有线程执行结束之后，系统资源（虚拟地址空间）会被操作系统回收。</p>
<p><code>pthread_exit();</code></p>
<p>当线程退出时，还可以通过该函数传出一些数据（其实是这些数据的地址）。 注意不能传出栈中的数据。</p>
<p>可以通过下面三种方式：</p>
<ol>
<li>heap</li>
<li>全局&#x2F;static</li>
<li>接受主线程（调用线程）中的数据，并传出接受的数据。</li>
</ol>
<p>子线程是不能访问主线程的栈空间的，但是主线程可以主动传入。</p>
<h3 id="4-线程回收"><a href="#4-线程回收" class="headerlink" title="4. 线程回收"></a>4. 线程回收</h3><p>主线程回收子线程资源。</p>
<p>回收什么资源呢？</p>
<p>我们知道，线程独占stack等，当线程结束时，stack资源会自动释放，heap，data和text等共享资源由操作系统自动回收。</p>
<p>主线程回收的主要是“内核资源”。这件事子线程自己干不了。</p>
<p><code>pthread_join(tid, **retval);</code></p>
<p>为什么第二个参数接受一个二级指针呢？</p>
<p>因为我们如果要接受<code>pthread_exit();</code> 返回的数据，就要使用一个指针（<code>void*</code>）接受。因为 <code>pthread_exit</code> 返回的数据类型就是 <code>void*</code>。</p>
<p>如果我们要修改一个指针（注意不是指针指向的数据），就要传入一个指针的地址，所以我们就要用指向指针的指针。</p>
<p>注意 join 是一个阻塞函数。</p>
<h3 id="5-线程分离"><a href="#5-线程分离" class="headerlink" title="5. 线程分离"></a>5. 线程分离</h3><p>detach：分离</p>
<p>默认情况下，主线程和子线程是有联系的，即，主线程需要释放子线程拥有的资源。</p>
<p>调用这个函数之后，指定的子线程和主线程分离。当子线程推出的时候，其占用的内核资源就被系统的其他进程接管并回收了。（这意味着 <code>pthread_join()</code> 无法回收子线程资源）</p>
<p>可能你会问，我们已经有了 <code>join</code> 了啊，他已经可以完成线程内核资源回收的任务了，为什么还有有 <code>detach</code> 呢，这是因为 <code>join</code> 是阻塞性函数，也就是说，当子线程不 <code>exit</code> 时，主线程就会一直处于阻塞状态。</p>
<p><code>detach</code> 就是给主线程减负的，当子线程结束时，其资源不需要主线程来回收。</p>
<p>但是当主线程结束时，子线程仍然会结束，即使子线程处于 <code>detach</code> 状态。如果我们希望主线程结束时不影响子线程的执行，应该调用 <code>exit</code> 函数。 </p>
<h2 id="二、线程同步"><a href="#二、线程同步" class="headerlink" title="二、线程同步"></a>二、线程同步</h2><h3 id="1-为什么要同步"><a href="#1-为什么要同步" class="headerlink" title="1. 为什么要同步"></a>1. 为什么要同步</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX (25)</span></span><br><span class="line"><span class="type">int</span> sum;    </span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">add</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch = *(<span class="type">char</span>*)arg;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> old = sum;</span><br><span class="line">        old ++ ;</span><br><span class="line">        <span class="comment">// do something to make thread run currency worse</span></span><br><span class="line">        usleep(<span class="number">5</span>);</span><br><span class="line">        sum = old;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%c]sum = %d\n&quot;</span>, ch, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2;</span><br><span class="line">    <span class="type">char</span> c1 = <span class="string">&#x27;A&#x27;</span>, c2 = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    pthread_create(&amp;p1, <span class="literal">NULL</span>, add, (<span class="type">void</span>*)&amp;c1);</span><br><span class="line">    pthread_create(&amp;p2, <span class="literal">NULL</span>, add, (<span class="type">void</span>*)&amp;c2);</span><br><span class="line">    pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;End, sum = %d\n&quot;</span>, sum);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码希望通过两个线程实现对 sum 的累加，并希望结果为50，但是却不是。</p>
<h3 id="2-互斥锁"><a href="#2-互斥锁" class="headerlink" title="2. 互斥锁"></a>2. 互斥锁</h3><p>如其名，互斥锁只能被一个线程使用。</p>
<p>通过互斥锁，让线程线性执行，这样就不会有并发问题。</p>
<p>锁的个数取决于临界资源而不是线程个数。</p>
<p>另外，可以发现使用互斥锁的函数都是用的mutex指针，这就说明我们的mutex不能分配在 局部内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create mutex</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// init</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// destory</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destory</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">// lock，已经lock会阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">// 已经lock会失败</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<p>key :strict</p>
<blockquote>
<p>用来修饰指针，只有这个关键字修饰的指针才能访问指向的内存地址，其他指针都是不行的（类型匹配也不行）。</p>
<p><strong>TODO:</strong> 但是我测试不行？？</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> *restrict p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ++ *p;</span><br><span class="line">    <span class="type">int</span> *q = (<span class="type">int</span>*)p;</span><br><span class="line">    ++ *q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">add</span>(&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-读写锁"><a href="#3-读写锁" class="headerlink" title="3. 读写锁"></a>3. 读写锁</h3><p>读写锁是互斥锁的升级版。在做读操作的时候可以提高程序的执行效率，如果所有的线程都是读操作，那么都是并行的。而使用互斥锁，读操作是串行的。</p>
<p>其与互斥锁的区别主要在于读操作可以并行，因此，当线程涉及到大量读操作，读写锁的效率比互斥锁高。</p>
<p>读写锁虽然有读锁和写锁，但他是「一把锁」。</p>
<p>写锁的优先级比读锁高。</p>
<p>API:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declare</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">// init</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *restrict rolock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *restrict attr)</span></span>;</span><br><span class="line"><span class="comment">// destory</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_destory</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// read lock，如果已经加了写锁，线程阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// try read lock，如果已经写了写锁，失败返回，不会阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// write lock，只要加了锁（读/写）就会失败，阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// try write lock</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_tryrwlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// unlock</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Example：下面是，5个线程执行读操作，3个线程执行写操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX (20)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_COUNT  (5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_COUNT (3)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum;    </span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func_read</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread read, id = %lu, sum = %d\n&quot;</span>, <span class="built_in">pthread_self</span>(), sum);</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="built_in">rand</span>() % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func_write</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="type">int</span> cur = sum;</span><br><span class="line">        cur ++ ;   </span><br><span class="line">        sum = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread write, id = %lu, sum = %d\n&quot;</span>, <span class="built_in">pthread_self</span>(), sum);</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_rwlock_init</span>(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">pthread_t</span> rd[READ_COUNT], wr[READ_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; READ_COUNT; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        rd[i] = <span class="built_in">pthread_create</span>(&amp;rd[i], <span class="literal">NULL</span>, func_read, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; WRITE_COUNT; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        wr[i] = <span class="built_in">pthread_create</span>(&amp;wr[i], <span class="literal">NULL</span>, func_write, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; READ_COUNT; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(rd[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; WRITE_COUNT; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(wr[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// expect sum = 60</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Father thread id = %ld\n, sum = %d&quot;</span>, <span class="built_in">pthread_self</span>(), sum);</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_rwlock_destroy</span>(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后，我们可以发现，所有打印出来的 sum 是升序的，这说明我们的读写锁没有问题，另外，我们可以发现，有大量读操作在最后才执行，这是因为前面说的，当一个读操作和一个写操作同时访问同一个临界资源时，写操作的优先级更高。</p>
<h3 id="4-条件变量"><a href="#4-条件变量" class="headerlink" title="4. 条件变量"></a>4. 条件变量</h3><p>严格意义上来说，条件变量的主要作用不是处理线程同步，<strong>而是进行线程的阻塞。</strong></p>
<p>如果多线程下只使用条件变量无法完成线程的同步，必须要配合互斥锁来使用。</p>
<p>那既然有了互斥锁，为什么还要用条件变量呢？主要是为了处理「生产者和消费者模型」。（常规的临界资源只有一份，只允许一个线程访问，而有时候临界资源可能有多份，可以分给多个线程，这就是条件变量的用处）</p>
<p>APIs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declare</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// create</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *restrict cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *restrict atrt)</span></span>;</span><br><span class="line"><span class="comment">// destroy</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// wait，会阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *restrict cond, <span class="type">pthread_mutex_t</span> *restrict mutex)</span></span>; <span class="comment">// 可以发现，这里使用了一个互斥锁;其中，互斥锁是用来同步的，条件变量是用来阻塞线程的。</span></span><br><span class="line"><span class="comment">// time wait，将线程阻塞一段时间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_timewait</span><span class="params">(<span class="type">pthread_cond_t</span> *restrict cond, <span class="type">pthread_mutex_t</span> *restrict mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *restrict abstime)</span></span>; <span class="comment">// 阻塞时间为 sec + nsec。</span></span><br><span class="line"><span class="comment">// signal specific one，至少有一个被解除阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cont_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// signal all，唤醒阻塞在条件变量伤的线程，被阻塞的线程全部解除阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>; 	<span class="comment">// 将所有线程唤醒之后，只有wait成功的线程才会执行，剩下的wait失败的线程会继续阻塞。</span></span><br></pre></td></tr></table></figure>

<p>为什么 pthread_cond_wait() 的参数有一个 mutex？</p>
<blockquote>
<p>首先，我们需要知道 wait 做了什么？</p>
<ol>
<li>释放自己占据的 mutex（作为参数传入）</li>
<li>阻塞，等待被别的线程唤醒</li>
<li>被唤醒后，再次获取 mutex（作为参数传入）</li>
</ol>
<p>现在明白了吧，一般来说，我们执行 cond_wait 的时候，都是已经 mutex_lock 的，如果我们不 unlock 的话，其他线程就无法进入临界区，也就无法 cond_signal，那么被阻塞的线程也就不会被唤醒。也就发生了死锁。</p>
</blockquote>
<p>example1：生产者消费者模型 - 链表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT (5)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node_t</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node_t</span> *next;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line">Node *head;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">produce</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> id = (<span class="type">unsigned</span> <span class="type">long</span>)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 链表不可能满，除非malloc错误</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> val = <span class="built_in">rand</span>() % <span class="number">1000</span>;</span><br><span class="line">        Node *newNode = (Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">        newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        newNode-&gt;val = val;</span><br><span class="line">        <span class="keyword">if</span>(newNode == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[Producer] id = %ld, malloc Wrong\n&quot;</span>, id);</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[Producer%d] id = %lu, val = %d\n&quot;</span>, id, <span class="built_in">pthread_self</span>(), val);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">        <span class="comment">// pthread_cond_broadcast(&amp;mutex);</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">consume</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> id = (<span class="type">unsigned</span> <span class="type">long</span>)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 阻塞消费者进程，并释放它的锁，否则，它既占据着mutex，又占据cond，就会死锁</span></span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);   </span><br><span class="line">        &#125;</span><br><span class="line">        Node *cur = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[Consumer%d] id = %lu, val = %d\n&quot;</span>, id, <span class="built_in">pthread_self</span>(), cur-&gt;val);</span><br><span class="line">        <span class="built_in">free</span>(cur);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">pthread_t</span> t1[COUNT], t2[COUNT];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;t1[i], <span class="literal">NULL</span>, produce, (<span class="type">void</span>*)i);</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;t2[i], <span class="literal">NULL</span>, consume, (<span class="type">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(t1[i], <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_join</span>(t2[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;cond);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这个生产者消费者模型中，我们使用链表储存产品，因为理论上可以存储无限个产品，所以只需要使用一个条件变量判断产品队列是否为空。</p>
<p>如果使用数组，即产品是有限的，那么我们还需要一个新的条件变量来判断产品是否满了。</p>
<p>注意我们不能同时使用同一个条件变量判断是否为满和是否为空。</p>
</blockquote>
<p>example2：生产者消费者模型 - 数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="5-信号量"><a href="#5-信号量" class="headerlink" title="5. 信号量"></a>5. 信号量</h3><p>同条件变量一样，信号量主要用于阻塞线程，不能完全保证线程安全，如果要保证线程安全，需要信号量和互斥锁一起使用。</p>
<p>另外，需要注意信号量的wait和条件变量的wait是不同的，这从参数列表就可以发现，信号量的wait参数列表中并没有 mutex 参数，因此，当线程阻塞时，他不会释放获取的 mutex 资源，因此，我们必须通过手工的方式控制信号量和锁的获取顺序：先获取信号量，再获取锁，以避免死锁。</p>
<p><code>&lt;semaphore.h&gt;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declare</span></span><br><span class="line"><span class="type">sem_t</span> sem;</span><br><span class="line"><span class="comment">// create</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br><span class="line">	<span class="comment">// pshared</span></span><br><span class="line">		<span class="comment">// 0: 线程同步</span></span><br><span class="line">		<span class="comment">// !0:进程同步</span></span><br><span class="line">	<span class="comment">// value:初始化当前信号量拥有的资源数，如果资源数为0，线程就会被阻塞了。</span></span><br><span class="line"><span class="comment">// destroy</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="type">se_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">// wait，if value==0，阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">// trywait，不会阻塞，直接失败</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">// timewait，资源数为0时，阻塞线程，在阻塞 abs_timeout 对应的时间之后，解除阻塞线程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec, *abs_timeout)</span></span>;</span><br><span class="line"><span class="comment">// post</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">// get shared value</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span></span>;</span><br><span class="line">	<span class="comment">// 第二个参数返回 shared-value，返回值是用来错误检查的</span></span><br></pre></td></tr></table></figure>

<p>example：生产者和消费者模型</p>
<h3 id="6-timespec"><a href="#6-timespec" class="headerlink" title="6. timespec"></a>6. timespec</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> tv_sec;	<span class="comment">// 秒</span></span><br><span class="line">    <span class="type">long</span> tv_nsec;	<span class="comment">// 纳秒</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line">time mytim = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span> tmsp;</span><br><span class="line">tmsp.tv.nsec = <span class="number">0</span>;</span><br><span class="line">tmsp.tv_sec = <span class="built_in">time</span>(<span class="literal">NULL</span>) + <span class="number">100</span>;	<span class="comment">// 线程阻塞100秒s</span></span><br></pre></td></tr></table></figure>

<h2 id="三、线程池"><a href="#三、线程池" class="headerlink" title="三、线程池"></a>三、线程池</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h3><p>为什么要有线程池</p>
<blockquote>
<p>同内存池的设计需求一样，线程池也是用来避免线程的大量创建和销毁所带来的巨大开销。</p>
</blockquote>
<p>线程池的组成部分</p>
<ol>
<li>任务队列：线程就是用来处理任务的，但是可能任务的个数要远大于线程的个数，因此无法一次性处理完所有的任务，因此我们就需要用一个 data struct（一般为数组 or 链表） 将任务存起来。</li>
<li>工作的线程：处理任务队列的任务的消费者，通常有多个。</li>
<li>管理者线程：不处理任务队列的任务，负责管理工作的线程（增加或者销毁线程），只有一个。</li>
</ol>
<p>任务队列的存在也意味着，线程池就差不多是一个生产者消费者模型。线程池负责为负消费者线程和任务队列，而使用者负责维护生产者线程（通过线程池提供的 API 接口）。</p>
<p>任务队列存储的是任务，而任务通常是一个个（回调）函数，因此任务队列需要存储函数的地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">工作线程是一直不停的干活，管理线程是间隔检测的。</span><br><span class="line">如何“销毁”线程？让他们自杀</span><br><span class="line">没干活的线程在哪呢？通过worker函数可以发现，没工作的线程都阻塞在了条件变量里面，那么我们可以唤醒所有线程。</span><br></pre></td></tr></table></figure>

<h3 id="2-虚假唤醒"><a href="#2-虚假唤醒" class="headerlink" title="2. 虚假唤醒"></a>2. 虚假唤醒</h3><p><font color=blue>TODO</font></p>
<h1 id="C-thread-pool-1"><a href="#C-thread-pool-1" class="headerlink" title="C++:thread_pool"></a>C++:thread_pool</h1>
                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">jyyyx</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2023/06/15/cpp_concurrency_in_action/">http://example.com/2023/06/15/cpp_concurrency_in_action/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint polocy. If reproduced, please indicate source
                    <a href="/about" target="_blank">jyyyx</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">No tag</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2023/06/15/csapp/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="csapp">
                        
                        <span class="card-title">csapp</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-06-15
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/csapp/" class="post-category">
                                    csapp
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/06/15/redis/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/19.jpg" class="responsive-img" alt="redis">
                        
                        <span class="card-title">redis</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-06-15
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/redis/" class="post-category">
                                    redis
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023</span>
            
            <span id="year">2023</span>
            <a href="/about" target="_blank">jyyyx</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1181062873" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
