<!DOCTYPE HTML>
<html lang="cn">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="csapp, cs">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>csapp | jyyyyyyyyyx</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">jyyyyyyyyyx</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>Contact</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">jyyyyyyyyyx</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			About
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/1.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">csapp</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">No tag</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/csapp/" class="post-category">
                                csapp
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2023-06-15
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h1><h2 id="0x-ff-杂项"><a href="#0x-ff-杂项" class="headerlink" title="0x ff 杂项"></a>0x ff 杂项</h2><p>Instruction set Architecture：ISA,指令集体系架构</p>
<p>软件和硬件之间的一层抽象层</p>
<p>冯诺依曼计算机，即程序<strong>存储型</strong>计算机</p>
<p>重要思想：程序就是一系列被编码了的字节序列（看上去和数据一模一样）</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/SovietPower/p/14877143.html">https://www.cnblogs.com/SovietPower/p/14877143.html</a></p>
<h2 id="0x-00-参考资料-amp-amp-lab"><a href="#0x-00-参考资料-amp-amp-lab" class="headerlink" title="0x 00 参考资料 &amp;&amp; lab"></a>0x 00 参考资料 &amp;&amp; lab</h2><p>official：</p>
<p><a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/students.html">官网</a></p>
<p><a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/labs.html">实验</a></p>
<hr>
<p>note:</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17K4y1N7Q2?spm_id_from=333.999.0.0&vd_source=38033fe3a1f136728a1d6f8acf710b51">视频详解</a> </p>
<p><a target="_blank" rel="noopener" href="https://github.com/yangminz/bcst_csapp">笔记参考视频的源码</a></p>
<hr>
<p>lab：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/wuxueqian14/CSAPP-Lab#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">比较详细的Attack，Data，Boom Lab参考</a></p>
<p><a target="_blank" rel="noopener" href="https://kazamayc.github.io/2021/02/05/csapp-lab/">Boom，Attack，Shell Lab</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/505497911">全部实验的详细参考–知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43362650/article/details/122890142">全部实验的详细参考–CSDN</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Exely/CSAPP-Labs">全部实验的详细参考–Github</a></p>
<hr>
<p>video:</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1RK4y1R7Kf?spm_id_from=333.999.0.0&vd_source=38033fe3a1f136728a1d6f8acf710b51">导读</a>        <a target="_blank" rel="noopener" href="https://fengmuzi2003.gitbook.io/csapp3e/">导读笔记</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cD4y1D7uR?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click&vd_source=38033fe3a1f136728a1d6f8acf710b51">小视频复习</a></p>
<hr>
<p>book：</p>
<p><a target="_blank" rel="noopener" href="https://hansimov.gitbook.io/csapp/">学生版重点知识</a></p>
<p><a href="instructor">讲师版重点知识</a></p>
<hr>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lab操作流程</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.datalab：</span></span><br><span class="line">在源文件 bits.c 中完善函数即可</span><br><span class="line">./dlc bits.c 	 // 用于检查程序是否合法，是否使用了程序规定的符号</span><br><span class="line">make btest   	 // btest是评分(检查对错工具)，每次执行btets前都要重新make一下</span><br><span class="line">./btest bits.c   // 评分</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.bomblab</span></span><br><span class="line">./bomb</span><br><span class="line">输入答案</span><br><span class="line">导读P3-52分钟有第一关的实操</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.attacklab</span></span><br><span class="line">./hex2raw &lt; att1.txt &gt; attraw1.txt // 将字节序列at t1转换为字符串attraw1</span><br><span class="line">./ctarget -q -i attraw1.txt     //测试答案</span><br><span class="line">// (https://github.com/wuxueqian14/csapp-lab/tree/master/Attack%20Lab)</span><br></pre></td></tr></table></figure>



<h2 id="0x-01-二进制"><a href="#0x-01-二进制" class="headerlink" title="0x 01 二进制"></a>0x 01 二进制</h2><p>内存中存储的是电压，然后通过（不知道）某种方式<strong>抽象</strong>为数字01，然而计算机的内存太大了，以致于01的个数实在太多了，于是，我们把原有的0和1分块，并再次抽象为0,1…。</p>
<p><img src="file:///C:\Users\24072\AppData\Roaming\Tencent\Users\2407217576\QQ\WinTemp\RichOle\7E[W6J9]YPX$8MS~3CCM[DG.png" alt="img"></p>
<p>加入内存中有n bit,每m bit分为一块，则最多可以分为2^m块，因为m bit的排列组合数为2 ^ n个序列（sequence）</p>
<p>例如十进制数字123，它应该表示为<code>1*10^2 + 2*10^1 + 3*10^0</code>，所以这里的123准确来说应该是一个sequence，而不是一个数。</p>
<p>数是一个比较唯心的抽象的概念，你说一个数3，它可以是十进制序列3，也可以是二进制序列11…，3和11都是这个真正的（唯心的）3，这些序列之间是一一对应的，不仅如此，他们的运算也是一一对应的。十进制的序列1+2，对应的二进制下序列为1+01</p>
<p><strong>取反对称</strong>：对称轴的两侧是相反数</p>
<p>对于1,2,3,4，他们分别取反对称于-1，-2，-3，-4</p>
<p>对于二进制000,001,010,011，他们分别取反对称于111,110,101,100</p>
<p><img src="https://s1.328888.xyz/2022/08/29/CrzXC.png" alt="IMAGE"></p>
<h2 id="0x-02-二进制运算"><a href="#0x-02-二进制运算" class="headerlink" title="0x 02 二进制运算"></a>0x 02 二进制运算</h2><p><strong>位运算的循环圈：</strong></p>
<p><img src="https://s1.328888.xyz/2022/09/06/5OAqi.png" alt="IMG"></p>
<p>​										（int类型有符号数）</p>
<p><img src="https://s1.328888.xyz/2022/09/06/5jEa0.png" alt="img"></p>
<p>​										(int类型无符号数)</p>
<p>通过这张图，你可能会更好地理解补码和无符号数运算是在mod 2^n 下计算的意义。</p>
<p>看一下树状数组lowbit函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x; <span class="comment">// &lt;==&gt; x &amp; (~x + 1);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数为什么能求得最后一个1所在位置的代表的权值呢？</p>
<p>首先 -x，其实就是x的补码。关于补码，我们有一个求补码的方法：从右到左直到第一个1保持不变，后面的位取反，我们将x和x的补码做与运算，最后得到的结果一定是这样的形式：00..010..0，最后一个1左侧全为0，右侧也全为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">func1</span><span class="params">(<span class="type">unsigned</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 输出一个无符号数x，判断x在十六进制下的的每一位是不是字母</span></span><br><span class="line">    <span class="comment">// 如果该位是字母就返回1，否则返回0</span></span><br><span class="line">    <span class="comment">// 并以一个16进制数的形式返回</span></span><br><span class="line">    <span class="type">unsigned</span> x1 = (x &amp; <span class="number">0x22222222</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> x2 = (x &amp; <span class="number">0x44444444</span>) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> x3 = (x &amp; <span class="number">0x88888888</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;[1]:%04x\n[2]:%04x\n[3]:%04x\n&quot;, x1, x2, x3);</span></span><br><span class="line">    <span class="keyword">return</span> x3 &amp; (x2 | x1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">func2</span><span class="params">(<span class="type">unsigned</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 输出一个无符号数x，判断x在十六进制下的每一位是不是字母</span></span><br><span class="line">    <span class="comment">// 如果所有位都是字母返回1，否则返回0</span></span><br><span class="line">    x = func1(x); <span class="comment">//得到了每一位的结果</span></span><br><span class="line">    x = x &amp; (x &gt;&gt; <span class="number">16</span>); <span class="comment">// 每次判断一半</span></span><br><span class="line">    x = x &amp; (x &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">    x = x &amp; (x &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">func3</span><span class="params">(<span class="type">unsigned</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// bigCount</span></span><br><span class="line">    <span class="type">unsigned</span> c;</span><br><span class="line">    c = (x &amp; <span class="number">0x55555555</span>) + ((x &gt;&gt;  <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    c = (c &amp; <span class="number">0x33333333</span>) + ((c &gt;&gt;  <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    c = (c &amp; <span class="number">0x0f0f0f0f</span>) + ((c &gt;&gt;  <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>);</span><br><span class="line">    c = (c &amp; <span class="number">0x00ff00ff</span>) + ((c &gt;&gt;  <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>);</span><br><span class="line">    c = (c &amp; <span class="number">0x0000ffff</span>) + ((c &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> x = <span class="number">0x1</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;0x%X = %X\n&quot;, x, func1(x));</span></span><br><span class="line">    <span class="comment">// printf(&quot;0x%X = %X\n&quot;, x, func2(x));</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%X = %d\n&quot;</span>, x, func3(x));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0x-03-浮点数"><a href="#0x-03-浮点数" class="headerlink" title="0x 03 浮点数"></a>0x 03 浮点数</h2><p>为什么 IEEE 754浮点数Float类型的bias&#x3D;127而不是128？</p>
<p>其实这也没有一个官方的说法，不过为了让自己接受这个设定，我们可以从两个角度考虑：</p>
<ol>
<li>首先，bias采用127时绝对值的范围比较对称</li>
<li>其次，bias采用127时最大的指数是127比bias&#x3D;128时的126大，虽然只大1，但是我们直到指数的增长是“爆炸”的，因此其表示的范围也大得多。</li>
</ol>
<p>浮点的根据exp和frac分为三种情况：</p>
<ol>
<li>exp&#x3D;111..1，指数全1。此时又分为两种情况：（1）当frac全0时表示无穷大，根据符号位又分为正无穷和负无穷。（2）frac不全为0，表示NaN，一种未定义行为。（可以这样区分无穷和NaN，由于未定义的行为有很多，因此需要根据frac进一步区分，所以frac不是固定的全0，（胡乱猜的），可以这样记忆）。</li>
<li>exp&#x3D;000..0，指数全0。表示不规格化的浮点数。这里的主要目的是为了拓展精度和范围（往值小的方向）。</li>
<li>else，规格化浮点数。</li>
</ol>
<p>将一个无符号数转换为一个浮点数的表示形式并保存在一个无符号数字中</p>
<p><a target="_blank" rel="noopener" href="https://lostphp.com/hexconvert/">IEEE 754浮点数十六进制相互转换</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/68131179">关于浮点数舍入的讨论</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">uint2float</span><span class="params">(<span class="type">uint32_t</span> u)</span>&#123; <span class="comment">// 将一个服务号数u转换成浮点数存储的形式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 特判</span></span><br><span class="line">    <span class="keyword">if</span> (u == <span class="number">0x00000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x00000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到最后一个1的后面的一个位置，求得该1后面还有多少个数</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">0</span> &amp;&amp; (((u &gt;&gt; n) &amp; <span class="number">0x1</span>) == <span class="number">0x0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        n = n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n: &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint32_t</span> e, f; <span class="comment">// exp, frac</span></span><br><span class="line">    <span class="comment">// &lt;= 0000 0000 1.111 1111 1111 1111 1111 1111 : 32位</span></span><br><span class="line">    <span class="comment">// u的位数&lt;=24，此时再隐藏一个1，就&lt;=23位，于是frac就可以保存所有位，不需要舍入</span></span><br><span class="line">    <span class="keyword">if</span> (u &lt;= <span class="number">0x00ffffff</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// no need rounding</span></span><br><span class="line">        <span class="type">uint32_t</span> mask = <span class="number">0xffffffff</span> &gt;&gt; (<span class="number">32</span> - n); <span class="comment">// mask就是frac的掩码</span></span><br><span class="line">        f = (u &amp; mask) &lt;&lt; (<span class="number">23</span> - n);             <span class="comment">// f = u &amp; mask得到frac，但还需要左移移动到最右侧[frac00..0]，而不是[00..0frac]</span></span><br><span class="line">        e = n + <span class="number">127</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;e: 0x%x, f: 0x%x\n&quot;</span>, e, f);</span><br><span class="line">        <span class="keyword">return</span> (e &lt;&lt; <span class="number">23</span>) | f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;= 0000 0001 0000 0000 0000 0000 0000 0000 </span></span><br><span class="line">    <span class="comment">// 总位数&gt;=25，一位可以隐藏，还剩下至少24位，frac无法全部保存，需要舍入(rounding)</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// expand to 64 bit for situations like 0xffffffff</span></span><br><span class="line">        <span class="type">uint64_t</span> a = <span class="number">0</span>;</span><br><span class="line">        a += u;</span><br><span class="line">        <span class="comment">// compute g, r, s</span></span><br><span class="line">        <span class="type">uint32_t</span> g = (a &gt;&gt; (n - <span class="number">23</span>)) &amp; <span class="number">0x1</span>;</span><br><span class="line">        <span class="type">uint32_t</span> r = (a &gt;&gt; (n - <span class="number">23</span> - <span class="number">1</span>)) &amp; <span class="number">0x1</span>;</span><br><span class="line">        <span class="type">uint32_t</span> s = <span class="number">0x0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">23</span> - <span class="number">1</span>; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            s = s | ((u &gt;&gt; j) &amp; <span class="number">0x1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// compute carry</span></span><br><span class="line">        a = a &gt;&gt; (n - <span class="number">23</span>);</span><br><span class="line">        <span class="comment">// 0    1    ?    ... ?</span></span><br><span class="line">        <span class="comment">// [24] [23] [22] ... [0]</span></span><br><span class="line">        <span class="keyword">if</span> (r &amp; (g | s) == <span class="number">0x1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = a + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check carry</span></span><br><span class="line">        <span class="keyword">if</span> ((a &gt;&gt; <span class="number">23</span>) == <span class="number">0x1</span>) /</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 0    1    ?    ... ?</span></span><br><span class="line">            <span class="comment">// [24] [23] [22] ... [0]</span></span><br><span class="line">            f = a &amp; <span class="number">0x007fffff</span>; <span class="comment">// 0x0000 0000 0111 1111 1111 1111 1111 1111只保留frac</span></span><br><span class="line">            e = n + <span class="number">127</span>;</span><br><span class="line">            <span class="keyword">return</span> (e &lt;&lt; <span class="number">23</span>) | f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((a &gt;&gt; <span class="number">23</span>) == <span class="number">0x2</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1    0    0    ... 0</span></span><br><span class="line">            <span class="comment">// [24] [23] [22] ... [0]</span></span><br><span class="line">            e = n + <span class="number">1</span> + <span class="number">127</span>;</span><br><span class="line">            <span class="keyword">return</span> (e &lt;&lt; <span class="number">23</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// INF as default error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x7f800000</span>; <span class="comment">// 0 1111 1111 000 0000 0000 0000 0000 0000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;  <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, uint2float(<span class="number">0x10000000</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0x-04-时序电路和组合电路"><a href="#0x-04-时序电路和组合电路" class="headerlink" title="0x 04 时序电路和组合电路"></a>0x 04 时序电路和组合电路</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_20265495/article/details/41314577">原文链接：</a></p>
<hr>
<p><strong>数字电路</strong>根据逻辑功能的不同特点，可以分成两大类，一类叫<strong>组合逻辑电路</strong>（简称组合电路），另一类叫做<strong>时序逻辑电路</strong>（简称时序电路）。组合逻辑电路在逻辑功能上的特点是任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关。而时序逻辑电路在逻辑功能上的特点是任意时刻的输出不仅取决于当时的输入信号，而且还取决于电路原来的状态，或者说，还与以前的输入有关。</p>
<p>时序电路，是由最基本的逻辑门电路加上反馈逻辑回路（输出到输入）或器件组合而成的电路，与组合电路最本质的区别在于时序电路具有记忆功能。</p>
<p>时序电路的特点是：输出不仅取决于当时的输入值，而且还与电路过去的状态有关。它类似于含储能元件的电感或电容的电路，如触发器、锁存器、计数器、移位寄存器、存储器等电路都是时序电路的典型器件，时序逻辑电路的状态是由存储电路来记忆和表示的。</p>
<p>时序电路和组合电路的区别：<br>时序电路具有<strong>记忆功能</strong>。时序电路的特点是：输出不仅取决于当时的输入值，而且还与电路过去的状态有关。组合逻辑电路在逻辑功能上的特点是任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关</p>
<p>时序电路是 时序 逻辑 电路。时序，时间 顺序，是在时钟的推动下工作的，cpu就是一个复杂的时序电路。</p>
<p>组合逻辑电路和时序逻辑电路的最根本区别在于：组合逻辑电路的输出在任一时刻只取决于当时的输入信号；而时序逻辑电路的输出，不仅和当前的输入有关，还和上时刻的输出有关，它具有记忆元件（触发器），可以记录前一时刻的输出状态，它可以没有输入，仅在时钟的驱动下，给出输出。</p>
<p>时序电路的基本结构：</p>
<p><img src="https://img-blog.csdn.net/20151210201333026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>结构特征：<em>电路由组合电路和存储电路组成</em>，电路存在反馈 </p>
<h2 id="0x-05-缓冲区漏洞实验"><a href="#0x-05-缓冲区漏洞实验" class="headerlink" title="0x 05 缓冲区漏洞实验"></a>0x 05 缓冲区漏洞实验</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//bomb.c</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">4</span>];</span><br><span class="line">	gets(buffer); <span class="comment">//缓冲区溢出的关键</span></span><br><span class="line">	<span class="built_in">puts</span>(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;pls input: &quot;</span>);</span><br><span class="line">	echo();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">操作步骤：</span><br><span class="line">1. gcc bomb.c -o main -fno-stack-protector -g</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-fno-stack-protector取消栈保护？</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-g调试模式，因为后面还需要调试</span></span><br><span class="line"></span><br><span class="line">2. gdb main</span><br><span class="line">2.1 在echo函数的gets函数加上一个断点：b 6</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span>函数位于main.c的第六行</span></span><br><span class="line">2.2 r</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">run运行程序，此时会在断点gets函数停下</span></span><br><span class="line">2.3 info f </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示栈信息，如下方图-栈信息所示</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在这些信息中，我们需要注意三个地址：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(1)frame at 0x7ff.f3d0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(2)rbp at   0x7ff.f3c0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(3)bip at.  0x7ff.f3c8</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中frame at的地址是函数<span class="built_in">echo</span>占用栈的地址</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时，返回地址rip和旧的栈顶指针rbp已经入栈</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">由此可见，程序还没运行，返回地址和旧的栈顶指针就会入栈</span></span><br><span class="line">2.4 p/a &amp;buffer[0]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印数组buffer的首地址</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过结构图，我们可以发现，数组与返回地址rip之间差了12（c8-bc）字节，如果我们gets的数组大于等于12字节，那么返回地址的数据就会被破坏，</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>![image-20220907100422585](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220907100422585.png)</p>
<p>(图-栈信息)</p>
<p>![13C288AA-6A07-463D-A689-CC7FEF2DCB91](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;13C288AA-6A07-463D-A689-CC7FEF2DCB91.png)</p>
<p>(图-数组地址)</p>
<p><img src="https://1484576603-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MV9vJFv4kmvRLgEog6g%2F-MZuBW3GNKr5zld5JHFH%2F-MZuER6OHxdJ7z3gtPNL%2Fimage.png?alt=media&token=ecba360a-06d3-4734-9430-aab5fd84cbee" alt="img"></p>
<p>(图-视频测试运行gets前的栈)</p>
<p><img src="https://1484576603-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MV9vJFv4kmvRLgEog6g%2F-MZrajFxkCIYEw7i-1-F%2F-MZrrKB09-F7NqAWNBKB%2Finitpintu_%E5%89%AF%E6%9C%AC.jpg?alt=media&token=35b89f3f-e6d2-4aa9-b7d0-2da8ad86450b" alt="img"></p>
<p>（图-视频测试运行gets后的栈）</p>
<h2 id="0x-06-Computer-English"><a href="#0x-06-Computer-English" class="headerlink" title="0x 06 Computer English"></a>0x 06 Computer English</h2><hr>
<p>common：注释</p>
<p>override：覆盖</p>
<p>entry：入口，条目，输入</p>
<p>Place holder：站位</p>
<p>ascending：升序</p>
<p>descending：降序</p>
<p>comma：逗号</p>
<p>brackets：括号</p>
<p>determine: 确定，决定，判定，下决心</p>
<p>deterministic: 确定行</p>
<p>finite: 有限的</p>
<p>infinite: 无限的</p>
<p>automaton: 自动机</p>
<p>positive: 正数</p>
<p>negative: 负数</p>
<p>decimal: 十进制</p>
<p>hexadecimal：十六进制</p>
<p>octal: 八进制</p>
<p>optimazation：优化</p>
<p>pruning：剪枝</p>
<p>decode:译码</p>
<p>instance: 例子，实例</p>
<p>cpu和memory 就组成了一个状态机</p>
<p>operand 操作数</p>
<p>opreator：操作符</p>
<p>memory：内存&#x2F;存储器</p>
<p>recursion：递归</p>
<p>reduce：归约</p>
<p>iterate: 迭代</p>
<p>transistor：晶体管</p>
<p>complement：补充，补运算(～)，辅</p>
<p>parse: 解析</p>
<p>simulator: 模拟器</p>
<p>simulate: 模拟，仿真，假装</p>
<p>converter：转换器</p>
<p>verbose: 冗长的，啰嗦</p>
<p>handler: 管理者，处理程序</p>
<p>illustrate: 说明</p>
<p>universal: 通用的</p>
<p>pecuilar:  特有，奇特，一场</p>
<hr>
<h2 id="0x-07-makefile"><a href="#0x-07-makefile" class="headerlink" title="0x 07 makefile"></a>0x 07 <a target="_blank" rel="noopener" href="https://subingwen.cn/linux/makefile/#3-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F">makefile</a></h2><h3 id="1-规则"><a href="#1-规则" class="headerlink" title=".1 规则"></a>.1 规则</h3><p>（1）make命令具有<strong>自动推导</strong>的功能，例如依赖中的.o文件，即使不存在，make会使用内部默认的构造规则生成这些.o文件。</p>
<p>（2）make后面<strong>不带参数</strong>默认执行第一条命令</p>
<p>（3）mak的<strong>时间戳规则</strong>：</p>
<blockquote>
<p>make 命令执行的时候会根据文件的时间戳判定是否执行 makefile 文件中相关规则中的命令。</p>
<ol>
<li>目标是通过依赖生成的，因此正常情况下：目标时间戳 &gt; 所有依赖的时间戳 , 如果执行 make 命令的时候检测到规则中的目标和依赖满足这个条件，那么规则中的命令就不会被执行。</li>
<li>当依赖文件被更新了，文件时间戳也会随之被更新，这时候 目标时间戳 &lt; 某些依赖的时间戳 , 在这种情况下目标文件会通过规则中的命令被重新生成。</li>
<li>如果规则中的目标对应的文件根本就不存在， 那么规则中的命令肯定会被执行。</li>
</ol>
</blockquote>
<p>（4）对于不生成目标文件的目标称为伪目标，为了避免微伪目标的名字和真实的文件名重复，我们可以在伪目标的前面加上关键字：.PHONY(假) 例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean: </span></span><br><span class="line">	rm *.o</span><br></pre></td></tr></table></figure>

<p>声明位伪目标主要是避免这种情况：</p>
<blockquote>
<p>如果目标不存在规则的命令肯定被执行， 如果目标文件存在了就需要比较规则中目标文件和依赖文件的时间戳，满足条件才执行规则的命令，否则不执行。</p>
<p>加入目标是clean，而恰好有一个真实的clean文件，只要clean文件不更新，那么clean目标就无法执行。</p>
</blockquote>
<p>（提醒）<strong>目录连接到博客中的实例6可以好好看看👀</strong></p>
<h3 id="2-变量"><a href="#2-变量" class="headerlink" title=".2 变量"></a>.2 变量</h3><p>make中的变量分为三种：</p>
<p><strong>1.自定义变量</strong>：即用户自己定义的变量，makefile中的变量是<strong>没有类型</strong>的，直接创建变量然后给其赋值就可以了。通过$(obj) 可以取出自定义的obj变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">obj = main.c</span><br><span class="line">target = main</span><br><span class="line">depend = main.o</span><br><span class="line"></span><br><span class="line">$(target): $(depend)</span><br><span class="line">	gcc $(obj) -o $(target)</span><br><span class="line"></span><br><span class="line"># --------------</span><br><span class="line"># 上面的命令等价于下面：</span><br><span class="line"></span><br><span class="line">main: main.o</span><br><span class="line">	gcc main.c -o main</span><br></pre></td></tr></table></figure>

<p><strong>2.预定义变量：</strong>在makefile中有一些已经定义好的变量，用户可以直接使用这些变量，不用进行定义，预定义变量的名字一般是大写的。</p>
<p>![96D31374-3040-4B27-8A65-B9DE685E3351](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;96D31374-3040-4B27-8A65-B9DE685E3351.png)</p>
<p><strong>3.自动变量：</strong>makefile智能鼓的规则语句经常会出现目标文件和依赖文件，<strong>自动变量用来代表这些规则中的目标文件和依赖文件，并且衙门只能在规则的命令总使用。</strong></p>
<p>![DC05ED8E-B70B-44FB-A799-E6D0C938CF7F](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;DC05ED8E-B70B-44FB-A799-E6D0C938CF7F.png)</p>
<h3 id="3-模式匹配"><a href="#3-模式匹配" class="headerlink" title=".3 模式匹配"></a>.3 模式匹配</h3><p>模式匹配常常与自动变量结合使用，用来简化makefile，减少冗余和重复书写。</p>
<h3 id="4-函数"><a href="#4-函数" class="headerlink" title=".4 函数"></a>.4 函数</h3><p>1.wildcard：通配符，用来匹配制定目录下的文件</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用举例: 分别搜索三个不同目录下的 .c 格式的源文件</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> /home/robin/a/*.c /home/robin/b/*.c *.c)</span>  <span class="comment"># *.c == ./*.c</span></span><br><span class="line"><span class="comment"># 返回值: 得到一个大的字符串, 里边有若干个满足条件的文件名, 文件名之间使用空格间隔</span></span><br><span class="line">/home/robin/a/a.c /home/robin/a/b.c /home/robin/b/c.c /home/robin/b/d.c e.c f.c</span><br></pre></td></tr></table></figure>



<p>2.patsubst：pattern subsitude，匹配代替，用来替换文件名的后缀</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src = a.cpp b.cpp c.cpp e.cpp</span><br><span class="line"><span class="comment"># 把变量 src 中的所有文件名的后缀从 .cpp 替换为 .o</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(src)</span>)</span> </span><br><span class="line"><span class="comment"># obj 的值为: a.o b.o c.o e.o</span></span><br></pre></td></tr></table></figure>



<h2 id="0x-08-gdb"><a href="#0x-08-gdb" class="headerlink" title="0x 08 gdb"></a>0x 08 gdb</h2><h3 id="0-参考"><a href="#0-参考" class="headerlink" title=".0 参考"></a>.0 参考</h3><p>![9523F5A0-416A-4635-99DB-47685282748F](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;9523F5A0-416A-4635-99DB-47685282748F.png)</p>
<p><a target="_blank" rel="noopener" href="https://subingwen.cn/linux/gdb/#5-3-3-next">本文档参考来源，功能基础而简单</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/XxPIfrQ3E0GR88UsmQNggg">设计多线程，多进城等高级功能，较为复杂</a></p>
<p><a target="_blank" rel="noopener" href="https://www.yanbinghu.com/2019/04/20/41283.html">知乎</a></p>
<h3 id="1-添加命令行参数"><a href="#1-添加命令行参数" class="headerlink" title=".1 添加命令行参数"></a>.1 添加命令行参数</h3><figure class="highlight plaintext"><figcaption><span>args …```	启动gdb后，在程序启动之前设置参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```show args```	查看设置的命令行参数</span><br><span class="line"></span><br><span class="line">### .2 启动程序</span><br><span class="line"></span><br><span class="line">在整个gdb调试过程中，启动饮用程序的命令只能使用一次。</span><br><span class="line"></span><br><span class="line">```run```		可以缩写为 `r`，如果程序中设置了断点会停在第一个断点的位置，如果没有设置断点，程序就执行完了。</span><br><span class="line"></span><br><span class="line">`start` 	启动程序，最终会阻塞在main函数的第一行，等待输入后续其他 gdb 命令。</span><br><span class="line"></span><br><span class="line">&gt; start 是要开始运行， run 是真的运行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### .3 退出 gdb</span><br><span class="line"></span><br><span class="line">`quit`  缩写为 `q`</span><br><span class="line"></span><br><span class="line">### .4 查看代码</span><br><span class="line"></span><br><span class="line">`list`	可以缩写为 `l` ，通过这个命令可以查看项目中任意一个文件中的内容，并且还可以通过文件行号，函数名等方式查看。</span><br><span class="line"></span><br><span class="line">``` shell</span><br><span class="line">(gdb) list</span><br><span class="line">(gdb) list 行号</span><br><span class="line">(gdb) list 函数名</span><br></pre></td></tr></table></figure>

<p>一个项目通常由多个源文件构成，默认情况下通过 list 查看的是程序入口 main 函数对应的文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list 文件名：行号</span><br><span class="line">(gdb) list 文件名：函数名</span><br></pre></td></tr></table></figure>

<p>默认情况下 list 之显示 10 行的内容。如果想显示更多，可以通过 <code>set listsize</code> 设置，同时如果想查看当前显示的行数可以通过 <code>show listsize</code> 查看。这里的 	<code>listsize</code> 可以缩写为 <code>list</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set listsize 行号</span><br><span class="line">(gdb) show listsize</span><br></pre></td></tr></table></figure>



<h3 id="5-断点操作"><a href="#5-断点操作" class="headerlink" title=".5 断点操作"></a>.5 断点操作</h3><p>如果想通过 gdb 掉时某一行或者得到某个变量在运行状态下的实际值，就需要在这一行设置断点，程序指定到断点的位置就会阻塞。我们就可以通过 gdb 的调试命令得到我们想要的信息了。</p>
<p>设置断点：<code>break</code> 缩写为 <code>b</code></p>
<p>断点的设置方式由两种：</p>
<ol>
<li>常规断点：程序只要运行到这个位置就会阻塞</li>
<li>条件断点：只有指定的条件被满足了程序才会在断点处阻塞</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置普通断点到当前文件</span></span><br><span class="line">(gdb) b 行号</span><br><span class="line">(gdb) b 函数名 # 停在函数的第一行</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置普通断点到某个非当前文件</span></span><br><span class="line">(gdb) b 文件名：行号</span><br><span class="line">(gdb) b 问价名：函数名 # 停在函数的第一行</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置条件断点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通常情况下，在循环中条件断点用的比较多</span></span><br><span class="line">(gdb)  b 行号 if 变量名 == 某个值</span><br></pre></td></tr></table></figure>

<hr>
<p>查看断点：<code>info break</code> ，其中 <code>info</code> 可以缩写为 <code>i</code> , <code>break</code> 可以缩写为 <code>b</code></p>
<blockquote>
<p>info break 查看断点信息时的一些常用的属性：Num:   断点的编号，删除断点或者设置断点状态的时候都需要使用<br>Enb:    当前断点的状态，y 表示断点可用，n 表示断点不可用<br>What:  描述断点被设置在了哪个文件的哪一行或者哪个函数上</p>
</blockquote>
<hr>
<p>如果确定设置的某个断点不再被使用了，可用将其删除，删除命令是 <code>delete</code> 断点编号 , 这个 <code>delete</code> 可以简写为 <code>del</code> 也可以再简写为 <code>d</code>。</p>
<p>删除断点的方式有两种: <strong>删除(一个或者多个)指定断点</strong>或者<strong>删除一个连续的断点区间</strong>，具体操作如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">delete == del == d</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要 info b 查看断点的信息, 第一列就是编号</span></span><br><span class="line">(gdb) d 断点的编号1 [断点编号2 ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例:</span> </span><br><span class="line">(gdb) d 1          # 删除第1个断点</span><br><span class="line">(gdb) d 2 4 6      # 删除第2,4,6个断点</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除一个范围, 断点编号 num1 - numN 是一个连续区间</span></span><br><span class="line">(gdb) d num1-numN</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例, 删除第1到第5个断点</span></span><br><span class="line">(gdb) d 1-5</span><br></pre></td></tr></table></figure>



<hr>
<p>如果某个断点只是临时不需要了，我们可以将其设置为不可用状态，设置命令为 <code>disable</code> 断点编号，当需要的时候再将其设置回可用状态，设置命令为 <code>enable</code> 断点编号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 让断点失效之后, gdb调试过程中程序是不会停在这个位置的</span><br><span class="line"># disable == dis</span><br><span class="line"># 设置某一个或者某几个断点无效</span><br><span class="line">(gdb) dis 断点1的编号 [断点2的编号 ...]</span><br><span class="line"></span><br><span class="line"># 设置某个区间断点无效</span><br><span class="line">(gdb) dis 断点1编号-断点n编号</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 查看断点信息</span><br><span class="line">(gdb) i b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       breakpoint     keep y   0x0000000000400cce in main() at test.cpp:14</span><br><span class="line">4       breakpoint     keep y   0x0000000000400cdd in main() at test.cpp:16</span><br><span class="line">5       breakpoint     keep y   0x0000000000400d46 in main() at test.cpp:23</span><br><span class="line">6       breakpoint     keep y   0x0000000000400d4e in main() at test.cpp:25</span><br><span class="line">7       breakpoint     keep y   0x0000000000400d6e in main() at test.cpp:28</span><br><span class="line">8       breakpoint     keep y   0x0000000000400d7d in main() at test.cpp:30</span><br><span class="line"></span><br><span class="line"># 设置第2, 第4 个断点无效</span><br><span class="line">(gdb) dis 2 4</span><br><span class="line"></span><br><span class="line"># 查看断点信息</span><br><span class="line">(gdb) i b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       breakpoint     keep n   0x0000000000400cce in main() at test.cpp:14</span><br><span class="line">4       breakpoint     keep n   0x0000000000400cdd in main() at test.cpp:16</span><br><span class="line">5       breakpoint     keep y   0x0000000000400d46 in main() at test.cpp:23</span><br><span class="line">6       breakpoint     keep y   0x0000000000400d4e in main() at test.cpp:25</span><br><span class="line">7       breakpoint     keep y   0x0000000000400d6e in main() at test.cpp:28</span><br><span class="line">8       breakpoint     keep y   0x0000000000400d7d in main() at test.cpp:30</span><br><span class="line"></span><br><span class="line"># 设置 第5,6,7,8个 断点无效</span><br><span class="line">(gdb) dis 5-8</span><br><span class="line"></span><br><span class="line"># 查看断点信息</span><br><span class="line">(gdb) i b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       breakpoint     keep n   0x0000000000400cce in main() at test.cpp:14</span><br><span class="line">4       breakpoint     keep n   0x0000000000400cdd in main() at test.cpp:16</span><br><span class="line">5       breakpoint     keep n   0x0000000000400d46 in main() at test.cpp:23</span><br><span class="line">6       breakpoint     keep n   0x0000000000400d4e in main() at test.cpp:25</span><br><span class="line">7       breakpoint     keep n   0x0000000000400d6e in main() at test.cpp:28</span><br><span class="line">8       breakpoint     keep n   0x0000000000400d7d in main() at test.cpp:30</span><br></pre></td></tr></table></figure>

<p>让无效的断点生效：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">enable</span> == ena</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置某一个或者某几个断点有效</span></span><br><span class="line">(gdb) ena 断点1的编号 [断点2的编号 ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置某个区间断点有效</span></span><br><span class="line">(gdb) ena 断点1编号-断点n编号</span><br></pre></td></tr></table></figure>



<h3 id="6-调试命令"><a href="#6-调试命令" class="headerlink" title=".6 调试命令"></a>.6 调试命令</h3><p>如果调试的程序被断点阻塞了又想让程序继续执行，这时候就可以使用 <code>continue</code> 命令。程序会继续运行，直到遇到下一个有效的断点。&#96;&#96;continue<code>可以缩写为</code>c&#96;。</p>
<p>在 gdb 调试的时候如果需要打印变量的值， 使用的命令是 <code>print</code>, 可缩写为 <code>p</code>。如果打印的变量是整数还可以指定输出的整数的格式，格式化输出的整数对应的字符表如下：</p>
<p>![9BDD57D6-6D87-4080-B269-951C45DEC259](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;9BDD57D6-6D87-4080-B269-951C45DEC259.png)</p>
<p><code>printf</code> 的语法格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">print</span> == p</span></span><br><span class="line">(gdb) p 变量名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果变量是一个整形, 默认对应的值是以10进制格式输出, 其他格式请参考上表</span></span><br><span class="line">(gdb) p/fmt 变量名</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例</span></span><br><span class="line">(gdb) p i       # 10进制</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">5 = 3</span></span><br><span class="line">(gdb) p/x i     # 16进制</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">6 = 0x3</span></span><br><span class="line">(gdb) p/o i     # 8进制</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">7 = 03</span></span><br></pre></td></tr></table></figure>

<p>如果在调试过程中需要查看某个变量的类型，可以使用命令 <code>ptype</code>, 语法格式如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法格式</span></span><br><span class="line">(gdb) ptype 变量名</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印变量类型</span></span><br><span class="line">(gdb) ptype i</span><br><span class="line">type = int</span><br><span class="line">(gdb) ptype array[i]</span><br><span class="line">type = int</span><br><span class="line">(gdb) ptype array</span><br><span class="line">type = int [12]</span><br></pre></td></tr></table></figure>

<hr>
<p>单步调试</p>
<p><code>step</code> 命令可以缩写为 <code>s</code>, 命令被执行一次代码被向下执行一行，如果这一行是一个函数调用，那么程序会进入到函数体内部。</p>
<p>如果通过 <code>s</code> 单步调试进入到函数内部，<strong>想要跳出这个函数体， 可以执行 <code>finish</code> 命令。如果想要跳出函数体必须要保证函数体内不能有有效断点，否则无法跳出。</strong></p>
<p><code>next</code> 命令和 <code>step</code> 命令功能是相似的，只是在使用 <code>next</code> 调试程序的时候不会进入到函数体内部，<code>next</code> 可以缩写为 <code>n</code></p>
<p>通过 <code>until</code> 命令可以直接跳出某个循环体，这样就能提高调试效率了。如果想直接从循环体中跳出，必须要满足以下的条件，否则命令不会生效：</p>
<h2 id="0x-e5-结构体字节对齐规则"><a href="#0x-e5-结构体字节对齐规则" class="headerlink" title="0x e5 结构体字节对齐规则"></a>0x e5 结构体字节对齐规则</h2><p>结构体的大小绝大部分情况下不会直接等于各个成员大小的总和，编译器为了优化对结构体成员的访问总会在结构体中插入一些空白字节，有如下结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">align_basic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么此时<code>sizeof(align_basic)</code>的值会是<code>sizeof(char)+sizeof(int)+sizeof(double)</code>的值么？</p>
<p><img src="https://pic3.zhimg.com/80/v2-dca7f4f607fdbc884079e30c10ceb7ae_1440w.png" alt="img"></p>
<p>如上图经过测试我们发现其大小为16个字节并不等于1+4+8&#x3D;13个字节，可知编译器给align_basic结构体插入了另外3个字节，接下来我们将分析编译器对齐字节的规则以及结构体在内存中的结构，首先感谢<a href="https://link.zhihu.com/?target=http://blog.csdn.net/liukun321/article/details/6974282">结构体在内存中的对齐规则 - 咕唧咕唧shubo.lk的专栏 - 博客频道 - CSDN.NET</a>这篇文章的作者，在此之前我对内存对齐也是一知半解，很多时候也解释不明白。</p>
<p>&#x3D;&#x3D;规则一：结构体中元素按照定义顺序依次置于内存中，但并不是紧密排列。从结构体首地址开始依次将元素放入内存时，元素会被放置在其自身对齐大小的整数倍地址上。&#x3D;&#x3D;这里说的地址是元素在结构体中的偏移量，结构体首地址偏移量为0。</p>
<p>在align_basic中元素c是第一个元素，那么它的地址为0，第二个元素i不会被放在地址1处，int的对齐大小为4个字节，此时虽然元素c只占据一个字节，但是由于i的地址必须在4字节的整数倍上，所以地址必须再向后在移动三个字节，故而需要放在地址4上，此时前两个元素已经占据了8个字节的空间，第三个元素d会被直接放在地址8上，因为double的对齐大小为8个字节，而前面两个元素已经占据了8个字节，正好是double对齐大小的整数倍，所以元素d不需要再往后移动。说了这么多也不如让机器给我们验证下有说服力：</p>
<p><code>printf(&quot;%d %d %d %d\n&quot;, sizeof(align_basic), &amp;align_basic::c, &amp;align_basic::i, &amp;align_basic::d);</code></p>
<p><img src="https://pic3.zhimg.com/80/v2-d729bea11322919cc59e03e03d3e221a_1440w.png" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-25407fa9c8f77c2f3d17a12546793a0d_1440w.png" alt="img"></p>
<p>那么这样就够了吗，会不会太简单？我们把元素i和d的位置交换下，此时结构体的大小会是20吗，我们仍然先让机器说话，(⊙o⊙)…毕竟后面打脸有证据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">align_basic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">double</span> d;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(align_basic));</span><br></pre></td></tr></table></figure>

<p><img src="https://pic4.zhimg.com/80/v2-cbfea1a547f205a2d4b2306748da3953_1440w.png" alt="img"></p>
<p>我们发现此时结构体的大小并不是20而是24，那么多出来的这4个字节如何解释？我们引出第二条规则。</p>
<p>&#x3D;&#x3D;规则二：如果结构体大小不是所有元素中最大对齐大小的整数倍，则结构体对齐到最大元素对齐大小的整数倍，填充空间放置到结构体末尾。&#x3D;&#x3D;</p>
<p>运用规则一，此时c仍然是第一个元素，其地址为0，第二个元素地址为8， 第三个元素地址为16，然后运用规则二，c，d，i中d的对齐大小为8最大所以整个结构必须对齐到8的整数倍，前面是三个元素已经占据了20个字节的空间，只需要在结构体的尾部填充4个字节的空间就是8的倍数了，所以此时整个结构体的大小为24个字节。</p>
<p><code>printf(&quot;%d %d %d %d\n&quot;, sizeof(align_basic), &amp;align_basic::c, &amp;align_basic::d, &amp;align_basic::i);</code></p>
<p><img src="https://pic3.zhimg.com/80/v2-c66b0aa643b60eecb9dbf06916c56482_1440w.png" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-0294208ed70bb94feb9868310a191eb3_1440w.png" alt="img"></p>
<p>&#x3D;&#x3D;规则三：基本数据类型的对齐大小为其自身的大小，结构体数据类型的对齐大小为其元素中最大对齐大小元素的对齐大小。&#x3D;&#x3D; 规则三可以由规则二推导出来。</p>
<p>char类型的对齐大小为1字节，short类型的对齐大小为2字节，int类型的大小为4字节，double的对齐大小为8字节，align_basic结构体中最大对齐大小元素为d是double类型，所以align_basic的对齐大小是8。有人会问如果结构体中有数组呢？很简单将数组看做是连续数个相同类型的元素即可。</p>
<h2 id="0x-e6-第一章小结"><a href="#0x-e6-第一章小结" class="headerlink" title="0x e6 第一章小结"></a>0x e6 第一章小结</h2><p>深入理解计算机系统的“系统”，并不是操作系统，这个系统包括了硬件，操作系统，网络，编译等等</p>
<p>学习计算机系统应该具备的三个<strong>抽象能力</strong>：问题抽象，系统抽象（csapp），数据抽象</p>
<p>计算机系统是由硬件和<strong>系统软件</strong>组成的。</p>
<p>数字的机器表示方法是对真值的<strong>有限近似值</strong>。</p>
<p>指令的执行：</p>
<ol>
<li>从磁盘读取指令和数据到内存</li>
<li>从内存送到cpu中去执行</li>
<li>将返回的数据送到屏幕</li>
</ol>
<h2 id="0x-e7-bomb-lab"><a href="#0x-e7-bomb-lab" class="headerlink" title="0x e7 bomb lab"></a>0x e7 bomb lab</h2><h3 id="1-phase1"><a href="#1-phase1" class="headerlink" title=".1 phase1"></a>.1 phase1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">disas main，可以发现我们输入的字符串赋值给了 $rdi</span><br><span class="line">并且之后调用了函数&lt;phase_1&gt;</span><br><span class="line">disas phase_1</span><br><span class="line">发现没有修改寄存器 $rdi 的值</span><br><span class="line">然后把一个立即数 0x402400 传给了寄存器 $esi</span><br><span class="line">之后调用函数 &lt;strings_not_euqal&gt;</span><br><span class="line">在之后test $eax $eax</span><br><span class="line">如果 je，即 $eax = 0</span><br><span class="line">调用函数 &lt;eoplode_bomb&gt;，炸弹爆炸</span><br><span class="line">否则正常返回</span><br><span class="line"></span><br><span class="line">进入函数 &lt;strings_not_equal&gt;</span><br><span class="line">该函数又会调用 &lt;string_length&gt; 函数</span><br><span class="line">这个函数会计算 $rdi 内字符串的长度</span><br><span class="line"></span><br><span class="line">p/x $rdx :以x(16进制)方式打印寄存器$rdx的值</span><br><span class="line">x $rdx 检查(examine) $rdx内存中的值</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/36809923">watch &#x3D; sepcial break</a></p>
<h3 id="2-phase2"><a href="#2-phase2" class="headerlink" title=".2 phase2"></a>.2 phase2</h3><h3 id="3-phase3"><a href="#3-phase3" class="headerlink" title=".3 phase3"></a>.3 phase3</h3><p>![78E9B95E-D7EC-4E49-8A30-94EF4B0A4D48](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;78E9B95E-D7EC-4E49-8A30-94EF4B0A4D48.png)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># phase_3</span><br><span class="line"><span class="title function_">if</span><span class="params">(eax &gt; <span class="number">1</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">7</span> &lt; rsp + <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        eax = rsp + <span class="number">0x8</span>; <span class="comment">// first input</span></span><br><span class="line">        <span class="keyword">switch</span>(eax)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">                eax = <span class="number">0xcf</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                eax = <span class="number">0x137</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                eax = <span class="number">0x2c3</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                eax = <span class="number">0x100</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                eax = <span class="number">0x185</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                eax = <span class="number">0xce</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                eax = <span class="number">0x2aa</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">        &#125;</span><br><span class="line">        	<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        		eax = <span class="number">0x147</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;       		</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BOOM!!!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有多组答案：注意第二个参数不能输入十六进制数，只能输入10进制数，因为这里的数据的读如是采用sscanf，把我们的输入作为str,如果我们的第二个参数是个十六进制数，那么一定以0x开头，结果0会被读取到第二个参数，读到x不合法就结束了。</p>
<table>
<thead>
<tr>
<th>第一个参数</th>
<th>第二个参数</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>207</td>
</tr>
<tr>
<td>1</td>
<td>311</td>
</tr>
<tr>
<td>2</td>
<td>707</td>
</tr>
<tr>
<td>3</td>
<td>256</td>
</tr>
<tr>
<td>4</td>
<td>389</td>
</tr>
<tr>
<td>5</td>
<td>206</td>
</tr>
<tr>
<td>6</td>
<td>682</td>
</tr>
<tr>
<td>7</td>
<td>327</td>
</tr>
</tbody></table>
<h3 id="4-phase4"><a href="#4-phase4" class="headerlink" title=".4 phase4"></a>.4 phase4</h3><p>第一个参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.func4:</span><br><span class="line">eax = edx</span><br><span class="line">eax -= edx</span><br><span class="line">ecx = eax</span><br><span class="line">ecx &gt;&gt;= <span class="number">0x1f</span> <span class="comment">// unsigned</span></span><br><span class="line">eax += ecx</span><br><span class="line">eax &gt;&gt;= <span class="number">1</span></span><br><span class="line">ecx = &amp;(rax+rso+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span>(ecx &lt;= edi)  </span><br><span class="line">&#123;</span><br><span class="line">    eax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(exc &gt;= edi)  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 只有当 ecx&lt;=edi&lt;=ecx，即edi=ecx=7时可以正常退出并返回0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        。。。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    edx = &amp;(rcx - <span class="number">1</span>)</span><br><span class="line">    call func4</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// goal: make eax = 0</span></span><br></pre></td></tr></table></figure>



<p>第二个参数看phrase4的汇编很容易得出为0</p>
<h3 id="5-phase5"><a href="#5-phase5" class="headerlink" title=".5 phase5"></a>.5 phase5</h3><p><a target="_blank" rel="noopener" href="https://github.com/wuxueqian14/csapp-lab/tree/master/Bomb%20Lab">reference</a></p>
<h3 id="6-phase6"><a href="#6-phase6" class="headerlink" title=".6 phase6"></a>.6 phase6</h3><p>不想做了</p>
<h3 id="7-phase7"><a href="#7-phase7" class="headerlink" title=".7 phase7"></a>.7 phase7</h3><p>no</p>
<h3 id="8-answer-2016"><a href="#8-answer-2016" class="headerlink" title=".8 answer(2016)"></a>.8 answer(2016)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">7 327</span><br><span class="line">7 0</span><br><span class="line">)/.%&amp;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="0x-09-Assembly实验"><a href="#0x-09-Assembly实验" class="headerlink" title="0x 09 Assembly实验"></a>0x 09 Assembly实验</h2><p><img src="/Users/epoch/Library/Containers/com.tencent.qq/Data/Library/Caches/Images/BE9A5FC6EBB55797FF78C5D5105D31DF.png" alt="BE9A5FC6EBB55797FF78C5D5105D31DF"></p>
<p>如上图，我们用(gdb) x mingling打印 0x7fffffffe3b0附近的值，这个地址是个虚拟地址，它在内存中的值为0x0</p>
<p>栈指针是会浮动的！但是rsp和rbp的差值应该是不变的。</p>
<p>gdb(ni) ：会跳出函数执行</p>
<p>gdb(si)：会进入函数执行</p>
<p>![A44D5C36-2816-49B3-9E01-23E15BC5DA72](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;A44D5C36-2816-49B3-9E01-23E15BC5DA72.png)</p>
<p>小端存储的又一个例子啊，我们把寄存器 %rbp(0x7fffffffe3d0) 放入 %rsp，观察可以发现，0x00007ffff倍放在了后面的地址，而0xffffe3d0被放在了前面的地址。x命令打印的地址从左到右，从上到下是以4为单位递增的，</p>
<h2 id="0x-0a-ld-preload环境变量劫持函数"><a href="#0x-0a-ld-preload环境变量劫持函数" class="headerlink" title="0x 0a ld_preload环境变量劫持函数"></a>0x 0a ld_preload环境变量劫持函数</h2><p>首先在目录下创建两个文件 main.c 和 txt</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> <span class="comment">// main.c</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE *fd = fopen(<span class="string">&quot;txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;*** open file error!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;open file success!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常来说最后程序会正确执行</p>
<p>但如果我们更改动态链接库</p>
<p>先创建一个trik动态链接库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">// trik.c</span></span></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*** Always open error!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC trik.c -o trik.so</span><br><span class="line">LD_PRELOAD=$PWD/trik.so ./a.out</span><br></pre></td></tr></table></figure>

<p>最后文件会打开失败</p>
<p>![53DE4182-359A-4F3E-80BB-4B97508E7F9B](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;53DE4182-359A-4F3E-80BB-4B97508E7F9B.png)</p>
<p>原理就是通过自己写的库函数劫持系统的库函数，使得程序执行我们的库函数。</p>
<h2 id="0x-0b-attack-lab"><a href="#0x-0b-attack-lab" class="headerlink" title="0x 0b attack lab"></a>0x 0b attack lab</h2><h2 id="0x0c-链接-points"><a href="#0x0c-链接-points" class="headerlink" title="0x0c 链接 points"></a>0x0c 链接 points</h2><p>1.引入哑节点dummy</p>
<p>2.引入数据结构–elf</p>
<p>3.静态链接的过程：elf定位到符号-&gt;符号解析-&gt;重定位</p>
<p>4.*.o, elf 都是二进制文件</p>
<p>5.unix下大部分工具都在&#x2F;usr&#x2F;bin或者&#x2F;bin目录下的。使用hexdump可以查看二进制文件</p>
<p>6.第一个section的name为空（其实叫做 undefine section），且数据全为0，里面存放的内容是undefine的数据。</p>
<p>7.将函数定义为一个弱符号：<code>attribute__((weak)) int add*() &#123;&#125;</code> ,这里的 <code>add</code> 函数被定义为一个弱符号，它可以被强符号函数 <code>add</code> 覆盖。</p>
<p>8.对于 <code>C Language</code> 来说，出现 <code>Warning</code> 说明你的语句有<strong>歧义</strong> ，但是 C 语言为你选择了一种结果，注意这种结果可能与你的本意不同！</p>
<p>9.对于初始化为 <code>0</code> 的全局变量和静态变量，也被划分到 <code>.bss</code>，这是因为全局变量和静态变量默认初始化就是 <code>0</code>。</p>
<p>10.为什么在可重定位目标文件中有 <code>COMMON</code>，在可执行目标文件中就没有 <code>COMMON</code> 了呢。</p>
<blockquote>
<p> 回想一下<code>COMMON</code>的定义，对于未初始化的全局变量， 属于<code>COMMON</code>。</p>
<p>对于未初始化的全局变量， 在链接之后它有三种可能的情况（假设这里有两个文件 <code>s1.c</code>, <code>s2.c</code>，在 <code>s1.c</code> 中定义有未初始化的全局变量 <code>g</code>）</p>
<ol>
<li><p>如果在 <code>s2.c</code> 中也定义了一个全局变量 <code>g</code> 并且初始化为 <code>0</code>，则 <code>g</code> 属于 <code>.bss</code> 节</p>
</li>
<li><p>如果初始化不是 <code>0</code>，就属于 <code>.data</code></p>
</li>
<li><p>如果 <code>s2.c</code> 没有定义 <code>g</code> ，那么 s2 就属于 <code>.bss</code></p>
<p>因为有如上三种（合法）情况，所以把它划分到 <code>COMMON</code>，而之所以在可执行目标文件中没有了 <code>COMMON</code> ,是因为此时已经链接完了，<code>g</code> 属于那个节已经很明确了，因此也就不需要了。</p>
</li>
</ol>
</blockquote>
<ol start="11">
<li></li>
</ol>
<h2 id="0x0d-修改-ROF-信息的实验"><a href="#0x0d-修改-ROF-信息的实验" class="headerlink" title="0x0d 修改 ROF 信息的实验"></a>0x0d 修改 ROF 信息的实验</h2><p>首先编译源文件 <code>add.c</code> 生成可重定位目标文件 <code>add.o</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> addcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	addcnt ++ ;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用 <code>hexdump -S add.o</code> 查看 <code>Section Headers</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000003c  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000228</span><br><span class="line">       0000000000000060  0000000000000018   I       9     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  0000007c</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  0000007c</span><br><span class="line">       0000000000000004  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .comment          PROGBITS         0000000000000000  0000007c</span><br><span class="line">       0000000000000027  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  000000a3</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .eh_frame         PROGBITS         0000000000000000  000000a8</span><br><span class="line">       0000000000000030  0000000000000000   A       0     0     8</span><br><span class="line">  [ 8] .rela.eh_frame    RELA             0000000000000000  00000288</span><br><span class="line">       0000000000000018  0000000000000018   I       9     7     8</span><br><span class="line">  [ 9] .symtab           SYMTAB           0000000000000000  000000d8</span><br><span class="line">       0000000000000138  0000000000000018          10    11     8</span><br><span class="line">  [10] .strtab           STRTAB           0000000000000000  00000210</span><br><span class="line">       0000000000000018  0000000000000000           0     0     1</span><br><span class="line">  [11] .shstrtab         STRTAB           0000000000000000  000002a0</span><br><span class="line">       0000000000000059  0000000000000000           0     0     1</span><br></pre></td></tr></table></figure>

<p>可以发现下标为 <code>1</code> 的节是 <code>.text</code> 节</p>
<p>我们现在要修改 <code>add.o</code> 使其显示为 <code>.ext</code> 节</p>
<p>首先需要下载 <code>hexedit</code></p>
<p>然后拷贝一份 <code>add.o</code> 的副本 <code>badadd.o</code></p>
<p>（不在源文件上直接修改是个好习惯）</p>
<p>然后执行命令<code>hexdump -c badadd.o</code> 找到 <code>.text</code> 的位置。</p>
<p>通过 <code>elf header</code> 中的信息可以得到 <code>Section header table</code> 的 <code>offset</code> 为 <code>0x300</code>，其中每个条目(<code>entry</code>) 的 <code>size</code> 为 <code>0x40</code> ，由此可以得到第二个条目（下标为1）的 <code>.text</code> 节的位置为 <code>0x340</code>，并通过 <code>struct elf64_shdr</code> 得到前 <code>4</code> 个字节为 <code>name</code>。</p>
<p><code>00000340  20 00 00 00 01 00 00 00  06 00 00 00 00 00 00 00  | ...............|</code></p>
<p><code>name = 0x00000020</code> ,我们只需要修改其为 <code>0x00000022</code>，就可以实现 <code>name</code> 往后偏移两个字节</p>
<p>这样 <code>name</code> 就从 &#96;&#96;.text<code>变成了</code>ext&#96;</p>
<p>执行命令：<code>hexedit badadd.o</code> 找到位置并修改即可。</p>
<p>按 <code>F10</code> 退出</p>
<p>最后结果如下：</p>
<p><code>readelf -S badadd.o</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] ext               PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000003c  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000228</span><br><span class="line">       0000000000000060  0000000000000018   I       9     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  0000007c</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  0000007c</span><br><span class="line">       0000000000000004  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .comment          PROGBITS         0000000000000000  0000007c</span><br><span class="line">       0000000000000027  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  000000a3</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .eh_frame         PROGBITS         0000000000000000  000000a8</span><br><span class="line">       0000000000000030  0000000000000000   A       0     0     8</span><br><span class="line">  [ 8] .rela.eh_frame    RELA             0000000000000000  00000288</span><br><span class="line">       0000000000000018  0000000000000018   I       9     7     8</span><br><span class="line">  [ 9] .symtab           SYMTAB           0000000000000000  000000d8</span><br><span class="line">       0000000000000138  0000000000000018          10    11     8</span><br><span class="line">  [10] .strtab           STRTAB           0000000000000000  00000210</span><br><span class="line">       0000000000000018  0000000000000000           0     0     1</span><br><span class="line">  [11] .shstrtab         STRTAB           0000000000000000  000002a0</span><br><span class="line">       0000000000000059  0000000000000000           0     0     1</span><br></pre></td></tr></table></figure>







<h2 id="0x0e-vim-tabe"><a href="#0x0e-vim-tabe" class="headerlink" title="0x0e vim tabe"></a>0x0e vim tabe</h2><p>vim中的分页命令，多窗口vim</p>
<p>通过<code>help tab-page-intro</code>命令，可以获得关于标签页使用的更多信息。</p>
<table>
<thead>
<tr>
<th><code>:tabnew</code></th>
<th align="left">新建标签页</th>
</tr>
</thead>
<tbody><tr>
<td><code>:tabs</code></td>
<td align="left">显示已打开标签页的列表</td>
</tr>
<tr>
<td><code>:tabc</code></td>
<td align="left">关闭当前标签页</td>
</tr>
<tr>
<td><code>:tabe &lt;filename&gt;</code></td>
<td align="left">打开新文件(tabedit)</td>
</tr>
<tr>
<td><code>:tabp</code></td>
<td align="left">移动到上一个标签页</td>
</tr>
<tr>
<td><code>:tabn</code></td>
<td align="left">移动到下一个标签页(tabnext)</td>
</tr>
<tr>
<td><code>:gt</code></td>
<td align="left">移动到下一个标签页</td>
</tr>
<tr>
<td><code>:tabr</code></td>
<td align="left">移动到第一个标签页(tabrewind,tabfirst)</td>
</tr>
<tr>
<td><code>:tabl</code></td>
<td align="left">移动到最后一个标签页(tablast)</td>
</tr>
<tr>
<td><code>$vim -p &lt;f1&gt; &lt;f2&gt; &lt;f3&gt;</code></td>
<td align="left">vim开启多个标签页</td>
</tr>
</tbody></table>
<h2 id="0x0f-bilbili-链接"><a href="#0x0f-bilbili-链接" class="headerlink" title="0x0f bilbili 链接"></a>0x0f bilbili 链接</h2><p>链接步骤：</p>
<blockquote>
<ol>
<li>parse text</li>
<li>symbol parse</li>
<li>Relocation</li>
</ol>
<p>2 和 3 都依赖于 1 的 text</p>
</blockquote>
<h1 id="Csapp-Link"><a href="#Csapp-Link" class="headerlink" title="Csapp Link"></a>Csapp Link</h1><h2 id="English"><a href="#English" class="headerlink" title="::English"></a>::English</h2><p>separate compliation：分离编译</p>
<p>mangling：重整</p>
<h2 id="Tool"><a href="#Tool" class="headerlink" title=":: Tool"></a>:: Tool</h2><p>GNU READELF：查看目标文件内容的很方便的工具。</p>
<h2 id="0x00-introduce"><a href="#0x00-introduce" class="headerlink" title="0x00 introduce"></a>0x00 introduce</h2><h3 id="1-链接的执行阶段"><a href="#1-链接的执行阶段" class="headerlink" title="1. 链接的执行阶段"></a>1. 链接的执行阶段</h3><ol>
<li>compile time</li>
<li>load time</li>
<li>run time</li>
</ol>
<h3 id="2-why-learn-link"><a href="#2-why-learn-link" class="headerlink" title="2. why learn link"></a>2. <strong>why</strong> learn link</h3><ol>
<li>理解链接器将帮助你构造大型程序</li>
<li>理解链接器将帮助你避免一些危险的编程错误。</li>
<li>理解链接器将帮助你理解语言的作用域规则是如何实现的。</li>
<li>理解链接将帮助你理解其他重要的系统概念。（加载和运行程序，虚拟内存，分页，内存映射）</li>
<li>理解链接将使你能够利用共享库。</li>
</ol>
<h2 id="0x01-compiler-driver"><a href="#0x01-compiler-driver" class="headerlink" title="0x01 compiler driver"></a>0x01 compiler driver</h2><p>compiler dirver：编译器驱动程序</p>
<p>它代表用户在需要的时候调用：</p>
<ol>
<li>cpp</li>
<li>cc1</li>
<li>as</li>
<li>ld</li>
</ol>
<p>可以使用 -v 选项查看这个过程</p>
<p>当我们在 Linux 命令行输入：<code>./proc</code></p>
<p>shell 调用操作系统中一个叫做<strong>加载器</strong>的函数，它将可执行文件 proc 中的代码和数据复制到内存，然后将控制转移到这个程序的开头。</p>
<h2 id="0x02-static-link"><a href="#0x02-static-link" class="headerlink" title="0x02 static link"></a>0x02 static link</h2><p>Relocaable object file: 由各种不同的代码和数据节（section）组成，每一节都是一个连续的字节序列。</p>
<p>为了构造 executable file，linker 必须完成两个主要任务：</p>
<ol>
<li>Symbol resolution（符号解析）：符号解析的目的是将每个符号引用正好和一个符号定义关联起来。</li>
<li>relocation（重定位）。</li>
</ol>
<p>Symbol（符号）：目标文件定义和引用符号，每个符号对应于一个函数，一个局部变量或一个静态变量（即C语言任何非 static 属性声明的变量）。</p>
<p>Compiler and Assembly generate code and data section start at address 0, linker connect every symbol define with one memory address, so can relocate those sections, and then modify all the symbol define, make them point the address. Linker use the detailed instructions of relocation entry(重定位条目) which generated by assembly to execute those relocation with no check.</p>
<h2 id="0x03-object-file"><a href="#0x03-object-file" class="headerlink" title="0x03 object file"></a>0x03 object file</h2><p>object file（目标文件） types:</p>
<ol>
<li>relocatable object file：在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li>
<li>executable object file</li>
<li>Share object file（共享目标文件）: 一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。</li>
</ol>
<p>Compiler and Assembly generate relocatable object file.  Linker generate executable  object file.</p>
<p>Technically talking, a object module(目标模块) is a byte sequence,  and a object file is a object module which storage in disk as a type of file.</p>
<p>目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。</p>
<ol>
<li>Unix: a.out</li>
<li>Windows: PE(Portable Executable)(可移植可执行)</li>
<li>MacOS-X: Mach-O </li>
<li>Modern x86-64 and Unix: ELF(Executable and Linkable Format)(可执行可链接格式)</li>
</ol>
<h2 id="0x04-relocatable-object-file"><a href="#0x04-relocatable-object-file" class="headerlink" title="0x04 relocatable object file"></a>0x04 relocatable object file</h2><p>典型的ELF可重定位目标文件</p>
<p><img src="https://s1.328888.xyz/2022/09/28/spfaF.png" alt="IMG"></p>
<p>ELF contains:   ELF header，Sections，Section header table(节头部表)。</p>
<p>(1) ELF header：</p>
<ol>
<li>以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的<strong>字的大小</strong>和<strong>字节顺序。</strong></li>
<li>剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包含：<ul>
<li>ELF 头的大小</li>
<li>目标文件的类型（可重定位、可执行或者共享）</li>
<li>机器类型（x86-64）</li>
<li>节头部表的文件偏移</li>
<li>节头部表中条目的大小和数量</li>
</ul>
</li>
</ol>
<p>(2) Section headere table: 不同 Section 的位置和大小是由节头部表描述的，其中目标文件中的每个节都有一个固定大小的条目（entry）。</p>
<p>(3) Section:</p>
<ol>
<li>.text：已编译程序的<strong>机器代码。</strong></li>
<li>.rodata：只读数据。</li>
<li>.data：已初始化的全局和静态 C 变量。（局部变量在栈中，既不出现在 .data中，也不出现在 .bss汇总）</li>
<li>.bss：未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量（默认初始化）。在目标文件中<strong>这个节不占用实际的空间，它仅仅是一个占位符。</strong> 目标文件中区分 .bss 和 .data 是为了<strong>空间效率</strong>：在目标文件中，未初始化变量不需要占用任何实际的磁盘空间。运行时，在内存中分配这些变量，初始化为0。</li>
<li>.symtab；符号表。存放在程序中<strong>引用</strong>和<strong>定义</strong>的函数和全局变量的信息。（不包含局部变量的条目）。</li>
<li>.rel.text：relocation。一个 .text 节总位置的列表。当 Linker 把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的<strong>指令</strong>都需要修改。</li>
<li>.rel.data：被模块定义或引用的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的值是一个全局变量地址或者外部定义的函数的<strong>地址</strong>，都需要被修改。</li>
<li>.debug：调试符号表。只有使用 -g 选项时才会得到这张表。</li>
<li>.line：原始 C 源程序中的行好和 .text 节 中机器指令之间的<strong>映射</strong>。只有使用 -g 选项时才会得到这张表。</li>
<li>.strtab：字符串表。其内容包含 .symbol 和 .debug节中的符号表，已经节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。</li>
</ol>
<p>为什么未初始化的数据成为  .bss</p>
<blockquote>
<p>起始于 IMB 704 汇编语言（大约在1957年） Block Storage Start(块存储开始)指令的首字母缩写。并沿用至今。</p>
<p>你可以这样理解并区分于 .data：Better Save Space（更好的节省空间）的缩写。</p>
</blockquote>
<h2 id="0x05-symbol-and-symbol-table"><a href="#0x05-symbol-and-symbol-table" class="headerlink" title="0x05 symbol and symbol table"></a>0x05 symbol and symbol table</h2><p>​			 	</p>
<p>每个 relocatable object module m 都有一个符号表，它包含 m 定义和引用的符号的信息。在 Linker 的上下文中，有三种不同的符号：</p>
<ol>
<li>m 定义的并且能被其他 module 引用的全局符号。</li>
<li>其他 module 定义并被模块 m 引用的全局符号，</li>
<li>只被 m 定义和引用的局部符号。</li>
</ol>
<p>符号表是由 Assembly 构造的，使用 Compiler 输出到汇编语言 .s 文件中的符号。</p>
<p>.symtab 节的内容是一个数组，数组的元素是一个符号条目：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="type">char</span> type: <span class="number">4</span>,</span><br><span class="line">    	binding: <span class="number">4</span>;</span><br><span class="line">    <span class="type">char</span> reserved;</span><br><span class="line">    <span class="type">short</span> section;</span><br><span class="line">    <span class="type">long</span> value;</span><br><span class="line">    <span class="type">long</span> size;</span><br><span class="line">&#125; Elf_64_Symbol;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>name：是字符串表中的字节串，指向符号的以 null 结尾的字符串名字。</p>
<p>section（base_address）：到节头部表的索引，指明被分配到那个节。</p>
<p>value（offset_address）：是符号的地址。对于可重定位的 module 来说，value 是距定义目标的节的其实地址的 offset。</p>
<p>size：是目标的大小（byte）。</p>
<p>type：data or function。</p>
<p>binding：static or global</p>
<p>有三个特殊的<strong>伪节</strong>，它们在节头部表中是没有条目的（只有可重定位目标模块才有）：</p>
<ol>
<li>ABS：不应该被重定位的符号。</li>
<li>UNDEF：未定义的符号，也就是在本目标模块中引用，但是在其它地方定义的符号。</li>
<li>COMMON：还未被分配位置的未初始化的数据目标。对于 common u符号，value 字段给出<strong>对其要求</strong>。</li>
</ol>
<p>common 和 .bss 的区别很细微，现代的 GCC 根据以下规则分配符号：</p>
<ol>
<li>Common: 未初始化的全局变量</li>
<li>.bss：未初始化的静态变量，及其初始化为0的全局变量和静态变量</li>
</ol>
</blockquote>
<h2 id="0x06-symbol-parse"><a href="#0x06-symbol-parse" class="headerlink" title="0x06 symbol parse"></a>0x06 symbol parse</h2><h3 id="1-链接器解析符号引用的方法"><a href="#1-链接器解析符号引用的方法" class="headerlink" title="1.链接器解析符号引用的方法"></a>1.链接器解析符号引用的方法</h3><p>链接器解析符号引用的方法是将每个引用于它输入的可重定位目标文件的符号表的一个确定的符号定义关联起来。</p>
<p>对那些和引用定义在相同模块中的局部符号的引用，符号解析是非常简单明了的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保他们拥有唯一的名字。</p>
<p>不过，对全局符号的引用解析就棘手的多。当编译器遇到一个不是在当前模块中定义的符号（变量或者函数名）时，会假设该符号是在其它某个模块中定义的，升成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条（通常很难阅读的）错误信息并终止。</p>
<h3 id="2-c-和-java-中的重整和恢复"><a href="#2-c-和-java-中的重整和恢复" class="headerlink" title="2.c++ 和 java 中的重整和恢复"></a>2.c++ 和 java 中的<strong>重整</strong>和<strong>恢复</strong></h3><p>C++ 和 Java 都允许重载方法，这些方法在源代码中有相同名字，却有着不同的参数列表。那么链接器是如何区别这些不同的重载函数之间的差异呢？</p>
<p>因此编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。这种编码过程叫做重整（mangling），而相反的过程叫做恢复（demangling）。</p>
<p>幸运的事，C++ 和 Java使用兼容的重整策略。一个被重整的类名字是由名字中字符的整数数量，后面跟上原始名字组成的。例如：类 Foo 被编码成 3Foo。方法被编码为原始方法名，后面加上‘__’（下划线），加上被重整的雷鸣，再加上每个参数的单字母编码。比如：Foo::bar(int, long) 被编码为 bar_3fooil。</p>
<p>重整全局变量和模版名字的策略是相似的。</p>
<p>例如 C++程序 ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> sum1, sum2;</span><br><span class="line">	sum1 = <span class="built_in">get</span>(a, b, c);</span><br><span class="line">	sum2 = <span class="built_in">get</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum1: &quot;</span> &lt;&lt; sum1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum2: &quot;</span> &lt;&lt; sum2 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<p><code>readelf mangling.o --syms</code></p>
<p>得到如下符号表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Symbol table &#x27;.symtab&#x27; contains 30 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS mangling.cpp</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text</span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 .data</span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 .bss</span><br><span class="line">     5: 0000000000000000     1 OBJECT  LOCAL  DEFAULT    4 _ZStL8__ioinit</span><br><span class="line">     6: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    4 $d</span><br><span class="line">     7: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    1 $x</span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 .rodata</span><br><span class="line">     9: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    5 $d</span><br><span class="line">    10: 00000000000000fc    96 FUNC    LOCAL  DEFAULT    1 _Z41__static_ini[...]</span><br><span class="line">    11: 000000000000015c    28 FUNC    LOCAL  DEFAULT    1 _GLOBAL__sub_I__[...]</span><br><span class="line">    12: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 .init_array</span><br><span class="line">    13: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    6 $d</span><br><span class="line">    14: 0000000000000000     0 SECTION LOCAL  DEFAULT    9 .note.GNU-stack</span><br><span class="line">    15: 0000000000000014     0 NOTYPE  LOCAL  DEFAULT   10 $d</span><br><span class="line">    16: 0000000000000000     0 SECTION LOCAL  DEFAULT   10 .eh_frame</span><br><span class="line">    17: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 .comment</span><br><span class="line">    18: 0000000000000000    32 FUNC    GLOBAL DEFAULT    1 _Z3getii</span><br><span class="line">    19: 0000000000000020    44 FUNC    GLOBAL DEFAULT    1 _Z3getiii</span><br><span class="line">    20: 000000000000004c   176 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    21: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZSt4cout</span><br><span class="line">    22: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZStlsISt11char_[...]</span><br><span class="line">    23: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSolsEi</span><br><span class="line">    24: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZSt4endlIcSt11c[...]</span><br><span class="line">    25: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSolsEPFRSoS_E</span><br><span class="line">    26: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSt8ios_base4I[...]</span><br><span class="line">    27: 0000000000000000     0 NOTYPE  GLOBAL HIDDEN   UND __dso_handle</span><br><span class="line">    28: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSt8ios_base4I[...]</span><br><span class="line">    29: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND __cxa_atexit</span><br></pre></td></tr></table></figure>

<p>可以观察到，两个 get 函数分别被标识为：<code>_Z3getii</code> 和 <code>_Z3getiii</code></p>
<h3 id="3-Linux-处理多重定义的符号"><a href="#3-Linux-处理多重定义的符号" class="headerlink" title="3. Linux 处理多重定义的符号"></a>3. Linux 处理多重定义的符号</h3><p>强符号：函数和已初始化的全局变量</p>
<p>弱符号：未初始化的全局变量</p>
<p>Linux 处理多重定义的符号名的三个规则：</p>
<ol>
<li>不允许多个同名的强符号。</li>
<li>如果有一个强符号和多个弱符号同名，选择强符号。</li>
<li>如果有多个弱符号同名，任意选择一个。</li>
</ol>
<h3 id="4-静态库"><a href="#4-静态库" class="headerlink" title="4. 静态库"></a>4. 静态库</h3><h4 id="4-1-为什么要引入静态库？"><a href="#4-1-为什么要引入静态库？" class="headerlink" title="4.1 为什么要引入静态库？"></a>4.1 为什么要引入静态库？</h4><p>如果不引入静态库的话，试想一下编译器开发人员会使用什么方法来向用户提供这些函数。</p>
<blockquote>
<p>编译器代劳！</p>
</blockquote>
<p>一种方法是让编译器辨认出对标准函数的调用，并直接生成相应的代码。对于那些提供了一小部分标准函数的语言（例如 Pascal）是可以的，但是对于 C 这种标准定义了大量的标准函数是不可以的。因为每次添加、修改或删除一个标准库函数时，就需要一个新的编译器版本。然而，对于应用程序猿而言，这种方法是非常方便的，因为标准函数将总是可用（只需要你编译器开发人员搞定就行了，管我什么事 - -</p>
<blockquote>
<p>所有函数对应一个可重定位目标模块！</p>
</blockquote>
<p>另一种方法是将所有的 C 函数都放在一个单独的可重定位目标模块中（比如说 libc.a），应用程序猿可以把这个模块连接到他们的可执行文件中：</p>
<p><code>gcc main.c /usr/lib/libc.o</code></p>
<p>IOS C99 定义的 C库：libc.a; 数学函数库：libm.a</p>
<p>通过把函数放在目标模块中，可以把编译器的实现与标准函数的实现分离开来。但是，现在每个可执行文件都包含着一份标准函数集合的副本（除非你不链接它，但这怎么可能呢？），这是对<strong>磁盘的极度浪费</strong>！在一个典型的系统中，libc.a 大约是 5MB，llib.a 大约是 2MB）。另外，每个运行的程序都将它的这些函数的副本放在内存中，这是<strong>对内存的极大浪费</strong>。此外，只要标准库修改了一个小小的地方，无论多么小，你都要重新编译整个源文件，非常<strong>耗时</strong>。</p>
<blockquote>
<p>每个函数对应一个可重定位目标模块！</p>
</blockquote>
<p>我们可以通过为每个库函数创建一个独立的可重定位模块，把他们放在一个为大家都知道的目录中来解决其中的一些问题。然而，问题也是相当明显的：</p>
<ol>
<li>那你要手写多少模块啊？</li>
<li>太多了不小心写错名字了怎么办？从头再检查一遍吧！</li>
<li>太多了，你得写到什么时候？</li>
<li>。。。</li>
<li>真是一个麻烦又耗时又糟心的过程！</li>
</ol>
<p><code> gcc main.c /usr/lib/printf.o /usr/lib/scanf.o ........</code></p>
<blockquote>
<p>静态库！</p>
</blockquote>
<p>于是，为了解决这些问题，静态库诞生了！！！</p>
<p>我们可以结合上面的方法，既不把所有函数划分到一个模块，也不每个函数对应一个模块，而是把一些相关的函数划分到一个模块（例如 C 标准库和数学库等），然后封装成一个单独的静态库文件。而不是每个函数对应一个模块。</p>
<p><code>gcc main.c /usr/lib/libc.a /usr/lib/libm.a .. </code></p>
<p>你可能会问：这个静态库和前面把所有函数放在一个可重定位目标模块有什么区别吗？不就是一个叫（模块 .o)，一个叫静态库（.a）罢了！</p>
<p>那我可就得给你好好讲讲了：当所有函数封装在一个模块中，那我们链接的时候，就不得不链接所有库函数了。</p>
<p>但是！接下来好好听了！</p>
<p>如果说模块是函数的集合，那么静态库就是模块的集合！所以，你可能想到了，虽然我们链接到了静态库，但并不链接静态库中的所有模块，而是只链接需要用到的模块，这样既避免了类似于一个函数一个模块那样链接模块太多的问题，又避免了链接所有模块的问题。</p>
<p>你可能会问：这怎么实现呢？</p>
<p>答案是：暴力出奇迹，循环判断是否用到就好了。用不到的模块就舍弃掉。</p>
<p>妙不妙！再看一看静态库的定义吧。</p>
<blockquote>
<p>在 Linux 中，静态库是以一种称为 <strong>存档(archive)</strong> 的特殊文件形式存放在<strong>磁盘</strong>中的。存档是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件由后缀（.a)标识。</p>
</blockquote>
<h3 id="4-2-创建静态库"><a href="#4-2-创建静态库" class="headerlink" title="4.2 创建静态库"></a>4.2 创建静态库</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/x_wukong/p/5713437.html">静态库和动态库创建参考</a></p>
<blockquote>
<p>(1) 首先，我们需要源文件（.c）</p>
<p>这里为 mul.c 和 add.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mulcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	mulcnt ++ ;</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125;<span class="comment">// mul.c</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> addcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	addcnt ++ ;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;<span class="comment">// add.c</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>(2) 然后，我们需要将源文件处理成可重定位目标文件</p>
</blockquote>
<p><code>gcc -c add.c mul.c</code></p>
<blockquote>
<p>(3) 最后，将需要的可重定位目标文件封装到静态库中。</p>
<p>例如： <code>ar rcs mylib.a a.o b.o...</code></p>
<p>r: replace and insert</p>
<p>c : create</p>
<p>s: add index</p>
</blockquote>
<p><code>ar rcs mylib.a add.o mul.o</code></p>
<blockquote>
<p>(4) 别以为就这样结束了，编写个 main 程序测试你下你的库吧！</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> s1 = add(x, y);</span><br><span class="line">	<span class="type">int</span> s2 = mul(x, y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;x = %d, y = %d\nsum = %d, mul = %d\n&quot;</span>, x, y, s1, s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c testar.c # 先编译生成可执行文件</span><br><span class="line">gcc --static -o main testar.o -L. mylib.a # 与静态库链接</span><br></pre></td></tr></table></figure>

<blockquote>
<p>–static 参数告诉编译器驱动程序，链接器应该构建一个完全链接的可执行目标文件，它可以加载到内存并运行，在加载时无需更进一步的链接。所以说不加也是可以的。</p>
<p>-Ldir 指明了链接器在那个目录下查找 mylib.a，dot就表示当前目录。</p>
</blockquote>
<h2 id="0x07-relocation"><a href="#0x07-relocation" class="headerlink" title="0x07 relocation"></a>0x07 relocation</h2><h3 id="1-重定位的任务："><a href="#1-重定位的任务：" class="headerlink" title="1. 重定位的任务："></a>1. 重定位的任务：</h3><p>重定位合并输入模块，并为每个符号分配运行时地址。</p>
<p>由两步组成：</p>
<ol>
<li><p>重定位节和符号定义：</p>
<ol>
<li>将所有相同类型的节合并为一个节</li>
<li>将运行时内存地址赋给新的聚合节</li>
<li>赋给输入模块定义的每个符号</li>
</ol>
<p>完成后，程序中的每条指令和全局变量都有唯一的运行时内存地址了。</p>
</li>
<li><p>重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为<strong>重定位条目</strong>的数据结构。</p>
</li>
</ol>
<h3 id="2-重定位条目"><a href="#2-重定位条目" class="headerlink" title="2. 重定位条目"></a>2. 重定位条目</h3><p>为什么需要重定位条目？</p>
<blockquote>
<p>当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。</p>
<p>它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。</p>
<p>所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个 <strong>“重定位条目”</strong>，告诉链接器在将目标文件合并成可执行文件时许和修改这个引用。</p>
<p>代码的重定位条目放在 .rel.text 中，已初始化数据的重定位条目放在 .rel.data 中。</p>
</blockquote>
<p>ELF 重定位条目的格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> offset;	<span class="comment">// 我在那</span></span><br><span class="line">    <span class="type">long</span> type: <span class="number">32</span>;	<span class="comment">// 怎么引用</span></span><br><span class="line">    	smybol: <span class="number">32</span>; <span class="comment">// 我引用了谁</span></span><br><span class="line">    <span class="type">long</span> addend;	<span class="comment">// 我的偏移量</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>offset 是需要被修改的引用的在节内的偏移。（一般是一个地址）</p>
<p>symbol 标识被修改引用应该指向的符号。</p>
<p>type 告知链接器如何修改新的引用。</p>
<p>addend 是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。（addend的值一般是当前引用的地址距离下一条指令的偏移）（讲的标准一点就是对 rip 的修正，因为重定位所在的地址并不是下一条指令的 rip 地址）</p>
</blockquote>
<p>两种最基本的重定位类型（type）：</p>
<ol>
<li><p>R_X86_64_PC32：重定位一个使用 32 位 PC 相对地址的引用。（一个 PC 相对地址就是距程序计数器(PC)的当前运行时值的偏移量。当 CPU 执行一条使用 PC 相对寻址的指令时，它就将在指令中编码的 32 位值加上 PC 的当前运行时值，得到有效地址， PC 值通常是<strong>下一条</strong>指令在内存中的地址）。</p>
<blockquote>
<p>简而言之，<strong>相对</strong>的意思就是，相对于<strong>下一条指令</strong>的偏移量。</p>
</blockquote>
</li>
<li><p>R_X86_64_32：重定位一个 32 位绝对地址的引用。通过绝对寻址，CPU 直接使用在指令中编码的 32 位值作为有效地址。</p>
</li>
</ol>
<h3 id="3-重定位符号引用"><a href="#3-重定位符号引用" class="headerlink" title="3. 重定位符号引用"></a>3. 重定位符号引用</h3><blockquote>
<p> 相对引用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call addr </span><br><span class="line">	sym.offset: R_X86_64_PC32 sym</span><br></pre></td></tr></table></figure>

<p>首先，要清楚我们的目标：通过 addr 的<strong>相对偏移</strong>得到该符号的运行时地址，这个地址我们是已知的。（我们用ADDR(x)表示符号 x 的运行时地址）</p>
<p>当前引用的地址 + 距离下一条指令的偏移量 +  addr &#x3D; 目标符号的运行时地址</p>
<p>addr &#x3D; ADDR(sym) - （当前引用的地址 + 距离下一条指令的偏移量）</p>
<p>不过，距离下一条指令的偏移量通常以 sym.addend 的形式存在，于是，上式变成了：</p>
<p>addr &#x3D; ADDR(sym) - 当前引用的地址 + sym.addend</p>
<blockquote>
<p>我们发现，公式在经过转换后，由 “距离” 下一条指令的偏移量变成了 “加上”  sym.addend。</p>
<p>而偏移量肯定是一个正数（不然怎么偏移到下一条指令），所以说 sym.addend 肯定是个负数。</p>
<p>自己推导的，不一定对？？</p>
</blockquote>
<p>而当前引用的地址 &#x3D; 引用所在节的运行时地址 + 引用的偏移(sym.offset)</p>
<p>所以，上式最终等于如下：</p>
<p>addr &#x3D; ADDR(sym) - （ADDR(Section) + sym.offset）+ sym.addend</p>
<hr>
<blockquote>
<p>绝对引用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call addr</span><br><span class="line">	sym.offset: R-X86_64_32 sym</span><br></pre></td></tr></table></figure>

<p>addr &#x3D; ADDR(sym) + sym.addend</p>
<p>在绝对引用中，我们依然需要加上偏移量addend，只不过 sym.addend&#x3D;0。</p>
<p>可以发现，相较于绝对引用，相对引用只需要减去当前引用的地址即可，距离下一条指令的偏移保存在了 addend 中。</p>
<h2 id="0x08-executable-object-file"><a href="#0x08-executable-object-file" class="headerlink" title="0x08 executable object file"></a>0x08 executable object file</h2><p>典型的 ELF 可执行目标文件（EOF，段和节）：</p>
<p><img src="https://s1.328888.xyz/2022/09/28/spsQp.png" alt="img"></p>
<p>ELF头还包括了程序的入口点？也就是程序的第一条指令的地址。</p>
<p>通过图可以发现，EOF 文件中还多了 .init 节。.init节定义了一个小函数，叫做 _init_，程序的初始化代码会调用它。</p>
<p>.text，.data，.rodata 与可重定位目标文件的节是相似的，除了这些节已经被重定位到它们最终的运行时内存地址以外。</p>
<p>因为 EOF 文件是<strong>完全链接</strong>的（已被重定位），所以它不再需要 .rel 节。</p>
<blockquote>
<p>EOF 文件还有对其要求。这主要与虚拟内存有关</p>
</blockquote>
<h2 id="0x09-load-EOF"><a href="#0x09-load-EOF" class="headerlink" title="0x09 load EOF"></a>0x09 load EOF</h2><p>我们通常在 Linux Shell 命令行输入可执行目标文件的名字 (例如prog) 来执行它:</p>
<p><code>Linux&gt; ./prog</code></p>
<p>因为 prog 不是一个内置的 shell 命令，所以 shell 会认为 prog 是一个可执行目标文件。</p>
<p>通过调用某个驻留在内存中称为<strong>加载器（loader）</strong>的操作系统代码来运行它。</p>
<p>任何 Linux 程序都可以通过调用 <strong>execve()</strong> 调用加载器。</p>
<p>加载器将 EOF 文件的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序从磁盘复制到内存并运行的过程叫做 “加载”。</p>
<p><img src="https://s1.328888.xyz/2022/10/12/8jGhJ.png" alt="img"></p>
<h2 id="0x0a-dynamic-link-shared-library"><a href="#0x0a-dynamic-link-shared-library" class="headerlink" title="0x0a dynamic link shared library"></a>0x0a dynamic link shared library</h2><h3 id="1-为什么引入动态库"><a href="#1-为什么引入动态库" class="headerlink" title="1. 为什么引入动态库"></a>1. 为什么引入动态库</h3><p>当然是因为静态库有一些缺点了。</p>
<p>第一个问题，静态库不方便后续的更新和维护。</p>
<blockquote>
<p>静态库和所有软件一样，需要定期维护和更新。</p>
<p>如果应用程序员想要使用一个库的最新版本，他们必须以某种方式了解到该库的更新情况，然后显式的将他们的程序与更新了的库重新链接。</p>
</blockquote>
<p>第二个问题，静态户仍然会造成对内存资源的极大浪费。 </p>
<blockquote>
<p>虽然在上面 “引入静态库” 一节中我们已经说明了，静态库已经是一种比较节约内存资源的方式。</p>
<p>但那仅仅是在只针对一个文件的情况下，我们尽可能只引用必须用到的模块而避免引用了许多不会用到的模块造成内存浪费。</p>
<p>但试想一下，如果我们存在许多文件呢，几乎每个文件都会用到 printf() 函数等标准 IO 函数。在运行时，这些函数的代码会被复制到每个运行进程的文本段中（试想一下如果我们 printf() 了几百次，难道每一次调用都要复制一份 printf() 的代码吗？那也太浪费内存了！）。</p>
<p>特别是在一个运行上百个金层的典型系统上，这将是对稀缺的内存资源的极大浪费。</p>
<p><strong>（内存的一个有趣属性就是无论系统的内存多大，他总是一种奇缺资源。磁盘空间和厨房的垃圾桶具有同样的属性）。</strong></p>
</blockquote>
<p>于是，为了致力解决静态库的缺憾，共享库诞生了。</p>
<p><strong>共享库是一个目标模块</strong>，在运行或加载时，<strong>可以加载到任意的内存空间</strong>，并和一个在内存中的程序<strong>链接</strong>起来。这个链接的过程就叫做 <strong>“动态链接”</strong>，是由一个叫做动态链接器的程序来执行的。</p>
<p>共享库也称为 **“共享目标”(shared object)**。在 Linux 系统中用 <strong>.so</strong> 后缀来标识。微软的操作系统大量的使用了共享库，它们称为 **DLL(动态链接库)**。</p>
<h3 id="2-共享库的工作方式"><a href="#2-共享库的工作方式" class="headerlink" title="2. 共享库的工作方式"></a>2. 共享库的工作方式</h3><p>共享库是以两种不同的方式来实现 “共享”的。</p>
<p>首先，在任何给定的文件系统中，对于一个酷只有一个 .so 文件，所有引用该库的可执行目标文件分享这个 .so 文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行目标文件中。（解决了静态库内存浪费的问题）</p>
<p>其次，再内存中，一个共享库的 .text 节的一个副本可以被不同的正在运行的进程共享（与虚拟内存有关）。</p>
<p><img src="https://s1.328888.xyz/2022/10/12/86kb0.png" alt="img"></p>
<p>如何构造一个共享库：</p>
<p><code>gcc -shared -fpic -o libname.so module1.o module2.o ....</code></p>
<blockquote>
<p>-fpic 选项指示编译器生成与位置无关的代码。</p>
<p>-shared 选项指示编译器创建一个共享的目标文件。</p>
</blockquote>
<p>下面将将这个共享库链接到程序当中：</p>
<p><code>gcc -o prog main.c ./libname.so</code></p>
<p>根据上图(7-16)我们可以发现，可执行目标文件 prog21 在加载之后，也就是运行时可以和动态库 livvector.so 链接。基本的思路就是当创建可执行文件时，静态执行一些链接，然后在程序加载时，<strong>动态完成链接过程</strong>。</p>
<blockquote>
<p>by xjy：</p>
<p>注意上面的话并不矛盾，前一句话说程序运行时和动态库链接，下一句又说在程序加载时动态完成链接。一个是在运行时，一个是在加载时。</p>
<p>这可能是因为程序并不是直接全部加载到内存的（操作系统），它用到一点就加载一点，所以说，加载和运行是交叉的。</p>
</blockquote>
<p>注意，再整个链接的过程当没有任何动态库的代码和数据真的被复制到可执行文件 prog21 当中。反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对动态库中代码和数据的引用。</p>
<h3 id="3-小实验"><a href="#3-小实验" class="headerlink" title="3. 小实验"></a>3. 小实验</h3><p>下面是一个小实验，1.c，2.c 用来构建动态库和静态库，main.c 是测试函数。</p>
<p>app 是链接静态库生成的可执行文件。</p>
<p>prog 是链接动态库生成的可执行文件。</p>
<p>可以发现，prog 的大小比 app 小的多（小了50多倍）。</p>
<p><img src="https://s1.328888.xyz/2022/10/12/86JI6.png" alt="IMG"></p>
<h1 id="csapp-memory"><a href="#csapp-memory" class="headerlink" title="csapp memory"></a>csapp memory</h1><h2 id="一、cache"><a href="#一、cache" class="headerlink" title="一、cache"></a>一、cache</h2><h3 id="0x01-一种初始化方式"><a href="#0x01-一种初始化方式" class="headerlink" title="0x01 一种初始化方式"></a>0x01 一种初始化方式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">&#125; <span class="type">node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">node_t</span> p = &#123;</span><br><span class="line">        .l = <span class="number">100</span>,</span><br><span class="line">        .r = <span class="number">200</span>,</span><br><span class="line">        .s = <span class="string">&quot;hello,world!&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;node: %d %d %s\n&quot;</span>, p.l, p.r, p.s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="0x02-note"><a href="#0x02-note" class="headerlink" title="0x02 note"></a>0x02 note</h3><p>我们知道内存是分页的，cache的 line 只会存在于某一个页，它不会跨页存在。</p>
<h3 id="0x03-true-x2F-fake-sharing"><a href="#0x03-true-x2F-fake-sharing" class="headerlink" title="0x03 true&#x2F;fake sharing"></a>0x03 true&#x2F;fake sharing</h3><p>罪魁祸首：MESI 协议</p>
<p>false sharing有一个问题，就是对于sum求和这个例子，虽然我们设置sum1和sum2分别求和，但是sum1和sum2都是分配在栈上的，并且地址十分接近，所以它们可能在同一个cache当中，这样不管是sum1修改还是sum2修改，都会触法 MESI 的同步协议，这样 false sharing的速度和true sharing相差几乎无几。</p>
<h3 id="0x04-MESI-protocol"><a href="#0x04-MESI-protocol" class="headerlink" title="0x04 MESI protocol"></a>0x04 MESI protocol</h3><p>exclusive：独有的</p>
<p>exclusive 和 shared 不能共存</p>
<p>四种状态：（由于读数据不会产生数据一致性问题，因此这里只考虑写数据操作）</p>
<p>M: (exclusive) modify, like dirty. 物理地址被缓存到某一个 cache，并且数据已经被修改</p>
<p>E:  exclusive (clean).物理地址被缓存到某一个 cache，并且数据没有被修改</p>
<p>S:  (exclusive) shared clean.物理地址被缓存到 cache，并且多个 cache 共享。</p>
<blockquote>
<p>如果修改一个状态为 s 的 cache，它会发送一个广播，将所有其他状态为 s 的 cache 的状态修改为 invalid（具体方法是将其拥有数据写入到 dram，然后修改状态为 invalid），然后将自己的状态修改为 M，这样就可以保证全局状态下只有一个 M，也就是 exclusive的。</p>
</blockquote>
<p>I: invalid.物理地址并没有缓存到 cache。</p>
<blockquote>
<p>此时如果发生 cache write</p>
<ol>
<li>如果其他 cache 的状态都是 invalid，从内存 load 数据，修改器状态为 M。</li>
<li>如果存在 (shared)S状态 的 cache，将它们的数据写入到 dram，然后修改状态为 invalid。</li>
</ol>
</blockquote>
<p>每个处理器的cache line都是 dram 的 cache line 的拷贝</p>
<h2 id="二、page-table"><a href="#二、page-table" class="headerlink" title="二、page table"></a>二、page table</h2><h3 id="0x01-tips"><a href="#0x01-tips" class="headerlink" title="0x01 tips"></a>0x01 tips</h3><p>地址翻译由硬件实现，操作系统为应用提供这个功能。</p>
<p>TLB 也是一个 cache。</p>
<p>现在 64 位的处理器(cpu)的虚拟地址一般其实只有 48 位，剩下的 16 位属于内核。</p>
<p>虚拟地址空间呈现局部密集，整体稀疏的特征。</p>
<p>多级页表在最坏的情况下（满映射，每页都必须有有效数据）是一棵完全二叉树，此时页表条目会比朴素页表多出来一倍。但这种情况几乎不可能出现（虚拟地址空间的稀疏性和程序的局部性）。</p>
<p>页表分配在操作系统的内核态。</p>
<p>在windows下，资源管理器的内存中可以看到：分页缓冲池和非分页缓冲池。分页缓冲池指的是可以和磁盘进行换入(page in)和换出(page out)的页，而非分页并不是指不分页，而是不能喝磁盘进行 swap。</p>
<h3 id="0x02-how-to-reflect-va2pa"><a href="#0x02-how-to-reflect-va2pa" class="headerlink" title="0x02 how to reflect va2pa"></a>0x02 how to reflect va2pa</h3><p>在我们编写的地址转换函数中，我们简单的通过去模数将物理地址转换为虚拟地址，然而，这是极为不合理的，例如：</p>
<ol>
<li>产生不合法的地址（地址越界）。例如：0x200(1024)%0x200&#x3D;0x000，它产生了一个地址为 0 的地址，这显然是错误的。</li>
<li>不同进程间地址冲突的问题。因为每个进程的地址都是从 0x00400000 开始的，而相同地址取模之后的值是相同的，这就会导致地址冲突。</li>
</ol>
<p>一种可行的方法是使用 hashmap 完成物理地址到虚拟地址地址映射。它解决了使用取模方法产生的冲突和越界问题，但是，它又会产生以下两个问题：</p>
<ol>
<li>内存浪费严重。在 hashmap 中，我们需要额外的两份空间来分别存储物理地址和虚拟地址以记录他们的映射关系，并且，由于 hashmap 并不是全部使用的，它的内部会有空闲，因此我们还需要乘上一个空闲率 k(k&gt;&#x3D;1)，因此 hashmap 就需要额外的 2k 倍的额外内存空间要保存映射信息。</li>
<li>破坏程序的局部性。由于 hashmap 的映射是离散的，这就会导致程序会被离散化，破坏程序的局部性。</li>
</ol>
<p>但是，hashmap 产生的这两个问题属于 性能 问题，它只是导致程序运行效率不好，并不会导致程序运行错误。而取模方法则会导致程序运行出错。</p>
<p>现在我们再来想，hashmap 中记录如此之多的映射信息是否有必要？</p>
<p>肯定是有必要的，不然我们就无法找到物理地址了。但是！如果我们通过虚拟地址映射到物理地址不是离散的，例如：</p>
<blockquote>
<p>虚拟地址 0x1,0x2，通过 hashmap 地址映射为物理地址：0xa, 0xabcd。如果我们想找到这两个物理地址，我们必须保存映射信息，因为 0xa, 0xabcd 之间毫无关联。但是这种离散性是毫无必要的，如果我们将地址映射为 0xa, 0xb 这种连续的地址的话，它不仅可以避免破坏程序的局部性，还能减少地址映射需要保存的信息。</p>
<p>比如虚拟地址 [0x0, 0xffff] 这一块区域，如果我们采用 hashmap，它需要 0xffff 份映射信息，这也太多了。但是，如果 hashmap 映射的地址是连续的，我们就可以通过三元组(va0, pa0, offset) （offset表示偏移量）来找到这个区域内任意一个地址的映射，并且仅仅只需要一份映射信息，对于任意 va，pa&#x3D;pa0+va-va0（va &gt;&#x3D; va0 &amp;&amp; va &lt;&#x3D; va0 + offset）。</p>
<p>现在， 完成地址映射需要的额外信息由 2k 变成了 3M，M 就是上述三元组的数量，这个 M 远小于地址的数量。</p>
</blockquote>
<p>这就是分段思想。</p>
<p>当然，分段也是有问题的，例如：</p>
<ol>
<li>碎片。内部碎片和外部碎片。</li>
<li>每次计算都需要比较 va 是否越界。(va &gt;&#x3D; va0 &amp;&amp; va &lt;&#x3D; va0 + offset)</li>
<li>不方便拓展。当我们的段太大或者或许频繁拓展的时候，寻找一个合适的空间比较麻烦。</li>
</ol>
<p>所以说，我们需要把 offset 变成一个较小且固定的数值，这就是分页思想。</p>
<h3 id="0x03-address-transfer"><a href="#0x03-address-transfer" class="headerlink" title="0x03 address transfer"></a>0x03 address transfer</h3><p><a target="_blank" rel="noopener" href="http://www.wowotech.net/memory_management/arm64-memory-addressing.html">ARM64架构下地址翻译相关的宏定义</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/muahao/p/10297852.html">else</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1374439">else</a></p>
<h3 id="0x04-page-falult"><a href="#0x04-page-falult" class="headerlink" title="0x04 page falult"></a>0x04 page falult</h3><p>MM: main memory，主存</p>
<p>page table is the <strong>cache</strong> from disk to main memory</p>
<p>交换空间：当我们页表缓存的页满了之后，我们想再往内存映射一页，此时需要将该页 page out，但是如果该页的数据被修改了 dirty，我们该怎么办？</p>
<ol>
<li>不管它，这肯定不行</li>
<li>将该页写回文件 program file，这也肯定不行，我们不应该修改源文件。</li>
<li>放到别的地方 – swap space。</li>
</ol>
<p>将一页从 mm 放到 swap space 的过程就叫做 swap out</p>
<p>相反的，将页从 swap space 再放到 mm 的过程叫做 swap in</p>
<p>所以说，一个文件占用的空间包括了 mm 和 swap</p>
<p>swap space 也在磁盘</p>
<p><strong>demand paging</strong>:  waiting until the miss to copy the page to DRAM is konwn as deman paging</p>
<p>程序的代码文件，例如 .data 段它是存储在磁盘当中的，所以它与内存之间可以存在映射关系，但是 .data 段，stack, heap 不是存储在磁盘当中的，当我们需要把这些短存放在磁盘当中时，我们需要放入 swap space 中。它们又称为<strong>“匿名页”</strong>(在磁盘中没有文件与它对应)。 </p>
<h2 id="三、virtual-memory-overview"><a href="#三、virtual-memory-overview" class="headerlink" title="三、virtual memory overview"></a>三、virtual memory overview</h2><p>​       virtual memory 主要是为了解决物理内存和进程所看到的虚拟内存不匹配的问题，所以说每个 virtual memory 肯定是提供给每一个<strong>进程</strong>的。</p>
<p>每个进程就是一段 active 的内存，例如：</p>
<ol>
<li>.text 是死的</li>
<li>.data 是活的，因为它需要写入操作等</li>
</ol>
<p>如果区分 user 的虚拟地址空间和 kernel 的虚拟地址空间：kernel 的64位虚拟地址的最高位是1，user 的64位虚拟地址的最高位是 0。</p>
<p>我们通常看到的程序的虚拟地址空间图中， user 的虚拟地址空间地址的高部分都被 stack 占用了，但是这通常是作者的简化，实际上地址的最高部分被 kernel 部分占用了，只不过一半不标识出来。</p>
<p>只有第一级页表可以区分user mode or kernel mode，因为只有第一级页表可以得到地址的最高位。</p>
<p>用户的虚拟地址空间中的 user 部分映射到程序的虚拟地址空间的user 部分，映射方法为：0x0 + addr，kernel mode 部分的映射方法为：0xffff + addr，user的虚拟地址空间的地址最高为2^48。0xffff正好是16位。</p>
<p>pgb 在 kernel 中只有唯一一份。</p>
<p>kernel 的虚拟地址从 2^47？</p>
<p>内核的地址翻译全局一致。</p>
<h2 id="四、TLB"><a href="#四、TLB" class="headerlink" title="四、TLB"></a>四、TLB</h2><p>hardware acceleration：硬件加速</p>
<p>TLB is the cache of va2pa</p>
<p>我们可以把 cache 看作一个 key-value 库</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">jyyyx</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2023/06/15/csapp/">http://example.com/2023/06/15/csapp/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint polocy. If reproduced, please indicate source
                    <a href="/about" target="_blank">jyyyx</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">No tag</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2023/06/15/memoy/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/6.jpg" class="responsive-img" alt="Memory Management">
                        
                        <span class="card-title">Memory Management</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-06-15
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/C/" class="post-category">
                                    C++
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/06/15/cpp_concurrency_in_action/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="C++ concurrency programming">
                        
                        <span class="card-title">C++ concurrency programming</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-06-15
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/C/" class="post-category">
                                    C++
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023</span>
            
            <span id="year">2023</span>
            <a href="/about" target="_blank">jyyyx</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1181062873" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
