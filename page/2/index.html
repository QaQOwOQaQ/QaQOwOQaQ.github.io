<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qaqowoqaq.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="jyyyyyyyyyx">
<meta property="og:url" content="https://qaqowoqaq.github.io/page/2/index.html">
<meta property="og:site_name" content="jyyyyyyyyyx">
<meta property="og:locale">
<meta property="article:author" content="jyyyx">
<meta property="article:tag" content="cs">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://qaqowoqaq.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'cn'
  };
</script>

  <title>jyyyyyyyyyx</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">jyyyyyyyyyx</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">后来居上</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">csapp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-15 20:20:57" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-16 10:06:48" itemprop="dateModified" datetime="2023-06-16T10:06:48+08:00">2023-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/csapp/" itemprop="url" rel="index"><span itemprop="name">csapp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h1><h2 id="0x-ff-杂项"><a href="#0x-ff-杂项" class="headerlink" title="0x ff 杂项"></a>0x ff 杂项</h2><p>Instruction set Architecture：ISA,指令集体系架构</p>
<p>软件和硬件之间的一层抽象层</p>
<p>冯诺依曼计算机，即程序<strong>存储型</strong>计算机</p>
<p>重要思想：程序就是一系列被编码了的字节序列（看上去和数据一模一样）</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/SovietPower/p/14877143.html">https://www.cnblogs.com/SovietPower/p/14877143.html</a></p>
<h2 id="0x-00-参考资料-amp-amp-lab"><a href="#0x-00-参考资料-amp-amp-lab" class="headerlink" title="0x 00 参考资料 &amp;&amp; lab"></a>0x 00 参考资料 &amp;&amp; lab</h2><p>official：</p>
<p><a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/students.html">官网</a></p>
<p><a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/labs.html">实验</a></p>
<hr>
<p>note:</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17K4y1N7Q2?spm_id_from=333.999.0.0&vd_source=38033fe3a1f136728a1d6f8acf710b51">视频详解</a> </p>
<p><a target="_blank" rel="noopener" href="https://github.com/yangminz/bcst_csapp">笔记参考视频的源码</a></p>
<hr>
<p>lab：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/wuxueqian14/CSAPP-Lab#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">比较详细的Attack，Data，Boom Lab参考</a></p>
<p><a target="_blank" rel="noopener" href="https://kazamayc.github.io/2021/02/05/csapp-lab/">Boom，Attack，Shell Lab</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/505497911">全部实验的详细参考–知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43362650/article/details/122890142">全部实验的详细参考–CSDN</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Exely/CSAPP-Labs">全部实验的详细参考–Github</a></p>
<hr>
<p>video:</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1RK4y1R7Kf?spm_id_from=333.999.0.0&vd_source=38033fe3a1f136728a1d6f8acf710b51">导读</a>        <a target="_blank" rel="noopener" href="https://fengmuzi2003.gitbook.io/csapp3e/">导读笔记</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cD4y1D7uR?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click&vd_source=38033fe3a1f136728a1d6f8acf710b51">小视频复习</a></p>
<hr>
<p>book：</p>
<p><a target="_blank" rel="noopener" href="https://hansimov.gitbook.io/csapp/">学生版重点知识</a></p>
<p><a href="instructor">讲师版重点知识</a></p>
<hr>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lab操作流程</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.datalab：</span></span><br><span class="line">在源文件 bits.c 中完善函数即可</span><br><span class="line">./dlc bits.c 	 // 用于检查程序是否合法，是否使用了程序规定的符号</span><br><span class="line">make btest   	 // btest是评分(检查对错工具)，每次执行btets前都要重新make一下</span><br><span class="line">./btest bits.c   // 评分</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.bomblab</span></span><br><span class="line">./bomb</span><br><span class="line">输入答案</span><br><span class="line">导读P3-52分钟有第一关的实操</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.attacklab</span></span><br><span class="line">./hex2raw &lt; att1.txt &gt; attraw1.txt // 将字节序列at t1转换为字符串attraw1</span><br><span class="line">./ctarget -q -i attraw1.txt     //测试答案</span><br><span class="line">// (https://github.com/wuxueqian14/csapp-lab/tree/master/Attack%20Lab)</span><br></pre></td></tr></table></figure>



<h2 id="0x-01-二进制"><a href="#0x-01-二进制" class="headerlink" title="0x 01 二进制"></a>0x 01 二进制</h2><p>内存中存储的是电压，然后通过（不知道）某种方式<strong>抽象</strong>为数字01，然而计算机的内存太大了，以致于01的个数实在太多了，于是，我们把原有的0和1分块，并再次抽象为0,1…。</p>
<p><img src="file:///C:\Users\24072\AppData\Roaming\Tencent\Users\2407217576\QQ\WinTemp\RichOle\7E[W6J9]YPX$8MS~3CCM[DG.png" alt="img"></p>
<p>加入内存中有n bit,每m bit分为一块，则最多可以分为2^m块，因为m bit的排列组合数为2 ^ n个序列（sequence）</p>
<p>例如十进制数字123，它应该表示为<code>1*10^2 + 2*10^1 + 3*10^0</code>，所以这里的123准确来说应该是一个sequence，而不是一个数。</p>
<p>数是一个比较唯心的抽象的概念，你说一个数3，它可以是十进制序列3，也可以是二进制序列11…，3和11都是这个真正的（唯心的）3，这些序列之间是一一对应的，不仅如此，他们的运算也是一一对应的。十进制的序列1+2，对应的二进制下序列为1+01</p>
<p><strong>取反对称</strong>：对称轴的两侧是相反数</p>
<p>对于1,2,3,4，他们分别取反对称于-1，-2，-3，-4</p>
<p>对于二进制000,001,010,011，他们分别取反对称于111,110,101,100</p>
<p><img src="https://s1.328888.xyz/2022/08/29/CrzXC.png" alt="IMAGE"></p>
<h2 id="0x-02-二进制运算"><a href="#0x-02-二进制运算" class="headerlink" title="0x 02 二进制运算"></a>0x 02 二进制运算</h2><p><strong>位运算的循环圈：</strong></p>
<p><img src="https://s1.328888.xyz/2022/09/06/5OAqi.png" alt="IMG"></p>
<p>​										（int类型有符号数）</p>
<p><img src="https://s1.328888.xyz/2022/09/06/5jEa0.png" alt="img"></p>
<p>​										(int类型无符号数)</p>
<p>通过这张图，你可能会更好地理解补码和无符号数运算是在mod 2^n 下计算的意义。</p>
<p>看一下树状数组lowbit函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x; <span class="comment">// &lt;==&gt; x &amp; (~x + 1);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数为什么能求得最后一个1所在位置的代表的权值呢？</p>
<p>首先 -x，其实就是x的补码。关于补码，我们有一个求补码的方法：从右到左直到第一个1保持不变，后面的位取反，我们将x和x的补码做与运算，最后得到的结果一定是这样的形式：00..010..0，最后一个1左侧全为0，右侧也全为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">func1</span><span class="params">(<span class="type">unsigned</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 输出一个无符号数x，判断x在十六进制下的的每一位是不是字母</span></span><br><span class="line">    <span class="comment">// 如果该位是字母就返回1，否则返回0</span></span><br><span class="line">    <span class="comment">// 并以一个16进制数的形式返回</span></span><br><span class="line">    <span class="type">unsigned</span> x1 = (x &amp; <span class="number">0x22222222</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> x2 = (x &amp; <span class="number">0x44444444</span>) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> x3 = (x &amp; <span class="number">0x88888888</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;[1]:%04x\n[2]:%04x\n[3]:%04x\n&quot;, x1, x2, x3);</span></span><br><span class="line">    <span class="keyword">return</span> x3 &amp; (x2 | x1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">func2</span><span class="params">(<span class="type">unsigned</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 输出一个无符号数x，判断x在十六进制下的每一位是不是字母</span></span><br><span class="line">    <span class="comment">// 如果所有位都是字母返回1，否则返回0</span></span><br><span class="line">    x = func1(x); <span class="comment">//得到了每一位的结果</span></span><br><span class="line">    x = x &amp; (x &gt;&gt; <span class="number">16</span>); <span class="comment">// 每次判断一半</span></span><br><span class="line">    x = x &amp; (x &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">    x = x &amp; (x &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">func3</span><span class="params">(<span class="type">unsigned</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// bigCount</span></span><br><span class="line">    <span class="type">unsigned</span> c;</span><br><span class="line">    c = (x &amp; <span class="number">0x55555555</span>) + ((x &gt;&gt;  <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    c = (c &amp; <span class="number">0x33333333</span>) + ((c &gt;&gt;  <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    c = (c &amp; <span class="number">0x0f0f0f0f</span>) + ((c &gt;&gt;  <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>);</span><br><span class="line">    c = (c &amp; <span class="number">0x00ff00ff</span>) + ((c &gt;&gt;  <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>);</span><br><span class="line">    c = (c &amp; <span class="number">0x0000ffff</span>) + ((c &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> x = <span class="number">0x1</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;0x%X = %X\n&quot;, x, func1(x));</span></span><br><span class="line">    <span class="comment">// printf(&quot;0x%X = %X\n&quot;, x, func2(x));</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%X = %d\n&quot;</span>, x, func3(x));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0x-03-浮点数"><a href="#0x-03-浮点数" class="headerlink" title="0x 03 浮点数"></a>0x 03 浮点数</h2><p>为什么 IEEE 754浮点数Float类型的bias&#x3D;127而不是128？</p>
<p>其实这也没有一个官方的说法，不过为了让自己接受这个设定，我们可以从两个角度考虑：</p>
<ol>
<li>首先，bias采用127时绝对值的范围比较对称</li>
<li>其次，bias采用127时最大的指数是127比bias&#x3D;128时的126大，虽然只大1，但是我们直到指数的增长是“爆炸”的，因此其表示的范围也大得多。</li>
</ol>
<p>浮点的根据exp和frac分为三种情况：</p>
<ol>
<li>exp&#x3D;111..1，指数全1。此时又分为两种情况：（1）当frac全0时表示无穷大，根据符号位又分为正无穷和负无穷。（2）frac不全为0，表示NaN，一种未定义行为。（可以这样区分无穷和NaN，由于未定义的行为有很多，因此需要根据frac进一步区分，所以frac不是固定的全0，（胡乱猜的），可以这样记忆）。</li>
<li>exp&#x3D;000..0，指数全0。表示不规格化的浮点数。这里的主要目的是为了拓展精度和范围（往值小的方向）。</li>
<li>else，规格化浮点数。</li>
</ol>
<p>将一个无符号数转换为一个浮点数的表示形式并保存在一个无符号数字中</p>
<p><a target="_blank" rel="noopener" href="https://lostphp.com/hexconvert/">IEEE 754浮点数十六进制相互转换</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/68131179">关于浮点数舍入的讨论</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">uint2float</span><span class="params">(<span class="type">uint32_t</span> u)</span>&#123; <span class="comment">// 将一个服务号数u转换成浮点数存储的形式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 特判</span></span><br><span class="line">    <span class="keyword">if</span> (u == <span class="number">0x00000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x00000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到最后一个1的后面的一个位置，求得该1后面还有多少个数</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">0</span> &amp;&amp; (((u &gt;&gt; n) &amp; <span class="number">0x1</span>) == <span class="number">0x0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        n = n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n: &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint32_t</span> e, f; <span class="comment">// exp, frac</span></span><br><span class="line">    <span class="comment">// &lt;= 0000 0000 1.111 1111 1111 1111 1111 1111 : 32位</span></span><br><span class="line">    <span class="comment">// u的位数&lt;=24，此时再隐藏一个1，就&lt;=23位，于是frac就可以保存所有位，不需要舍入</span></span><br><span class="line">    <span class="keyword">if</span> (u &lt;= <span class="number">0x00ffffff</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// no need rounding</span></span><br><span class="line">        <span class="type">uint32_t</span> mask = <span class="number">0xffffffff</span> &gt;&gt; (<span class="number">32</span> - n); <span class="comment">// mask就是frac的掩码</span></span><br><span class="line">        f = (u &amp; mask) &lt;&lt; (<span class="number">23</span> - n);             <span class="comment">// f = u &amp; mask得到frac，但还需要左移移动到最右侧[frac00..0]，而不是[00..0frac]</span></span><br><span class="line">        e = n + <span class="number">127</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;e: 0x%x, f: 0x%x\n&quot;</span>, e, f);</span><br><span class="line">        <span class="keyword">return</span> (e &lt;&lt; <span class="number">23</span>) | f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;= 0000 0001 0000 0000 0000 0000 0000 0000 </span></span><br><span class="line">    <span class="comment">// 总位数&gt;=25，一位可以隐藏，还剩下至少24位，frac无法全部保存，需要舍入(rounding)</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// expand to 64 bit for situations like 0xffffffff</span></span><br><span class="line">        <span class="type">uint64_t</span> a = <span class="number">0</span>;</span><br><span class="line">        a += u;</span><br><span class="line">        <span class="comment">// compute g, r, s</span></span><br><span class="line">        <span class="type">uint32_t</span> g = (a &gt;&gt; (n - <span class="number">23</span>)) &amp; <span class="number">0x1</span>;</span><br><span class="line">        <span class="type">uint32_t</span> r = (a &gt;&gt; (n - <span class="number">23</span> - <span class="number">1</span>)) &amp; <span class="number">0x1</span>;</span><br><span class="line">        <span class="type">uint32_t</span> s = <span class="number">0x0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">23</span> - <span class="number">1</span>; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            s = s | ((u &gt;&gt; j) &amp; <span class="number">0x1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// compute carry</span></span><br><span class="line">        a = a &gt;&gt; (n - <span class="number">23</span>);</span><br><span class="line">        <span class="comment">// 0    1    ?    ... ?</span></span><br><span class="line">        <span class="comment">// [24] [23] [22] ... [0]</span></span><br><span class="line">        <span class="keyword">if</span> (r &amp; (g | s) == <span class="number">0x1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = a + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check carry</span></span><br><span class="line">        <span class="keyword">if</span> ((a &gt;&gt; <span class="number">23</span>) == <span class="number">0x1</span>) /</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 0    1    ?    ... ?</span></span><br><span class="line">            <span class="comment">// [24] [23] [22] ... [0]</span></span><br><span class="line">            f = a &amp; <span class="number">0x007fffff</span>; <span class="comment">// 0x0000 0000 0111 1111 1111 1111 1111 1111只保留frac</span></span><br><span class="line">            e = n + <span class="number">127</span>;</span><br><span class="line">            <span class="keyword">return</span> (e &lt;&lt; <span class="number">23</span>) | f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((a &gt;&gt; <span class="number">23</span>) == <span class="number">0x2</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1    0    0    ... 0</span></span><br><span class="line">            <span class="comment">// [24] [23] [22] ... [0]</span></span><br><span class="line">            e = n + <span class="number">1</span> + <span class="number">127</span>;</span><br><span class="line">            <span class="keyword">return</span> (e &lt;&lt; <span class="number">23</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// INF as default error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x7f800000</span>; <span class="comment">// 0 1111 1111 000 0000 0000 0000 0000 0000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;  <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, uint2float(<span class="number">0x10000000</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0x-04-时序电路和组合电路"><a href="#0x-04-时序电路和组合电路" class="headerlink" title="0x 04 时序电路和组合电路"></a>0x 04 时序电路和组合电路</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_20265495/article/details/41314577">原文链接：</a></p>
<hr>
<p><strong>数字电路</strong>根据逻辑功能的不同特点，可以分成两大类，一类叫<strong>组合逻辑电路</strong>（简称组合电路），另一类叫做<strong>时序逻辑电路</strong>（简称时序电路）。组合逻辑电路在逻辑功能上的特点是任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关。而时序逻辑电路在逻辑功能上的特点是任意时刻的输出不仅取决于当时的输入信号，而且还取决于电路原来的状态，或者说，还与以前的输入有关。</p>
<p>时序电路，是由最基本的逻辑门电路加上反馈逻辑回路（输出到输入）或器件组合而成的电路，与组合电路最本质的区别在于时序电路具有记忆功能。</p>
<p>时序电路的特点是：输出不仅取决于当时的输入值，而且还与电路过去的状态有关。它类似于含储能元件的电感或电容的电路，如触发器、锁存器、计数器、移位寄存器、存储器等电路都是时序电路的典型器件，时序逻辑电路的状态是由存储电路来记忆和表示的。</p>
<p>时序电路和组合电路的区别：<br>时序电路具有<strong>记忆功能</strong>。时序电路的特点是：输出不仅取决于当时的输入值，而且还与电路过去的状态有关。组合逻辑电路在逻辑功能上的特点是任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关</p>
<p>时序电路是 时序 逻辑 电路。时序，时间 顺序，是在时钟的推动下工作的，cpu就是一个复杂的时序电路。</p>
<p>组合逻辑电路和时序逻辑电路的最根本区别在于：组合逻辑电路的输出在任一时刻只取决于当时的输入信号；而时序逻辑电路的输出，不仅和当前的输入有关，还和上时刻的输出有关，它具有记忆元件（触发器），可以记录前一时刻的输出状态，它可以没有输入，仅在时钟的驱动下，给出输出。</p>
<p>时序电路的基本结构：</p>
<p><img src="https://img-blog.csdn.net/20151210201333026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>结构特征：<em>电路由组合电路和存储电路组成</em>，电路存在反馈 </p>
<h2 id="0x-05-缓冲区漏洞实验"><a href="#0x-05-缓冲区漏洞实验" class="headerlink" title="0x 05 缓冲区漏洞实验"></a>0x 05 缓冲区漏洞实验</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//bomb.c</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">4</span>];</span><br><span class="line">	gets(buffer); <span class="comment">//缓冲区溢出的关键</span></span><br><span class="line">	<span class="built_in">puts</span>(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;pls input: &quot;</span>);</span><br><span class="line">	echo();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">操作步骤：</span><br><span class="line">1. gcc bomb.c -o main -fno-stack-protector -g</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-fno-stack-protector取消栈保护？</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-g调试模式，因为后面还需要调试</span></span><br><span class="line"></span><br><span class="line">2. gdb main</span><br><span class="line">2.1 在echo函数的gets函数加上一个断点：b 6</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span>函数位于main.c的第六行</span></span><br><span class="line">2.2 r</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">run运行程序，此时会在断点gets函数停下</span></span><br><span class="line">2.3 info f </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示栈信息，如下方图-栈信息所示</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在这些信息中，我们需要注意三个地址：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(1)frame at 0x7ff.f3d0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(2)rbp at   0x7ff.f3c0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(3)bip at.  0x7ff.f3c8</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中frame at的地址是函数<span class="built_in">echo</span>占用栈的地址</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时，返回地址rip和旧的栈顶指针rbp已经入栈</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">由此可见，程序还没运行，返回地址和旧的栈顶指针就会入栈</span></span><br><span class="line">2.4 p/a &amp;buffer[0]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印数组buffer的首地址</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过结构图，我们可以发现，数组与返回地址rip之间差了12（c8-bc）字节，如果我们gets的数组大于等于12字节，那么返回地址的数据就会被破坏，</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>![image-20220907100422585](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220907100422585.png)</p>
<p>(图-栈信息)</p>
<p>![13C288AA-6A07-463D-A689-CC7FEF2DCB91](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;13C288AA-6A07-463D-A689-CC7FEF2DCB91.png)</p>
<p>(图-数组地址)</p>
<p><img src="https://1484576603-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MV9vJFv4kmvRLgEog6g%2F-MZuBW3GNKr5zld5JHFH%2F-MZuER6OHxdJ7z3gtPNL%2Fimage.png?alt=media&token=ecba360a-06d3-4734-9430-aab5fd84cbee" alt="img"></p>
<p>(图-视频测试运行gets前的栈)</p>
<p><img src="https://1484576603-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MV9vJFv4kmvRLgEog6g%2F-MZrajFxkCIYEw7i-1-F%2F-MZrrKB09-F7NqAWNBKB%2Finitpintu_%E5%89%AF%E6%9C%AC.jpg?alt=media&token=35b89f3f-e6d2-4aa9-b7d0-2da8ad86450b" alt="img"></p>
<p>（图-视频测试运行gets后的栈）</p>
<h2 id="0x-06-Computer-English"><a href="#0x-06-Computer-English" class="headerlink" title="0x 06 Computer English"></a>0x 06 Computer English</h2><hr>
<p>common：注释</p>
<p>override：覆盖</p>
<p>entry：入口，条目，输入</p>
<p>Place holder：站位</p>
<p>ascending：升序</p>
<p>descending：降序</p>
<p>comma：逗号</p>
<p>brackets：括号</p>
<p>determine: 确定，决定，判定，下决心</p>
<p>deterministic: 确定行</p>
<p>finite: 有限的</p>
<p>infinite: 无限的</p>
<p>automaton: 自动机</p>
<p>positive: 正数</p>
<p>negative: 负数</p>
<p>decimal: 十进制</p>
<p>hexadecimal：十六进制</p>
<p>octal: 八进制</p>
<p>optimazation：优化</p>
<p>pruning：剪枝</p>
<p>decode:译码</p>
<p>instance: 例子，实例</p>
<p>cpu和memory 就组成了一个状态机</p>
<p>operand 操作数</p>
<p>opreator：操作符</p>
<p>memory：内存&#x2F;存储器</p>
<p>recursion：递归</p>
<p>reduce：归约</p>
<p>iterate: 迭代</p>
<p>transistor：晶体管</p>
<p>complement：补充，补运算(～)，辅</p>
<p>parse: 解析</p>
<p>simulator: 模拟器</p>
<p>simulate: 模拟，仿真，假装</p>
<p>converter：转换器</p>
<p>verbose: 冗长的，啰嗦</p>
<p>handler: 管理者，处理程序</p>
<p>illustrate: 说明</p>
<p>universal: 通用的</p>
<p>pecuilar:  特有，奇特，一场</p>
<hr>
<h2 id="0x-07-makefile"><a href="#0x-07-makefile" class="headerlink" title="0x 07 makefile"></a>0x 07 <a target="_blank" rel="noopener" href="https://subingwen.cn/linux/makefile/#3-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F">makefile</a></h2><h3 id="1-规则"><a href="#1-规则" class="headerlink" title=".1 规则"></a>.1 规则</h3><p>（1）make命令具有<strong>自动推导</strong>的功能，例如依赖中的.o文件，即使不存在，make会使用内部默认的构造规则生成这些.o文件。</p>
<p>（2）make后面<strong>不带参数</strong>默认执行第一条命令</p>
<p>（3）mak的<strong>时间戳规则</strong>：</p>
<blockquote>
<p>make 命令执行的时候会根据文件的时间戳判定是否执行 makefile 文件中相关规则中的命令。</p>
<ol>
<li>目标是通过依赖生成的，因此正常情况下：目标时间戳 &gt; 所有依赖的时间戳 , 如果执行 make 命令的时候检测到规则中的目标和依赖满足这个条件，那么规则中的命令就不会被执行。</li>
<li>当依赖文件被更新了，文件时间戳也会随之被更新，这时候 目标时间戳 &lt; 某些依赖的时间戳 , 在这种情况下目标文件会通过规则中的命令被重新生成。</li>
<li>如果规则中的目标对应的文件根本就不存在， 那么规则中的命令肯定会被执行。</li>
</ol>
</blockquote>
<p>（4）对于不生成目标文件的目标称为伪目标，为了避免微伪目标的名字和真实的文件名重复，我们可以在伪目标的前面加上关键字：.PHONY(假) 例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean: </span></span><br><span class="line">	rm *.o</span><br></pre></td></tr></table></figure>

<p>声明位伪目标主要是避免这种情况：</p>
<blockquote>
<p>如果目标不存在规则的命令肯定被执行， 如果目标文件存在了就需要比较规则中目标文件和依赖文件的时间戳，满足条件才执行规则的命令，否则不执行。</p>
<p>加入目标是clean，而恰好有一个真实的clean文件，只要clean文件不更新，那么clean目标就无法执行。</p>
</blockquote>
<p>（提醒）<strong>目录连接到博客中的实例6可以好好看看👀</strong></p>
<h3 id="2-变量"><a href="#2-变量" class="headerlink" title=".2 变量"></a>.2 变量</h3><p>make中的变量分为三种：</p>
<p><strong>1.自定义变量</strong>：即用户自己定义的变量，makefile中的变量是<strong>没有类型</strong>的，直接创建变量然后给其赋值就可以了。通过$(obj) 可以取出自定义的obj变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">obj = main.c</span><br><span class="line">target = main</span><br><span class="line">depend = main.o</span><br><span class="line"></span><br><span class="line">$(target): $(depend)</span><br><span class="line">	gcc $(obj) -o $(target)</span><br><span class="line"></span><br><span class="line"># --------------</span><br><span class="line"># 上面的命令等价于下面：</span><br><span class="line"></span><br><span class="line">main: main.o</span><br><span class="line">	gcc main.c -o main</span><br></pre></td></tr></table></figure>

<p><strong>2.预定义变量：</strong>在makefile中有一些已经定义好的变量，用户可以直接使用这些变量，不用进行定义，预定义变量的名字一般是大写的。</p>
<p>![96D31374-3040-4B27-8A65-B9DE685E3351](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;96D31374-3040-4B27-8A65-B9DE685E3351.png)</p>
<p><strong>3.自动变量：</strong>makefile智能鼓的规则语句经常会出现目标文件和依赖文件，<strong>自动变量用来代表这些规则中的目标文件和依赖文件，并且衙门只能在规则的命令总使用。</strong></p>
<p>![DC05ED8E-B70B-44FB-A799-E6D0C938CF7F](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;DC05ED8E-B70B-44FB-A799-E6D0C938CF7F.png)</p>
<h3 id="3-模式匹配"><a href="#3-模式匹配" class="headerlink" title=".3 模式匹配"></a>.3 模式匹配</h3><p>模式匹配常常与自动变量结合使用，用来简化makefile，减少冗余和重复书写。</p>
<h3 id="4-函数"><a href="#4-函数" class="headerlink" title=".4 函数"></a>.4 函数</h3><p>1.wildcard：通配符，用来匹配制定目录下的文件</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用举例: 分别搜索三个不同目录下的 .c 格式的源文件</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> /home/robin/a/*.c /home/robin/b/*.c *.c)</span>  <span class="comment"># *.c == ./*.c</span></span><br><span class="line"><span class="comment"># 返回值: 得到一个大的字符串, 里边有若干个满足条件的文件名, 文件名之间使用空格间隔</span></span><br><span class="line">/home/robin/a/a.c /home/robin/a/b.c /home/robin/b/c.c /home/robin/b/d.c e.c f.c</span><br></pre></td></tr></table></figure>



<p>2.patsubst：pattern subsitude，匹配代替，用来替换文件名的后缀</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src = a.cpp b.cpp c.cpp e.cpp</span><br><span class="line"><span class="comment"># 把变量 src 中的所有文件名的后缀从 .cpp 替换为 .o</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(src)</span>)</span> </span><br><span class="line"><span class="comment"># obj 的值为: a.o b.o c.o e.o</span></span><br></pre></td></tr></table></figure>



<h2 id="0x-08-gdb"><a href="#0x-08-gdb" class="headerlink" title="0x 08 gdb"></a>0x 08 gdb</h2><h3 id="0-参考"><a href="#0-参考" class="headerlink" title=".0 参考"></a>.0 参考</h3><p>![9523F5A0-416A-4635-99DB-47685282748F](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;9523F5A0-416A-4635-99DB-47685282748F.png)</p>
<p><a target="_blank" rel="noopener" href="https://subingwen.cn/linux/gdb/#5-3-3-next">本文档参考来源，功能基础而简单</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/XxPIfrQ3E0GR88UsmQNggg">设计多线程，多进城等高级功能，较为复杂</a></p>
<p><a target="_blank" rel="noopener" href="https://www.yanbinghu.com/2019/04/20/41283.html">知乎</a></p>
<h3 id="1-添加命令行参数"><a href="#1-添加命令行参数" class="headerlink" title=".1 添加命令行参数"></a>.1 添加命令行参数</h3><figure class="highlight plaintext"><figcaption><span>args …```	启动gdb后，在程序启动之前设置参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```show args```	查看设置的命令行参数</span><br><span class="line"></span><br><span class="line">### .2 启动程序</span><br><span class="line"></span><br><span class="line">在整个gdb调试过程中，启动饮用程序的命令只能使用一次。</span><br><span class="line"></span><br><span class="line">```run```		可以缩写为 `r`，如果程序中设置了断点会停在第一个断点的位置，如果没有设置断点，程序就执行完了。</span><br><span class="line"></span><br><span class="line">`start` 	启动程序，最终会阻塞在main函数的第一行，等待输入后续其他 gdb 命令。</span><br><span class="line"></span><br><span class="line">&gt; start 是要开始运行， run 是真的运行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### .3 退出 gdb</span><br><span class="line"></span><br><span class="line">`quit`  缩写为 `q`</span><br><span class="line"></span><br><span class="line">### .4 查看代码</span><br><span class="line"></span><br><span class="line">`list`	可以缩写为 `l` ，通过这个命令可以查看项目中任意一个文件中的内容，并且还可以通过文件行号，函数名等方式查看。</span><br><span class="line"></span><br><span class="line">``` shell</span><br><span class="line">(gdb) list</span><br><span class="line">(gdb) list 行号</span><br><span class="line">(gdb) list 函数名</span><br></pre></td></tr></table></figure>

<p>一个项目通常由多个源文件构成，默认情况下通过 list 查看的是程序入口 main 函数对应的文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list 文件名：行号</span><br><span class="line">(gdb) list 文件名：函数名</span><br></pre></td></tr></table></figure>

<p>默认情况下 list 之显示 10 行的内容。如果想显示更多，可以通过 <code>set listsize</code> 设置，同时如果想查看当前显示的行数可以通过 <code>show listsize</code> 查看。这里的 	<code>listsize</code> 可以缩写为 <code>list</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set listsize 行号</span><br><span class="line">(gdb) show listsize</span><br></pre></td></tr></table></figure>



<h3 id="5-断点操作"><a href="#5-断点操作" class="headerlink" title=".5 断点操作"></a>.5 断点操作</h3><p>如果想通过 gdb 掉时某一行或者得到某个变量在运行状态下的实际值，就需要在这一行设置断点，程序指定到断点的位置就会阻塞。我们就可以通过 gdb 的调试命令得到我们想要的信息了。</p>
<p>设置断点：<code>break</code> 缩写为 <code>b</code></p>
<p>断点的设置方式由两种：</p>
<ol>
<li>常规断点：程序只要运行到这个位置就会阻塞</li>
<li>条件断点：只有指定的条件被满足了程序才会在断点处阻塞</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置普通断点到当前文件</span></span><br><span class="line">(gdb) b 行号</span><br><span class="line">(gdb) b 函数名 # 停在函数的第一行</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置普通断点到某个非当前文件</span></span><br><span class="line">(gdb) b 文件名：行号</span><br><span class="line">(gdb) b 问价名：函数名 # 停在函数的第一行</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置条件断点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通常情况下，在循环中条件断点用的比较多</span></span><br><span class="line">(gdb)  b 行号 if 变量名 == 某个值</span><br></pre></td></tr></table></figure>

<hr>
<p>查看断点：<code>info break</code> ，其中 <code>info</code> 可以缩写为 <code>i</code> , <code>break</code> 可以缩写为 <code>b</code></p>
<blockquote>
<p>info break 查看断点信息时的一些常用的属性：Num:   断点的编号，删除断点或者设置断点状态的时候都需要使用<br>Enb:    当前断点的状态，y 表示断点可用，n 表示断点不可用<br>What:  描述断点被设置在了哪个文件的哪一行或者哪个函数上</p>
</blockquote>
<hr>
<p>如果确定设置的某个断点不再被使用了，可用将其删除，删除命令是 <code>delete</code> 断点编号 , 这个 <code>delete</code> 可以简写为 <code>del</code> 也可以再简写为 <code>d</code>。</p>
<p>删除断点的方式有两种: <strong>删除(一个或者多个)指定断点</strong>或者<strong>删除一个连续的断点区间</strong>，具体操作如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">delete == del == d</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要 info b 查看断点的信息, 第一列就是编号</span></span><br><span class="line">(gdb) d 断点的编号1 [断点编号2 ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例:</span> </span><br><span class="line">(gdb) d 1          # 删除第1个断点</span><br><span class="line">(gdb) d 2 4 6      # 删除第2,4,6个断点</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除一个范围, 断点编号 num1 - numN 是一个连续区间</span></span><br><span class="line">(gdb) d num1-numN</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例, 删除第1到第5个断点</span></span><br><span class="line">(gdb) d 1-5</span><br></pre></td></tr></table></figure>



<hr>
<p>如果某个断点只是临时不需要了，我们可以将其设置为不可用状态，设置命令为 <code>disable</code> 断点编号，当需要的时候再将其设置回可用状态，设置命令为 <code>enable</code> 断点编号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 让断点失效之后, gdb调试过程中程序是不会停在这个位置的</span><br><span class="line"># disable == dis</span><br><span class="line"># 设置某一个或者某几个断点无效</span><br><span class="line">(gdb) dis 断点1的编号 [断点2的编号 ...]</span><br><span class="line"></span><br><span class="line"># 设置某个区间断点无效</span><br><span class="line">(gdb) dis 断点1编号-断点n编号</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 查看断点信息</span><br><span class="line">(gdb) i b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       breakpoint     keep y   0x0000000000400cce in main() at test.cpp:14</span><br><span class="line">4       breakpoint     keep y   0x0000000000400cdd in main() at test.cpp:16</span><br><span class="line">5       breakpoint     keep y   0x0000000000400d46 in main() at test.cpp:23</span><br><span class="line">6       breakpoint     keep y   0x0000000000400d4e in main() at test.cpp:25</span><br><span class="line">7       breakpoint     keep y   0x0000000000400d6e in main() at test.cpp:28</span><br><span class="line">8       breakpoint     keep y   0x0000000000400d7d in main() at test.cpp:30</span><br><span class="line"></span><br><span class="line"># 设置第2, 第4 个断点无效</span><br><span class="line">(gdb) dis 2 4</span><br><span class="line"></span><br><span class="line"># 查看断点信息</span><br><span class="line">(gdb) i b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       breakpoint     keep n   0x0000000000400cce in main() at test.cpp:14</span><br><span class="line">4       breakpoint     keep n   0x0000000000400cdd in main() at test.cpp:16</span><br><span class="line">5       breakpoint     keep y   0x0000000000400d46 in main() at test.cpp:23</span><br><span class="line">6       breakpoint     keep y   0x0000000000400d4e in main() at test.cpp:25</span><br><span class="line">7       breakpoint     keep y   0x0000000000400d6e in main() at test.cpp:28</span><br><span class="line">8       breakpoint     keep y   0x0000000000400d7d in main() at test.cpp:30</span><br><span class="line"></span><br><span class="line"># 设置 第5,6,7,8个 断点无效</span><br><span class="line">(gdb) dis 5-8</span><br><span class="line"></span><br><span class="line"># 查看断点信息</span><br><span class="line">(gdb) i b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       breakpoint     keep n   0x0000000000400cce in main() at test.cpp:14</span><br><span class="line">4       breakpoint     keep n   0x0000000000400cdd in main() at test.cpp:16</span><br><span class="line">5       breakpoint     keep n   0x0000000000400d46 in main() at test.cpp:23</span><br><span class="line">6       breakpoint     keep n   0x0000000000400d4e in main() at test.cpp:25</span><br><span class="line">7       breakpoint     keep n   0x0000000000400d6e in main() at test.cpp:28</span><br><span class="line">8       breakpoint     keep n   0x0000000000400d7d in main() at test.cpp:30</span><br></pre></td></tr></table></figure>

<p>让无效的断点生效：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">enable</span> == ena</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置某一个或者某几个断点有效</span></span><br><span class="line">(gdb) ena 断点1的编号 [断点2的编号 ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置某个区间断点有效</span></span><br><span class="line">(gdb) ena 断点1编号-断点n编号</span><br></pre></td></tr></table></figure>



<h3 id="6-调试命令"><a href="#6-调试命令" class="headerlink" title=".6 调试命令"></a>.6 调试命令</h3><p>如果调试的程序被断点阻塞了又想让程序继续执行，这时候就可以使用 <code>continue</code> 命令。程序会继续运行，直到遇到下一个有效的断点。&#96;&#96;continue<code>可以缩写为</code>c&#96;。</p>
<p>在 gdb 调试的时候如果需要打印变量的值， 使用的命令是 <code>print</code>, 可缩写为 <code>p</code>。如果打印的变量是整数还可以指定输出的整数的格式，格式化输出的整数对应的字符表如下：</p>
<p>![9BDD57D6-6D87-4080-B269-951C45DEC259](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;9BDD57D6-6D87-4080-B269-951C45DEC259.png)</p>
<p><code>printf</code> 的语法格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">print</span> == p</span></span><br><span class="line">(gdb) p 变量名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果变量是一个整形, 默认对应的值是以10进制格式输出, 其他格式请参考上表</span></span><br><span class="line">(gdb) p/fmt 变量名</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例</span></span><br><span class="line">(gdb) p i       # 10进制</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">5 = 3</span></span><br><span class="line">(gdb) p/x i     # 16进制</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">6 = 0x3</span></span><br><span class="line">(gdb) p/o i     # 8进制</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">7 = 03</span></span><br></pre></td></tr></table></figure>

<p>如果在调试过程中需要查看某个变量的类型，可以使用命令 <code>ptype</code>, 语法格式如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法格式</span></span><br><span class="line">(gdb) ptype 变量名</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印变量类型</span></span><br><span class="line">(gdb) ptype i</span><br><span class="line">type = int</span><br><span class="line">(gdb) ptype array[i]</span><br><span class="line">type = int</span><br><span class="line">(gdb) ptype array</span><br><span class="line">type = int [12]</span><br></pre></td></tr></table></figure>

<hr>
<p>单步调试</p>
<p><code>step</code> 命令可以缩写为 <code>s</code>, 命令被执行一次代码被向下执行一行，如果这一行是一个函数调用，那么程序会进入到函数体内部。</p>
<p>如果通过 <code>s</code> 单步调试进入到函数内部，<strong>想要跳出这个函数体， 可以执行 <code>finish</code> 命令。如果想要跳出函数体必须要保证函数体内不能有有效断点，否则无法跳出。</strong></p>
<p><code>next</code> 命令和 <code>step</code> 命令功能是相似的，只是在使用 <code>next</code> 调试程序的时候不会进入到函数体内部，<code>next</code> 可以缩写为 <code>n</code></p>
<p>通过 <code>until</code> 命令可以直接跳出某个循环体，这样就能提高调试效率了。如果想直接从循环体中跳出，必须要满足以下的条件，否则命令不会生效：</p>
<h2 id="0x-e5-结构体字节对齐规则"><a href="#0x-e5-结构体字节对齐规则" class="headerlink" title="0x e5 结构体字节对齐规则"></a>0x e5 结构体字节对齐规则</h2><p>结构体的大小绝大部分情况下不会直接等于各个成员大小的总和，编译器为了优化对结构体成员的访问总会在结构体中插入一些空白字节，有如下结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">align_basic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么此时<code>sizeof(align_basic)</code>的值会是<code>sizeof(char)+sizeof(int)+sizeof(double)</code>的值么？</p>
<p><img src="https://pic3.zhimg.com/80/v2-dca7f4f607fdbc884079e30c10ceb7ae_1440w.png" alt="img"></p>
<p>如上图经过测试我们发现其大小为16个字节并不等于1+4+8&#x3D;13个字节，可知编译器给align_basic结构体插入了另外3个字节，接下来我们将分析编译器对齐字节的规则以及结构体在内存中的结构，首先感谢<a href="https://link.zhihu.com/?target=http://blog.csdn.net/liukun321/article/details/6974282">结构体在内存中的对齐规则 - 咕唧咕唧shubo.lk的专栏 - 博客频道 - CSDN.NET</a>这篇文章的作者，在此之前我对内存对齐也是一知半解，很多时候也解释不明白。</p>
<p>&#x3D;&#x3D;规则一：结构体中元素按照定义顺序依次置于内存中，但并不是紧密排列。从结构体首地址开始依次将元素放入内存时，元素会被放置在其自身对齐大小的整数倍地址上。&#x3D;&#x3D;这里说的地址是元素在结构体中的偏移量，结构体首地址偏移量为0。</p>
<p>在align_basic中元素c是第一个元素，那么它的地址为0，第二个元素i不会被放在地址1处，int的对齐大小为4个字节，此时虽然元素c只占据一个字节，但是由于i的地址必须在4字节的整数倍上，所以地址必须再向后在移动三个字节，故而需要放在地址4上，此时前两个元素已经占据了8个字节的空间，第三个元素d会被直接放在地址8上，因为double的对齐大小为8个字节，而前面两个元素已经占据了8个字节，正好是double对齐大小的整数倍，所以元素d不需要再往后移动。说了这么多也不如让机器给我们验证下有说服力：</p>
<p><code>printf(&quot;%d %d %d %d\n&quot;, sizeof(align_basic), &amp;align_basic::c, &amp;align_basic::i, &amp;align_basic::d);</code></p>
<p><img src="https://pic3.zhimg.com/80/v2-d729bea11322919cc59e03e03d3e221a_1440w.png" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-25407fa9c8f77c2f3d17a12546793a0d_1440w.png" alt="img"></p>
<p>那么这样就够了吗，会不会太简单？我们把元素i和d的位置交换下，此时结构体的大小会是20吗，我们仍然先让机器说话，(⊙o⊙)…毕竟后面打脸有证据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">align_basic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">double</span> d;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(align_basic));</span><br></pre></td></tr></table></figure>

<p><img src="https://pic4.zhimg.com/80/v2-cbfea1a547f205a2d4b2306748da3953_1440w.png" alt="img"></p>
<p>我们发现此时结构体的大小并不是20而是24，那么多出来的这4个字节如何解释？我们引出第二条规则。</p>
<p>&#x3D;&#x3D;规则二：如果结构体大小不是所有元素中最大对齐大小的整数倍，则结构体对齐到最大元素对齐大小的整数倍，填充空间放置到结构体末尾。&#x3D;&#x3D;</p>
<p>运用规则一，此时c仍然是第一个元素，其地址为0，第二个元素地址为8， 第三个元素地址为16，然后运用规则二，c，d，i中d的对齐大小为8最大所以整个结构必须对齐到8的整数倍，前面是三个元素已经占据了20个字节的空间，只需要在结构体的尾部填充4个字节的空间就是8的倍数了，所以此时整个结构体的大小为24个字节。</p>
<p><code>printf(&quot;%d %d %d %d\n&quot;, sizeof(align_basic), &amp;align_basic::c, &amp;align_basic::d, &amp;align_basic::i);</code></p>
<p><img src="https://pic3.zhimg.com/80/v2-c66b0aa643b60eecb9dbf06916c56482_1440w.png" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-0294208ed70bb94feb9868310a191eb3_1440w.png" alt="img"></p>
<p>&#x3D;&#x3D;规则三：基本数据类型的对齐大小为其自身的大小，结构体数据类型的对齐大小为其元素中最大对齐大小元素的对齐大小。&#x3D;&#x3D; 规则三可以由规则二推导出来。</p>
<p>char类型的对齐大小为1字节，short类型的对齐大小为2字节，int类型的大小为4字节，double的对齐大小为8字节，align_basic结构体中最大对齐大小元素为d是double类型，所以align_basic的对齐大小是8。有人会问如果结构体中有数组呢？很简单将数组看做是连续数个相同类型的元素即可。</p>
<h2 id="0x-e6-第一章小结"><a href="#0x-e6-第一章小结" class="headerlink" title="0x e6 第一章小结"></a>0x e6 第一章小结</h2><p>深入理解计算机系统的“系统”，并不是操作系统，这个系统包括了硬件，操作系统，网络，编译等等</p>
<p>学习计算机系统应该具备的三个<strong>抽象能力</strong>：问题抽象，系统抽象（csapp），数据抽象</p>
<p>计算机系统是由硬件和<strong>系统软件</strong>组成的。</p>
<p>数字的机器表示方法是对真值的<strong>有限近似值</strong>。</p>
<p>指令的执行：</p>
<ol>
<li>从磁盘读取指令和数据到内存</li>
<li>从内存送到cpu中去执行</li>
<li>将返回的数据送到屏幕</li>
</ol>
<h2 id="0x-e7-bomb-lab"><a href="#0x-e7-bomb-lab" class="headerlink" title="0x e7 bomb lab"></a>0x e7 bomb lab</h2><h3 id="1-phase1"><a href="#1-phase1" class="headerlink" title=".1 phase1"></a>.1 phase1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">disas main，可以发现我们输入的字符串赋值给了 $rdi</span><br><span class="line">并且之后调用了函数&lt;phase_1&gt;</span><br><span class="line">disas phase_1</span><br><span class="line">发现没有修改寄存器 $rdi 的值</span><br><span class="line">然后把一个立即数 0x402400 传给了寄存器 $esi</span><br><span class="line">之后调用函数 &lt;strings_not_euqal&gt;</span><br><span class="line">在之后test $eax $eax</span><br><span class="line">如果 je，即 $eax = 0</span><br><span class="line">调用函数 &lt;eoplode_bomb&gt;，炸弹爆炸</span><br><span class="line">否则正常返回</span><br><span class="line"></span><br><span class="line">进入函数 &lt;strings_not_equal&gt;</span><br><span class="line">该函数又会调用 &lt;string_length&gt; 函数</span><br><span class="line">这个函数会计算 $rdi 内字符串的长度</span><br><span class="line"></span><br><span class="line">p/x $rdx :以x(16进制)方式打印寄存器$rdx的值</span><br><span class="line">x $rdx 检查(examine) $rdx内存中的值</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/36809923">watch &#x3D; sepcial break</a></p>
<h3 id="2-phase2"><a href="#2-phase2" class="headerlink" title=".2 phase2"></a>.2 phase2</h3><h3 id="3-phase3"><a href="#3-phase3" class="headerlink" title=".3 phase3"></a>.3 phase3</h3><p>![78E9B95E-D7EC-4E49-8A30-94EF4B0A4D48](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;78E9B95E-D7EC-4E49-8A30-94EF4B0A4D48.png)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># phase_3</span><br><span class="line"><span class="title function_">if</span><span class="params">(eax &gt; <span class="number">1</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">7</span> &lt; rsp + <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        eax = rsp + <span class="number">0x8</span>; <span class="comment">// first input</span></span><br><span class="line">        <span class="keyword">switch</span>(eax)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">                eax = <span class="number">0xcf</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                eax = <span class="number">0x137</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                eax = <span class="number">0x2c3</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                eax = <span class="number">0x100</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                eax = <span class="number">0x185</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                eax = <span class="number">0xce</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                eax = <span class="number">0x2aa</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">        &#125;</span><br><span class="line">        	<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        		eax = <span class="number">0x147</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;       		</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BOOM!!!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有多组答案：注意第二个参数不能输入十六进制数，只能输入10进制数，因为这里的数据的读如是采用sscanf，把我们的输入作为str,如果我们的第二个参数是个十六进制数，那么一定以0x开头，结果0会被读取到第二个参数，读到x不合法就结束了。</p>
<table>
<thead>
<tr>
<th>第一个参数</th>
<th>第二个参数</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>207</td>
</tr>
<tr>
<td>1</td>
<td>311</td>
</tr>
<tr>
<td>2</td>
<td>707</td>
</tr>
<tr>
<td>3</td>
<td>256</td>
</tr>
<tr>
<td>4</td>
<td>389</td>
</tr>
<tr>
<td>5</td>
<td>206</td>
</tr>
<tr>
<td>6</td>
<td>682</td>
</tr>
<tr>
<td>7</td>
<td>327</td>
</tr>
</tbody></table>
<h3 id="4-phase4"><a href="#4-phase4" class="headerlink" title=".4 phase4"></a>.4 phase4</h3><p>第一个参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.func4:</span><br><span class="line">eax = edx</span><br><span class="line">eax -= edx</span><br><span class="line">ecx = eax</span><br><span class="line">ecx &gt;&gt;= <span class="number">0x1f</span> <span class="comment">// unsigned</span></span><br><span class="line">eax += ecx</span><br><span class="line">eax &gt;&gt;= <span class="number">1</span></span><br><span class="line">ecx = &amp;(rax+rso+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span>(ecx &lt;= edi)  </span><br><span class="line">&#123;</span><br><span class="line">    eax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(exc &gt;= edi)  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 只有当 ecx&lt;=edi&lt;=ecx，即edi=ecx=7时可以正常退出并返回0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        。。。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    edx = &amp;(rcx - <span class="number">1</span>)</span><br><span class="line">    call func4</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// goal: make eax = 0</span></span><br></pre></td></tr></table></figure>



<p>第二个参数看phrase4的汇编很容易得出为0</p>
<h3 id="5-phase5"><a href="#5-phase5" class="headerlink" title=".5 phase5"></a>.5 phase5</h3><p><a target="_blank" rel="noopener" href="https://github.com/wuxueqian14/csapp-lab/tree/master/Bomb%20Lab">reference</a></p>
<h3 id="6-phase6"><a href="#6-phase6" class="headerlink" title=".6 phase6"></a>.6 phase6</h3><p>不想做了</p>
<h3 id="7-phase7"><a href="#7-phase7" class="headerlink" title=".7 phase7"></a>.7 phase7</h3><p>no</p>
<h3 id="8-answer-2016"><a href="#8-answer-2016" class="headerlink" title=".8 answer(2016)"></a>.8 answer(2016)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">7 327</span><br><span class="line">7 0</span><br><span class="line">)/.%&amp;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="0x-09-Assembly实验"><a href="#0x-09-Assembly实验" class="headerlink" title="0x 09 Assembly实验"></a>0x 09 Assembly实验</h2><p><img src="/Users/epoch/Library/Containers/com.tencent.qq/Data/Library/Caches/Images/BE9A5FC6EBB55797FF78C5D5105D31DF.png" alt="BE9A5FC6EBB55797FF78C5D5105D31DF"></p>
<p>如上图，我们用(gdb) x mingling打印 0x7fffffffe3b0附近的值，这个地址是个虚拟地址，它在内存中的值为0x0</p>
<p>栈指针是会浮动的！但是rsp和rbp的差值应该是不变的。</p>
<p>gdb(ni) ：会跳出函数执行</p>
<p>gdb(si)：会进入函数执行</p>
<p>![A44D5C36-2816-49B3-9E01-23E15BC5DA72](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;A44D5C36-2816-49B3-9E01-23E15BC5DA72.png)</p>
<p>小端存储的又一个例子啊，我们把寄存器 %rbp(0x7fffffffe3d0) 放入 %rsp，观察可以发现，0x00007ffff倍放在了后面的地址，而0xffffe3d0被放在了前面的地址。x命令打印的地址从左到右，从上到下是以4为单位递增的，</p>
<h2 id="0x-0a-ld-preload环境变量劫持函数"><a href="#0x-0a-ld-preload环境变量劫持函数" class="headerlink" title="0x 0a ld_preload环境变量劫持函数"></a>0x 0a ld_preload环境变量劫持函数</h2><p>首先在目录下创建两个文件 main.c 和 txt</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> <span class="comment">// main.c</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE *fd = fopen(<span class="string">&quot;txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;*** open file error!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;open file success!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常来说最后程序会正确执行</p>
<p>但如果我们更改动态链接库</p>
<p>先创建一个trik动态链接库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">// trik.c</span></span></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*** Always open error!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC trik.c -o trik.so</span><br><span class="line">LD_PRELOAD=$PWD/trik.so ./a.out</span><br></pre></td></tr></table></figure>

<p>最后文件会打开失败</p>
<p>![53DE4182-359A-4F3E-80BB-4B97508E7F9B](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;53DE4182-359A-4F3E-80BB-4B97508E7F9B.png)</p>
<p>原理就是通过自己写的库函数劫持系统的库函数，使得程序执行我们的库函数。</p>
<h2 id="0x-0b-attack-lab"><a href="#0x-0b-attack-lab" class="headerlink" title="0x 0b attack lab"></a>0x 0b attack lab</h2><h2 id="0x0c-链接-points"><a href="#0x0c-链接-points" class="headerlink" title="0x0c 链接 points"></a>0x0c 链接 points</h2><p>1.引入哑节点dummy</p>
<p>2.引入数据结构–elf</p>
<p>3.静态链接的过程：elf定位到符号-&gt;符号解析-&gt;重定位</p>
<p>4.*.o, elf 都是二进制文件</p>
<p>5.unix下大部分工具都在&#x2F;usr&#x2F;bin或者&#x2F;bin目录下的。使用hexdump可以查看二进制文件</p>
<p>6.第一个section的name为空（其实叫做 undefine section），且数据全为0，里面存放的内容是undefine的数据。</p>
<p>7.将函数定义为一个弱符号：<code>attribute__((weak)) int add*() &#123;&#125;</code> ,这里的 <code>add</code> 函数被定义为一个弱符号，它可以被强符号函数 <code>add</code> 覆盖。</p>
<p>8.对于 <code>C Language</code> 来说，出现 <code>Warning</code> 说明你的语句有<strong>歧义</strong> ，但是 C 语言为你选择了一种结果，注意这种结果可能与你的本意不同！</p>
<p>9.对于初始化为 <code>0</code> 的全局变量和静态变量，也被划分到 <code>.bss</code>，这是因为全局变量和静态变量默认初始化就是 <code>0</code>。</p>
<p>10.为什么在可重定位目标文件中有 <code>COMMON</code>，在可执行目标文件中就没有 <code>COMMON</code> 了呢。</p>
<blockquote>
<p> 回想一下<code>COMMON</code>的定义，对于未初始化的全局变量， 属于<code>COMMON</code>。</p>
<p>对于未初始化的全局变量， 在链接之后它有三种可能的情况（假设这里有两个文件 <code>s1.c</code>, <code>s2.c</code>，在 <code>s1.c</code> 中定义有未初始化的全局变量 <code>g</code>）</p>
<ol>
<li><p>如果在 <code>s2.c</code> 中也定义了一个全局变量 <code>g</code> 并且初始化为 <code>0</code>，则 <code>g</code> 属于 <code>.bss</code> 节</p>
</li>
<li><p>如果初始化不是 <code>0</code>，就属于 <code>.data</code></p>
</li>
<li><p>如果 <code>s2.c</code> 没有定义 <code>g</code> ，那么 s2 就属于 <code>.bss</code></p>
<p>因为有如上三种（合法）情况，所以把它划分到 <code>COMMON</code>，而之所以在可执行目标文件中没有了 <code>COMMON</code> ,是因为此时已经链接完了，<code>g</code> 属于那个节已经很明确了，因此也就不需要了。</p>
</li>
</ol>
</blockquote>
<ol start="11">
<li></li>
</ol>
<h2 id="0x0d-修改-ROF-信息的实验"><a href="#0x0d-修改-ROF-信息的实验" class="headerlink" title="0x0d 修改 ROF 信息的实验"></a>0x0d 修改 ROF 信息的实验</h2><p>首先编译源文件 <code>add.c</code> 生成可重定位目标文件 <code>add.o</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> addcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	addcnt ++ ;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用 <code>hexdump -S add.o</code> 查看 <code>Section Headers</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000003c  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000228</span><br><span class="line">       0000000000000060  0000000000000018   I       9     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  0000007c</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  0000007c</span><br><span class="line">       0000000000000004  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .comment          PROGBITS         0000000000000000  0000007c</span><br><span class="line">       0000000000000027  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  000000a3</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .eh_frame         PROGBITS         0000000000000000  000000a8</span><br><span class="line">       0000000000000030  0000000000000000   A       0     0     8</span><br><span class="line">  [ 8] .rela.eh_frame    RELA             0000000000000000  00000288</span><br><span class="line">       0000000000000018  0000000000000018   I       9     7     8</span><br><span class="line">  [ 9] .symtab           SYMTAB           0000000000000000  000000d8</span><br><span class="line">       0000000000000138  0000000000000018          10    11     8</span><br><span class="line">  [10] .strtab           STRTAB           0000000000000000  00000210</span><br><span class="line">       0000000000000018  0000000000000000           0     0     1</span><br><span class="line">  [11] .shstrtab         STRTAB           0000000000000000  000002a0</span><br><span class="line">       0000000000000059  0000000000000000           0     0     1</span><br></pre></td></tr></table></figure>

<p>可以发现下标为 <code>1</code> 的节是 <code>.text</code> 节</p>
<p>我们现在要修改 <code>add.o</code> 使其显示为 <code>.ext</code> 节</p>
<p>首先需要下载 <code>hexedit</code></p>
<p>然后拷贝一份 <code>add.o</code> 的副本 <code>badadd.o</code></p>
<p>（不在源文件上直接修改是个好习惯）</p>
<p>然后执行命令<code>hexdump -c badadd.o</code> 找到 <code>.text</code> 的位置。</p>
<p>通过 <code>elf header</code> 中的信息可以得到 <code>Section header table</code> 的 <code>offset</code> 为 <code>0x300</code>，其中每个条目(<code>entry</code>) 的 <code>size</code> 为 <code>0x40</code> ，由此可以得到第二个条目（下标为1）的 <code>.text</code> 节的位置为 <code>0x340</code>，并通过 <code>struct elf64_shdr</code> 得到前 <code>4</code> 个字节为 <code>name</code>。</p>
<p><code>00000340  20 00 00 00 01 00 00 00  06 00 00 00 00 00 00 00  | ...............|</code></p>
<p><code>name = 0x00000020</code> ,我们只需要修改其为 <code>0x00000022</code>，就可以实现 <code>name</code> 往后偏移两个字节</p>
<p>这样 <code>name</code> 就从 &#96;&#96;.text<code>变成了</code>ext&#96;</p>
<p>执行命令：<code>hexedit badadd.o</code> 找到位置并修改即可。</p>
<p>按 <code>F10</code> 退出</p>
<p>最后结果如下：</p>
<p><code>readelf -S badadd.o</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] ext               PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000003c  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000228</span><br><span class="line">       0000000000000060  0000000000000018   I       9     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  0000007c</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  0000007c</span><br><span class="line">       0000000000000004  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .comment          PROGBITS         0000000000000000  0000007c</span><br><span class="line">       0000000000000027  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  000000a3</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .eh_frame         PROGBITS         0000000000000000  000000a8</span><br><span class="line">       0000000000000030  0000000000000000   A       0     0     8</span><br><span class="line">  [ 8] .rela.eh_frame    RELA             0000000000000000  00000288</span><br><span class="line">       0000000000000018  0000000000000018   I       9     7     8</span><br><span class="line">  [ 9] .symtab           SYMTAB           0000000000000000  000000d8</span><br><span class="line">       0000000000000138  0000000000000018          10    11     8</span><br><span class="line">  [10] .strtab           STRTAB           0000000000000000  00000210</span><br><span class="line">       0000000000000018  0000000000000000           0     0     1</span><br><span class="line">  [11] .shstrtab         STRTAB           0000000000000000  000002a0</span><br><span class="line">       0000000000000059  0000000000000000           0     0     1</span><br></pre></td></tr></table></figure>







<h2 id="0x0e-vim-tabe"><a href="#0x0e-vim-tabe" class="headerlink" title="0x0e vim tabe"></a>0x0e vim tabe</h2><p>vim中的分页命令，多窗口vim</p>
<p>通过<code>help tab-page-intro</code>命令，可以获得关于标签页使用的更多信息。</p>
<table>
<thead>
<tr>
<th><code>:tabnew</code></th>
<th align="left">新建标签页</th>
</tr>
</thead>
<tbody><tr>
<td><code>:tabs</code></td>
<td align="left">显示已打开标签页的列表</td>
</tr>
<tr>
<td><code>:tabc</code></td>
<td align="left">关闭当前标签页</td>
</tr>
<tr>
<td><code>:tabe &lt;filename&gt;</code></td>
<td align="left">打开新文件(tabedit)</td>
</tr>
<tr>
<td><code>:tabp</code></td>
<td align="left">移动到上一个标签页</td>
</tr>
<tr>
<td><code>:tabn</code></td>
<td align="left">移动到下一个标签页(tabnext)</td>
</tr>
<tr>
<td><code>:gt</code></td>
<td align="left">移动到下一个标签页</td>
</tr>
<tr>
<td><code>:tabr</code></td>
<td align="left">移动到第一个标签页(tabrewind,tabfirst)</td>
</tr>
<tr>
<td><code>:tabl</code></td>
<td align="left">移动到最后一个标签页(tablast)</td>
</tr>
<tr>
<td><code>$vim -p &lt;f1&gt; &lt;f2&gt; &lt;f3&gt;</code></td>
<td align="left">vim开启多个标签页</td>
</tr>
</tbody></table>
<h2 id="0x0f-bilbili-链接"><a href="#0x0f-bilbili-链接" class="headerlink" title="0x0f bilbili 链接"></a>0x0f bilbili 链接</h2><p>链接步骤：</p>
<blockquote>
<ol>
<li>parse text</li>
<li>symbol parse</li>
<li>Relocation</li>
</ol>
<p>2 和 3 都依赖于 1 的 text</p>
</blockquote>
<h1 id="Csapp-Link"><a href="#Csapp-Link" class="headerlink" title="Csapp Link"></a>Csapp Link</h1><h2 id="English"><a href="#English" class="headerlink" title="::English"></a>::English</h2><p>separate compliation：分离编译</p>
<p>mangling：重整</p>
<h2 id="Tool"><a href="#Tool" class="headerlink" title=":: Tool"></a>:: Tool</h2><p>GNU READELF：查看目标文件内容的很方便的工具。</p>
<h2 id="0x00-introduce"><a href="#0x00-introduce" class="headerlink" title="0x00 introduce"></a>0x00 introduce</h2><h3 id="1-链接的执行阶段"><a href="#1-链接的执行阶段" class="headerlink" title="1. 链接的执行阶段"></a>1. 链接的执行阶段</h3><ol>
<li>compile time</li>
<li>load time</li>
<li>run time</li>
</ol>
<h3 id="2-why-learn-link"><a href="#2-why-learn-link" class="headerlink" title="2. why learn link"></a>2. <strong>why</strong> learn link</h3><ol>
<li>理解链接器将帮助你构造大型程序</li>
<li>理解链接器将帮助你避免一些危险的编程错误。</li>
<li>理解链接器将帮助你理解语言的作用域规则是如何实现的。</li>
<li>理解链接将帮助你理解其他重要的系统概念。（加载和运行程序，虚拟内存，分页，内存映射）</li>
<li>理解链接将使你能够利用共享库。</li>
</ol>
<h2 id="0x01-compiler-driver"><a href="#0x01-compiler-driver" class="headerlink" title="0x01 compiler driver"></a>0x01 compiler driver</h2><p>compiler dirver：编译器驱动程序</p>
<p>它代表用户在需要的时候调用：</p>
<ol>
<li>cpp</li>
<li>cc1</li>
<li>as</li>
<li>ld</li>
</ol>
<p>可以使用 -v 选项查看这个过程</p>
<p>当我们在 Linux 命令行输入：<code>./proc</code></p>
<p>shell 调用操作系统中一个叫做<strong>加载器</strong>的函数，它将可执行文件 proc 中的代码和数据复制到内存，然后将控制转移到这个程序的开头。</p>
<h2 id="0x02-static-link"><a href="#0x02-static-link" class="headerlink" title="0x02 static link"></a>0x02 static link</h2><p>Relocaable object file: 由各种不同的代码和数据节（section）组成，每一节都是一个连续的字节序列。</p>
<p>为了构造 executable file，linker 必须完成两个主要任务：</p>
<ol>
<li>Symbol resolution（符号解析）：符号解析的目的是将每个符号引用正好和一个符号定义关联起来。</li>
<li>relocation（重定位）。</li>
</ol>
<p>Symbol（符号）：目标文件定义和引用符号，每个符号对应于一个函数，一个局部变量或一个静态变量（即C语言任何非 static 属性声明的变量）。</p>
<p>Compiler and Assembly generate code and data section start at address 0, linker connect every symbol define with one memory address, so can relocate those sections, and then modify all the symbol define, make them point the address. Linker use the detailed instructions of relocation entry(重定位条目) which generated by assembly to execute those relocation with no check.</p>
<h2 id="0x03-object-file"><a href="#0x03-object-file" class="headerlink" title="0x03 object file"></a>0x03 object file</h2><p>object file（目标文件） types:</p>
<ol>
<li>relocatable object file：在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li>
<li>executable object file</li>
<li>Share object file（共享目标文件）: 一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。</li>
</ol>
<p>Compiler and Assembly generate relocatable object file.  Linker generate executable  object file.</p>
<p>Technically talking, a object module(目标模块) is a byte sequence,  and a object file is a object module which storage in disk as a type of file.</p>
<p>目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。</p>
<ol>
<li>Unix: a.out</li>
<li>Windows: PE(Portable Executable)(可移植可执行)</li>
<li>MacOS-X: Mach-O </li>
<li>Modern x86-64 and Unix: ELF(Executable and Linkable Format)(可执行可链接格式)</li>
</ol>
<h2 id="0x04-relocatable-object-file"><a href="#0x04-relocatable-object-file" class="headerlink" title="0x04 relocatable object file"></a>0x04 relocatable object file</h2><p>典型的ELF可重定位目标文件</p>
<p><img src="https://s1.328888.xyz/2022/09/28/spfaF.png" alt="IMG"></p>
<p>ELF contains:   ELF header，Sections，Section header table(节头部表)。</p>
<p>(1) ELF header：</p>
<ol>
<li>以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的<strong>字的大小</strong>和<strong>字节顺序。</strong></li>
<li>剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包含：<ul>
<li>ELF 头的大小</li>
<li>目标文件的类型（可重定位、可执行或者共享）</li>
<li>机器类型（x86-64）</li>
<li>节头部表的文件偏移</li>
<li>节头部表中条目的大小和数量</li>
</ul>
</li>
</ol>
<p>(2) Section headere table: 不同 Section 的位置和大小是由节头部表描述的，其中目标文件中的每个节都有一个固定大小的条目（entry）。</p>
<p>(3) Section:</p>
<ol>
<li>.text：已编译程序的<strong>机器代码。</strong></li>
<li>.rodata：只读数据。</li>
<li>.data：已初始化的全局和静态 C 变量。（局部变量在栈中，既不出现在 .data中，也不出现在 .bss汇总）</li>
<li>.bss：未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量（默认初始化）。在目标文件中<strong>这个节不占用实际的空间，它仅仅是一个占位符。</strong> 目标文件中区分 .bss 和 .data 是为了<strong>空间效率</strong>：在目标文件中，未初始化变量不需要占用任何实际的磁盘空间。运行时，在内存中分配这些变量，初始化为0。</li>
<li>.symtab；符号表。存放在程序中<strong>引用</strong>和<strong>定义</strong>的函数和全局变量的信息。（不包含局部变量的条目）。</li>
<li>.rel.text：relocation。一个 .text 节总位置的列表。当 Linker 把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的<strong>指令</strong>都需要修改。</li>
<li>.rel.data：被模块定义或引用的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的值是一个全局变量地址或者外部定义的函数的<strong>地址</strong>，都需要被修改。</li>
<li>.debug：调试符号表。只有使用 -g 选项时才会得到这张表。</li>
<li>.line：原始 C 源程序中的行好和 .text 节 中机器指令之间的<strong>映射</strong>。只有使用 -g 选项时才会得到这张表。</li>
<li>.strtab：字符串表。其内容包含 .symbol 和 .debug节中的符号表，已经节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。</li>
</ol>
<p>为什么未初始化的数据成为  .bss</p>
<blockquote>
<p>起始于 IMB 704 汇编语言（大约在1957年） Block Storage Start(块存储开始)指令的首字母缩写。并沿用至今。</p>
<p>你可以这样理解并区分于 .data：Better Save Space（更好的节省空间）的缩写。</p>
</blockquote>
<h2 id="0x05-symbol-and-symbol-table"><a href="#0x05-symbol-and-symbol-table" class="headerlink" title="0x05 symbol and symbol table"></a>0x05 symbol and symbol table</h2><p>​			 	</p>
<p>每个 relocatable object module m 都有一个符号表，它包含 m 定义和引用的符号的信息。在 Linker 的上下文中，有三种不同的符号：</p>
<ol>
<li>m 定义的并且能被其他 module 引用的全局符号。</li>
<li>其他 module 定义并被模块 m 引用的全局符号，</li>
<li>只被 m 定义和引用的局部符号。</li>
</ol>
<p>符号表是由 Assembly 构造的，使用 Compiler 输出到汇编语言 .s 文件中的符号。</p>
<p>.symtab 节的内容是一个数组，数组的元素是一个符号条目：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="type">char</span> type: <span class="number">4</span>,</span><br><span class="line">    	binding: <span class="number">4</span>;</span><br><span class="line">    <span class="type">char</span> reserved;</span><br><span class="line">    <span class="type">short</span> section;</span><br><span class="line">    <span class="type">long</span> value;</span><br><span class="line">    <span class="type">long</span> size;</span><br><span class="line">&#125; Elf_64_Symbol;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>name：是字符串表中的字节串，指向符号的以 null 结尾的字符串名字。</p>
<p>section（base_address）：到节头部表的索引，指明被分配到那个节。</p>
<p>value（offset_address）：是符号的地址。对于可重定位的 module 来说，value 是距定义目标的节的其实地址的 offset。</p>
<p>size：是目标的大小（byte）。</p>
<p>type：data or function。</p>
<p>binding：static or global</p>
<p>有三个特殊的<strong>伪节</strong>，它们在节头部表中是没有条目的（只有可重定位目标模块才有）：</p>
<ol>
<li>ABS：不应该被重定位的符号。</li>
<li>UNDEF：未定义的符号，也就是在本目标模块中引用，但是在其它地方定义的符号。</li>
<li>COMMON：还未被分配位置的未初始化的数据目标。对于 common u符号，value 字段给出<strong>对其要求</strong>。</li>
</ol>
<p>common 和 .bss 的区别很细微，现代的 GCC 根据以下规则分配符号：</p>
<ol>
<li>Common: 未初始化的全局变量</li>
<li>.bss：未初始化的静态变量，及其初始化为0的全局变量和静态变量</li>
</ol>
</blockquote>
<h2 id="0x06-symbol-parse"><a href="#0x06-symbol-parse" class="headerlink" title="0x06 symbol parse"></a>0x06 symbol parse</h2><h3 id="1-链接器解析符号引用的方法"><a href="#1-链接器解析符号引用的方法" class="headerlink" title="1.链接器解析符号引用的方法"></a>1.链接器解析符号引用的方法</h3><p>链接器解析符号引用的方法是将每个引用于它输入的可重定位目标文件的符号表的一个确定的符号定义关联起来。</p>
<p>对那些和引用定义在相同模块中的局部符号的引用，符号解析是非常简单明了的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保他们拥有唯一的名字。</p>
<p>不过，对全局符号的引用解析就棘手的多。当编译器遇到一个不是在当前模块中定义的符号（变量或者函数名）时，会假设该符号是在其它某个模块中定义的，升成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条（通常很难阅读的）错误信息并终止。</p>
<h3 id="2-c-和-java-中的重整和恢复"><a href="#2-c-和-java-中的重整和恢复" class="headerlink" title="2.c++ 和 java 中的重整和恢复"></a>2.c++ 和 java 中的<strong>重整</strong>和<strong>恢复</strong></h3><p>C++ 和 Java 都允许重载方法，这些方法在源代码中有相同名字，却有着不同的参数列表。那么链接器是如何区别这些不同的重载函数之间的差异呢？</p>
<p>因此编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。这种编码过程叫做重整（mangling），而相反的过程叫做恢复（demangling）。</p>
<p>幸运的事，C++ 和 Java使用兼容的重整策略。一个被重整的类名字是由名字中字符的整数数量，后面跟上原始名字组成的。例如：类 Foo 被编码成 3Foo。方法被编码为原始方法名，后面加上‘__’（下划线），加上被重整的雷鸣，再加上每个参数的单字母编码。比如：Foo::bar(int, long) 被编码为 bar_3fooil。</p>
<p>重整全局变量和模版名字的策略是相似的。</p>
<p>例如 C++程序 ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> sum1, sum2;</span><br><span class="line">	sum1 = <span class="built_in">get</span>(a, b, c);</span><br><span class="line">	sum2 = <span class="built_in">get</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum1: &quot;</span> &lt;&lt; sum1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum2: &quot;</span> &lt;&lt; sum2 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<p><code>readelf mangling.o --syms</code></p>
<p>得到如下符号表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Symbol table &#x27;.symtab&#x27; contains 30 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS mangling.cpp</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text</span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 .data</span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 .bss</span><br><span class="line">     5: 0000000000000000     1 OBJECT  LOCAL  DEFAULT    4 _ZStL8__ioinit</span><br><span class="line">     6: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    4 $d</span><br><span class="line">     7: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    1 $x</span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 .rodata</span><br><span class="line">     9: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    5 $d</span><br><span class="line">    10: 00000000000000fc    96 FUNC    LOCAL  DEFAULT    1 _Z41__static_ini[...]</span><br><span class="line">    11: 000000000000015c    28 FUNC    LOCAL  DEFAULT    1 _GLOBAL__sub_I__[...]</span><br><span class="line">    12: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 .init_array</span><br><span class="line">    13: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    6 $d</span><br><span class="line">    14: 0000000000000000     0 SECTION LOCAL  DEFAULT    9 .note.GNU-stack</span><br><span class="line">    15: 0000000000000014     0 NOTYPE  LOCAL  DEFAULT   10 $d</span><br><span class="line">    16: 0000000000000000     0 SECTION LOCAL  DEFAULT   10 .eh_frame</span><br><span class="line">    17: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 .comment</span><br><span class="line">    18: 0000000000000000    32 FUNC    GLOBAL DEFAULT    1 _Z3getii</span><br><span class="line">    19: 0000000000000020    44 FUNC    GLOBAL DEFAULT    1 _Z3getiii</span><br><span class="line">    20: 000000000000004c   176 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    21: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZSt4cout</span><br><span class="line">    22: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZStlsISt11char_[...]</span><br><span class="line">    23: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSolsEi</span><br><span class="line">    24: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZSt4endlIcSt11c[...]</span><br><span class="line">    25: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSolsEPFRSoS_E</span><br><span class="line">    26: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSt8ios_base4I[...]</span><br><span class="line">    27: 0000000000000000     0 NOTYPE  GLOBAL HIDDEN   UND __dso_handle</span><br><span class="line">    28: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSt8ios_base4I[...]</span><br><span class="line">    29: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND __cxa_atexit</span><br></pre></td></tr></table></figure>

<p>可以观察到，两个 get 函数分别被标识为：<code>_Z3getii</code> 和 <code>_Z3getiii</code></p>
<h3 id="3-Linux-处理多重定义的符号"><a href="#3-Linux-处理多重定义的符号" class="headerlink" title="3. Linux 处理多重定义的符号"></a>3. Linux 处理多重定义的符号</h3><p>强符号：函数和已初始化的全局变量</p>
<p>弱符号：未初始化的全局变量</p>
<p>Linux 处理多重定义的符号名的三个规则：</p>
<ol>
<li>不允许多个同名的强符号。</li>
<li>如果有一个强符号和多个弱符号同名，选择强符号。</li>
<li>如果有多个弱符号同名，任意选择一个。</li>
</ol>
<h3 id="4-静态库"><a href="#4-静态库" class="headerlink" title="4. 静态库"></a>4. 静态库</h3><h4 id="4-1-为什么要引入静态库？"><a href="#4-1-为什么要引入静态库？" class="headerlink" title="4.1 为什么要引入静态库？"></a>4.1 为什么要引入静态库？</h4><p>如果不引入静态库的话，试想一下编译器开发人员会使用什么方法来向用户提供这些函数。</p>
<blockquote>
<p>编译器代劳！</p>
</blockquote>
<p>一种方法是让编译器辨认出对标准函数的调用，并直接生成相应的代码。对于那些提供了一小部分标准函数的语言（例如 Pascal）是可以的，但是对于 C 这种标准定义了大量的标准函数是不可以的。因为每次添加、修改或删除一个标准库函数时，就需要一个新的编译器版本。然而，对于应用程序猿而言，这种方法是非常方便的，因为标准函数将总是可用（只需要你编译器开发人员搞定就行了，管我什么事 - -</p>
<blockquote>
<p>所有函数对应一个可重定位目标模块！</p>
</blockquote>
<p>另一种方法是将所有的 C 函数都放在一个单独的可重定位目标模块中（比如说 libc.a），应用程序猿可以把这个模块连接到他们的可执行文件中：</p>
<p><code>gcc main.c /usr/lib/libc.o</code></p>
<p>IOS C99 定义的 C库：libc.a; 数学函数库：libm.a</p>
<p>通过把函数放在目标模块中，可以把编译器的实现与标准函数的实现分离开来。但是，现在每个可执行文件都包含着一份标准函数集合的副本（除非你不链接它，但这怎么可能呢？），这是对<strong>磁盘的极度浪费</strong>！在一个典型的系统中，libc.a 大约是 5MB，llib.a 大约是 2MB）。另外，每个运行的程序都将它的这些函数的副本放在内存中，这是<strong>对内存的极大浪费</strong>。此外，只要标准库修改了一个小小的地方，无论多么小，你都要重新编译整个源文件，非常<strong>耗时</strong>。</p>
<blockquote>
<p>每个函数对应一个可重定位目标模块！</p>
</blockquote>
<p>我们可以通过为每个库函数创建一个独立的可重定位模块，把他们放在一个为大家都知道的目录中来解决其中的一些问题。然而，问题也是相当明显的：</p>
<ol>
<li>那你要手写多少模块啊？</li>
<li>太多了不小心写错名字了怎么办？从头再检查一遍吧！</li>
<li>太多了，你得写到什么时候？</li>
<li>。。。</li>
<li>真是一个麻烦又耗时又糟心的过程！</li>
</ol>
<p><code> gcc main.c /usr/lib/printf.o /usr/lib/scanf.o ........</code></p>
<blockquote>
<p>静态库！</p>
</blockquote>
<p>于是，为了解决这些问题，静态库诞生了！！！</p>
<p>我们可以结合上面的方法，既不把所有函数划分到一个模块，也不每个函数对应一个模块，而是把一些相关的函数划分到一个模块（例如 C 标准库和数学库等），然后封装成一个单独的静态库文件。而不是每个函数对应一个模块。</p>
<p><code>gcc main.c /usr/lib/libc.a /usr/lib/libm.a .. </code></p>
<p>你可能会问：这个静态库和前面把所有函数放在一个可重定位目标模块有什么区别吗？不就是一个叫（模块 .o)，一个叫静态库（.a）罢了！</p>
<p>那我可就得给你好好讲讲了：当所有函数封装在一个模块中，那我们链接的时候，就不得不链接所有库函数了。</p>
<p>但是！接下来好好听了！</p>
<p>如果说模块是函数的集合，那么静态库就是模块的集合！所以，你可能想到了，虽然我们链接到了静态库，但并不链接静态库中的所有模块，而是只链接需要用到的模块，这样既避免了类似于一个函数一个模块那样链接模块太多的问题，又避免了链接所有模块的问题。</p>
<p>你可能会问：这怎么实现呢？</p>
<p>答案是：暴力出奇迹，循环判断是否用到就好了。用不到的模块就舍弃掉。</p>
<p>妙不妙！再看一看静态库的定义吧。</p>
<blockquote>
<p>在 Linux 中，静态库是以一种称为 <strong>存档(archive)</strong> 的特殊文件形式存放在<strong>磁盘</strong>中的。存档是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件由后缀（.a)标识。</p>
</blockquote>
<h3 id="4-2-创建静态库"><a href="#4-2-创建静态库" class="headerlink" title="4.2 创建静态库"></a>4.2 创建静态库</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/x_wukong/p/5713437.html">静态库和动态库创建参考</a></p>
<blockquote>
<p>(1) 首先，我们需要源文件（.c）</p>
<p>这里为 mul.c 和 add.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mulcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	mulcnt ++ ;</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125;<span class="comment">// mul.c</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> addcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	addcnt ++ ;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;<span class="comment">// add.c</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>(2) 然后，我们需要将源文件处理成可重定位目标文件</p>
</blockquote>
<p><code>gcc -c add.c mul.c</code></p>
<blockquote>
<p>(3) 最后，将需要的可重定位目标文件封装到静态库中。</p>
<p>例如： <code>ar rcs mylib.a a.o b.o...</code></p>
<p>r: replace and insert</p>
<p>c : create</p>
<p>s: add index</p>
</blockquote>
<p><code>ar rcs mylib.a add.o mul.o</code></p>
<blockquote>
<p>(4) 别以为就这样结束了，编写个 main 程序测试你下你的库吧！</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> s1 = add(x, y);</span><br><span class="line">	<span class="type">int</span> s2 = mul(x, y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;x = %d, y = %d\nsum = %d, mul = %d\n&quot;</span>, x, y, s1, s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c testar.c # 先编译生成可执行文件</span><br><span class="line">gcc --static -o main testar.o -L. mylib.a # 与静态库链接</span><br></pre></td></tr></table></figure>

<blockquote>
<p>–static 参数告诉编译器驱动程序，链接器应该构建一个完全链接的可执行目标文件，它可以加载到内存并运行，在加载时无需更进一步的链接。所以说不加也是可以的。</p>
<p>-Ldir 指明了链接器在那个目录下查找 mylib.a，dot就表示当前目录。</p>
</blockquote>
<h2 id="0x07-relocation"><a href="#0x07-relocation" class="headerlink" title="0x07 relocation"></a>0x07 relocation</h2><h3 id="1-重定位的任务："><a href="#1-重定位的任务：" class="headerlink" title="1. 重定位的任务："></a>1. 重定位的任务：</h3><p>重定位合并输入模块，并为每个符号分配运行时地址。</p>
<p>由两步组成：</p>
<ol>
<li><p>重定位节和符号定义：</p>
<ol>
<li>将所有相同类型的节合并为一个节</li>
<li>将运行时内存地址赋给新的聚合节</li>
<li>赋给输入模块定义的每个符号</li>
</ol>
<p>完成后，程序中的每条指令和全局变量都有唯一的运行时内存地址了。</p>
</li>
<li><p>重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为<strong>重定位条目</strong>的数据结构。</p>
</li>
</ol>
<h3 id="2-重定位条目"><a href="#2-重定位条目" class="headerlink" title="2. 重定位条目"></a>2. 重定位条目</h3><p>为什么需要重定位条目？</p>
<blockquote>
<p>当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。</p>
<p>它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。</p>
<p>所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个 <strong>“重定位条目”</strong>，告诉链接器在将目标文件合并成可执行文件时许和修改这个引用。</p>
<p>代码的重定位条目放在 .rel.text 中，已初始化数据的重定位条目放在 .rel.data 中。</p>
</blockquote>
<p>ELF 重定位条目的格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> offset;	<span class="comment">// 我在那</span></span><br><span class="line">    <span class="type">long</span> type: <span class="number">32</span>;	<span class="comment">// 怎么引用</span></span><br><span class="line">    	smybol: <span class="number">32</span>; <span class="comment">// 我引用了谁</span></span><br><span class="line">    <span class="type">long</span> addend;	<span class="comment">// 我的偏移量</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>offset 是需要被修改的引用的在节内的偏移。（一般是一个地址）</p>
<p>symbol 标识被修改引用应该指向的符号。</p>
<p>type 告知链接器如何修改新的引用。</p>
<p>addend 是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。（addend的值一般是当前引用的地址距离下一条指令的偏移）（讲的标准一点就是对 rip 的修正，因为重定位所在的地址并不是下一条指令的 rip 地址）</p>
</blockquote>
<p>两种最基本的重定位类型（type）：</p>
<ol>
<li><p>R_X86_64_PC32：重定位一个使用 32 位 PC 相对地址的引用。（一个 PC 相对地址就是距程序计数器(PC)的当前运行时值的偏移量。当 CPU 执行一条使用 PC 相对寻址的指令时，它就将在指令中编码的 32 位值加上 PC 的当前运行时值，得到有效地址， PC 值通常是<strong>下一条</strong>指令在内存中的地址）。</p>
<blockquote>
<p>简而言之，<strong>相对</strong>的意思就是，相对于<strong>下一条指令</strong>的偏移量。</p>
</blockquote>
</li>
<li><p>R_X86_64_32：重定位一个 32 位绝对地址的引用。通过绝对寻址，CPU 直接使用在指令中编码的 32 位值作为有效地址。</p>
</li>
</ol>
<h3 id="3-重定位符号引用"><a href="#3-重定位符号引用" class="headerlink" title="3. 重定位符号引用"></a>3. 重定位符号引用</h3><blockquote>
<p> 相对引用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call addr </span><br><span class="line">	sym.offset: R_X86_64_PC32 sym</span><br></pre></td></tr></table></figure>

<p>首先，要清楚我们的目标：通过 addr 的<strong>相对偏移</strong>得到该符号的运行时地址，这个地址我们是已知的。（我们用ADDR(x)表示符号 x 的运行时地址）</p>
<p>当前引用的地址 + 距离下一条指令的偏移量 +  addr &#x3D; 目标符号的运行时地址</p>
<p>addr &#x3D; ADDR(sym) - （当前引用的地址 + 距离下一条指令的偏移量）</p>
<p>不过，距离下一条指令的偏移量通常以 sym.addend 的形式存在，于是，上式变成了：</p>
<p>addr &#x3D; ADDR(sym) - 当前引用的地址 + sym.addend</p>
<blockquote>
<p>我们发现，公式在经过转换后，由 “距离” 下一条指令的偏移量变成了 “加上”  sym.addend。</p>
<p>而偏移量肯定是一个正数（不然怎么偏移到下一条指令），所以说 sym.addend 肯定是个负数。</p>
<p>自己推导的，不一定对？？</p>
</blockquote>
<p>而当前引用的地址 &#x3D; 引用所在节的运行时地址 + 引用的偏移(sym.offset)</p>
<p>所以，上式最终等于如下：</p>
<p>addr &#x3D; ADDR(sym) - （ADDR(Section) + sym.offset）+ sym.addend</p>
<hr>
<blockquote>
<p>绝对引用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call addr</span><br><span class="line">	sym.offset: R-X86_64_32 sym</span><br></pre></td></tr></table></figure>

<p>addr &#x3D; ADDR(sym) + sym.addend</p>
<p>在绝对引用中，我们依然需要加上偏移量addend，只不过 sym.addend&#x3D;0。</p>
<p>可以发现，相较于绝对引用，相对引用只需要减去当前引用的地址即可，距离下一条指令的偏移保存在了 addend 中。</p>
<h2 id="0x08-executable-object-file"><a href="#0x08-executable-object-file" class="headerlink" title="0x08 executable object file"></a>0x08 executable object file</h2><p>典型的 ELF 可执行目标文件（EOF，段和节）：</p>
<p><img src="https://s1.328888.xyz/2022/09/28/spsQp.png" alt="img"></p>
<p>ELF头还包括了程序的入口点？也就是程序的第一条指令的地址。</p>
<p>通过图可以发现，EOF 文件中还多了 .init 节。.init节定义了一个小函数，叫做 _init_，程序的初始化代码会调用它。</p>
<p>.text，.data，.rodata 与可重定位目标文件的节是相似的，除了这些节已经被重定位到它们最终的运行时内存地址以外。</p>
<p>因为 EOF 文件是<strong>完全链接</strong>的（已被重定位），所以它不再需要 .rel 节。</p>
<blockquote>
<p>EOF 文件还有对其要求。这主要与虚拟内存有关</p>
</blockquote>
<h2 id="0x09-load-EOF"><a href="#0x09-load-EOF" class="headerlink" title="0x09 load EOF"></a>0x09 load EOF</h2><p>我们通常在 Linux Shell 命令行输入可执行目标文件的名字 (例如prog) 来执行它:</p>
<p><code>Linux&gt; ./prog</code></p>
<p>因为 prog 不是一个内置的 shell 命令，所以 shell 会认为 prog 是一个可执行目标文件。</p>
<p>通过调用某个驻留在内存中称为<strong>加载器（loader）</strong>的操作系统代码来运行它。</p>
<p>任何 Linux 程序都可以通过调用 <strong>execve()</strong> 调用加载器。</p>
<p>加载器将 EOF 文件的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序从磁盘复制到内存并运行的过程叫做 “加载”。</p>
<p><img src="https://s1.328888.xyz/2022/10/12/8jGhJ.png" alt="img"></p>
<h2 id="0x0a-dynamic-link-shared-library"><a href="#0x0a-dynamic-link-shared-library" class="headerlink" title="0x0a dynamic link shared library"></a>0x0a dynamic link shared library</h2><h3 id="1-为什么引入动态库"><a href="#1-为什么引入动态库" class="headerlink" title="1. 为什么引入动态库"></a>1. 为什么引入动态库</h3><p>当然是因为静态库有一些缺点了。</p>
<p>第一个问题，静态库不方便后续的更新和维护。</p>
<blockquote>
<p>静态库和所有软件一样，需要定期维护和更新。</p>
<p>如果应用程序员想要使用一个库的最新版本，他们必须以某种方式了解到该库的更新情况，然后显式的将他们的程序与更新了的库重新链接。</p>
</blockquote>
<p>第二个问题，静态户仍然会造成对内存资源的极大浪费。 </p>
<blockquote>
<p>虽然在上面 “引入静态库” 一节中我们已经说明了，静态库已经是一种比较节约内存资源的方式。</p>
<p>但那仅仅是在只针对一个文件的情况下，我们尽可能只引用必须用到的模块而避免引用了许多不会用到的模块造成内存浪费。</p>
<p>但试想一下，如果我们存在许多文件呢，几乎每个文件都会用到 printf() 函数等标准 IO 函数。在运行时，这些函数的代码会被复制到每个运行进程的文本段中（试想一下如果我们 printf() 了几百次，难道每一次调用都要复制一份 printf() 的代码吗？那也太浪费内存了！）。</p>
<p>特别是在一个运行上百个金层的典型系统上，这将是对稀缺的内存资源的极大浪费。</p>
<p><strong>（内存的一个有趣属性就是无论系统的内存多大，他总是一种奇缺资源。磁盘空间和厨房的垃圾桶具有同样的属性）。</strong></p>
</blockquote>
<p>于是，为了致力解决静态库的缺憾，共享库诞生了。</p>
<p><strong>共享库是一个目标模块</strong>，在运行或加载时，<strong>可以加载到任意的内存空间</strong>，并和一个在内存中的程序<strong>链接</strong>起来。这个链接的过程就叫做 <strong>“动态链接”</strong>，是由一个叫做动态链接器的程序来执行的。</p>
<p>共享库也称为 **“共享目标”(shared object)**。在 Linux 系统中用 <strong>.so</strong> 后缀来标识。微软的操作系统大量的使用了共享库，它们称为 **DLL(动态链接库)**。</p>
<h3 id="2-共享库的工作方式"><a href="#2-共享库的工作方式" class="headerlink" title="2. 共享库的工作方式"></a>2. 共享库的工作方式</h3><p>共享库是以两种不同的方式来实现 “共享”的。</p>
<p>首先，在任何给定的文件系统中，对于一个酷只有一个 .so 文件，所有引用该库的可执行目标文件分享这个 .so 文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行目标文件中。（解决了静态库内存浪费的问题）</p>
<p>其次，再内存中，一个共享库的 .text 节的一个副本可以被不同的正在运行的进程共享（与虚拟内存有关）。</p>
<p><img src="https://s1.328888.xyz/2022/10/12/86kb0.png" alt="img"></p>
<p>如何构造一个共享库：</p>
<p><code>gcc -shared -fpic -o libname.so module1.o module2.o ....</code></p>
<blockquote>
<p>-fpic 选项指示编译器生成与位置无关的代码。</p>
<p>-shared 选项指示编译器创建一个共享的目标文件。</p>
</blockquote>
<p>下面将将这个共享库链接到程序当中：</p>
<p><code>gcc -o prog main.c ./libname.so</code></p>
<p>根据上图(7-16)我们可以发现，可执行目标文件 prog21 在加载之后，也就是运行时可以和动态库 livvector.so 链接。基本的思路就是当创建可执行文件时，静态执行一些链接，然后在程序加载时，<strong>动态完成链接过程</strong>。</p>
<blockquote>
<p>by xjy：</p>
<p>注意上面的话并不矛盾，前一句话说程序运行时和动态库链接，下一句又说在程序加载时动态完成链接。一个是在运行时，一个是在加载时。</p>
<p>这可能是因为程序并不是直接全部加载到内存的（操作系统），它用到一点就加载一点，所以说，加载和运行是交叉的。</p>
</blockquote>
<p>注意，再整个链接的过程当没有任何动态库的代码和数据真的被复制到可执行文件 prog21 当中。反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对动态库中代码和数据的引用。</p>
<h3 id="3-小实验"><a href="#3-小实验" class="headerlink" title="3. 小实验"></a>3. 小实验</h3><p>下面是一个小实验，1.c，2.c 用来构建动态库和静态库，main.c 是测试函数。</p>
<p>app 是链接静态库生成的可执行文件。</p>
<p>prog 是链接动态库生成的可执行文件。</p>
<p>可以发现，prog 的大小比 app 小的多（小了50多倍）。</p>
<p><img src="https://s1.328888.xyz/2022/10/12/86JI6.png" alt="IMG"></p>
<h1 id="csapp-memory"><a href="#csapp-memory" class="headerlink" title="csapp memory"></a>csapp memory</h1><h2 id="一、cache"><a href="#一、cache" class="headerlink" title="一、cache"></a>一、cache</h2><h3 id="0x01-一种初始化方式"><a href="#0x01-一种初始化方式" class="headerlink" title="0x01 一种初始化方式"></a>0x01 一种初始化方式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">&#125; <span class="type">node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">node_t</span> p = &#123;</span><br><span class="line">        .l = <span class="number">100</span>,</span><br><span class="line">        .r = <span class="number">200</span>,</span><br><span class="line">        .s = <span class="string">&quot;hello,world!&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;node: %d %d %s\n&quot;</span>, p.l, p.r, p.s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="0x02-note"><a href="#0x02-note" class="headerlink" title="0x02 note"></a>0x02 note</h3><p>我们知道内存是分页的，cache的 line 只会存在于某一个页，它不会跨页存在。</p>
<h3 id="0x03-true-x2F-fake-sharing"><a href="#0x03-true-x2F-fake-sharing" class="headerlink" title="0x03 true&#x2F;fake sharing"></a>0x03 true&#x2F;fake sharing</h3><p>罪魁祸首：MESI 协议</p>
<p>false sharing有一个问题，就是对于sum求和这个例子，虽然我们设置sum1和sum2分别求和，但是sum1和sum2都是分配在栈上的，并且地址十分接近，所以它们可能在同一个cache当中，这样不管是sum1修改还是sum2修改，都会触法 MESI 的同步协议，这样 false sharing的速度和true sharing相差几乎无几。</p>
<h3 id="0x04-MESI-protocol"><a href="#0x04-MESI-protocol" class="headerlink" title="0x04 MESI protocol"></a>0x04 MESI protocol</h3><p>exclusive：独有的</p>
<p>exclusive 和 shared 不能共存</p>
<p>四种状态：（由于读数据不会产生数据一致性问题，因此这里只考虑写数据操作）</p>
<p>M: (exclusive) modify, like dirty. 物理地址被缓存到某一个 cache，并且数据已经被修改</p>
<p>E:  exclusive (clean).物理地址被缓存到某一个 cache，并且数据没有被修改</p>
<p>S:  (exclusive) shared clean.物理地址被缓存到 cache，并且多个 cache 共享。</p>
<blockquote>
<p>如果修改一个状态为 s 的 cache，它会发送一个广播，将所有其他状态为 s 的 cache 的状态修改为 invalid（具体方法是将其拥有数据写入到 dram，然后修改状态为 invalid），然后将自己的状态修改为 M，这样就可以保证全局状态下只有一个 M，也就是 exclusive的。</p>
</blockquote>
<p>I: invalid.物理地址并没有缓存到 cache。</p>
<blockquote>
<p>此时如果发生 cache write</p>
<ol>
<li>如果其他 cache 的状态都是 invalid，从内存 load 数据，修改器状态为 M。</li>
<li>如果存在 (shared)S状态 的 cache，将它们的数据写入到 dram，然后修改状态为 invalid。</li>
</ol>
</blockquote>
<p>每个处理器的cache line都是 dram 的 cache line 的拷贝</p>
<h2 id="二、page-table"><a href="#二、page-table" class="headerlink" title="二、page table"></a>二、page table</h2><h3 id="0x01-tips"><a href="#0x01-tips" class="headerlink" title="0x01 tips"></a>0x01 tips</h3><p>地址翻译由硬件实现，操作系统为应用提供这个功能。</p>
<p>TLB 也是一个 cache。</p>
<p>现在 64 位的处理器(cpu)的虚拟地址一般其实只有 48 位，剩下的 16 位属于内核。</p>
<p>虚拟地址空间呈现局部密集，整体稀疏的特征。</p>
<p>多级页表在最坏的情况下（满映射，每页都必须有有效数据）是一棵完全二叉树，此时页表条目会比朴素页表多出来一倍。但这种情况几乎不可能出现（虚拟地址空间的稀疏性和程序的局部性）。</p>
<p>页表分配在操作系统的内核态。</p>
<p>在windows下，资源管理器的内存中可以看到：分页缓冲池和非分页缓冲池。分页缓冲池指的是可以和磁盘进行换入(page in)和换出(page out)的页，而非分页并不是指不分页，而是不能喝磁盘进行 swap。</p>
<h3 id="0x02-how-to-reflect-va2pa"><a href="#0x02-how-to-reflect-va2pa" class="headerlink" title="0x02 how to reflect va2pa"></a>0x02 how to reflect va2pa</h3><p>在我们编写的地址转换函数中，我们简单的通过去模数将物理地址转换为虚拟地址，然而，这是极为不合理的，例如：</p>
<ol>
<li>产生不合法的地址（地址越界）。例如：0x200(1024)%0x200&#x3D;0x000，它产生了一个地址为 0 的地址，这显然是错误的。</li>
<li>不同进程间地址冲突的问题。因为每个进程的地址都是从 0x00400000 开始的，而相同地址取模之后的值是相同的，这就会导致地址冲突。</li>
</ol>
<p>一种可行的方法是使用 hashmap 完成物理地址到虚拟地址地址映射。它解决了使用取模方法产生的冲突和越界问题，但是，它又会产生以下两个问题：</p>
<ol>
<li>内存浪费严重。在 hashmap 中，我们需要额外的两份空间来分别存储物理地址和虚拟地址以记录他们的映射关系，并且，由于 hashmap 并不是全部使用的，它的内部会有空闲，因此我们还需要乘上一个空闲率 k(k&gt;&#x3D;1)，因此 hashmap 就需要额外的 2k 倍的额外内存空间要保存映射信息。</li>
<li>破坏程序的局部性。由于 hashmap 的映射是离散的，这就会导致程序会被离散化，破坏程序的局部性。</li>
</ol>
<p>但是，hashmap 产生的这两个问题属于 性能 问题，它只是导致程序运行效率不好，并不会导致程序运行错误。而取模方法则会导致程序运行出错。</p>
<p>现在我们再来想，hashmap 中记录如此之多的映射信息是否有必要？</p>
<p>肯定是有必要的，不然我们就无法找到物理地址了。但是！如果我们通过虚拟地址映射到物理地址不是离散的，例如：</p>
<blockquote>
<p>虚拟地址 0x1,0x2，通过 hashmap 地址映射为物理地址：0xa, 0xabcd。如果我们想找到这两个物理地址，我们必须保存映射信息，因为 0xa, 0xabcd 之间毫无关联。但是这种离散性是毫无必要的，如果我们将地址映射为 0xa, 0xb 这种连续的地址的话，它不仅可以避免破坏程序的局部性，还能减少地址映射需要保存的信息。</p>
<p>比如虚拟地址 [0x0, 0xffff] 这一块区域，如果我们采用 hashmap，它需要 0xffff 份映射信息，这也太多了。但是，如果 hashmap 映射的地址是连续的，我们就可以通过三元组(va0, pa0, offset) （offset表示偏移量）来找到这个区域内任意一个地址的映射，并且仅仅只需要一份映射信息，对于任意 va，pa&#x3D;pa0+va-va0（va &gt;&#x3D; va0 &amp;&amp; va &lt;&#x3D; va0 + offset）。</p>
<p>现在， 完成地址映射需要的额外信息由 2k 变成了 3M，M 就是上述三元组的数量，这个 M 远小于地址的数量。</p>
</blockquote>
<p>这就是分段思想。</p>
<p>当然，分段也是有问题的，例如：</p>
<ol>
<li>碎片。内部碎片和外部碎片。</li>
<li>每次计算都需要比较 va 是否越界。(va &gt;&#x3D; va0 &amp;&amp; va &lt;&#x3D; va0 + offset)</li>
<li>不方便拓展。当我们的段太大或者或许频繁拓展的时候，寻找一个合适的空间比较麻烦。</li>
</ol>
<p>所以说，我们需要把 offset 变成一个较小且固定的数值，这就是分页思想。</p>
<h3 id="0x03-address-transfer"><a href="#0x03-address-transfer" class="headerlink" title="0x03 address transfer"></a>0x03 address transfer</h3><p><a target="_blank" rel="noopener" href="http://www.wowotech.net/memory_management/arm64-memory-addressing.html">ARM64架构下地址翻译相关的宏定义</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/muahao/p/10297852.html">else</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1374439">else</a></p>
<h3 id="0x04-page-falult"><a href="#0x04-page-falult" class="headerlink" title="0x04 page falult"></a>0x04 page falult</h3><p>MM: main memory，主存</p>
<p>page table is the <strong>cache</strong> from disk to main memory</p>
<p>交换空间：当我们页表缓存的页满了之后，我们想再往内存映射一页，此时需要将该页 page out，但是如果该页的数据被修改了 dirty，我们该怎么办？</p>
<ol>
<li>不管它，这肯定不行</li>
<li>将该页写回文件 program file，这也肯定不行，我们不应该修改源文件。</li>
<li>放到别的地方 – swap space。</li>
</ol>
<p>将一页从 mm 放到 swap space 的过程就叫做 swap out</p>
<p>相反的，将页从 swap space 再放到 mm 的过程叫做 swap in</p>
<p>所以说，一个文件占用的空间包括了 mm 和 swap</p>
<p>swap space 也在磁盘</p>
<p><strong>demand paging</strong>:  waiting until the miss to copy the page to DRAM is konwn as deman paging</p>
<p>程序的代码文件，例如 .data 段它是存储在磁盘当中的，所以它与内存之间可以存在映射关系，但是 .data 段，stack, heap 不是存储在磁盘当中的，当我们需要把这些短存放在磁盘当中时，我们需要放入 swap space 中。它们又称为<strong>“匿名页”</strong>(在磁盘中没有文件与它对应)。 </p>
<h2 id="三、virtual-memory-overview"><a href="#三、virtual-memory-overview" class="headerlink" title="三、virtual memory overview"></a>三、virtual memory overview</h2><p>​       virtual memory 主要是为了解决物理内存和进程所看到的虚拟内存不匹配的问题，所以说每个 virtual memory 肯定是提供给每一个<strong>进程</strong>的。</p>
<p>每个进程就是一段 active 的内存，例如：</p>
<ol>
<li>.text 是死的</li>
<li>.data 是活的，因为它需要写入操作等</li>
</ol>
<p>如果区分 user 的虚拟地址空间和 kernel 的虚拟地址空间：kernel 的64位虚拟地址的最高位是1，user 的64位虚拟地址的最高位是 0。</p>
<p>我们通常看到的程序的虚拟地址空间图中， user 的虚拟地址空间地址的高部分都被 stack 占用了，但是这通常是作者的简化，实际上地址的最高部分被 kernel 部分占用了，只不过一半不标识出来。</p>
<p>只有第一级页表可以区分user mode or kernel mode，因为只有第一级页表可以得到地址的最高位。</p>
<p>用户的虚拟地址空间中的 user 部分映射到程序的虚拟地址空间的user 部分，映射方法为：0x0 + addr，kernel mode 部分的映射方法为：0xffff + addr，user的虚拟地址空间的地址最高为2^48。0xffff正好是16位。</p>
<p>pgb 在 kernel 中只有唯一一份。</p>
<p>kernel 的虚拟地址从 2^47？</p>
<p>内核的地址翻译全局一致。</p>
<h2 id="四、TLB"><a href="#四、TLB" class="headerlink" title="四、TLB"></a>四、TLB</h2><p>hardware acceleration：硬件加速</p>
<p>TLB is the cache of va2pa</p>
<p>我们可以把 cache 看作一个 key-value 库</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">C++ concurrency programming</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-15 20:20:57" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-16 10:15:25" itemprop="dateModified" datetime="2023-06-16T10:15:25+08:00">2023-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-Concurrency-In-Action"><a href="#C-Concurrency-In-Action" class="headerlink" title="C++ Concurrency In Action"></a>C++ Concurrency In Action</h1><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/Cpp_Concurrency_In_Action/README.md#C++%20Concurrency%20In%20Action">Book开源处,感觉翻译很烂</a></p>
<p>关于异常：</p>
<blockquote>
<p><strong>出现异常并不意味着程序本身出了问题，而是程序外部的输入无法让正常业务继续执行，这时应该执行的是异常业务，而异常就是这两种业务转接的桥梁——它提供一种机制，使得程序员在遵守一定规则之下，这个异常业务能够正确完成。</strong></p>
<p>异常安全的三个级别：noexcept,  basic, strong</p>
<p><a target="_blank" rel="noopener" href="https://01io.tech/error-handling-cpp-exception-safety/">ref</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/how-to-design-for-exception-safety?view=msvc-170">ref</a></p>
</blockquote>
<h2 id="P0-English"><a href="#P0-English" class="headerlink" title="P0 English"></a>P0 English</h2><p>spin：自旋转</p>
<p>unary predicate：一元谓词s</p>
<p>binary predicate：二元谓词</p>
<p>predicate：谓词</p>
<p>snapshot：快照</p>
<p>nice-to-have：可有可无</p>
<p>parallelism: 并行</p>
<p>serialization：串形</p>
<p>RAII: Resource Acqusition Is Initialization，资源获取即初始化</p>
<p>Abstraction penalty：抽象代价</p>
<p>daemon thread: 守护线程</p>
<p>invariants:不变量</p>
<p>race condition：条件竞争</p>
<p>grammar：语法</p>
<p>semantics：语义</p>
<p>malicious_function：恶意函数</p>
<p>hierarchical: 分层的</p>
<p>granularity: 粒度</p>
<p>idiom：惯用法</p>
<p>nest: 嵌套</p>
<p>recursive：互斥</p>
<p>synchronization：同步</p>
<p>condition variable：条件变量</p>
<p>future：期望</p>
<p>spurious wakeup：伪唤醒</p>
<p>asynchronization：异步</p>
<p>pivot：枢纽</p>
<p>chrono：时间</p>
<h2 id="P1-Hello-concurrency"><a href="#P1-Hello-concurrency" class="headerlink" title="P1 Hello, concurrency"></a>P1 Hello, concurrency</h2><p><strong>contest switch</strong></p>
<blockquote>
<p>save cpu state and instruction pointer, calculate which task should we switched, and load new cpu state. then, cpu will load the instruction and data in cache</p>
</blockquote>
<p><strong>hardware concurrency</strong></p>
<blockquote>
<p>truly concurrency</p>
</blockquote>
<p><strong>the way of concurrency</strong></p>
<blockquote>
<ol>
<li><p>Multiprocessing concurrency: need to IPC, so more complex and more slowly, but it has good isolation and more safety</p>
</li>
<li><p>Multithreading concurrency: need to solve concurrency problem carefully</p>
</li>
</ol>
</blockquote>
<p>**Warning: **this book base on multiply thread concurrency</p>
<p><strong>why need to concurrency:</strong> only one for code <strong>ioslation</strong> and other for <strong>prefomance</strong></p>
<p><strong>test code:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, Concurrency!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(hello)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="P2-Thread-management"><a href="#P2-Thread-management" class="headerlink" title="P2 Thread management"></a>P2 Thread management</h2><h3 id="2-1-preface"><a href="#2-1-preface" class="headerlink" title="2.1 preface"></a>2.1 preface</h3><h4 id="2-1-1-generalize"><a href="#2-1-1-generalize" class="headerlink" title="2.1.1 generalize"></a>2.1.1 generalize</h4><blockquote>
<ol>
<li>create and run a new thread</li>
<li>join or detain thread</li>
<li>unique identify of thread</li>
</ol>
</blockquote>
<h4 id="2-1-2-start-thread"><a href="#2-1-2-start-thread" class="headerlink" title="2.1.2 start thread"></a>2.1.2 start thread</h4><p>thread run when you create a object of <code>std::thread</code></p>
<p><code>std::thread</code> can create a object by <code>function object</code>, like this example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, Concurrency!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">background_task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Hello, I am a new thread!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// do something else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Good bye~&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    background_task f;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(f)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>But, if you want to pass a tempate object to <code>std::thread</code>, in this way:<code>thread my_t(background_task());</code></p>
<p>You will found this run with error: <code>my_t is a declaration of funtion</code></p>
<p>This is because C++’s <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Most_vexing_parse">most vexing parse</a>, in that declaration, my_t will be parsed in a funtion but a object, you can solve this by following way:</p>
<ol>
<li>use of an extra parenthesis: <code>thread t(( background_task() ));</code></li>
<li>use C++11 initialization: <code>thread t&#123; background_task() &#125;;</code></li>
<li>use C++11 lambda:</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread <span class="title">t</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    cout &lt;&lt; <span class="string">&quot;Hello, this is a thread!&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    cout &lt;&lt; <span class="string">&quot;byt~&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>If you doesn’t decide join or detain your thread, then it will call dtor(<code>std::terminate()</code>).</p>
<h4 id="2-1-2-join-thread"><a href="#2-1-2-join-thread" class="headerlink" title="2.1.2 join thread"></a>2.1.2 join thread</h4><p>If you detach a thread like this way:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> &amp;i;</span><br><span class="line">    <span class="built_in">func</span>(<span class="type">int</span> &amp;_i) : <span class="built_in">i</span>(_i) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">1024</span> * <span class="number">1024</span>; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; j &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;-Hello,World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oops</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> local_state = <span class="number">1024</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(local_state)</span></span>;</span><br><span class="line">    <span class="built_in">my_func</span>();</span><br><span class="line">    <span class="function">thread <span class="title">my_thread</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    my_thread.<span class="built_in">detach</span>(); <span class="comment">// wrong!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">oops</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>In <code>std::thread my_thread</code>, we pass by value of <code>my_func</code> and access local object in <code>func::operator()</code> , if funtion <code>oops</code> exit before thread <code>my_thread</code> exit, then <code>my_thread</code> will access local value which is destoryed, and the behaviour when it happened is UB. </p>
<blockquote>
<p>so it is important to choose a valid way to wait you thread.</p>
<p>and a programming habit is <strong>do not create a thread which can access local object</strong></p>
</blockquote>
<p>A easy and rude way to wait a thread until exit is <code>join</code></p>
<p>if you call <code>join</code>, the resoures about thread will clean automatilly, and you cant call <code>join</code> double times and more.</p>
<p>you can call <code>joinable()</code> to get if you can join, it return false if you haved joined </p>
<h4 id="2-1-3-join-in-special-condition"><a href="#2-1-3-join-in-special-condition" class="headerlink" title="2.1.3 join in special condition"></a>2.1.3 join in special condition</h4><p>Look the next code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(thread &amp;<span class="type">_t</span>)</span> : t(_t) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">thread_guard</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~ thread_guard&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(t.<span class="built_in">joinable</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~ end&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">thread_guard</span>(thread_guard <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    thread_guard&amp; <span class="keyword">operator</span>=(thread_guard <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    thread &amp;t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;function f() do something here..&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span>(<span class="built_in">string</span>(<span class="string">&quot;No reason exception&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> local_state = <span class="number">1024</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(local_state)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">    <span class="comment">// if do_something() throw exception</span></span><br><span class="line">    <span class="comment">// then t.join will be skiped and t would call terminate</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(string &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch in main: &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>In function <code>f()</code>, if <code>do_something()</code> throw exception, and not catched, then <code>f()</code> wiil exit and skiped <code>join()</code></p>
<p>A solution is followings:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;function f() do something here..&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span>(<span class="built_in">string</span>(<span class="string">&quot;No reason exception&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> local_state = <span class="number">1024</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(local_state)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">do_something</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(string &amp;e) <span class="comment">// (1)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch in f: &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(string &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch in main: &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>But, a better way is in RAII</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">thread_guard</span>(thread&amp; <span class="type">_t</span>) : <span class="built_in">t</span>(<span class="type">_t</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">thread_guard</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~thread_guard&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(t.<span class="built_in">joinable</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~thread_guard end&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">thread_guard</span>(<span class="type">const</span> thread&amp; <span class="type">_t</span>)=<span class="keyword">delete</span>;</span><br><span class="line">    thread_guard&amp; <span class="keyword">operator</span>=(<span class="type">const</span> thread&amp; <span class="type">_t</span>) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    thread &amp;t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;function f() do something here..&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span>(<span class="built_in">string</span>(<span class="string">&quot;No reason exception&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> local_state = <span class="number">1024</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(local_state)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="function">thread_guard <span class="title">g</span><span class="params">(t)</span></span>;</span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">    <span class="comment">// the next will skiped if do_something() throw exception</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;f() end&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(string &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch in main: &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this way, although <code>do_something()</code> will throw exception and skip <code>join</code>, the object <code>g</code> will call <code>dtor</code> to <code>join</code> the thread he managed</p>
<h4 id="2-1-4-detach-thread"><a href="#2-1-4-detach-thread" class="headerlink" title="2.1.4 detach thread"></a>2.1.4 detach thread</h4><h3 id="2-2-pass-value"><a href="#2-2-pass-value" class="headerlink" title="2.2 pass value"></a>2.2 pass value</h3><p>Whaterver the parameters type you set(reference or value), thread will <strong>copy</strong> always! Just copy all arguments in the memory space itself.</p>
<p>In the following code, function <code>f()</code> receive a int pass by value and a string pass by reference</p>
<p>And because we detach the thread <code>t</code>, so we would can’t receiver it’s output.</p>
<blockquote>
<p>在下面的代码中，函数 f 打印的 s 可能会乱码，这是因为函数 buf 实际上是一个指针变量，它指向局部变量。</p>
<p>并且它的类型是 <code>const char *</code>，当我们把它传递给 <code>string</code> 时，会执行一个隐式类型转换。</p>
<p>但是，我们无法确保隐式类型转换与 thread 传递参数时进行 copy 的执行顺序问题， 也就是说，有可能传递给 string 的事转换前的变量（buf 只想的指针）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i, string <span class="type">const</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;string: &quot;</span> &lt;&lt; s &lt;&lt; endl; <span class="comment">// string s will chaos</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;value = %i&quot;</span>, value);</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(f, value, buf)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func end&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So, the solution is easy, explicit call type convention</p>
<p><code>thread t(f, value, string(buf));</code></p>
<hr>
<p>But, sometimes, we actually want to pass by refernece, the solution is use <code>std::ref</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread: &quot;</span> &lt;&lt; &amp;i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1024</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func: &quot;</span> &lt;&lt; &amp;value &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(f, ref(value))</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func end&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Also, you can pass class funtion and it’s this object</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;val: &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X x;</span><br><span class="line">    x.val = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// pass pointer </span></span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(&amp;X::do_work, &amp;x)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func end&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>But, for some type, the operator assignment or operator copy is deleted, like <code>unique_ptr&lt;&gt;</code>, so should <code>move</code> but copy.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(unique_ptr&lt;<span class="type">int</span>&gt; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(f, move(q))</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func() end&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It would CE If you not use <code>std::move</code>.</p>
<blockquote>
<p>Thread cant copt too.</p>
</blockquote>
<h3 id="2-3-transfer-possessiveness"><a href="#2-3-transfer-possessiveness" class="headerlink" title="2.3 transfer possessiveness"></a>2.3 transfer possessiveness</h3><h4 id="2-3-1-preface"><a href="#2-3-1-preface" class="headerlink" title="2.3.1 preface"></a>2.3.1 preface</h4><p>你不能通过赋新值操作来“丢弃”一个线程，即：你不能将一个线程 move 到一个已经分配了任务的线程。</p>
<p>你也不可以将一个线程 copy 到另一个线程，但是你可以将一个线程 move 到另一个空线程。</p>
<p>对于下面的形式（1）是合法的，因为 <code>thread(f)</code> 是一个临时对象 – 移动操作会隐式的调用，如果是一个 <code>具名对象</code>， 就需要显示的调用 <code>move</code>，如 (2) 所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">thread t;</span><br><span class="line">t = <span class="built_in">thread</span>(f); <span class="comment">// (1)</span></span><br><span class="line">thread t2 = <span class="built_in">move</span>(f); <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure>

<p>但是对于 (3) 所示就会 CE：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread t;</span><br><span class="line">t = <span class="built_in">thread</span>(f);</span><br><span class="line">thread t2 = <span class="built_in">move</span>(t);</span><br><span class="line">t = <span class="built_in">thread</span>(f);</span><br><span class="line">t2 = <span class="built_in">move</span>(t);   <span class="comment">// (3) t2 已经被分配</span></span><br><span class="line">t2.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>



<h4 id="2-3-2-scoped-thread"><a href="#2-3-2-scoped-thread" class="headerlink" title="2.3.2 scoped_thread"></a>2.3.2 scoped_thread</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">scoped_thread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_thread</span><span class="params">(std::thread <span class="type">_t</span>)</span> </span></span><br><span class="line"><span class="function">        : t(std::move(_t)) </span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="keyword">if</span>(!t.<span class="built_in">joinable</span>())</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;No thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">scoped_thread</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scoped_thread</span>(<span class="type">const</span> scoped_thread&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    scoped_thread&amp; <span class="keyword">operator</span>=(<span class="type">const</span> scoped_thread&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    thread t;   <span class="comment">// 不能是引用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> local_value = <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">// 下面药多加一对括号，否则会被认定为函数的声明</span></span><br><span class="line">    <span class="comment">// 通过 move，我们就无需创建具名对象来创建 thread</span></span><br><span class="line">    <span class="function">scoped_thread <span class="title">t</span><span class="params">((std::thread(func(local_value))))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func() end&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>疑问？</p>
<p>为啥不把 ctor 里的 t 设置为右值引用呢？</p>
</blockquote>
<h4 id="2-3-3-jpthread"><a href="#2-3-3-jpthread" class="headerlink" title="2.3.3 jpthread"></a>2.3.3 jpthread</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">scoped_thread</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">joining_thread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">joining_thread</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>; <span class="comment">// ??</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">joining_thread</span><span class="params">(Callable &amp;&amp;func, Args&amp;&amp; ...args)</span></span></span><br><span class="line"><span class="function">        :t(std::forward&lt;Callable&gt;(func), std::forward&lt;Args&gt;(args) ...) // ???</span></span><br><span class="line"><span class="function">        &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">joining_thread</span>(joining_thread &amp;&amp;other) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">t</span>(std::<span class="built_in">move</span>(other.t))</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">joining_thread</span>(thread <span class="type">_t</span>) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">t</span>(std::<span class="built_in">move</span>(<span class="type">_t</span>))</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">    joining_thread&amp; <span class="keyword">operator</span>=(joining_thread &amp;&amp;other) <span class="keyword">noexcept</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">joinable</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        t = std::<span class="built_in">move</span>(other.t);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为啥不是 thread &amp;&amp;t</span></span><br><span class="line">    joining_thread&amp; <span class="keyword">operator</span>=(thread t) <span class="keyword">noexcept</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">joinable</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        t = std::<span class="built_in">move</span>(t);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">joining_thread</span>() <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">joinable</span>())</span><br><span class="line">            <span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(joining_thread &amp;other)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        t.<span class="built_in">swap</span>(other.t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="function">thread::id <span class="title">get_id</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">get_id</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">joinable</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">joinable</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::thread&amp; <span class="title">as_thread</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread&amp; <span class="title">as_thread</span><span class="params">()</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 将 const thread&amp; 的 const 属性去掉</span></span><br><span class="line">        <span class="comment">// 去掉 const 属性必须用 const_cast</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;thread&amp;&gt;(</span><br><span class="line">            <span class="comment">// 将 &amp;this 转换为 const 类型</span></span><br><span class="line">            <span class="comment">// 加上 const 属性用 static_cast</span></span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">const</span> joining_thread&amp;&gt;(*<span class="keyword">this</span>).<span class="built_in">as_thread</span>()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::thread t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>疑问？</p>
<p>为啥不把 ctor 中的 <code>thread t</code> 改为 <code>thread &amp;&amp;t</code> 呢？</p>
</blockquote>
<h3 id="2-4-determin-count-of-thread"><a href="#2-4-determin-count-of-thread" class="headerlink" title="2.4 determin count of thread"></a>2.4 determin count of thread</h3><p><code>thread::hardware_concurrency()</code> ：返回并发线程的数量。</p>
<p>并行版的 <code>std::accumulate</code></p>
<blockquote>
<p>因为数据范围并不大，因此得出的时间消耗意义不大！</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========================*/</span></span><br><span class="line"><span class="comment">/*      std::accumulate      */</span></span><br><span class="line"><span class="comment">/*    concurrency version    */</span></span><br><span class="line"><span class="comment">/*===========================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// just the warpped function of std::accumulate</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">accumulate_block</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator first, Iterator last, T&amp; result)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        result = std::<span class="built_in">accumulate</span>(first, last, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">parallel_accumulate</span><span class="params">(Iterator first, Iterator last, T init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">cul_t</span> = <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">ul_t</span> = <span class="type">unsigned</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">cul_t</span> length = std::<span class="built_in">distance</span>(first, last);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// special check</span></span><br><span class="line">    <span class="keyword">if</span>(!length)</span><br><span class="line">        <span class="keyword">return</span> init;</span><br><span class="line"></span><br><span class="line">    <span class="type">cul_t</span> min_pre_thread = <span class="number">25</span>; <span class="comment">// 一个线程至少处理 25 个任务</span></span><br><span class="line">    <span class="comment">// 最大线程数为：任务总数 / 每个线程处理的任务数量，上取整</span></span><br><span class="line">    <span class="type">cul_t</span> max_threads = (length + min_pre_thread - <span class="number">1</span>) / min_pre_thread;</span><br><span class="line">    </span><br><span class="line">    <span class="type">cul_t</span> hardware_thread = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为上下文切换的成本也很高，因此和系统真正的并发量取 min</span></span><br><span class="line">    <span class="type">cul_t</span> num_threads = std::<span class="built_in">min</span>(hardware_thread != <span class="number">0</span> ? hardware_thread : <span class="number">2</span>, max_threads);</span><br><span class="line">    <span class="comment">// 每个线程处理一个任务块</span></span><br><span class="line">    <span class="type">cul_t</span> block_size = length / num_threads;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;T&gt; <span class="title">results</span><span class="params">(num_threads)</span></span>; <span class="comment">// result[num_threads-1] uesed to save finally result</span></span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(num_threads - <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分块 </span></span><br><span class="line">    Iterator block_start = first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">ul_t</span> i = <span class="number">0</span>; i &lt; num_threads - <span class="number">1</span>; ++ i )</span><br><span class="line">    &#123;</span><br><span class="line">        Iterator block_end = block_start;</span><br><span class="line">        std::<span class="built_in">advance</span>(block_end, block_size);</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(</span><br><span class="line">            <span class="built_in">accumulate_block</span>&lt;Iterator, T&gt;(),</span><br><span class="line">            block_start, block_end, std::<span class="built_in">ref</span>(results[i])</span><br><span class="line">        );</span><br><span class="line">        block_start = block_end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最终可能不满一个整块，即可能不能切好分为一个块</span></span><br><span class="line">    <span class="built_in">accumulate_block</span>&lt;Iterator, T&gt;()(</span><br><span class="line">        block_start, last, results[num_threads - <span class="number">1</span>]</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计最终结果</span></span><br><span class="line">    for_each(threads.<span class="built_in">begin</span>(), threads.<span class="built_in">end</span>(), <span class="built_in">mem_fn</span>(&amp;thread::join));</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(results.<span class="built_in">begin</span>(), results.<span class="built_in">end</span>(), init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    vector&lt;ull&gt; num;</span><br><span class="line">    ull sum;</span><br><span class="line">    <span class="type">clock_t</span> cur;</span><br><span class="line">    <span class="type">const</span> ull MAX_REP = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span>(ull i = <span class="number">0</span>; i &lt; MAX_REP; i ++ )</span><br><span class="line">        num.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test std::accumulate</span></span><br><span class="line">    cur = <span class="built_in">clock</span>();</span><br><span class="line">    sum = <span class="built_in">accumulate</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>(), (ull)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;time = %.4lf\n&quot;</span>, (<span class="built_in">clock</span>()-cur) * <span class="number">1.0</span> / CLOCKS_PER_SEC);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sum: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// test concurrency accumulate</span></span><br><span class="line">    cur = <span class="built_in">clock</span>();</span><br><span class="line">    sum = <span class="built_in">parallel_accumulate</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>(), (ull)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;time = %.4lf\n&quot;</span>, (<span class="built_in">clock</span>()-cur) * <span class="number">1.0</span> / CLOCKS_PER_SEC);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sum: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="2-5-thread-id"><a href="#2-5-thread-id" class="headerlink" title="2.5 thread id"></a>2.5 thread id</h3><p><code>thread::get_id()</code>：如果线程没有执行，会打印：<code>thread::id of a non-executing thread</code></p>
<p><code>this_thread::get_id()</code> ： 返回当前线程的 id</p>
<p>线程标识符可以用来比较，排序，哈希等。</p>
<p>通过线程标识符可以实现不同的线程执行不同的任务。</p>
<p><code>get_id()</code> 的输出是依赖于实现的，但是C++ 标准规定相同 ID 的线程必须有相同的输出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line">thread::id master_thread_id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(this_thread::<span class="built_in">get_id</span>() == master_thread_id)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am master&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am slaver&quot;</span> &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    vector&lt;thread&gt; threads;</span><br><span class="line">    <span class="comment">// create master</span></span><br><span class="line">    <span class="function">thread <span class="title">master</span><span class="params">(fun, <span class="number">0</span>)</span></span>;</span><br><span class="line">    master_thread_id = master.<span class="built_in">get_id</span>();</span><br><span class="line">    threads.<span class="built_in">push_back</span>(<span class="built_in">move</span>(master));    <span class="comment">// must add move!</span></span><br><span class="line">    <span class="comment">// create slaver</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ )    threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(fun, i + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// join</span></span><br><span class="line">    for_each(threads.<span class="built_in">begin</span>(), threads.<span class="built_in">end</span>(), <span class="built_in">mem_fn</span>(&amp;thread::join));</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="P3-data-share"><a href="#P3-data-share" class="headerlink" title="P3 data share"></a>P3 data share</h2><h3 id="3-1-problems"><a href="#3-1-problems" class="headerlink" title="3.1 problems"></a>3.1 problems</h3><h4 id="3-1-1-race-condition"><a href="#3-1-1-race-condition" class="headerlink" title="3.1.1 race condition"></a>3.1.1 race condition</h4><p>条件竞争分为恶性条件竞争和良性条件竞争，良性条件竞争不会对系统有什么影响。</p>
<p>避免恶性条件竞争的方法：</p>
<ol>
<li>对数据结构采用某种保护机制，例如：mutex</li>
<li>无锁数据结构</li>
<li>事务</li>
</ol>
<h4 id="3-1-2-use-mutex-to-avoid-RC"><a href="#3-1-2-use-mutex-to-avoid-RC" class="headerlink" title="3.1.2 use mutex to avoid RC"></a>3.1.2 use mutex to avoid RC</h4><p>C++ 为我们提供了互斥量用来避免恶性条件竞争，我们可以通过实例化 <code>std::mutex</code> 创建互斥量，并通过 <code>lock()</code> 和 <code>unlock()</code> 进行上锁和解锁，但并不推荐你这么做，认为人总会犯错 😭</p>
<p>所以，类似智能指针，C++ 标准库为互斥量提供了一个 RAII 语法的模板类 <code>std::lock_guard</code>，其会在构造的时候自动上锁，并在析构的时候自动解锁。</p>
<p>他们都在 <code>&lt;mutex&gt;</code> 头文件当中。</p>
<p>示例程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========================*/</span></span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt; L; <span class="comment">// shared data</span></span><br><span class="line">mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_list</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">guard</span><span class="params">(m)</span></span>;</span><br><span class="line">    L.<span class="built_in">push_back</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">list_contains</span><span class="params">(<span class="type">int</span> value_to_find)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">guard</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(L.<span class="built_in">begin</span>(), L.<span class="built_in">end</span>(), value_to_find) != L.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )    L.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">list_contains</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但互斥量也不总是安全的，例如我们在一个类中返回了被保护数据的指针或引用时，会破坏对数据的保护，并且不会被互斥锁限制。</p>
<p>因此，对接口的设计需要相当谨慎，要确保互斥量能锁住任何对保护数据的访问，并且“不留后门”。</p>
<p>例如，在下面的程序当中，我们通过引用把被保护数据传递到互斥锁作用于之外，从而造成一个潜在的陷阱：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">some_data</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    string b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;You are a fool man😄...\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">data_wrapper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    some_data data;</span><br><span class="line">    std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">process_data</span><span class="params">(Function func)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">l</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="built_in">func</span>(data); <span class="comment">// 传递“保护”数据给用户函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">some_data *unprotected;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">malicious_function</span><span class="params">(some_data&amp; protected_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unprotected = &amp;protected_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data_wrapper x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.<span class="built_in">process_data</span>(malicious_function);</span><br><span class="line">    <span class="comment">// 现在，我么将一个被保护的数据拿出来了，并且可以随意处理</span></span><br><span class="line">    unprotected-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">Foo</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-mutex"><a href="#3-2-mutex" class="headerlink" title="3.2 mutex"></a>3.2 mutex</h3><h4 id="3-2-1-RC-between-interface"><a href="#3-2-1-RC-between-interface" class="headerlink" title="3.2.1 RC between interface"></a>3.2.1 RC between interface</h4><p>使用互斥量对数据进行保护并不能万事大吉。</p>
<p>例一：删除双链表中的一个节点</p>
<blockquote>
<p>当我们要删除双链表中的节点 <code>P</code> 时，仅仅对 P 添加互斥量是不行的，还需要对 <code>P-&gt;next</code>, <code>P-&gt;prev</code> 同时添加互斥锁。</p>
</blockquote>
<p>例二：堆栈</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s.<span class="built_in">empty</span>()) <span class="comment">// (1)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> value = s.<span class="built_in">top</span>(); <span class="comment">// (2)</span></span><br><span class="line">        s.<span class="built_in">pop</span>();             <span class="comment">// (3)</span></span><br><span class="line">        <span class="built_in">do_something</span>(value); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，当堆栈非空时，我们希望从中取出栈顶素，再调用 <code>pop()</code>，但其实 (1) 和 (2) 之间是有竞争条件的，也就是说，可能存在一个线程在 (1) 与 (2) 之间也掉用了 <code>pop()</code>。</p>
<p>另一个潜在的竞争条件发正在 (2) 和 (3) 之间，可能有两个线程先后执行了 <code>top()</code>，但没有执行 <code>pop()</code>，此时两个线程处理后 <code>value</code> 的值可能是相同的，这种错误很难定位，因为程序没有出错，出错的是你的逻辑。</p>
<blockquote>
<p>这就需要接口设计上有较大的改动，提议之一就是使用同一互斥量来保护 top()和 pop()。Tom Cargill[1]指出当一个对象的拷贝构造函数在栈中抛出一个异常，这样的处理方式就会有问题。在 Herb Sutter[2]看来，这个问题可以从“异常安全”的角度完美解决，不过潜在的条件竞争，可能会组成一些新的组合。</p>
</blockquote>
<p>一个很有意思的事情是，我们可能不得不面临例二中的竞争条件。在堆栈的 pop 操作中（有返回值），如果我们直接把容器元素 ”移动“ 到目标位置，可能会因为 <code>bad_alloc</code> 异常，也就是内存不足而导致数据没有拷贝出去，并且栈中的数据也杯破坏了。</p>
<p>因此，设计人员通常把这个操作操作分为两部分：</p>
<ol>
<li>top()</li>
<li>pop()</li>
</ol>
<p>由此来确保数据不会在内存不足时出错，但我们之前讨论过了，在 1 和 2 之间，有竞争条件。</p>
<p>但幸好，我们还有其它选项，尽管他们也不是完美的。</p>
<p><strong>solution1：将变量的引用作为参数，传入 pop() 函数中取得想要的”弹出值“</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; stk;</span><br><span class="line"><span class="comment">/*------------------------*/</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">stk.<span class="built_in">pop</span>(result);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种方法有明显的缺点：</p>
<ol>
<li>需要构造出一个栈中类型的实例用于接受目标值，这会导致空间和空间的额外开销等</li>
<li>要求类型必须支持赋值操作，很多类型即使支持移动构造和拷贝构造，可能也不支持赋值</li>
</ol>
</blockquote>
<p><strong>solution2：无异常抛出的拷贝构造函数或移动构造函数</strong></p>
<p><strong>solution3：返回指向弹出值的指针</strong></p>
<p><strong>solution4：“选项1 + 选项2”或 “选项1 + 选项3”</strong></p>
<p><strong>Example： thread safe stack</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">empty_stack</span> : exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[Error] empty stack!&quot;</span>; <span class="comment">// 不要添加格式控制符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsaft_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsaft_stack</span>() : <span class="built_in">data</span>(std::<span class="built_in">stack</span>&lt;T&gt;()) &#123;&#125;</span><br><span class="line">    <span class="built_in">threadsaft_stack</span>(<span class="type">const</span> threadsaft_stack &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在函数体而不是成员初始化列表中copy可以确保数据的正确性</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;</span><br><span class="line">        data = other.m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不提供太多接口</span></span><br><span class="line">    threadsaft_stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsaft_stack &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        data.<span class="built_in">push</span>(new_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>())    <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();    <span class="comment">// 检查是否为空</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在修改的堆栈前，分配出返回值</span></span><br><span class="line">        <span class="function"><span class="type">const</span> std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(std::make_shared&lt;T&gt;(data.top())))</span></span>;</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>())    <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">        <span class="comment">// 注意下面调用的都是 stack 的内置函数</span></span><br><span class="line">        value = data.<span class="built_in">top</span>();</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;T&gt; data;</span><br><span class="line">    std::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    threadsaft_stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++ )  s.<span class="built_in">push</span>(i);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;push done&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    s.<span class="built_in">pop</span>(x);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">Foo</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实本质上就是将原本的两个函数（top 和 pop）实现的操作集成到一个函数（pop）当中，这样就可以通过互斥量完成数据的保护。</p>
<p>通过一个函数修改我们的参数，很自然的有两种方式，一是返回值，而是传引用。</p>
<p>在返回值这种方式中，return 一个引用是危险的，这我们前面提到过。直接 return 值的话开销可能很大，因此我们考虑传出一个动态对象，而手动 new&#x2F;delete 不安全，因此使用智能指针。</p>
</blockquote>
<h4 id="3-2-2-deadlock"><a href="#3-2-2-deadlock" class="headerlink" title="3.2.2 deadlock"></a>3.2.2 deadlock</h4><p>避免死锁的方法：</p>
<ol>
<li>指定获得锁的顺序</li>
<li>一次性加全部锁</li>
<li>…</li>
</ol>
<p>C++ 标准库的 <code>std::lock</code> 可以一次性锁住多个互斥量并且没有死锁风险。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bank_account</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">bank_account</span><span class="params">(<span class="type">int</span> _balance)</span> : balance(_balance) &#123;</span>&#125;</span><br><span class="line">    <span class="type">int</span> balance;</span><br><span class="line">    std::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less_amount</span> : std::exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Too little money in your amount ^ ^ !&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transfer</span><span class="params">(bank_account &amp;from, bank_account &amp;to, <span class="type">int</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;from == &amp;to)    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(from.balance &lt; amount)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span>(<span class="built_in">less_amount</span>());</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">lock</span>(from.m, to.m);</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock1</span><span class="params">(from.m, std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock2</span><span class="params">(to.m, std::adopt_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    from.balance -= amount;</span><br><span class="line">    to.balance += amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">bank_account <span class="title">my_account</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">bank_account <span class="title">your_account</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(transfer, std::ref(my_account), std::ref(your_account), <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(transfer, std::ref(your_account), std::ref(my_account), <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(transfer, std::ref(my_account), std::ref(my_account), <span class="number">100</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;my_account.balance = &quot;</span> &lt;&lt; my_account.balance &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;your_account.balance = &quot;</span> &lt;&lt; your_account.balance &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然规定一个获得锁的顺序可以避免死锁，但他不是万能的，甚至说，会起到适得其反的效果，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bank_account</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">bank_account</span><span class="params">(<span class="type">int</span> _balance)</span> : balance(_balance) &#123;</span>&#125;</span><br><span class="line">    <span class="type">int</span> balance;</span><br><span class="line">    std::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less_amount</span> : std::exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Too little money in your amount ^ ^ !&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bank_swap</span><span class="params">(bank_account &amp;from, bank_account &amp;to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;from == &amp;to)    <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::lock(from.m, to.m);</span></span><br><span class="line">    from.m.<span class="built_in">lock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I get From, balance: &quot;</span> &lt;&lt; from.balance &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);   </span><br><span class="line">    </span><br><span class="line">    to.m.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock1</span><span class="params">(from.m, std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock2</span><span class="params">(to.m, std::adopt_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(from.balance, to.balance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">bank_account <span class="title">my_account</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">bank_account <span class="title">your_account</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(bank_swap, std::ref(my_account), std::ref(your_account))</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(bank_swap, std::ref(your_account), std::ref(my_account))</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;my_account.balance = &quot;</span> &lt;&lt; my_account.balance &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;your_account.balance = &quot;</span> &lt;&lt; your_account.balance &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们虽然在 <code>swap()</code> 中规定了获得锁的顺序，但是如果我们交换了 <code>swap()</code> 的参数顺序，那么结果就很可怕了！</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/lock_tag">std::defer_lock, std::try_to_lock, std::adopt_lock</a></p>
<table>
<thead>
<tr>
<th><code>defer_lock_t</code></th>
<th>不获得互斥的所有权</th>
</tr>
</thead>
<tbody><tr>
<td>try_to_lock_t</td>
<td>尝试获得互斥的所有权而不阻塞</td>
</tr>
<tr>
<td>adopt_lock_t</td>
<td>假设调用方线程已拥有互斥的所有权</td>
</tr>
</tbody></table>
</blockquote>
<p><strong>Advise to avoid deadlock：</strong></p>
<ol>
<li>避免嵌套锁，尽量只使用一个锁</li>
<li>避免在持有锁时调用用户提供的代码</li>
<li>使用固定顺序获取锁</li>
<li>使用层级锁</li>
</ol>
<h4 id="3-2-3-hierarchical-mutex"><a href="#3-2-3-hierarchical-mutex" class="headerlink" title="3.2.3 hierarchical_mutex"></a>3.2.3 hierarchical_mutex</h4><blockquote>
<p> <a target="_blank" rel="noopener" href="https://mysteriouspreserve.com/blog/2021/09/15/Hierarchical-Mutex/">reference</a></p>
</blockquote>
<p>层级锁的意义在于：在运行时约定是否进行检查，这个建议需要对应用层进行分层，并且识别在给定层上所有互斥量。</p>
<p>层级锁的核心就是：每个互斥量有一个层级值，线程只能以层级值递减的顺序获取锁，由此实现顺序性。</p>
<p>**Sample complement: **</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hierarchical_mutex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">hierarchical_mutex</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> value)</span></span></span><br><span class="line"><span class="function">        : hierarchichy_value(value), </span></span><br><span class="line"><span class="function">          previous_hierarchichy_value(<span class="number">0</span>)</span></span><br><span class="line"><span class="function">        &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">        internal_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">// 备份层级值</span></span><br><span class="line">        <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 恢复层级值</span></span><br><span class="line">        this_thread_hierarchy_value = previous_hierarchichy_value;</span><br><span class="line">        internal_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">        <span class="keyword">if</span>(!internal_mutex.<span class="built_in">try_lock</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex internal_mutex;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 需要构造的锁的层级值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hierarchichy_value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this_thread_hierarchy_value 的备份</span></span><br><span class="line">    <span class="comment">// 因为在 unlock 之后需要恢复上一次的值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> previous_hierarchichy_value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前的层级值，第二个锁的层级值必须小于该值</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">long</span> this_thread_hierarchy_value; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_for_hierarchy_violation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 如果需要构造的锁的层级值大于等于当前锁的层级值，不合法</span></span><br><span class="line">        <span class="keyword">if</span>(this_thread_hierarchy_value &lt;= hierarchichy_value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;mutex hierarchy violated&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update_hierarchy_value</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 更新当前锁的层级值</span></span><br><span class="line">        previous_hierarchichy_value = this_thread_hierarchy_value;</span><br><span class="line">        this_thread_hierarchy_value = hierarchichy_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能加 static</span></span><br><span class="line"><span class="function"><span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title">hierarchical_mutex::this_thread_hierarchy_value</span><span class="params">(ULONG_MAX)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">m1</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">m2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;F2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">lock_guard&lt;hierarchical_mutex&gt; <span class="title">lock</span><span class="params">(m1)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;F1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">lock_guard&lt;hierarchical_mutex&gt; <span class="title">lock</span><span class="params">(m2)</span></span>;</span><br><span class="line">    <span class="built_in">f2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">f1</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>初始化 static 成员时不能加 static，避免与 class 之外的 static 变量混淆</li>
<li>为什么将 this_thread_hierarchy_value 设置为 thread_local static ? 只有这样才能实现动态更新层级，当我们更新了 this_thread_hierarchy_value 的值之后，下一个创建的 hierarchical_mutex 对象使用的是更新之后的值。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Foo::x</span><span class="params">(<span class="number">1024</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo f;</span><br><span class="line">    cout &lt;&lt; f.x &lt;&lt; endl;    <span class="comment">// 1024</span></span><br><span class="line">    f.x = <span class="number">233</span>;</span><br><span class="line">    cout &lt;&lt; f.x&lt;&lt; endl;     <span class="comment">// 233</span></span><br><span class="line">    Foo g;</span><br><span class="line">    cout &lt;&lt; g.x &lt;&lt; endl;    <span class="comment">// 233</span></span><br><span class="line">    cout &lt;&lt; Foo::x &lt;&lt; endl; <span class="comment">// 233</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="3-2-4-std-uniqie-lock"><a href="#3-2-4-std-uniqie-lock" class="headerlink" title="3.2.4 std::uniqie_lock"></a>3.2.4 std::uniqie_lock</h4><p>对 swap 函数的改写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bank_account</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">bank_account</span><span class="params">(<span class="type">int</span> balance)</span> : balance&#123;</span>balance&#125; &#123;&#125;</span><br><span class="line">    <span class="type">int</span> balance;</span><br><span class="line">    std::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_swap</span><span class="params">(bank_account &amp;from, bank_account &amp;to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;from == &amp;to) <span class="keyword">return</span>; <span class="comment">// avoid deadlock in case of self transfer</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将互斥量传入 unique 表示该互斥量应该保持解锁状态（不应该再被其他线程上锁）</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(from.m, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock_b</span><span class="params">(to.m, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="comment">// std::defer_lock 留下未上锁的互斥量</span></span><br><span class="line">    std::<span class="built_in">lock</span>(lock_a, lock_b);</span><br><span class="line">    std::<span class="built_in">swap</span>(from.balance, to.balance);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bank_account my_account&#123;<span class="number">100</span>&#125;;</span><br><span class="line">    bank_account your_account&#123;<span class="number">50</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    std::thread t1&#123;my_swap, std::<span class="built_in">ref</span>(my_account), std::<span class="built_in">ref</span>(your_account)&#125;;</span><br><span class="line">    std::thread t2&#123;my_swap, std::<span class="built_in">ref</span>(your_account), std::<span class="built_in">ref</span>(my_account)&#125;;</span><br><span class="line">    std::thread t3&#123;my_swap, std::<span class="built_in">ref</span>(my_account), std::<span class="built_in">ref</span>(your_account)&#125;;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;my_account.balance = &quot;</span> &lt;&lt; my_account.balance &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;your_account.balance = &quot;</span> &lt;&lt; your_account.balance &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="3-2-5-Passing-of-mutex-ownership-in-different-domains"><a href="#3-2-5-Passing-of-mutex-ownership-in-different-domains" class="headerlink" title="3.2.5  Passing of mutex ownership in different domains"></a>3.2.5  Passing of mutex ownership in different domains</h4><p><code>std::unique_lock</code> 实例没有与自身相关的互斥量，互斥量的所有权可以通过<strong>移动操作</strong>， 在不同的实例间传递。</p>
<p>… 看不懂在干啥 😭</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">get_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> std::mutex some_mutex;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(some_mutex)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;get_lock()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> lock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(get_lock())</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;process_data()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(process_data)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="3-2-5-Lock-Granularity"><a href="#3-2-5-Lock-Granularity" class="headerlink" title="3.2.5 Lock Granularity"></a>3.2.5 Lock Granularity</h4><p>锁的粒度用来描述通过一个锁保护着的数据量大小。一个细粒度锁(a fine-grained lock) 能够保护较小的数据量，一个粗粒度锁(a coarse-grained lock)能保护较多的数据量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// private:</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> some_detail;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_detail</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> some_detail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Y</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Y</span>(<span class="type">int</span> _sd) : <span class="built_in">some_detail</span>(_sd) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Y &amp;lhs, <span class="type">const</span> Y &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(&amp;lhs == &amp;rhs)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> lhs_value = lhs.<span class="built_in">get_detail</span>(); <span class="comment">// (1)</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I get lhs value:&quot;</span> &lt;&lt; lhs_value &lt;&lt; endl;;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 锁的粒度小，在得到lhs_value之后</span></span><br><span class="line">        <span class="comment">// rhs_value可能不是获取lhs_value瞬间的值</span></span><br><span class="line">        <span class="comment">// 他的值可能被修改</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> rhs_value = rhs.<span class="built_in">get_detail</span>();  <span class="comment">// (2)</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I get rhs value!: &quot;</span> &lt;&lt; rhs_value &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> lhs_value == rhs_value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::thread::id master_id;</span><br><span class="line"></span><br><span class="line">Y a[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(this_thread::<span class="built_in">get_id</span>() == master_id) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]I am master!: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; (a[<span class="number">0</span>] == a[<span class="number">1</span>] ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]I am slaver: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">            a[id].some_detail = <span class="built_in">rand</span>() % <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    a[<span class="number">0</span>].some_detail = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>].some_detail = <span class="number">2</span>;</span><br><span class="line">    <span class="function">thread <span class="title">master</span><span class="params">(process, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    master_id = master.<span class="built_in">get_id</span>();</span><br><span class="line">    cout &lt;&lt; master.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    thread slaver[<span class="number">2</span>];</span><br><span class="line">    slaver[<span class="number">0</span>] = <span class="built_in">thread</span>(process, <span class="number">0</span>);</span><br><span class="line">    slaver[<span class="number">1</span>] = <span class="built_in">thread</span>(process, <span class="number">1</span>);</span><br><span class="line">    master.<span class="built_in">join</span>();</span><br><span class="line">    slaver[<span class="number">0</span>].<span class="built_in">join</span>();</span><br><span class="line">    slaver[<span class="number">1</span>].<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-3-subsititute-of-shared-data-protect"><a href="#3-3-subsititute-of-shared-data-protect" class="headerlink" title="3.3 subsititute of shared data protect"></a>3.3 subsititute of shared data protect</h3><h4 id="3-3-1-protect-initialization-process-of-data"><a href="#3-3-1-protect-initialization-process-of-data" class="headerlink" title="3.3.1 protect initialization process of data"></a>3.3.1 protect initialization process of data</h4><p>假设我们有一个共享源，构建代价很昂贵，他可能会打开一个数据库连接或分配出很多的资源。</p>
<p>Lazy Initialization 在单线程代码中很常见 —— 没一个操作都需要对源进行检查，了解数据是否被初始化，然后在其使用前决定，数据是否需要初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">some_resources</span>;</span><br><span class="line">std::shared_ptr&lt;some_resources&gt; resources_ptr;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!resources_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// lazy initialization</span></span><br><span class="line">        resources_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resources);</span><br><span class="line">    &#125;</span><br><span class="line">    resources_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多线程中，一种大粒度锁方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">some_resources</span>;</span><br><span class="line">std::shared_ptr&lt;some_resources&gt; resources_ptr;</span><br><span class="line">std::mutex resource_mutex;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(resource_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!resources_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        resources_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resources);</span><br><span class="line">    &#125;</span><br><span class="line">    resources_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声名狼藉的“双重检查锁模式”:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resources&gt; resources_ptr;</span><br><span class="line">std::mutex resource_mutex;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!resources_ptr)	<span class="comment">// 第一次检查</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在 if 与加锁之间，resources_ptr 可能被修改了</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(resource_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(!resources_ptr) <span class="comment">// 第二次检查</span></span><br><span class="line">        &#123;</span><br><span class="line">            resources_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resources); <span class="comment">// (1)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resources_ptr-&gt;<span class="built_in">do_something</span>(); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个模式声名狼藉的原因在于，存在潜在的条件竞争。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf">具体的可以参考这里</a></p>
</blockquote>
<p>论文太长，我粗略的看了一下，我们知道，new 是分为两步的：</p>
<ol>
<li>operator new(size_of_object)</li>
<li>ctor</li>
<li>assign</li>
</ol>
<p>文章给出代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Singleton *<span class="title">Singleton::instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pInstance == <span class="number">0</span>) &#123;</span><br><span class="line">        Lock lock;</span><br><span class="line">        <span class="keyword">if</span> (pInstance == <span class="number">0</span>) &#123;</span><br><span class="line">            pInstance =               <span class="comment">// Step 3</span></span><br><span class="line">            <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(Singleton)); <span class="comment">// Step 1</span></span><br><span class="line">            <span class="keyword">new</span> (pInstance) Singleton;    <span class="comment">// Step 2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文章的意思应该是，在 ctor 之前，对象还没被构建，此时指向它的指针为空，即使 ctor 完成了，我们还需要将其地址赋值给指向它的指针，而在ctor与assign之间，指针依然为空。</p>
<p>指针为空就意味着，第二次检查不一定是有效的，也即，仍然可能有多个线程进入 (1) 从而破坏数据，并且行为是未定义的！</p>
<hr>
<p>为了解决这种条件竞争，C++ 标准库提供了 <code>std::once_flag</code> 和 <code>std::call_once</code> ，并且使用 <code>std::call_one</code> 比使用互斥量消耗的资源更少。</p>
<blockquote>
<p><code>std::call_once</code> : 顾名思义，可以准确执行一次 callable object，其通过 <code>std::once_flag</code> 来判断是否被执行过，如果多次调用，会抛出异常。</p>
<p>call_one 分为:</p>
<ol>
<li>active call：第一次调用</li>
<li>passive call：后序调用</li>
<li>exceptional call：抛出异常的调用，不会修改 once_flag</li>
</ol>
</blockquote>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::once_flag flag1, flag2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simple_do_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(flag1, []()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Simple example: call one\n&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">may_throw_function</span><span class="params">(<span class="type">bool</span> do_throw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(do_throw)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;throw: call once will retry\n&quot;</span>;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Do no throw: call once will not attempt retry\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_once</span><span class="params">(<span class="type">bool</span> do_throw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">call_once</span>(flag2, may_throw_function, do_throw);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;get exception\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">st1</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">st2</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">st3</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">st4</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    st1.<span class="built_in">join</span>();</span><br><span class="line">    st2.<span class="built_in">join</span>();</span><br><span class="line">    st3.<span class="built_in">join</span>();</span><br><span class="line">    st4.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(do_once, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t4</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Foo</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此，可以将上面的例子修改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr;</span><br><span class="line">std::once_flag resource_flag;  <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_resource</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	resource_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::<span class="built_in">call_once</span>(resource_flag,init_resource); <span class="comment">// 可以完整的进行一次初始化</span></span><br><span class="line">	resource_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    std::once_flag flag;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;do once&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        std::<span class="built_in">call_once</span>(flag, &amp;X::do_once, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f2&quot;</span> &lt;&lt; endl;</span><br><span class="line">        std::<span class="built_in">call_once</span>(flag, &amp;X::do_once, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X x;</span><br><span class="line">    x.<span class="built_in">f1</span>();</span><br><span class="line">    x.<span class="built_in">f2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Foo</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1</span><br><span class="line">do once</span><br><span class="line">f2</span><br></pre></td></tr></table></figure>

<hr>
<p>局部 static 变量的线程安全的初始化方式（<code>std::call_once</code> 的替代方案）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span>;</span><br><span class="line"><span class="function">my_class&amp; <span class="title">get_my_class_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> my_class instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化和定义完全在一个线程中发生，并且没有其他线程可在初始化完成前对其进行处理。</p>
<p>其实这个就是例子设计模式(<strong>Singleton</strong>)的思路，让 static 变量在函数内部完成初始化，从而使得调用该对象时，该对象一定被初始化。</p>
<p>但是为什么呢？</p>
<p>其实主要是因为<strong>“C++只能保证在同一个文件中声明的static变量的初始化顺序与其变量声明的顺序一致。但是不能保证不同的文件中的static变量的初始化顺序。”</strong></p>
<p>然后对于单例模式而言，不同的单例对象之间进行调用也是常见的场景。比如我有一个单例，存储了程序启动时加载的配置文件的内容。另外有一个单例，掌管着一个全局的日志管理器。在日志管理初始化的时候，要通过配置文件的单例对象来获取到某个配置项，实现日志打印。</p>
<p>这时候两个单例在不同文件中各自实现，很有可能在日志管理器的单例使用配置文件单例的时候，配置文件的单例对象是没有被初始化的。这个未初始化可能产生的风险指的是C++变量的未初始化，而不是说配置文件未加载的之类业务逻辑上的未初始化导致的问题。</p>
<p>而<code>Meyers&#39; Singleton</code>写法中，单例对象是次访问的时候（也就是次调用<code>getInstance()</code>函数的时候）才初始化的，但也是恰恰因为如此，因而能保证如果没有初始化，在该函数调用的时候，是能完成初始化的。所以先<code>getInstance()</code>再访问 这种形式的单例 其关键并不是在于这个形式。而是在于其内容，局部static变量能保证通过函数来获取static变量的时候，该函数返回的对象是肯定完成了初始化的！</p>
<p>另外，该写法需要 C++11 的支持，因为在 C++11 之后，static 变量的初始化是线程安全的。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://z.itpub.net/article/detail/DC3250F681713244F01A546413CC2828">「详细信息参考这里—reference」</a></p>
</blockquote>
<h4 id="3-3-2-protect-data-struct-which-updatelessly"><a href="#3-3-2-protect-data-struct-which-updatelessly" class="headerlink" title="3.3.2 protect data struct which updatelessly"></a>3.3.2 protect data struct which updatelessly</h4><p>对于更新比较少，读取频繁的数据结构，使用 <code>std::mutex</code> 显得有些反应过激了，因为在没有修改时，它将削弱并发读取数据的可能性，因此，这里需要一种不同的互斥量 – 读写锁：一个“写”线程独立访问，多个 “读” 线程并发访问。</p>
<p>C++ 标准库暂时没有提供“读者-写者锁”，但是 Boost 库提供了支持 <code>boost::shared_lock</code> (读写锁)，通常用于读操作比较频繁的，而写操作比较少的情况。</p>
<p>读写锁比起mutex具有更高的适用性，具有更高的并行性，可以有多个线程同时占用读模式的读写锁，但是只能有一个线程占用写模式的读写锁，读写锁的基本规则可以总结为<strong>“write first，read shared，cross mutex(交叉互斥)”</strong>，具体表现为读写锁的三种状态：</p>
<ol>
<li>当读写锁是写加锁状态时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞。（交叉互斥）</li>
<li>当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是以写模式对它进行加锁的线程将会被阻塞。（读共享，交叉互斥）</li>
<li>当读写锁在读模式的锁状态时，如果有另外的线程试图以写模式加锁，读写锁通常会阻塞随后的读模式锁的请求，这样可以避免读模式锁长期占用，而等待的写模式锁请求则长期阻塞。（写优先）</li>
</ol>
<p>注：其实在读者-写者问题中，有读者优先和写者优先两种模式，只是在 <strong>shared_mutex which in boost library default complement in writing first</strong>，这其实也是有道理的，<strong>because we always want to read the least data</strong>，这就得保证写者优先。</p>
<p>例子：模拟 dns 缓存的修改和查询</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/thread/shared_mutex.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dns_entry</span></span><br><span class="line">&#123;</span><br><span class="line">    string domain;</span><br><span class="line">    string ip_addr;</span><br><span class="line">    <span class="comment">/*....*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dns_cache</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;std::string, dns_entry&gt; entries;   <span class="comment">// 缓存 dns 数据</span></span><br><span class="line">    <span class="keyword">mutable</span> boost::shared_mutex entry_mutex;    <span class="comment">// 对数据进行保护</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// from domin name to IP addr</span></span><br><span class="line">    <span class="function">dns_entry <span class="title">find_entry</span><span class="params">(<span class="type">const</span> std::string &amp;domain)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">boost::shared_lock&lt;boost::shared_mutex&gt; <span class="title">lk</span><span class="params">(entry_mutex)</span></span>; <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">auto</span> it = entries.<span class="built_in">find</span>(domain);</span><br><span class="line">        <span class="keyword">return</span> (it == entries.<span class="built_in">end</span>()) ? <span class="built_in">dns_entry</span>() : it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update_or_addr_entry</span><span class="params">(<span class="type">const</span> std::string &amp;domain, <span class="type">const</span> dns_entry &amp;dns_details)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;boost::shared_mutex&gt; <span class="title">lock</span><span class="params">(entry_mutex)</span></span>; <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="comment">// or add unique_lock&lt;boost::shared_mutex&gt;</span></span><br><span class="line">        entries[domain] = dns_details;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="3-3-3-nested-lock"><a href="#3-3-3-nested-lock" class="headerlink" title="3.3.3 nested lock"></a>3.3.3 nested lock</h4><p><code>std::recursive_mutex</code></p>
<h2 id="P4-synchronization"><a href="#P4-synchronization" class="headerlink" title="P4 synchronization"></a>P4 synchronization</h2><p>单单将数据保护起来并不能满足我们的需求。通常情况下，我们还想对单独的线程进行同步。例如，某个线程作为另一个线程的输入。</p>
<p>通过条件变量(<strong>condition variables</strong>)和期望(<strong>futures</strong>)实现线程之间的同步。</p>
<h3 id="4-1-wait-event-or-condition"><a href="#4-1-wait-event-or-condition" class="headerlink" title="4.1 wait event or condition"></a>4.1 wait event or condition</h3><h4 id="4-1-1-introduce"><a href="#4-1-1-introduce" class="headerlink" title="4.1.1 introduce"></a>4.1.1 introduce</h4><p>情景：我们需要等待一个事件。</p>
<p>最笨的方法是一直加锁，然后时间来临之后，处理事件，解锁。但是这种方法是很低效的，因为等待事件时我们持有锁但什么也不做。</p>
<p>进步的方法是下面这种（<code>std::this_thread::sleep_for()</code>），每隔一段时间就进行一次检查，但是这种方法的问题是，很难确定中间间隔的时间，太短或者太长了都不好！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/thread/shared_mutex.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag;</span><br><span class="line">std::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait_for_flag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(!flag)</span><br><span class="line">    &#123;</span><br><span class="line">        lk.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));    <span class="comment">// 100ms</span></span><br><span class="line">        lk.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">wait_for_flag</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好的办法就是使用条件变量，当时间发生时，广播“条件达成”的信息，由此出发等待该事件的线程。</p>
<h4 id="4-1-2-condition-variable"><a href="#4-1-2-condition-variable" class="headerlink" title="4.1.2 condition variable"></a>4.1.2 condition variable</h4><p>C++标准库对条件变量有两套实现：<code>std::condition_variable</code>和<code>std::condition_variable_any</code>。这两个实现都包含在<code>&lt;condition_variable&gt;</code>头文件的声明中。两者都需要与一个互斥量一起才能工作(互斥量是为了同步)；前者仅限于与<code>std::mutex</code>一起工作，而后者可以和任何满足最低标准的互斥量一起工作，从而加上了*_any*的后缀。因为<code>std::condition_variable_any</code>更加通用，这就可能从体积、性能，以及系统资源的使用方面产生额外的开销，所以<code>std::condition_variable</code>一般作为首选的类型，当对灵活性有硬性要求时，我们才会去考虑<code>std::condition_variable_any</code>。</p>
<p>下面是使用 <code>std::condition_variable</code> 处理等待数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">data_chunk</span> &#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">more_data_to_prepare</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> data_chunk&amp; <span class="title">prepare_data</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_last_chunk</span><span class="params">(<span class="type">const</span> data_chunk&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(data_chunk&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">std::mutex mut;</span><br><span class="line">std::queue&lt;data_chunk&gt; data_queue;</span><br><span class="line">std::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">more_data_to_prepare</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> data_chunk data = <span class="built_in">prepare_data</span>();</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(data);</span><br><span class="line">        data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">data_preocessing_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lock, []&#123; <span class="comment">// (1) 在这上锁 类似 try_lock</span></span><br><span class="line">            <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        data_chunk data = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        lock.<span class="built_in">unlock</span>();	<span class="comment">// (2) 记得解锁</span></span><br><span class="line">        <span class="built_in">process</span>(data);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">is_last_chunk</span>(data))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 (1) 中，如果条件不满足(<code>lambda</code> 返回 <code>false</code>)，<code>wait()</code> 函数将解锁互斥量，并将这个线程置于阻塞或等待状态。</p>
<p>当在 <code>data_preparation_thread</code> 中调用 <code>notify_one</code> 通知条件变量之后，处理数据的线程从睡眠状态中苏醒，重新获得互斥锁，并且对条件再次检查，当条件不满足时，线程将对互斥量解锁，并且重新开始等待，当条件满足时，从 <code>wait()</code> 返回并继续持有锁。</p>
<blockquote>
<p>注意在唤醒之后需要再次检查条件，因为可能还有其他线程也被唤醒，此时会有竞争。这就是所谓的**伪唤醒(spurious wakeup)**，</p>
</blockquote>
<p>这也是为甚么要使用 <code>std::unique_lock</code> 而不是 <code>std::lock_guard</code> 的原因 —— 等待中的线程必须在等待期间解锁互斥量，并在这之后对互斥量再次上锁，而 <code>std::lock_guard</code> 没有这么灵活。</p>
<blockquote>
<p>其实这也说明了 <code>std::unique_lock</code> 的主要用途 —— 和 <code>std::condition_variable</code> 配合使用，做到多次 <code>lock()</code> 和 <code>unlock()</code>。</p>
</blockquote>
<h4 id="4-1-3-thread-safety-queue"><a href="#4-1-3-thread-safety-queue" class="headerlink" title="4.1.3 thread safety queue"></a>4.1.3 thread safety queue</h4><p><code>std::queue</code> 接口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Container</span> = std::deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">queue</span>(<span class="type">const</span> Container&amp;);</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">queue</span><span class="params">(Container&amp;&amp; = Container())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="function"><span class="keyword">explicit</span> <span class="title">queue</span><span class="params">(<span class="type">const</span> Alloc&amp;)</span></span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="built_in">queue</span>(<span class="type">const</span> Container&amp;, <span class="type">const</span> Alloc&amp;);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="built_in">queue</span>(Container&amp;&amp;, <span class="type">const</span> Alloc&amp;);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="built_in">queue</span>(queue&amp;&amp;, <span class="type">const</span> Alloc&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(queue &amp;q)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T&amp;&amp; x)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt; <span class="type">void</span> <span class="title">emplace</span><span class="params">(Args&amp;&amp;... args)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>线程安全的队列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mut; <span class="comment">// 互斥量必须是可变的</span></span><br><span class="line">    std::queue&lt;T&gt; data_queue;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_queue</span>(<span class="type">const</span> threadsafe_queue&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;std::mutex&gt; <span class="title">my_lock</span><span class="params">(mut)</span></span>;    <span class="comment">// 为什么不对自己上锁呢？</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.mut)</span></span>;</span><br><span class="line">        data_queue = other.data_queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_queue</span>(threadsafe_queue&amp;&amp; other) <span class="comment">// 自己写的，可能有误？</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;std::mutex&gt; <span class="title">my_lock</span><span class="params">(mut)</span></span>;    <span class="comment">// 为什么不对自己上锁呢？</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.mut)</span></span>;</span><br><span class="line">        data_queue = <span class="built_in">move</span>(other.data_queue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    threadsafe_queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_queue&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(new_value);</span><br><span class="line">        data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T &amp;value)</span> <span class="comment">// 通过传引用获得 front 并 pop</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 防止 front-pop 接口之间存在的竞争条件</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = data_queue.<span class="built_in">front</span>(); <span class="comment">// get value</span></span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();    <span class="comment">// NULL</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        value = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        std::shared_ptr&lt;T&gt; res = (std::<span class="built_in">make_shared</span>&lt;T&gt;(data_queue.<span class="built_in">front</span>()));</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data_queue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line"></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同之前提到的一样，当我们执行 <code>front()-pop()</code> 时，会有接口之间的条件竞争，因此我们需要将这两个函数放到同一个函数中。</p>
<h3 id="4-2-future"><a href="#4-2-future" class="headerlink" title="4.2 future"></a>4.2 future</h3><h4 id="4-2-1-introdece"><a href="#4-2-1-introdece" class="headerlink" title="4.2.1 introdece"></a>4.2.1 introdece</h4><p>C++ 标准库模型将这种一次性事件成为**期望(future)**。当事件发生时，这个“期望”就不能被重置。</p>
<p>在C++标准库中，有两种“期望”，使用两种类型模板实现，声明在头文件中: 唯一<em>期望</em>(unique futures)(<code>std::future&lt;&gt;</code>)和<em>共享期望</em>(shared futures)(<code>std::shared_future&lt;&gt;</code>)。这是仿照<code>std::unique_ptr</code>和<code>std::shared_ptr</code>。<code>std::future</code>的实例只能与一个指定事件相关联，而<code>std::shared_future</code>的实例就能关联多个事件。后者的实现中，所有实例会在同时变为就绪状态，并且他们可以访问与事件相关的任何数据。这种数据关联与模板有关，比如<code>std::unique_ptr</code> 和<code>std::shared_ptr</code>的模板参数就是相关联的数据类型。在与数据无关的地方，可以使用<code>std::future&lt;void&gt;</code>与<code>std::shared_future&lt;void&gt;</code>的特化模板。虽然，我希望用于线程间的通讯，但是“期望”对象本身并不提供同步访问。当多个线程需要访问一个独立“期望”对象时，他们必须使用互斥量或类似同步机制对访问进行保护，如在第3章提到的那样。不过，在你将要阅读到的4.2.5节中，多个线程会对一个<code>std::shared_future&lt;&gt;</code>实例的副本进行访问，而不需要期望同步，即使他们是同一个异步结果。</p>
<p>最基本的一次性事件，就是一个后台运行出的计算结果。在第2章中，你已经了解了<code>std::thread</code> 执行的任务不能有返回值，并且我能保证，这个问题将在使用“期望”后解决——现在就来看看是怎么解决的。</p>
<h4 id="4-2-2-background-task-with-return-value-—-async"><a href="#4-2-2-background-task-with-return-value-—-async" class="headerlink" title="4.2.2 background task with return value — async"></a>4.2.2 background task with return value — async</h4><p>假设，你现在有一个需要长时间的运算，你需要能计算出一个有效的值，但是你现在并不迫切需要这个值。因为 <code>std::thread</code> 并不提供接受返回值的机制，这里就需要 <code>std::async</code> 函数模板（也就是在 <code>&lt;future&gt;</code> 中声明）</p>
<p>当不着急得到任务的结果时，你可以使用 <code>std::async</code> 启动一个<strong>异步</strong>任务，与 <code>std::thread</code> 对象等待的方式不同，<code>std::async</code> 会返回一个 <code>std::future</code> 对象，这个对象持有最终计算出来的结果，你只需要调用这个对象的 <code>get()</code> 成员函数；并且会阻塞线程直到“期望”状态未就绪为止。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_the_answer_to_ltuae</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; the_answer = std::<span class="built_in">async</span>(find_the_answer_to_ltuae);</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The answer is &quot;</span> &lt;&lt; the_answer.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>std::thread</code> 方式一样，<code>std::async</code> 允许通过添加额外的调用参数，想函数传递额外的参数。</p>
<p>例如，第一个参数是指向成员函数的指针，第二个参数是提供这个函数成员类的具体对象。</p>
<p>和 <code>std::thread</code> 一样，当参数是右值时，拷贝操作将使用移动的方式转移原始数据。</p>
<p>我们还可以在调用之前向 <code>std::async</code> 传递一个额外参数，这个参数的类型是 <code>std::launch</code>，它提供了两种策略可供选择：</p>
<ul>
<li><code>std::launch::async</code> ：在调用 <code>std::async</code> 之后就开始创建线程</li>
<li><code>std::launch::deferred</code> ： 延迟加载方式创建线程。调用 <code>std::async</code> 不创建线程，直到调用了 <code>future</code> 的 <code>get()</code> 或者 <code>wait()</code> 时才创建线程。（<strong>lazy calculate</strong>）</li>
</ul>
<p>默认策略是 <code>std::launch::async | std::launch::deferred</code></p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> std::string&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        i ++ ;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;] id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">bar</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;] id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f1 和 f2 可能在 main 结束之后才执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过指向 x 的指针调用 foo</span></span><br><span class="line"><span class="keyword">auto</span> f1 = std::<span class="built_in">async</span>(&amp;X::foo, &amp;x, <span class="number">42</span>, <span class="string">&quot;f1&quot;</span>);</span><br><span class="line"><span class="comment">// 通过 x 的拷贝调用 bar</span></span><br><span class="line"><span class="keyword">auto</span> f2 = std::<span class="built_in">async</span>(&amp;X::bar, x, <span class="string">&quot;f2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=============================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; d &lt;&lt; std::endl;</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;] id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 y 的移动构造函数调用 operator()</span></span><br><span class="line"><span class="keyword">auto</span> f3 = std::<span class="built_in">async</span>(<span class="built_in">Y</span>(), <span class="string">&quot;f3&quot;</span>);</span><br><span class="line"><span class="comment">// 通过 y 的引用调用 operator()</span></span><br><span class="line"><span class="keyword">auto</span> f4 = std::<span class="built_in">async</span>(std::<span class="built_in">ref</span>(y), <span class="string">&quot;f4&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=============================================*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">move_only</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">move_only</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">move_only</span>(move_only&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">move_only</span>(<span class="type">const</span> move_only&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    move_only&amp; <span class="keyword">operator</span>=(move_only&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    move_only&amp; <span class="keyword">operator</span>=(<span class="type">const</span> move_only&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string s)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;] id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move only!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f5 = std::<span class="built_in">async</span>(<span class="built_in">move_only</span>(), <span class="string">&quot;f5&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=============================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在新线程上执行</span></span><br><span class="line"><span class="keyword">auto</span> f6 = std::<span class="built_in">async</span>(std::launch::async, <span class="built_in">Y</span>(), <span class="string">&quot;f6&quot;</span>);</span><br><span class="line"><span class="comment">// 在 wait() 或 get() 调用时执行</span></span><br><span class="line"><span class="keyword">auto</span> f7 = std::<span class="built_in">async</span>(std::launch::deferred, &amp;X::bar, std::<span class="built_in">ref</span>(x), <span class="string">&quot;f7&quot;</span>);</span><br><span class="line"><span class="comment">// 实现选择执行方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std::string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;] id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> f8 = std::<span class="built_in">async</span>(std::launch::deferred | std::launch::async, f, <span class="string">&quot;f8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">// f7.wait();</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; hex &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// f8.get();</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::future</code> 有三种状态：</p>
<ul>
<li><code>future_status::deferred</code>：异步操作还未完成</li>
<li><code>future_status::ready</code> ：异步操作已经完成</li>
<li><code>future_status::timeout</code> ：异步操作超时，主要用于 <code>std::future&lt;T&gt;.wait_for()</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;step1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;step2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;step3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    std::future_status status;</span><br><span class="line">    <span class="keyword">auto</span> f = std::<span class="built_in">async</span>(std::launch::deferred ,process);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        status = f.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(status == std::future_status::deferred) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;deferred&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// f.wait();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(status == std::future_status::timeout) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;timeout&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(status == std::future_status::ready) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;ready&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(status != std::future_status::ready);</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039083151">reference</a></p>
</blockquote>
<h4 id="4-2-3-task-and-future"><a href="#4-2-3-task-and-future" class="headerlink" title="4.2.3 task and future"></a>4.2.3 task and future</h4><p><code>std::packaged_task&lt;&gt;</code> 会将 <code>future</code> 与函数或可调用对象进行绑定。当调用 <code>package_task&lt;&gt;</code> 时，就会调用相关函数或可调用对象，当 <code>future</code> 状态未就绪时，会存储返回值。</p>
<p><code>std::packaged_task&lt;&gt;</code> 的模板参数是一个函数签名。我们传入对象的签名可以与模板参数中指定的签名不一致，但是必须能隐式转换到目标类型。</p>
<p>例如，一种便特化的 <code>packaged_task</code> 的意义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">packaged_task</span>&lt;std::<span class="built_in">string</span>(std::vector&lt;<span class="type">char</span>*&gt;, <span class="type">int</span>)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">packaged_task</span><span class="params">(Callable &amp;&amp;f)</span></span>;</span><br><span class="line">    <span class="function">std::future&lt;std::string&gt; <span class="title">get_future</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::vector&lt;<span class="type">char</span>*&gt;, <span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>std::packaged_task</code> 是一个可调用对象，可以封装在 <code>std::function</code> 对象中，从而作为汉城函数传递到 <code>std::thread</code> 对象中，或作为可调用物对象传递到另一个函数中或直接调用。</p>
<p>例子1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line">std::mutex m;</span><br><span class="line">std::deque&lt;std::packaged_task&lt;<span class="type">void</span>()&gt; &gt; tasks;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">gui_shutdown_message_received</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_and_process_gui_message</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gui_thread</span><span class="params">()</span>  <span class="comment">// 1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">gui_shutdown_message_received</span>())  <span class="comment">// 2</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">get_and_process_gui_message</span>();  <span class="comment">// 3</span></span><br><span class="line">    std::packaged_task&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">      <span class="keyword">if</span>(tasks.<span class="built_in">empty</span>())  <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      task=std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());  <span class="comment">// 5</span></span><br><span class="line">      tasks.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">task</span>();  <span class="comment">// 6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">gui_bg_thread</span><span class="params">(gui_thread)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function">std::future&lt;<span class="type">void</span>&gt; <span class="title">post_task_for_gui_thread</span><span class="params">(Func f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::packaged_task&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(f)</span></span>;  <span class="comment">// 7</span></span><br><span class="line">  std::future&lt;<span class="type">void</span>&gt; res=task.<span class="built_in">get_future</span>();  <span class="comment">// 8</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;  <span class="comment">// 9</span></span><br><span class="line">  tasks.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(task));  <span class="comment">// 10</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c++ reference 上的例子 2：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task_lambda</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">([](<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">return</span> a + b;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; res = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="built_in">task</span>(<span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;task_lambda: &quot;</span> &lt;&lt; res.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task_bind</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意下面packaged_task的函数签名对应的参数要与bind对应 </span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(std::bind(my_add, <span class="number">2</span>, <span class="number">11</span>))</span></span>;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; res = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="built_in">task</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;task_bind: &quot;</span> &lt;&lt; res.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(my_add)</span></span>;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; res = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="comment">// move 到线程当中</span></span><br><span class="line">    <span class="function">std::thread <span class="title">task_td</span><span class="params">(std::move(task), <span class="number">2</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">    task_td.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;task_thread: &quot;</span> &lt;&lt; res.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">task_lambda</span>();</span><br><span class="line">    <span class="built_in">task_lambda</span>();</span><br><span class="line">    <span class="built_in">task_thread</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释一下：<code>std::future&lt;int&gt; result = task.get_future();</code> 这条语句并不会导致 <code>task</code> 封装的可调用对象的执行，它仅仅是将 <code>task</code> 的返回值存储到 <code>result</code> 这个对象当中。</p>
<blockquote>
<p>参考： </p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/611029683">Zhihu</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/thread/packaged_task">Cpp-reference</a></p>
</blockquote>
<h4 id="4-2-4-std-promises"><a href="#4-2-4-std-promises" class="headerlink" title="4.2.4 std::promises"></a>4.2.4 std::promises</h4><p>cppreference 例1:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">accumulate</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;::iterator first, std::vector&lt;<span class="type">int</span>&gt;::iterator last, </span></span></span><br><span class="line"><span class="params"><span class="function">                std::promise&lt;<span class="type">int</span>&gt; accumulate_promise)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = std::<span class="built_in">accumulate</span>(first, last, <span class="number">0</span>);</span><br><span class="line">    accumulate_promise.<span class="built_in">set_value</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_work</span><span class="params">(std::promise&lt;<span class="type">void</span>&gt; barrier)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    barrier.<span class="built_in">set_value</span>(); <span class="comment">// 注释掉改行不会阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; accumulate_promise;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; accumulate_future = accumulate_promise.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="comment">// 加上 :: ，防止识别为 std::accumulate</span></span><br><span class="line">    <span class="function">std::thread <span class="title">work_thread</span><span class="params">(::accumulate, numbers.begin(), numbers.end(), std::move(accumulate_promise))</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// future::get() 将等待直至该 future 拥有合法结果并取得它</span></span><br><span class="line">    <span class="comment">// 无需在 get() 前调用 wait()</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; accumulate_future.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    work_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 primise&lt;void&gt; 在线程间对状态发信号</span></span><br><span class="line">    std::promise&lt;<span class="type">void</span>&gt; barrier;</span><br><span class="line">    std::future&lt;<span class="type">void</span>&gt; barrier_future = barrier.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">new_work_thread</span><span class="params">(do_work, std::move(barrier))</span></span>;</span><br><span class="line">    barrier_future.<span class="built_in">wait</span>();</span><br><span class="line">    new_work_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例2: 线程等待另一个线程的数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promise = std::<span class="built_in">promise</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> t1 = std::<span class="built_in">thread</span>([&amp;promise]&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread running\n&quot;</span>;</span><br><span class="line">        <span class="comment">// do something ~</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// write data and invoke the threads which are waiting for that</span></span><br><span class="line">        promise.<span class="built_in">set_value</span>(<span class="number">42</span>);	<span class="comment">// 注释掉改行会阻塞</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread end\n&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// block until get value</span></span><br><span class="line">    cout &lt;&lt; promise.<span class="built_in">get_future</span>().<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>[TODO]</strong></p>
<p>在这里我发现了一个神奇的事情，如果是按照上面的形式（例2）即，lambda 表达式的形式创建线程，如果不 set_value() 的话，future::wait() 会一直等待，而使用显式的函数则不会（例1），为什么呢？</p>
</blockquote>
<blockquote>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6300e02d0625#">JianShu</a></p>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/promise">Cpp-reference</a></p>
</blockquote>
<h4 id="4-2-5-exception-and-future"><a href="#4-2-5-exception-and-future" class="headerlink" title="4.2.5 exception and future"></a>4.2.5 exception and future</h4><p>如果我们抛出一个异常，那么这个异常会存储到 <code>future</code> 中，然后 <code>future</code> 的状态设置为 <code>ready</code>，之后调用 <code>get()</code> 会抛出已存储的异常。</p>
<blockquote>
<p>注意！标准并未规定重新抛出的这个异常是原对象还是一份拷贝，这取决于山西i安</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">my_sqrt</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;out of range ^ ^\n&quot;</span>;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;x &lt; 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将 promise 与 future 绑定起来</span></span><br><span class="line">    std::promise&lt;<span class="type">double</span>&gt; promise;</span><br><span class="line">    std::future&lt;<span class="type">double</span>&gt; future = promise.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pls input a number: &quot;</span>;</span><br><span class="line">        <span class="type">double</span> x;       </span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        promise.<span class="built_in">set_value</span>(<span class="built_in">my_sqrt</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(<span class="type">const</span> exception &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// promise.set_exception(current_exception());</span></span><br><span class="line">        promise.<span class="built_in">set_exception</span>(std::<span class="built_in">make_exception_ptr</span>(<span class="built_in">logic_error</span>(<span class="string">&quot;sqrt() error ^ ^&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; future.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="4-2-6-waiting-of-multiple-thread"><a href="#4-2-6-waiting-of-multiple-thread" class="headerlink" title="4.2.6 waiting of multiple thread"></a>4.2.6 waiting of multiple thread</h4><p>如果并行代码没办法让多个线程等待同一个事件， <code>std::shared_future </code>可以帮你解决这个问题。因为<code>future</code>是只 <strong>move</strong> 的，所以其所有权可以在不同的实例中互相传递，但只有一个实例可以获得特定的同步结果，而 <code>std::shared_future</code>实例是可 <strong>copy</strong> 的，所以多个对象可以引用同一关联期望值的结果。</p>
<p>例: std::shared_future</p>
<p><code>std::shared_future</code> 顾名思义，就是多个线程共享一个 <code>std::shared_future</code>。可用在一个线程传递数据给多个线程的时候，多个线程在自身的线程空间内通过 <code>std::shared_future</code> 共享一个 <code>future</code>，这是线程安全的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line">    <span class="keyword">auto</span> promise = std::<span class="built_in">promise</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> t1 = std::<span class="built_in">thread</span>([&amp;promise]&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread 1 running\n&quot;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">4</span>));</span><br><span class="line">        <span class="comment">// 写入数据，这回唤醒那些正在等待数据的线程</span></span><br><span class="line">        promise.<span class="built_in">set_value</span>(<span class="number">42</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread 1 end\n&quot;</span>; </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> shared_future = std::<span class="built_in">shared_future</span>&lt;<span class="type">int</span>&gt;(promise.<span class="built_in">get_future</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> t2 = std::<span class="built_in">thread</span>([shared_future]&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread 2 running\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取数据，如果数据还没准备好就会阻塞</span></span><br><span class="line">        <span class="comment">// 这里使用 std::printf 而不是 std::cout 是为了保证输出在同一行</span></span><br><span class="line">        std::<span class="built_in">printf</span>(<span class="string">&quot;thread: 2 %d\n&quot;</span>, shared_future.<span class="built_in">get</span>());</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread 2 end\n&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::<span class="built_in">printf</span>(<span class="string">&quot;Test: %d\n&quot;</span>, shared_future.<span class="built_in">get</span>());</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>std::shared_future::get</code> 可以无限次调用，而 <code>std::future::get</code> 仅能调用一次。</p>
<p><code>std::shared_future::get</code> 返回的一定是引用（模板参数是 <code>void</code> 的除外）</p>
</blockquote>
<p>在每一个<code>std::shared_future</code>的独立对象上成员函数调用返回的结果还是不同步的，所以为了在多个线程访问一个独立对象时，避免数据竞争，必须使用锁来对访问进行保护。优先使用的办法：为了替代只有一个拷贝对象的情况，可以让每个线程都拥有自己对应的拷贝对象。这样，当每个线程都通过自己拥有的<code>std::shared_future</code>对象获取结果，那么多个线程访问共享同步结果就是安全的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line">    <span class="comment">// 注意 promise 只能 set 一次</span></span><br><span class="line">    <span class="keyword">auto</span> promise = std::<span class="built_in">promise</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="keyword">auto</span> shared_future = std::<span class="built_in">shared_future</span>&lt;<span class="type">int</span>&gt;(promise.<span class="built_in">get_future</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;promise, shared_future](<span class="type">int</span> x)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; running\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(x)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; shared_future.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            promise.<span class="built_in">set_value</span>(x);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; end\n&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = std::<span class="built_in">thread</span>(f, i);</span><br><span class="line">        threads.<span class="built_in">push_back</span>(<span class="built_in">move</span>(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">printf</span>(<span class="string">&quot;Test: %d\n&quot;</span>, shared_future.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t : threads)  t.<span class="built_in">join</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-time-limited-wait"><a href="#4-3-time-limited-wait" class="headerlink" title="4.3 time limited wait"></a>4.3 time limited wait</h3><h4 id="4-3-1-introduce"><a href="#4-3-1-introduce" class="headerlink" title="4.3.1 introduce"></a>4.3.1 introduce</h4><p>Sometimes, it is needed to limited the wating time of the wait thread.</p>
<p>There are two ways to signated if timeout:</p>
<ol>
<li>time duration(relative): you are expected to signated a duration of time like: 30s</li>
<li>time point(absolute): you are expected to signated a concrete  time like: <code>[UTC] 17:40:15.034583458</code>, <code>2011-11-30</code></li>
</ol>
<p>The variable which used for relative time  suffixed by <code>_for</code>, and other used for absolute time suffixed by <code>_until</code></p>
<p>Before observe the usage of timeout funtion, let’s check the way to signated the time in C++</p>
<h4 id="4-3-2-clock"><a href="#4-3-2-clock" class="headerlink" title="4.3.2 clock"></a>4.3.2 clock</h4><p><code>#include &lt;chrono&gt;</code></p>
<p>对于 C++ 来说，时钟就是时间信息源。并且，时钟是一个 <code>class</code>，提供了四种不同的信息：</p>
<ol>
<li>当前时间：<code>std::chrono::system_clock::now()</code> 会返回系统的当前时间，它属于 <code>time point</code>.</li>
<li>时间类型</li>
<li>时钟节拍：<code>std::chrono::high_resolution_clock</code> 可能是标准库中提供的具有最小节拍周期（因此具有最高的精度）的时钟。</li>
<li>稳定时钟：<code>std::chrono::steady_clock</code></li>
</ol>
<h4 id="4-3-3-ratio"><a href="#4-3-3-ratio" class="headerlink" title="4.3.3 ratio"></a>4.3.3 ratio</h4><p>先介绍一下 <code>std::ratio</code>，他定义在 <code>&lt;ratio&gt;</code> 头文件当中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">intmax_t</span> N, <span class="type">intmax_t</span> D = <span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">class</span> ratio &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> ratio&lt;num, den&gt; type;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">intmax_t</span> num;  <span class="comment">// 分子</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">intmax_t</span> den;  <span class="comment">// 分母</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>具体的可以参考 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/header/ratio">cppreference</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span> <span class="comment">// !</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="keyword">using</span> two_third = std::ratio&lt;<span class="number">2</span>, <span class="number">3</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> one_six   = std::ratio&lt;<span class="number">1</span>, <span class="number">6</span>&gt;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">using</span> sum = std::ratio_add&lt;two_third, one_six&gt;;</span><br><span class="line">    <span class="comment">// exppect print 5/6</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2/3 + 1/6 = &quot;</span> &lt;&lt; sum::num &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; sum::den &lt;&lt; endl;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-4-literal"><a href="#4-3-4-literal" class="headerlink" title="4.3.4 literal"></a>4.3.4 literal</h4><p>在 C++14 中的 <code>namespace std::chrono_literals</code> 中预定义了许多后缀操作符用来表示时长中的常用单位来简化代码。同样，还用用于表示字符串的 <code>namespace std::string_literals</code> 等。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// d 和 y 是 C++20 提供的</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> string_literals;</span><br><span class="line">    <span class="keyword">auto</span> one_day = <span class="number">24</span>h;</span><br><span class="line">    <span class="keyword">auto</span> half_an_hour = <span class="number">30</span>min;</span><br><span class="line">    <span class="keyword">auto</span> half_a_minuter = <span class="number">30</span>s;</span><br><span class="line">    <span class="comment">// 不常用的还有 ms（微秒）, us（微秒）, nm（纳秒）, </span></span><br><span class="line">    <span class="comment">// 1s = 1e3ms(毫秒) = 1e6us(微秒) = 1e9ns(纳秒) = 1e12ps(皮秒)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// auto 的类型是：</span></span><br><span class="line">    std::chrono::milliseconds ms = <span class="number">1</span>s;</span><br><span class="line">    cout &lt;&lt; ms.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> chrono_literals;</span><br><span class="line">    string s = <span class="string">&quot;hello&quot;</span>s; <span class="comment">// suffix by x</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test1</span>();</span><br><span class="line">    <span class="built_in">Test2</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-5-time-duration"><a href="#4-3-5-time-duration" class="headerlink" title="4.3.5 time duration"></a>4.3.5 time duration</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span> = std::ratio&lt;<span class="number">1</span>&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> duration;</span><br><span class="line"><span class="comment">// Rep: 表示计数的算数类型</span></span><br><span class="line"><span class="comment">// Period：表示计次周期的 std::ratio(即每秒的次数)</span></span><br></pre></td></tr></table></figure>

<p>通俗来讲，<code>Period</code> 指定的是 <code>duration</code> 的单位，默认是 <code>1s</code>,例如，如果 <code>Period</code> 指定的是 <code>ratio&lt;3600,1&gt;</code> ，那么单位就相当于 <code>h</code>，那么 <code>10</code> 个 <code>duration</code> 就是 <code>10h</code><br><code>Rep</code> 参数指定了传入的时间单位的类型，可以为 <code>float</code>, <code>int</code>, <code>int64</code> 等，如果为 <code>float</code> 则可以表示传入时间单位的“一部分”，比如传入 <code>1.2</code> 表示 <code>1.2</code> 倍个时间单位。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::chrono::duration;</span><br><span class="line">    <span class="keyword">using</span> std::chrono::duration_cast;</span><br><span class="line">    <span class="keyword">using</span> std::ratio;</span><br><span class="line"> </span><br><span class="line">    duration&lt;<span class="type">long</span> <span class="type">long</span>, ratio&lt;<span class="number">1</span>, <span class="number">1</span>&gt;&gt; tick_s&#123;<span class="number">15</span>&#125;; <span class="comment">// 15s</span></span><br><span class="line">    duration&lt;<span class="type">long</span> <span class="type">long</span>, ratio&lt;<span class="number">1</span>, <span class="number">1000</span>&gt;&gt; tick_ms&#123;<span class="number">15</span>&#125;; <span class="comment">// 1500ms</span></span><br><span class="line">    duration&lt;<span class="type">long</span> <span class="type">long</span>, ratio&lt;<span class="number">60</span>&gt;&gt; tick_min&#123;<span class="number">15</span>&#125;; <span class="comment">// 15min</span></span><br><span class="line">    duration&lt;<span class="type">float</span>, ratio&lt;<span class="number">3600</span>&gt;&gt; tick_h&#123;<span class="number">1.5</span>&#125;; <span class="comment">// 1.5h</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// count()方法可以返回我们设置的数值</span></span><br><span class="line">    cout &lt;&lt; tick_h.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;h&quot;</span> &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; tick_min.<span class="built_in">count</span>() &lt;&lt;  <span class="string">&quot;min&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// duration_cast </span></span><br><span class="line">    <span class="keyword">auto</span> min = <span class="built_in">duration_cast</span>&lt;std::chrono::minutes&gt;(tick_h);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1.5h = &quot;</span> &lt;&lt; min.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;min&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以隐式类型转换</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;15min = &quot;</span> &lt;&lt; chrono::<span class="built_in">seconds</span>(tick_min).<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以自定义转换类型</span></span><br><span class="line">    <span class="keyword">using</span> _day = duration&lt;<span class="type">double</span>, ratio&lt;<span class="number">24</span> * <span class="number">3600</span>&gt;&gt;;</span><br><span class="line">    <span class="keyword">auto</span> hour = duration&lt;<span class="type">long</span> <span class="type">long</span>, ratio&lt;<span class="number">3600</span>&gt;&gt;&#123;<span class="number">8</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;8h = &quot;</span> &lt;&lt; <span class="built_in">duration_cast</span>&lt;_day&gt;(hour).<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;day&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// duration 还可以支持算数运算和比较运算</span></span><br><span class="line">    <span class="comment">// 这里就不展示了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>例如：等待 <code>future</code> 状态变为就绪需要 35ms</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">task</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">40</span>ms);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f = std::<span class="built_in">async</span>(task);</span><br><span class="line">    <span class="keyword">if</span>(f.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">35</span>ms)) == std::future_status::ready)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ready&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;deferred&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-3-4-time-point"><a href="#4-3-4-time-point" class="headerlink" title="4.3.4 time point"></a>4.3.4 time point</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span> = <span class="keyword">typename</span> Clock::duration&gt;</span><br><span class="line"><span class="keyword">class</span> time_point;</span><br><span class="line"><span class="comment">// time_point 表示时间中的一个点</span></span><br><span class="line"><span class="comment">// Clock 表示时钟的类型</span></span><br><span class="line"><span class="comment">// Duration 存储一个自 Clock 的纪元起开始的时间间隔</span></span><br><span class="line"><span class="comment">// Unix 的纪元为 1970/1/1/00/00/00（epoch）</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slow_motion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">do</span>&#123;&#125; <span class="comment">// 生成 12! 个排列</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(a, a + <span class="number">12</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Test 1 */</span></span><br><span class="line">    <span class="type">const</span> time_point&lt;system_clock&gt; now = system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">time_t</span> t_c = system_clock::<span class="built_in">to_time_t</span>(now - <span class="number">24</span>h);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;24 hour ago, the time was &quot;</span> &lt;&lt; <span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;t_c), <span class="string">&quot;%F %T.\n&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Test 2 */</span></span><br><span class="line">    <span class="type">const</span> time_point&lt;steady_clock&gt; start = steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">slow_motion</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> end = steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Slow calculation took &quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(end - start).<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;us = &quot;</span></span><br><span class="line">         &lt;&lt; (end - start) / <span class="number">1</span>ms &lt;&lt; <span class="string">&quot;ms = &quot;</span></span><br><span class="line">         &lt;&lt; (end - start) / <span class="number">1</span>s &lt;&lt; <span class="string">&quot;s.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例2: 等待条件变量满足条件 —— 有超时功能</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> chrono_literals;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> done;</span><br><span class="line">std::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait_loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wait_loop running\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(<span class="number">100</span>ms);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wait loop sleep done.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> timeout = <span class="comment">// now + xms</span></span><br><span class="line">        std::chrono::steady_clock::<span class="built_in">now</span>() </span><br><span class="line">        + std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>);   </span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(!done)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cv.<span class="built_in">wait_until</span>(lock, timeout) == std::cv_status::timeout)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;timeout.\n&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do something or done = true</span></span><br><span class="line">        <span class="comment">// done = true;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wait_loop end\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread running.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(<span class="number">1000</span>ms);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread sleep done.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread end.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function">thread <span class="title">tl</span><span class="params">(wait_loop)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(signal)</span></span>;</span><br><span class="line">    tl.<span class="built_in">join</span>();</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">if</span>(done)    cout &lt;&lt; <span class="string">&quot;done.\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-3-5-use-timeout"><a href="#4-3-5-use-timeout" class="headerlink" title="4.3.5 use timeout"></a>4.3.5 use timeout</h4><p>使用超时机制的函数</p>
<table>
<thead>
<tr>
<th>类型&#x2F;命名空间</th>
<th>函数</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>std::this_thread[namespace]</td>
<td>sleep_for(duration)</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>sleep_until(time_point)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>std::condition_variable 或 std::condition_variable_any</td>
<td>wait_for(lock, duration)</td>
<td>std::cv_status::time_out 或 std::cv_status::no_timeout</td>
</tr>
<tr>
<td>wait_until(lock, time_point)</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>wait_for(lock, duration, predicate)</td>
<td>bool —— 当唤醒时，返回谓词的结果</td>
</tr>
<tr>
<td>wait_until(lock, duration, predicate)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>std::timed_mutex 或 std::recursive_timed_mutex</td>
<td>try_lock_for(duration)</td>
<td>bool —— 获取锁时返回true，否则返回fasle</td>
</tr>
<tr>
<td>try_lock_until(time_point)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>std::unique_lock<TimedLockable></td>
<td>unique_lock(lockable, duration)</td>
<td>N&#x2F;A —— 对新构建的对象调用owns_lock();</td>
</tr>
<tr>
<td>unique_lock(lockable, time_point)</td>
<td>当获取锁时返回true，否则返回false</td>
<td></td>
</tr>
<tr>
<td></td>
<td>try_lock_for(duration)</td>
<td>bool —— 当获取锁时返回true，否则返回false</td>
</tr>
<tr>
<td>try_lock_until(time_point)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>std::future<ValueType>或std::shared_future<ValueType></td>
<td>wait_for(duration)</td>
<td>当等待超时，返回std::future_status::timeout</td>
</tr>
<tr>
<td>wait_until(time_point)</td>
<td>当“期望”准备就绪时，返回std::future_status::ready</td>
<td></td>
</tr>
<tr>
<td>当“期望”持有一个为启动的延迟函数，返回std::future_status::deferred</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>现在，我们讨论的机制有：<strong>condition variable</strong>、“<strong>future</strong>”、“<strong>promise</strong>”还有 <strong>packaged_task</strong>。是时候从更高的角度去看待这些机制，怎么样使用这些机制，简化线程的同步操作。</p>
<h3 id="4-4-simplify-code"><a href="#4-4-simplify-code" class="headerlink" title="4.4 simplify code"></a>4.4 simplify code</h3><p>同步工具在本章成为“构建块”。</p>
<p>比起在多个线程间共享数据，每个任务最好拥有自己的数据，并且其他线程可以通过使用 <code>future</code> 获取运行结果。</p>
<h4 id="4-4-1-funtional-programming-by-future"><a href="#4-4-1-funtional-programming-by-future" class="headerlink" title="4.4.1 funtional programming by future"></a>4.4.1 funtional programming by future</h4><blockquote>
<p><strong>functional programming(FP)</strong> is a programming way which the function_return_value only depend on the arguments and you will get the same result always if you pass the same arguments</p>
</blockquote>
<p>串形版针对 <code>list</code> 的 <code>qsort</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">std::list&lt;T&gt; <span class="title">sequential_quick_sort</span><span class="params">(std::list&lt;T&gt; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(input.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">    std::list&lt;T&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::list::splice 实现将元素从一个list转移到另一个list</span></span><br><span class="line">    <span class="comment">// 并且仅仅通过 pointer move 实现，而不 copy or move elements</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// splice(const_iterator pos, list &amp;other, const_iterator it)</span></span><br><span class="line">    <span class="comment">// 从 other 转移 it 所指向的元素到 [*this](calleer) 当中，元素被插入到 pos 所指向的元素之前</span></span><br><span class="line">    <span class="comment">// 即，将 input 的第一个元素转移到 reesult 的 begin 之前</span></span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(), input, input.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="comment">// 选取一个“中间元素”</span></span><br><span class="line">    <span class="type">const</span> T&amp; pivot = *result.<span class="built_in">begin</span>();   <span class="comment">// pivot: 枢纽</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// paration 返回第一个不满足条件的元素的迭代器，正好是开区间</span></span><br><span class="line">    <span class="comment">// 方便 [) 的设计</span></span><br><span class="line">    <span class="comment">// 根据“中间元素”划分为左右去见</span></span><br><span class="line">    <span class="keyword">auto</span> divide_point = std::<span class="built_in">partition</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(),</span><br><span class="line">        [&amp;](<span class="type">const</span> T&amp; t)&#123;<span class="keyword">return</span> t &lt; pivot;&#125; <span class="comment">// 以 t&lt;pivot 划分元素，input左侧都是小于pivot，右侧大于pivot</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    std::list&lt;T&gt; lower_part;</span><br><span class="line">    lower_part.<span class="built_in">splice</span>(lower_part.<span class="built_in">end</span>(), input, input.<span class="built_in">begin</span>(), divide_point);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursion</span></span><br><span class="line">    <span class="comment">// 分别对左右区间的元素递归sort</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">new_lower</span><span class="params">(sequential_quick_sort(std::move(lower_part)))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">new_higher</span><span class="params">(sequential_quick_sort(std::move(input)))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// left, middle(privot), right</span></span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">end</span>(), new_higher);</span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(), new_lower);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; l&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    l = <span class="built_in">sequential_quick_sort</span>(l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;val : l)</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>qsort —— FP pattern with thread strongthen（并行版本）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">parallel_quick_sort</span><span class="params">(std::list&lt;T&gt; input)</span> -&gt; <span class="keyword">auto</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(input.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    </span><br><span class="line">    std::list&lt;T&gt; result;</span><br><span class="line">    </span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(), input, input.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="type">const</span> T&amp; pivot = *result.<span class="built_in">begin</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> divide_point = std::<span class="built_in">partition</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), </span><br><span class="line">        [&amp;](<span class="type">const</span> T&amp; t)&#123;</span><br><span class="line">            <span class="keyword">return</span> t &lt; pivot;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::list&lt;T&gt; lower_part;</span><br><span class="line">    lower_part.<span class="built_in">splice</span>(lower_part.<span class="built_in">end</span>(), input, </span><br><span class="line">        input.<span class="built_in">begin</span>(), divide_point);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的线程进行排序</span></span><br><span class="line">    std::future&lt;std::list&lt;T&gt;&gt; <span class="built_in">new_lower</span>(</span><br><span class="line">        std::<span class="built_in">async</span>(&amp;parallel_quick_sort&lt;T&gt;, std::<span class="built_in">move</span>(lower_part))</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 在当前线程中执行，无需一个新的线程</span></span><br><span class="line">    <span class="keyword">auto</span> new_higher = (</span><br><span class="line">        <span class="built_in">parallel_quick_sort</span>(std::<span class="built_in">move</span>(input))</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">end</span>(), new_higher);;</span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(), new_lower.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; l&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    l = <span class="built_in">parallel_quick_sort</span>(l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;val : l)</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，每调用一次 <code>parallel_quich_sort</code>，我们便创建一个新的线程，由于递归执行的缘故，线程的创建是指数级别的，也就是说，如果递归执行 10 次，那么就会创建 1024 个线程！但创建太多线程显然是不好的，因此 <code>async()</code> 会自动执行某些操作，避免创建太多线程。这也符合 <code>async()</code> 的策略（既可立马创建新线程，也可以以延迟加载的方式创建线程）。</p>
<p>其实，如果 <code>async()</code> 以延迟加载的方式执行，也就是直到在 <code>std::async()</code> 返回的 <code>future</code> 对象调用 <code>get()</code> 或者 <code>wait()</code> 时才执行。</p>
<p>然鹅，当调用 <code>get/wait</code> 时，函数会同步执行，即调用者会阻塞直到函数运行结束，如果 <code>get/wait</code> 没有被调用，函数就绝对不会执行。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039083151">ref here</a></p>
</blockquote>
<p>比起使用<code>std::async()</code>，你可以写一个spawn_task()函数对<code>std::packaged_task</code>和<code>std::thread</code>做简单的包装，如下面代码所示；你需要为函数结果创建一个<code>std::packaged_task</code>对象， 可以从这个对象中获取“期望”，或在线程中执行它，返回“期望”。</p>
<p>其本身并不提供太多的好处(并且事实上会造成大规模的超额任务)，但是它会为转型成一个更复杂的实现铺平道路，将会实现向一个队列添加任务，而后使用线程池的方式来运行它们。我们将在第9章再讨论线程池。使用<code>std::async</code>更适合于当你知道你在干什么，并且要完全控制在线程池中构建或执行过任务的线程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> A&gt;</span><br><span class="line">std::future&lt;std::result_of&lt;<span class="built_in">F</span>(A&amp;&amp;)&gt;::type&gt; <span class="built_in">spawn_task</span>(F &amp;&amp;f, A &amp;&amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::result_of&lt;<span class="built_in">F</span>(A&amp;&amp;)&gt;::type result_type;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">result_type</span><span class="params">(A&amp;&amp;)</span>&gt; <span class="title">task</span><span class="params">(std::move(f))</span></span>;</span><br><span class="line">    <span class="function">std::future&lt;result_type&gt; <span class="title">res</span><span class="params">(task.get_future())</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task), std::move(a))</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-2-synchronization-by-message-passing"><a href="#4-4-2-synchronization-by-message-passing" class="headerlink" title="4.4.2 synchronization by message passing"></a>4.4.2 synchronization by message passing</h4><blockquote>
<p> <strong>MPI：</strong>Message Passing Interface，消息传递接口</p>
<p><strong>CSP：</strong>Communicating Sequentiasl Processer，通讯顺序进程</p>
</blockquote>
<p><font color=blue>???????  THIS SECTION AND NEXT SECTION TODO</font></p>
<p>TODO …</p>
<h3 id="4-5-summary"><a href="#4-5-summary" class="headerlink" title="4.5 summary"></a>4.5 summary</h3><p>同步操作对于使用并发编写一款多线程应用来说，是很重要的一部分：如果没有同步，线程基本上就是独立的，也可写成单独的应用，因其任务之间的相关性，它们可作为一个群体直接执行。</p>
<p>本章，我们讨论了各式各样的同步操作，从基本的<strong>条件变量，到“期望”、“承诺”，再到打包任务</strong>。</p>
<p>我们也讨论了替代同步的解决方案：<strong>函数化模式编程，完全独立执行的函数，不会受到外部环境的影响；还有，消息传递模式，以消息子系统为中介，向线程异步的发送消息。</strong></p>
<h2 id="P5-memory-model-and-atomatic-operation"><a href="#P5-memory-model-and-atomatic-operation" class="headerlink" title="P5 memory model and atomatic operation"></a>P5 memory model and atomatic operation</h2><h2 id="P6-data-struct-with-mutex"><a href="#P6-data-struct-with-mutex" class="headerlink" title="P6 data struct with mutex"></a>P6 data struct with mutex</h2><p>本章主要内容：</p>
<ul>
<li>设计并发数据结构</li>
<li>如何设计</li>
<li>实现数据结构</li>
</ul>
<p>设计并发数据结构时，可以使用多线程中的构建块，比如：<code>condition_variable</code> 和 <code>mutex</code>。当然也要保证并发块在并发环境下的线程安全。</p>
<h3 id="6-1-the-significance-of-concurrency-design"><a href="#6-1-the-significance-of-concurrency-design" class="headerlink" title="6.1 the significance of concurrency design"></a>6.1 the significance of concurrency design</h3><p>设计并发数据结构是为了让多线程并发访问，并且线程可对数据结构做相同或不同的操作。</p>
<p>多线程环境下，无数据丢失和损坏，苏哟偶的数据都维持原样，且无竞争条件的数据结构，称之为“线程安全”的数据结构。</p>
<p>实际上，我们要通过设计线程安全的数据结构为线程提供并发访问数据结构的机会。因为就本质来说，互斥量为了保护数据，会显示阻止线程对数据的并发访问。</p>
<h4 id="6-1-1-guideline-of-desiging-the-concurrency-DB"><a href="#6-1-1-guideline-of-desiging-the-concurrency-DB" class="headerlink" title="6.1.1 guideline of desiging the concurrency DB"></a>6.1.1 guideline of desiging the concurrency DB</h4><p>设计并发数据结构时，需要两方面的考量：</p>
<ol>
<li>确保访问安全</li>
<li>真正并发访问</li>
</ol>
<p>第三章已经对如何保证数据安全做过简单的描述：</p>
<ul>
<li>确保无线程能够看到“不变量”变化时的状态</li>
<li>小心会引起条件竞争的接口，提供完整操作的函数，而非操作步骤（top-pop）</li>
<li>注意数据结构的行为是否会产生异常，从而确保“不变量”的状态</li>
<li>将死锁的概率降到最低。限制锁的范围，避免嵌套锁等</li>
</ul>
<p><strong>还需要考虑数据结构对于使用者有什么限制</strong>，当线程通过特殊的函数对数据结构进行访问时，其他的线程还有哪些函数能安全调用?</p>
<p>这是一个很重要的问题，普通的构造函数和析构函数需要独立访问数据结构，所以用户使用时，就不能在构造函数完成前或析构函数完成后对数据结构进行访问。当数据结构支持赋值操作swap()或拷贝构造时，作为 数据结构的设计者，即使线程操纵数据结构中有大量的函数，也需要保证这些操作在并发下是安全的(或确保 这些操作能够独立访问)，以保证并发访问时不会出错。</p>
<p>第二个方面是确保真正的并发，需要考虑一下问题：</p>
<ol>
<li>操作在锁的范围中进行，是否允许在锁外执行？</li>
<li>数据结构中不同的互斥能否保护不同的区域？</li>
<li>所有操作都需要同级互斥量的保护吗？</li>
<li>能否对数据结构进行简单的修改，增加并发访问的概率？</li>
</ol>
<p>这些问题都源于一个指导思想:<strong>如何让序列化访问最小化，让真实并发最大化?😊？？😭</strong></p>
<p>允许线程并发读取的数据结构并不少见，但修改必须是单线程的，这种结构类似于 <code>std::shared_mutex</code> 。同样，这种数据结构也很常见—— 支持多线程的不同操作时，也能串行执行相同的操作。</p>
<p>最简单的线程安全结构通常会对数据使用互斥量或锁。虽然，这么做还有问题，不过这样做相对简单，并且能保证只有一个线程在同一时间对数据结构进行独立访问。为了更轻松的设计线程安全的数据结构，接下来了解一下基于锁的数据结构。</p>
<h3 id="6-2-DS-based-on-mutex"><a href="#6-2-DS-based-on-mutex" class="headerlink" title="6.2 DS based on mutex"></a>6.2 DS based on mutex</h3><p>基于锁的并发数据结构确保访问线程持有锁的时间最短；对于只有一个互斥量的数据结构，需要锁之外的操作不能访问数据；使用多个互斥量保护数据结构不同的区域时要避免死锁。</p>
<h4 id="6-2-1-threadsafe-stack"><a href="#6-2-1-threadsafe-stack" class="headerlink" title="6.2.1 threadsafe stack"></a>6.2.1 threadsafe stack</h4><p>在 push() 操作中，无论如何都无法避免新数据的创建，除非你直接 move 原来的数据（右值引用 + move），但是直接 move 原来的数据有一个问题，那就是如果内存不足，move 一半异常了，那么原来的数据就会被破坏，因此，使用传值的方式拷贝初始数据，在 move 到容器中，更为稳妥。</p>
<p>这里的 “异常 - 安全” 好恶心😭</p>
<p>另外，这里的代码是可能发生死锁的;</p>
<p>用户要对栈负责，当栈未对一个数据进行拷贝或分配时，用户就不能想当然的将其添加到栈中。</p>
<p>所有成员函数都使用 std::lock_guard&lt;&gt; 保护数据，所以栈成员函数才是“线程安全”的。当然，构造与析构函数不是“线程安全”的，但构造与析构只有一次。调用不完全构造对象或是已销毁对象的成员函数，无论在哪种编程方式下都不可取。所以，用户就要保证在栈对象完成构造前，其他线程无法对其进行访问。并且，要保证在栈对象销毁后，停止所有线程的访问操作。</p>
<p>串形化的线程会隐性的限制程序性能。例如我们需要 pop 一个元素，那么当栈为空时我们只能等待，但这种等待时无意义的，我们希望它不这么闲着等，而是去做一些其他事，因此，这需要用户编写等待和提示的代码（例如：条件变量）。下面的队列就是如此。</p>
<h4 id="6-2-2-threadsafe-queue-–-mutex-amp-amp-condition-variable"><a href="#6-2-2-threadsafe-queue-–-mutex-amp-amp-condition-variable" class="headerlink" title="6.2.2 threadsafe queue – mutex &amp;&amp; condition_variable"></a>6.2.2 threadsafe queue – mutex &amp;&amp; condition_variable</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mut;</span><br><span class="line">    std::queue&lt;T&gt; data_queue;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; mut;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(std::<span class="built_in">move</span>(data));</span><br><span class="line">        data_cond.<span class="built_in">notify_one</span>(); <span class="comment">// 不为空，通知等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 因为wait可能假唤醒，因此这里需要多次lock&amp;&amp;unlock</span></span><br><span class="line">        <span class="comment">// 因此unique_lock用来搭配condition_variable是更好的选择</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        value = std::<span class="built_in">move</span>(data_queue.<span class="built_in">top</span>());</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* [TOOD]</span></span><br><span class="line"><span class="comment">    * 感觉这里可以把两个pop中判断queue是否为空的部分拿出来</span></span><br><span class="line"><span class="comment">    * 放到一个单独的函数里面，这样岂不是更好？</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T &amp;value)</span></span></span><br><span class="line"><span class="function">   </span>&#123;    </span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的代码在有一个问题，就是当 push() 执行 notice_one() 之后，如果唤醒的那个线程发生了异常死了，例如构造新的 shared_ptr 对象时发生异常，那么所有线程都将永眠，因为此时没有其它条件能将他们唤醒，解放方案有如下几种：</p>
<ol>
<li>notice_all()，但是这么做的开销太大了，因为往往只有一个线程最终唤醒，而其他线程仍然需要沉睡</li>
<li>当唤醒的线程异常时，调用 notice_one() 去唤醒另一个线程</li>
<li>将<code>std::shared_ptr&lt;&gt;</code>的初始化过程移到push()中，并且存储<code>std::shared_ptr&lt;&gt;</code>实例，而非直接使用数据的值。将<code>std::shared_ptr&lt;&gt;</code>拷贝到内部<code>std::queue&lt;&gt;</code>中，就不会抛出异常了，这样wait_and_pop()又是安全的了。</li>
</ol>
<p>下面是使用第三种方案修改后的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mut;</span><br><span class="line">    std::queue&lt;std::shared_ptr&lt;T&gt;&gt; data_queue;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 这样即使发生了异常也不会导致所有线程沉睡</span></span><br><span class="line">        <span class="comment">// 因为构造对象并不涉及对共享对象的访问</span></span><br><span class="line">        <span class="comment">// 因此它实际上不需要加锁</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">data</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(new_value))</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">        <span class="comment">// 分配完才加锁，减少锁持有的时间，提高并发能力</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(data);</span><br><span class="line">        data_cond.<span class="built_in">notify_one</span>(); <span class="comment">// 不为空，通知等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        value = std::<span class="built_in">move</span>(*data_queue.<span class="built_in">top</span>());</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        std::shared_ptr&lt;T&gt; res = data_queue.<span class="built_in">front</span>(); <span class="comment">// 改为赋值而不是创建</span></span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* [TOOD]</span></span><br><span class="line"><span class="comment">    * 感觉这里可以把两个pop中判断queue是否为空的部分拿出来</span></span><br><span class="line"><span class="comment">    * 放到一个单独的函数里面，这样岂不是更好？</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T &amp;value)</span></span></span><br><span class="line"><span class="function">   </span>&#123;    </span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = std::<span class="built_in">move</span>(*data_queue.<span class="built_in">front</span>());</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line">        std::shared_ptr&lt;T&gt; res = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-2-3-threadsaft-queue-small-granularity-amp-amp-condition-variable"><a href="#6-2-3-threadsaft-queue-small-granularity-amp-amp-condition-variable" class="headerlink" title="6.2.3 threadsaft queue -  small granularity &amp;&amp; condition_variable"></a>6.2.3 threadsaft queue -  small granularity &amp;&amp; condition_variable</h4><p>下面是一个单线程环境下简单队列的实现，它是一个有头尾节点的单链表，当链表为空时，头尾指针为空。</p>
<blockquote>
<p>头节点 !&#x3D; 头指针</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">    &#123;</span><br><span class="line">        T data;</span><br><span class="line">        std::unique_ptr&lt;node&gt; next; <span class="comment">//  使用智能指针</span></span><br><span class="line">        <span class="built_in">node</span>(T _data) : <span class="built_in">data</span>(<span class="built_in">move</span>(_data)) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::unique_ptr&lt;node&gt; head;</span><br><span class="line">    node *tail; <span class="comment">// 因为这里的tail并不从堆上分配内存，他只是指向一个地址，因此不需要使用智能指针代替</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Queue</span>(<span class="type">const</span> Queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回节点并删除</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">/* 这里的const是顶层const，指定res不能再指向别的东西了，但是数据仍然可以修改</span></span><br><span class="line"><span class="comment">        * 你可能疑惑，既然res不能修改，但是接受返回值的变量不一定有这个限制的，他是可以修改的，没错，可以修改，但要记住了，shared_ptr 是有引用计数的，你修改了指向，其实就相当于在修改引用计数（创建了一个新指针），这并不会修改原来的指针，顶多导致她引用计数为0从而被销毁了。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分别取得头节点的数据和next指针</span></span><br><span class="line">        <span class="function"><span class="type">const</span> std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(head-&gt;data))</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">        <span class="type">const</span> std::unique_ptr&lt;node&gt; old_head = std::<span class="built_in">move</span>(head);</span><br><span class="line">        <span class="comment">// 头指针指向下一个节点</span></span><br><span class="line">        head = std::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建新节点</span></span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node(std::move(new_value)))</span></span>;</span><br><span class="line">        <span class="type">const</span> node* new_tail = p.<span class="built_in">get</span>();</span><br><span class="line">        <span class="comment">// 2. 让尾节点的next指向新节点</span></span><br><span class="line">        <span class="keyword">if</span>(tail)</span><br><span class="line">            tail-&gt;next = std::<span class="built_in">move</span>(p);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            head = std::<span class="built_in">move</span>(p);</span><br><span class="line">        <span class="comment">// 3. 更新尾节为当前节点</span></span><br><span class="line">        tail = new_tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码在单线程下没问题，但是在多线程下问题就太多了！</p>
<p>因为在给定的实现中有两个数据项(head①和tail②)；即使，使用两个互斥量，来保护头指针和尾指针，也会出现问题。</p>
<p>显而易见的问题就是push()可以同时修改头指针⑤和尾指针⑥，所以push()函数会同时获取两个互斥量。虽然会将两个互斥量都上锁，但这还不是太糟糕的问题。糟糕的问题是push()和pop()都能访问next指针指向的节点：push()可更新tail-&gt;next④，而后try_pop()读取head-&gt;next③。当队列中只有一个元素时，head&#x3D;&#x3D;tail，所以head-&gt;next和tail-&gt;next是同一个对象，并且这个对象需要保护。不过，“在同一个对象在未被head和tail同时访问时，push()和try_pop()锁住的是同一个锁”，就不对了。所以，你就没有比之间实现更好的选择了。这里会“柳暗花明又一村”吗？</p>
<p>可以通过<strong>分离数据</strong>实现并发。</p>
<p>通过“预分配虚拟节点（无数据）”，确保这个节点永远在队列的最后，用来分离头尾指针能访问的节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;T&gt; data;</span><br><span class="line">        std::unique_ptr&lt;node&gt; next; <span class="comment">//  使用智能指针</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;node&gt; head;</span><br><span class="line">    node *tail; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>() <span class="comment">// 预分配一个虚拟节点</span></span><br><span class="line">    : <span class="built_in">head</span>(<span class="keyword">new</span> node), <span class="built_in">tail</span>(head.<span class="built_in">get</span>()) </span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    initialization: </span></span><br><span class="line"><span class="comment">        [head(taial)] -&gt; NULL </span></span><br><span class="line"><span class="comment">    push value a</span></span><br><span class="line"><span class="comment">        [head] -&gt; [a(tail)] -&gt; NULL</span></span><br><span class="line"><span class="comment">    push value b</span></span><br><span class="line"><span class="comment">        [head] -&gt; [a] -&gt; [b(tail)] -&gt; NULL</span></span><br><span class="line"><span class="comment">    pop value</span></span><br><span class="line"><span class="comment">        [head] -&gt; [a(tail)] -&gt; NULL</span></span><br><span class="line"><span class="comment">    这样，除了队列为空状态下 head-&gt;next == tail-&gt;next == NULL</span></span><br><span class="line"><span class="comment">    任何时候他们不会为同一个元素，而队列为空时，不会同时发生 push 和 pop</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">Queue</span>(<span class="type">const</span> Queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.<span class="built_in">get</span>() == tail) <span class="comment">// head与tail指向同一元素，队列为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 队列不为空，先 front() 再 pop()</span></span><br><span class="line">        <span class="function"><span class="type">const</span> std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(head-&gt;data)</span></span>; <span class="comment">// shared_ptr 不需要 move</span></span><br><span class="line">        <span class="type">const</span> std::unique_ptr&lt;node&gt; old_head = std::<span class="built_in">move</span>(head);</span><br><span class="line">        head = std::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 因为 tail 是我们预分配的节点，因此直接修改 tail 的 dat 即可</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">new_data</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(new_value))</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>; </span><br><span class="line">        tail-&gt;data = new_data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们已经把上次预分配的使用了，因此需要重新预分配并作为尾节点</span></span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node)</span></span>; </span><br><span class="line">        <span class="type">const</span> node* new_tail = p.<span class="built_in">get</span>();</span><br><span class="line">        tail-&gt;next = std::<span class="built_in">move</span>(p);</span><br><span class="line">        tail = new_tail;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过修改之后，push 便只需要访问 tail，而原来还需要访问 head，try_pop 需要访问 head 和 tail，但是 head 只在开始时用了一下，所以存在的时间很短。</p>
<p>不过，最重大的提升在于，try_pop 和 push 不能对同一节点进行操作，也就不需要互斥了。因此，现在只需要一个互斥量来保护 head 和 tail 就行了。</p>
<p>那么，该如何加锁呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsaft_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;T&gt; data;</span><br><span class="line">        std::unique_ptr&lt;node&gt; next;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::mutex head_mutex, tail_mutex;</span><br><span class="line">    std::unique_ptr&lt;node&gt; head;</span><br><span class="line">    node *tail;</span><br><span class="line"></span><br><span class="line">    <span class="function">node* <span class="title">get_tail</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">pop_head</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(head.<span class="built_in">get</span>() == <span class="built_in">get_tail</span>()) <span class="comment">// 队列为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::unique_ptr&lt;node&gt; old_head = std::<span class="built_in">move</span>(head_mutex);</span><br><span class="line">        <span class="comment">// move 掉 next 也是个好事，用户想得到的应该只是数据而不是 next 指针</span></span><br><span class="line">        head = std::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> old_head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsaft_queue</span>(): <span class="built_in">head</span>(<span class="keyword">new</span> node), <span class="built_in">tail</span>(head.<span class="built_in">get</span>()) &#123;&#125;</span><br><span class="line">    <span class="built_in">threadsaft_queue</span>(<span class="type">const</span> threadsaft_queue&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    threadsaft_queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsaft_queue&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::unique_ptr&lt;node&gt; old_head = <span class="built_in">pop_head</span>();</span><br><span class="line">        <span class="keyword">return</span> old_head ? old_head-&gt;data : std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">new_data</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(new_value))</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node)</span></span>;</span><br><span class="line">        <span class="type">const</span> node *new_tail = p.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">        tail-&gt;data = new_data;</span><br><span class="line">        tail-&gt;next = std::<span class="built_in">move</span>(p);</span><br><span class="line">        tail = new_tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>多线程环境下，节点及数据的分配时“并发安全”的。</p>
</blockquote>
<p>下面是可上锁和等待的线程安全队列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsaft_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;T&gt; data;</span><br><span class="line">        std::unique_ptr&lt;node&gt; next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex head_mutex, tail_mutex;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line">    std::unique_ptr&lt;node&gt; head;</span><br><span class="line">    node *tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">node* <span class="title">get_tail</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">pop_head</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">wait_for_data</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">wait_pop_head</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">wait_pop_head</span><span class="params">(T &amp;value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">try_pop_head</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">try_pop_head</span><span class="params">(T&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T &amp;value)</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T &amp;value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*====================*</span></span><br><span class="line"><span class="comment">*       function      *</span></span><br><span class="line"><span class="comment">*=====================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; threadsaft_queue&lt;T&gt;::<span class="built_in">try_pop</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_ptr&lt;node&gt; old_head = <span class="built_in">try_pop_head</span>();</span><br><span class="line">    <span class="keyword">return</span> old_head ? old_head-&gt;data : std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> threadsaft_queue&lt;T&gt;::<span class="built_in">try_pop</span>(T &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_ptr&lt;node&gt; old_head = <span class="built_in">try_pop_head</span>();</span><br><span class="line">    <span class="keyword">return</span> old_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; threadsaft_queue&lt;T&gt;::<span class="built_in">wait_and_pop</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> std::unique_ptr&lt;node&gt; old_head = <span class="built_in">wait_pop_head</span>();</span><br><span class="line">    <span class="keyword">return</span> old_head-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> threadsaft_queue&lt;T&gt;::<span class="built_in">wait_and_pop</span>(T &amp;new_value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> std::unique_ptr&lt;node&gt; old_head = <span class="built_in">wait_and_pop</span>(new_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> threadsaft_queue&lt;T&gt;::<span class="built_in">push</span>(T new_value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">new_data</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        std::make_shared&lt;T&gt;(std::move(new_value))</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node)</span></span>;</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// use &#123;&#125; to unlock early </span></span><br><span class="line">        <span class="type">const</span> node *new_tail = p.<span class="built_in">get</span>();</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">        tail-&gt;data = new_data;</span><br><span class="line">        tail-&gt;next = std::<span class="built_in">move</span>(p);</span><br><span class="line">        tail = new_tail;</span><br><span class="line">    &#125;</span><br><span class="line">    data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> threadsaft_queue&lt;T&gt;::<span class="built_in">empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> (head.<span class="built_in">get</span>() == <span class="built_in">get_tail</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*====================*</span></span><br><span class="line"><span class="comment">*   helper function   *</span></span><br><span class="line"><span class="comment">*=====================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> threadsaft_queue&lt;T&gt;::node* </span><br><span class="line">threadsaft_queue&lt;T&gt;::<span class="built_in">get_tail</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execute within head mutex</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::unique_ptr&lt;<span class="keyword">typename</span> threadsaft_queue&lt;T&gt;::node&gt; </span><br><span class="line">threadsaft_queue&lt;T&gt;::<span class="built_in">pop_head</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_ptr&lt;node&gt; old_head = std::<span class="built_in">move</span>(head);</span><br><span class="line">    head = std::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> old_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::unique_lock&lt;std::mutex&gt; </span><br><span class="line">threadsaft_queue&lt;T&gt;::<span class="built_in">wait_for_data</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 因为获取了 head_lock，所以下面调用 head.get() 并发安全</span></span><br><span class="line">    data_cond.<span class="built_in">wait</span>(head_lock, [&amp;]&#123;</span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">get</span>() != <span class="built_in">get_tail</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(head_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::unique_ptr&lt;<span class="keyword">typename</span> threadsaft_queue&lt;T&gt;::node&gt; </span><br><span class="line">threadsaft_queue&lt;T&gt;::<span class="built_in">wait_pop_head</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. [wait] until queue is not empty</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(wait_for_data())</span></span>;</span><br><span class="line">    <span class="comment">// 2. [pop] head</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::unique_ptr&lt;<span class="keyword">typename</span> threadsaft_queue&lt;T&gt;::node&gt; </span><br><span class="line">threadsaft_queue&lt;T&gt;::<span class="built_in">wait_pop_head</span>(T &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. [wait] until queue is not empty</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(wait_for_data())</span></span>;</span><br><span class="line">    <span class="comment">// get data</span></span><br><span class="line">    value = std::<span class="built_in">move</span>(*head-&gt;data);</span><br><span class="line">    <span class="comment">// 2. [pop] head</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::unique_ptr&lt;<span class="keyword">typename</span> threadsaft_queue&lt;T&gt;::node&gt; </span><br><span class="line">threadsaft_queue&lt;T&gt;::<span class="built_in">try_pop_head</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(head.<span class="built_in">get</span>() == <span class="built_in">get_tail</span>())</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;node&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::unique_ptr&lt;<span class="keyword">typename</span> threadsaft_queue&lt;T&gt;::node&gt; </span><br><span class="line">threadsaft_queue&lt;T&gt;::<span class="built_in">try_pop_head</span>(T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(head.<span class="built_in">get</span>() == <span class="built_in">get_tail</span>())</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;node&gt;();</span><br><span class="line">    value = std::<span class="built_in">move</span>(*head-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-3-design-more-complex-DS"><a href="#6-3-design-more-complex-DS" class="headerlink" title="6.3 design more complex DS"></a>6.3 design more complex DS</h3><p>栈和队列的设计太 easy 啦（然而我也招架不住😭），下面来点大的。😠😠😠</p>
<h4 id="6-3-1-threadsafe-dictionary"><a href="#6-3-1-threadsafe-dictionary" class="headerlink" title="6.3.1 threadsafe dictionary"></a>6.3.1 threadsafe dictionary</h4><p>和栈和队列一样，标准容器的接口不适合多线程进行并发访问，因为这些接口都存在固有的条件竞争，所以这些接口需要砍掉或者重新修订。</p>
<p>并发访问时，<code>std::map&lt;&gt;</code> 最大的问题在于 —— 迭代器。例如当迭代器引用的元素被其它线程删除时，迭代器就会失效，但我们不知道。</p>
<p>查询表（字典）基本操作：</p>
<ol>
<li>（增）添加 key-value</li>
<li>（删）删除 key-value</li>
<li>（改）修改指定 key 所对应的 value</li>
<li>（查）查询指定 key 所对应的 value</li>
<li>so on…</li>
</ol>
<p>如果你坚持之前的线程安全指导意见，例如：<strong>不要返回一个引用</strong>，并且用一个简单的互斥锁对每一个成员函数进行上锁，以确保每一个函数线程安全。最有可能的条件竞争在于，当一对“键值-数据”加入时；当两个线程都添加一个数据，那么肯定一个先一个后。一种方式是合并“添加”和“修改”操作为一个成员函数，就像清单3.13对域名系统缓存所做的那样。</p>
<p>区别多线程环境下一下容器的并发能力：</p>
<ol>
<li>二叉树，比如：红黑树</li>
<li>有序数组</li>
<li>哈希表</li>
</ol>
<p>其中哈希表并发性能最好，因为哈希表可以设计为同 bucket+list(或有序数组)，而每一个 bucket 可以独立加锁，bucket 与 bucket 之间独立</p>
<p>下面是基于哈希表，使用读写锁，线程安全的，字典：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [TODO] separate bucket_t from threadsafe_lookup_table</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> threadsafe_lookup_table </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="type">bucket_t</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">/* [BUG]</span></span><br><span class="line"><span class="comment">            if you don&#x27;t add this, in the function of get_map()</span></span><br><span class="line"><span class="comment">            you cant access the number of data typed bucket_data</span></span><br><span class="line"><span class="comment">            .... </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> threadsafe_lookup_table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">typedef</span> std::pair&lt;Key,Value&gt;                 bucket_value;</span><br><span class="line">        <span class="keyword">typedef</span> std::list&lt;bucket_value&gt;              bucket_data;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> bucket_data::iterator       bucket_iterator;</span><br><span class="line">        <span class="comment">/* [BUG]</span></span><br><span class="line"><span class="comment">            author use iterator, but it is go CE</span></span><br><span class="line"><span class="comment">            we should use const_iterator</span></span><br><span class="line"><span class="comment">            ... ?</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> bucket_data::const_iterator bucket_const_iterator;</span><br><span class="line"></span><br><span class="line">        bucket_data data;</span><br><span class="line">        <span class="keyword">mutable</span> std::shared_mutex mutex;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// helper function</span></span><br><span class="line">        <span class="function">bucket_const_iterator <span class="title">find_entry_for</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">/* [BUG]</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">find_if</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), </span><br><span class="line">                [&amp;](<span class="type">const</span> bucket_value &amp;items)&#123;</span><br><span class="line">                    <span class="keyword">return</span> items.first == key;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// Advise: do not return by reference</span></span><br><span class="line">        <span class="comment">// this function return the value which mapped to the key</span></span><br><span class="line">        <span class="comment">// if ther is no item match, then return default value</span></span><br><span class="line">        <span class="comment">// and the default value is designated by the caller</span></span><br><span class="line">        <span class="function">Value <span class="title">value_for</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> Value &amp;default_value)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>; <span class="comment">// read lock</span></span><br><span class="line">            bucket_const_iterator found_entry = <span class="built_in">find_entry_for</span>(key);</span><br><span class="line">            <span class="keyword">return</span> (found_entry == data.<span class="built_in">end</span>()) ? </span><br><span class="line">                default_value : found_entry-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update if this key is existed otherwise add this K-V</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">add_or_update_mapping</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> Value &amp;value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>; <span class="comment">// write lock</span></span><br><span class="line">            bucket_const_iterator found_entry = <span class="built_in">find_entry_for</span>(key);</span><br><span class="line">            <span class="keyword">if</span>(found_entry == data.<span class="built_in">end</span>())</span><br><span class="line">                data.<span class="built_in">push_back</span>(<span class="built_in">bucket_value</span>(key, value));</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* [BUG]</span></span><br><span class="line"><span class="comment">                    because we use the const_iterator(lower const for the data which pointed on)</span></span><br><span class="line"><span class="comment">                    so we cant&#x27;t modify the data</span></span><br><span class="line"><span class="comment">                    otherwise ust the type convertion</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">auto</span> &amp;data = <span class="built_in">const_cast</span>&lt;bucket_value&amp;&gt;(*found_entry);</span><br><span class="line">                data.second = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">reomove_mapping</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>; <span class="comment">// write lock</span></span><br><span class="line">            bucket_const_iterator found_entry = <span class="built_in">find_entry_for</span>(key);</span><br><span class="line">            <span class="keyword">if</span>(found_entry != data.<span class="built_in">end</span>())</span><br><span class="line">                data.<span class="built_in">erase</span>(found_entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;<span class="type">bucket_t</span>&gt;&gt; buckets;</span><br><span class="line">    Hash hasher;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bucket_t</span>&amp; <span class="title">get_bucket</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">const</span> std::<span class="type">size_t</span> bucket_index = <span class="built_in">hasher</span>(key) % buckets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// buckets[idx] is a object of unique_ptr </span></span><br><span class="line">        <span class="comment">// so use operator* to get the object which ptr pointed on</span></span><br><span class="line">        <span class="keyword">return</span> *buckets[bucket_index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key   key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value mapped_type;    </span><br><span class="line">    <span class="keyword">typedef</span> Hash  hash_type;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;Key, Value&gt; value_type;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_lookup_table</span>(</span><br><span class="line">        <span class="comment">// the _num_bucket should be a prime so that it will have the best performance</span></span><br><span class="line">        <span class="type">unsigned</span> _num_buckets = <span class="number">19</span>, <span class="type">const</span> Hash &amp;_hasher = <span class="built_in">Hash</span>()</span><br><span class="line">    ) : <span class="built_in">buckets</span>(_num_buckets), <span class="built_in">hasher</span>(_hasher) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; _num_buckets; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            buckets[i].<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="type">bucket_t</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_lookup_table</span>(<span class="type">const</span> threadsafe_lookup_table&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    threadsafe_lookup_table&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_lookup_table&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*        DO NOT NEED MUTEX</span></span><br><span class="line"><span class="comment">    *  because the count of buckets can&#x27;t changed</span></span><br><span class="line"><span class="comment">    *  so it is needn&#x27;t to lock in the following functions </span></span><br><span class="line"><span class="comment">    *  -- when they call get_bucket() </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// caller, should designated the default value</span></span><br><span class="line">    <span class="function">Value <span class="title">value_for</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> Value &amp;default_value = Value())</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_bucket</span>(key).<span class="built_in">value_for</span>(key, default_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_or_update_mapping</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> Value &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">get_bucket</span>(key).<span class="built_in">add_or_update_mapping</span>(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove_mapping</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">get_bucket</span>(key).<span class="built_in">reomove_mapping</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// snapshot, return the backup in std::map</span></span><br><span class="line">    <span class="comment">// because we need to lock all buckets</span></span><br><span class="line">    <span class="comment">// if we add unique_lock, it would much wasty</span></span><br><span class="line">    <span class="comment">// so a bettery way is to use shared_mutex(read-lock)</span></span><br><span class="line">    <span class="comment">// so that other threads can also read meanwhile when we have locked a bucket</span></span><br><span class="line">    <span class="comment">// and then, we want to get the current state</span></span><br><span class="line">    <span class="comment">// so we should lock all buckets at one time</span></span><br><span class="line">    <span class="comment">// it is bad to lock and copy bucket one by one</span></span><br><span class="line">    <span class="comment">// because eg. when we lock A, and B will be modified</span></span><br><span class="line">    <span class="comment">// so the state is not consistency</span></span><br><span class="line">    <span class="function">std::map&lt;Key,Value&gt; <span class="title">get_map</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::vector&lt;std::unique_lock&lt;std::shared_mutex&gt;&gt; locks;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            locks.<span class="built_in">push_back</span>(</span><br><span class="line">                std::<span class="built_in">unique_lock</span>&lt;std::shared_mutex&gt;(buckets[i]-&gt;mutex)</span><br><span class="line">            );</span><br><span class="line">        &#125;   </span><br><span class="line">        std::map&lt;Key,Value&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;map_item : buckets[i]-&gt;data)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">insert</span>(map_item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">using</span> _map = threadsafe_lookup_table&lt;Key, Value&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _map&lt;<span class="type">int</span>,string&gt; table;</span><br><span class="line">    table.<span class="built_in">add_or_update_mapping</span>(<span class="number">1</span>, <span class="string">&quot;jyyyx&quot;</span>);</span><br><span class="line">    cout &lt;&lt; table.<span class="built_in">value_for</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    table.<span class="built_in">add_or_update_mapping</span>(<span class="number">2</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    cout &lt;&lt; table.<span class="built_in">value_for</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    table.<span class="built_in">add_or_update_mapping</span>(<span class="number">1</span>, <span class="string">&quot;sbg&quot;</span>);</span><br><span class="line">    cout &lt;&lt; table.<span class="built_in">value_for</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        table.<span class="built_in">add_or_update_mapping</span>(i, <span class="string">&quot;jyyyx: &quot;</span> + <span class="built_in">to_string</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> mp = table.<span class="built_in">get_map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : mp)</span><br><span class="line">        cout &lt;&lt; x.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⚠️⚠️⚠️    <strong>[BUG]</strong>    ⚠️⚠️⚠️</p>
</blockquote>
<p>在上面的代码中出现了很恶心的 bug（也可能是我太蠢了）， 导致我排查了好长好长时间，其实错误原因很简单。</p>
<p>在成员函数中，如果我们添加了 const 函数修饰符，那么如果我们返回一个迭代器的话，其实返回的是 const_iterator 而不是 iterator，const_iterator 有底层修饰，不能修改指向的对象。</p>
<p>例如下面的代码会报错：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> list&lt;PII&gt; L;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> L::iterator       L_iterator;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> L::const_iterator L_const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    L l;</span><br><span class="line">    <span class="function">L_iterator <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> <span class="comment">// (1)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">find_if</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> PII &amp;it)&#123;</span><br><span class="line">            <span class="keyword">return</span> it.first == x;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_val</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        L_iterator entry = <span class="built_in">get</span>(x);</span><br><span class="line">        <span class="keyword">return</span> entry-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo f;</span><br><span class="line">    L &amp;l = f.l; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )   l.<span class="built_in">push_back</span>(&#123;i, i + <span class="number">10</span>&#125;);</span><br><span class="line">    L_iterator it = f.<span class="built_in">get</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    it-&gt;second = <span class="number">1000</span>;</span><br><span class="line">    cout &lt;&lt; f.<span class="built_in">get_val</span>(<span class="number">2</span>) &lt;&lt; endl;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="built_in">test</span>();&#125;</span><br></pre></td></tr></table></figure>

<p>报错信息主要内容如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> std::<span class="built_in">find_if</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> PII &amp;it)&#123;</span><br><span class="line">      |                ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">      |                            |</span><br><span class="line">      |                            std::_List_const_iterator&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;</span><br><span class="line">   <span class="number">20</span> |             <span class="keyword">return</span> it.first == x;</span><br><span class="line">      |             ~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">   <span class="number">21</span> |         &#125;);</span><br><span class="line">      |         ~~</span><br></pre></td></tr></table></figure>

<p>很明显的发现，编译器提示我们，我们的返回值是一个 <code>list::const_iterator</code> 类型，而不是 <code>list::iterator</code>。</p>
<p>那你可能会说，如果我们不希望返回 const_ierator 的话，把 (1) 处的 const 去掉不久行了？</p>
<p>那你就得好好看了，下面的错误更隐蔽和恶心，去掉 (1) 处的 const 之后，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a.cpp: In member function <span class="string">&#x27;int Foo::get_val(int) const&#x27;</span>:</span><br><span class="line">a.cpp:<span class="number">25</span>:<span class="number">33</span>: error: passing <span class="string">&#x27;const Foo&#x27;</span> as <span class="string">&#x27;this&#x27;</span> argument discards qualifiers [-fpermissive]</span><br><span class="line">   <span class="number">25</span> |         L_iterator entry = <span class="built_in">get</span>(x);</span><br><span class="line">      |                                 ^</span><br><span class="line">a.cpp:<span class="number">17</span>:<span class="number">16</span>: note:   in call to <span class="string">&#x27;L_iterator Foo::get(int)&#x27;</span></span><br><span class="line">   <span class="number">17</span> |     <span class="function">L_iterator <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// (1)</span></span></span><br><span class="line"><span class="function">      |                ^~~</span></span><br></pre></td></tr></table></figure>

<p>上面的报错信息不认真看，理解着看的话，有可能不知道他说的是什么意思！其实这种错误在 《Effective C++》 系列都是强调过的！由此可见，光理论，不实践，掌握的知识不牢固，容易忘！</p>
<p>其实人话来说，就是 get_val() 是一个 const 成员函数，所以，在这个函数中， **this 指针是 this *const(底层 const)**，想必如果你很敏感的话，那么你应该知道错在哪了！我们把一个 this *const 传入到一个非 const 的成员函数 get() 当中，那么在 get() 当中就可能修改我们的 this，从而间接的破坏了 get_val() 的 const 属性！</p>
<blockquote>
<p>实际上，上面的 bug 正是 《effective STL》的一条 item:</p>
<p>“const_iterator fist!”</p>
</blockquote>
<p>那么，作者为什么会写出如此不严谨的代码呢？是选，有意思的一点是，如果不进行测试，上面的代码是没有问题的！那么，到底是作者写这本时的 C++ 和编译器的版本问题，还是作者偷懒没有进行测试呢？大概是前者吧！😊</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangdamingll/article/details/107086966">最终在这篇博客找到了 bug 的解决方案，感恩！</a></p>
</blockquote>
<p>最后，给出使用 iterator 的版本，只需要把所有 const 成员函数修饰去掉就行了。</p>
<blockquote>
<p>解决问题的方法就是不让问题产生 😭</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key,<span class="keyword">typename</span> Value,<span class="keyword">typename</span> Hash=std::hash&lt;Key&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> threadsafe_lookup_table</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">class</span> bucket_type</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::pair&lt;Key,Value&gt; bucket_value;</span><br><span class="line">    <span class="keyword">typedef</span> std::list&lt;bucket_value&gt; bucket_data;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> bucket_data::iterator bucket_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> bucket_data::const_iterator bucket_const_iterator;</span><br><span class="line">    </span><br><span class="line">    bucket_data data;</span><br><span class="line">    <span class="keyword">mutable</span> shared_mutex mutex;  <span class="comment">// 1</span></span><br><span class="line">    <span class="function">bucket_iterator <span class="title">find_entry_for</span><span class="params">(Key <span class="type">const</span>&amp; key)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">find_if</span>(data.<span class="built_in">begin</span>(),data.<span class="built_in">end</span>(),</span><br><span class="line">      [&amp;](bucket_value <span class="type">const</span>&amp; item)</span><br><span class="line">      &#123;<span class="keyword">return</span> item.first==key;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Value <span class="title">value_for</span><span class="params">(Key <span class="type">const</span>&amp; key,Value <span class="type">const</span>&amp; default_value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="function">shared_lock&lt;shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;  <span class="comment">// 3</span></span><br><span class="line">      bucket_iterator <span class="type">const</span> found_entry=<span class="built_in">find_entry_for</span>(key);</span><br><span class="line">      <span class="keyword">return</span> (found_entry==data.<span class="built_in">end</span>())?</span><br><span class="line">        default_value:found_entry-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_or_update_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key,Value <span class="type">const</span>&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;  <span class="comment">// 4</span></span><br><span class="line">      bucket_iterator <span class="type">const</span> found_entry=<span class="built_in">find_entry_for</span>(key);</span><br><span class="line">      <span class="keyword">if</span>(found_entry==data.<span class="built_in">end</span>())</span><br><span class="line">      &#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(<span class="built_in">bucket_value</span>(key,value));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        found_entry-&gt;second=value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;  <span class="comment">// 5</span></span><br><span class="line">      bucket_iterator <span class="type">const</span> found_entry=<span class="built_in">find_entry_for</span>(key);</span><br><span class="line">      <span class="keyword">if</span>(found_entry!=data.<span class="built_in">end</span>())</span><br><span class="line">      &#123;</span><br><span class="line">        data.<span class="built_in">erase</span>(found_entry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;bucket_type&gt; &gt; buckets;  <span class="comment">// 6</span></span><br><span class="line">  Hash hasher;</span><br><span class="line">  <span class="function">bucket_type&amp; <span class="title">get_bucket</span><span class="params">(Key <span class="type">const</span>&amp; key)</span>   <span class="comment">// 7</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::<span class="type">size_t</span> <span class="type">const</span> bucket_index=<span class="built_in">hasher</span>(key)%buckets.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> *buckets[bucket_index];</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">  <span class="keyword">typedef</span> Value mapped_type;</span><br><span class="line">  <span class="keyword">typedef</span> Hash hash_type;</span><br><span class="line">  <span class="built_in">threadsafe_lookup_table</span>(</span><br><span class="line">    <span class="type">unsigned</span> num_buckets=<span class="number">19</span>,Hash <span class="type">const</span>&amp; hasher_=<span class="built_in">Hash</span>()):</span><br><span class="line">    <span class="built_in">buckets</span>(num_buckets),<span class="built_in">hasher</span>(hasher_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> i=<span class="number">0</span>;i&lt;num_buckets;++i)</span><br><span class="line">    &#123;</span><br><span class="line">      buckets[i].<span class="built_in">reset</span>(<span class="keyword">new</span> bucket_type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">threadsafe_lookup_table</span>(threadsafe_lookup_table <span class="type">const</span>&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  threadsafe_lookup_table&amp; <span class="keyword">operator</span>=(</span><br><span class="line">    threadsafe_lookup_table <span class="type">const</span>&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  <span class="function">Value <span class="title">value_for</span><span class="params">(Key <span class="type">const</span>&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                  Value <span class="type">const</span>&amp; default_value=Value())</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_bucket</span>(key).<span class="built_in">value_for</span>(key,default_value);  <span class="comment">// 8</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add_or_update_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key,Value <span class="type">const</span>&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_bucket</span>(key).<span class="built_in">add_or_update_mapping</span>(key,value);  <span class="comment">// 9</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_bucket</span>(key).<span class="built_in">remove_mapping</span>(key);  <span class="comment">// 10</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    threadsafe_lookup_table&lt;<span class="type">int</span>,string&gt; table;</span><br><span class="line">    table.<span class="built_in">add_or_update_mapping</span>(<span class="number">1</span>, <span class="string">&quot;jyyyx&quot;</span>);</span><br><span class="line">    cout &lt;&lt; table.<span class="built_in">value_for</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    table.<span class="built_in">add_or_update_mapping</span>(<span class="number">2</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    cout &lt;&lt; table.<span class="built_in">value_for</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    table.<span class="built_in">add_or_update_mapping</span>(<span class="number">1</span>, <span class="string">&quot;sbg&quot;</span>);</span><br><span class="line">    cout &lt;&lt; table.<span class="built_in">value_for</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-3-2-threadsafe-list"><a href="#6-3-2-threadsafe-list" class="headerlink" title="6.3.2 threadsafe list"></a>6.3.2 threadsafe list</h4><p>同上面谈到的，容器中的迭代器在并发时会产生麻烦，除非让迭代器持有锁，但这是个很槽糕的做法。因此这意味着迭代器受限于锁，而不是容器。</p>
<p>替代方案是使用迭代函数，例如：将 for_each 作为容器本身的一部分。这就能让容器对迭代的部分进行负责和锁定。</p>
<p>。。。</p>
<p>链表应该提供的操作：（增删改查）</p>
<ul>
<li>向列表添加一个元素</li>
<li>当某个条件满足时，就从链表中删除某个元素</li>
<li>当某个条件满足时，从链表中查找某个元素</li>
<li>当某个条件满足时，更新链表中的某个元素</li>
<li>（more）将当前容器中链表中的每个元素，复制到另一个容器中</li>
<li>（more）插入元素到某个指定的位置</li>
</ul>
<p>使用细粒度锁最初的想法，是为了<strong>让链表每个节点都拥有一个互斥量</strong>。当链表很长时，那么就会有很多的互斥量!这样的好处是对于链表中每一个独立的部分，都能实现真实的并发：其真正感兴趣的是对持有的节点群进行上锁，并且在移动到下一个节点的时，对当前节点进行释放。下面的清单中将展示这样的一个链表实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a list with head-node</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_list</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">    &#123;</span><br><span class="line">        std::mutex m;</span><br><span class="line">        std::shared_ptr&lt;T&gt; data;</span><br><span class="line">        std::unique_ptr&lt;node&gt; next;</span><br><span class="line">        <span class="built_in">node</span>() : <span class="built_in">next</span>() &#123;&#125; <span class="comment">// default NULL</span></span><br><span class="line">        <span class="built_in">node</span>(<span class="type">const</span> T &amp;value) : <span class="built_in">data</span>(std::<span class="built_in">make_shared</span>&lt;T&gt;(value)) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    node head; <span class="comment">// default head node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_list</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">threadsafe_list</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">remove_if</span>([](<span class="type">const</span> node&amp;)&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_list</span>(<span class="type">const</span> threadsafe_list&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    threadsafe_list&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_list&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// the construction of new node neeedn&#x27;t to lock</span></span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">new_node</span><span class="params">(<span class="keyword">new</span> node(value))</span></span>;</span><br><span class="line">        <span class="comment">// lock head</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(head.m)</span></span>;</span><br><span class="line">        new_node-&gt;next = std::<span class="built_in">move</span>(head.next);</span><br><span class="line">        head.next = std::<span class="built_in">move</span>(new_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">for_each</span><span class="params">(Function f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// the node of head is a fixed and virtual node</span></span><br><span class="line">        <span class="comment">// it means no one can change it, so there is no &quot;race condition&quot;</span></span><br><span class="line">        <span class="comment">// -- when multiple threads execute the follow sentense</span></span><br><span class="line">        node *current = &amp;head; </span><br><span class="line">        <span class="comment">// because we need do unlock by self, so unique_lock does</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(head.m)</span></span>; </span><br><span class="line">        <span class="keyword">while</span>(node *next = current-&gt;next.<span class="built_in">get</span>()) <span class="comment">// declare a local variable </span></span><br><span class="line">                            <span class="comment">// -- next in the while&#x27;s check ????</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// lock the next first and unlock the past succession</span></span><br><span class="line">            <span class="comment">// there is a beautiful name for this process: hand to hand lock ^_^</span></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">next_lock</span><span class="params">(next-&gt;m)</span></span>;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="comment">// because head is a virtual node(no data)</span></span><br><span class="line">            <span class="comment">// we should call funtion start at head-&gt;next</span></span><br><span class="line">            <span class="built_in">f</span>(*next-&gt;data);</span><br><span class="line">            current = next;</span><br><span class="line">            lock = std::<span class="built_in">move</span>(next_lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expect for unary Predicate</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</span></span><br><span class="line"><span class="function">    std::shared_ptr&lt;T&gt; <span class="title">find_first_if</span><span class="params">(Predicate p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node *current = &amp;head;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(head.m)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(node *next = current-&gt;next.<span class="built_in">get</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">next_lock</span><span class="params">(next-&gt;m)</span></span>;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">p</span>(*next-&gt;data))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> next-&gt;data;</span><br><span class="line">            &#125;</span><br><span class="line">            current = next;</span><br><span class="line">            lock = std::<span class="built_in">move</span>(next_lock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">remove_if</span><span class="params">(Predicate p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node *current = &amp;head;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(head.m)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(node *next = current-&gt;next.<span class="built_in">get</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">next_lock</span><span class="params">(next-&gt;m)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">p</span>(*next-&gt;data))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// usage of smart_ptr and move() can avoid to execute big copy</span></span><br><span class="line">                std::unique_ptr&lt;node&gt; old_next = std::<span class="built_in">move</span>(current-&gt;next);</span><br><span class="line">                current-&gt;next = std::<span class="built_in">move</span>(next-&gt;next);</span><br><span class="line">                next_lock.<span class="built_in">unlock</span>();</span><br><span class="line">                <span class="comment">// needn&#x27;t to move current to next node</span></span><br><span class="line">                <span class="comment">// because the new next node will satisfiy Predicate, too</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                lock.<span class="built_in">unlock</span>();</span><br><span class="line">                current = next;</span><br><span class="line">                lock = std::<span class="built_in">move</span>(next_lock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    threadsafe_list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )   </span><br><span class="line">        L.<span class="built_in">push_front</span>(i % <span class="number">5</span>);</span><br><span class="line">    L.for_each([](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    L.<span class="built_in">remove_if</span>([](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;<span class="keyword">return</span> x == <span class="number">4</span>;&#125;);</span><br><span class="line">    L.for_each([](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> it = L.<span class="built_in">find_first_if</span>([](<span class="type">const</span> <span class="type">int</span> x)&#123;<span class="keyword">return</span> x == <span class="number">1</span>;&#125;);</span><br><span class="line">    *it = <span class="number">1024</span>;</span><br><span class="line">    L.for_each([](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    it = L.<span class="built_in">find_first_if</span>([](<span class="type">const</span> <span class="type">int</span> x)&#123;<span class="keyword">return</span> x == <span class="number">1</span>;&#125;);</span><br><span class="line">    *it = <span class="number">666</span>;</span><br><span class="line">    L.for_each([](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    L.<span class="built_in">remove_if</span>([](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;<span class="keyword">return</span> x == <span class="number">1</span>;&#125;);</span><br><span class="line">    L.for_each([](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>学到了个新东西</p>
</blockquote>
<p>可以在 while 的条件判断里面声名一个局部变量，并且可以在 while body 里面使用，但是有个限制，就是只能使用默认比价方式（0，nullptr），如果你想使用特殊的比较方式，例如：<code>while((int y = x + 1) != 3)</code>，那么局部变量 y 的作用域实际上是 <code>(int y = x + 1)</code> 这个括号里面，除了括号就死了，因此在 while body 里面也就无法使用，这时候，就得在 while 外面声明这个变量了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="type">int</span> y = x + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        x ++ ;</span><br><span class="line">        <span class="keyword">if</span>(y &gt; <span class="number">10</span>)  <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="P7-data-struct-without-mutex"><a href="#P7-data-struct-without-mutex" class="headerlink" title="P7 data struct without mutex"></a>P7 data struct without mutex</h2><p><font color=blue> TODO</font></p>
<h2 id="P8-concurrency-design"><a href="#P8-concurrency-design" class="headerlink" title="P8 concurrency design"></a>P8 concurrency design</h2><p><font color=blue> TODO</font></p>
<p>文章主要内容包括：</p>
<ul>
<li>线程间划分数据的技术</li>
<li>影响并发代码性能的因素</li>
<li>性能因素是如何影响数据结构的设计</li>
<li>多线程代码中的异常安全</li>
<li>可拓展性</li>
<li>并行算法的实现</li>
</ul>
<h3 id="8-1-divide-work-among-threads"><a href="#8-1-divide-work-among-threads" class="headerlink" title="8.1 divide work among threads"></a>8.1 divide work among threads</h3><p> 最直白的，对于一个线程，是让他充当一个“全能”线程来完成所有工作，还是充当一个“专业”线程完成一件事情，还是两者混合。等等。诸如此类的选择至关重要。</p>
<h4 id="8-1-1-prepare-divide"><a href="#8-1-1-prepare-divide" class="headerlink" title="8.1.1 prepare divide"></a>8.1.1 prepare divide</h4><p>思想很简单，就是在创建线程之前，把多个任务分为一组，一个线程处理一组任务。</p>
<p>但是这样做仍然有一个不太好的地方，如代码2.8 所示，最后一步仍然是串行的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">accumulate_block</span>&lt;Iterator,T&gt;()</span><br><span class="line">(block_start,last,results[num_threads<span class="number">-1</span>]); </span><br></pre></td></tr></table></figure>

<p>不过，accumulate 实际上是一个递减操作（即任务的个数是逐渐减少的），因此当线程数量大于一个线程上最小处理项时，可以对函数递归调用，这样就可以最大化并行的程度。</p>
<blockquote>
<p>原本递归是等一个子函数执行完，再执行另一个子函数。但是通过线程，我们可以同时递归执行多个子函数，自函数再递归执行多个自函数，每个子函数占用一个线程。</p>
<p>可以发现，这对线程数量的要求比较高！</p>
</blockquote>
<h4 id="8-1-2-recursion-divide"><a href="#8-1-2-recursion-divide" class="headerlink" title="8.1.2 recursion divide"></a>8.1.2 recursion divide</h4><p>快速排序就用到了递归！</p>
<p>下面是 list 的快速排序算法的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO</span></span><br></pre></td></tr></table></figure>



<h4 id="8-1-3-work-divide"><a href="#8-1-3-work-divide" class="headerlink" title="8.1.3 work divide"></a>8.1.3 work divide</h4><p>多线程下有两个危险需要分离。</p>
<ol>
<li>第一个是对错误的担忧（主要表现为线程间共享着很多的数据）</li>
<li>第二个是不同的线程需要相互等待。</li>
</ol>
<p>这两种情况都是因为线程间很密切的交互。如果这种情况发生，就需要看一下为什么发生这么多交互。当所有交互都有相同的问题，就应该使用但线程来解决，并将引用同一源的线程提取出来。或者当有两个线程需要频繁的交流，在没有其它线程时，就可以将这两个线程合为一个线程。</p>
<p>当任务会应用到相同的任务序列，去处理独立的数据项时，就可以使用 pipeline 系统进行并发。</p>
<p>使用这种方式划分工作，可以为流水线中的每一阶段操作创建一个独立线程。</p>
<h3 id="8-2-performance-of-concurrency"><a href="#8-2-performance-of-concurrency" class="headerlink" title="8.2 performance of concurrency"></a>8.2 performance of concurrency</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34074740/article/details/92960920">关于cpu的核和芯</a></p>
<p>原生多核，封装多芯</p>
<p>作者说，四核两芯的cpu可以有16个线程，是因为超线程吗？</p>
</blockquote>
<h4 id="8-2-1-cpu-count"><a href="#8-2-1-cpu-count" class="headerlink" title="8.2.1 cpu count"></a>8.2.1 cpu count</h4><p>为了拓展线程的数量，且与硬件所支持的并发线程数一致，C++ 标准库提供了 <code>std::thread::hardware_concurrency()</code>，使用这个函数可以知道在给定硬件上可以拓展的线程数量。</p>
<blockquote>
<p>我的 MacBook M1 Air 才是 8</p>
</blockquote>
<p>使用的线程个数不是越多越好，太多线程进行切换会导致 oversubscription(超额请求)</p>
<h4 id="8-2-2-race-data-and-cache-ping-pong"><a href="#8-2-2-race-data-and-cache-ping-pong" class="headerlink" title="8.2.2 race data and cache ping-pong"></a>8.2.2 race data and cache ping-pong</h4><p>当多个线程在不同的处理器上时，对数据的读取通常不会有问题，因为数据会拷贝到每个线程的缓存中，并让多个处理器同时处理。然鹅，当有线程对数据进行修改，并且需要同步到其它核心的缓存时，需要浪费一定的时间。这样的修改可能会让其它处理情停下来，等待硬件内存更新缓存的数据。并且，根据 cpu 指令，这是一个特别慢的操作。</p>
<blockquote>
<p><strong>high contention</strong>：处理器之间经常需要等待数据的更改</p>
<p><strong>low contention</strong>：处理器之间很少需要相互等待</p>
<p><strong>cache ping-pong</strong>：在多个处理器的缓存之间来回传递的数据</p>
</blockquote>
<p>避免 cache ping-pong 的方法就是减少两个线程对同一个内存为止的竞争</p>
<h4 id="8-2-3-false-sharing"><a href="#8-2-3-false-sharing" class="headerlink" title="8.2.3 false sharing"></a>8.2.3 false sharing</h4><p>cache line sharing</p>
<p>其实就是减少缓存的刷新次数，降低数据伪共享缓存的概率。</p>
<h4 id="…"><a href="#…" class="headerlink" title="…."></a>….</h4><h3 id="8-3-design-data-struct-for-multiple-thread-environment"><a href="#8-3-design-data-struct-for-multiple-thread-environment" class="headerlink" title="8.3 design data struct for multiple thread environment"></a>8.3 design data struct for multiple thread environment</h3><p>当为多线程设计数据结构时，需要考虑：contention, false sharing, data proximity(数据临近)，这些对性能都有重大影响。</p>
<h2 id="P9-advance-thread-management"><a href="#P9-advance-thread-management" class="headerlink" title="P9 advance thread management"></a>P9 advance thread management</h2><h2 id="P10-parallel-algorithm"><a href="#P10-parallel-algorithm" class="headerlink" title="P10 parallel algorithm"></a>P10 parallel algorithm</h2><h2 id="P11-test-and-debug-in-multiple-thread-environment"><a href="#P11-test-and-debug-in-multiple-thread-environment" class="headerlink" title="P11 test and debug in multiple thread environment"></a>P11 test and debug in multiple thread environment</h2><p><strong>[TODO]</strong></p>
<h2 id="A-Myheader"><a href="#A-Myheader" class="headerlink" title="A Myheader"></a>A Myheader</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">@copyright jyyyx</span></span><br><span class="line"><span class="comment">    __</span></span><br><span class="line"><span class="comment">.__(.)&lt; (qaq ~~~)</span></span><br><span class="line"><span class="comment">\____)</span></span><br><span class="line"><span class="comment">~~~~~~~~~~~~~~~~~--&gt;</span></span><br><span class="line"><span class="comment">When I write this, only god and me konw what the program mean</span></span><br><span class="line"><span class="comment">Now, only god konws QAQ</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_HEADER_GUARD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_HEADER_GUARD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span> <span class="comment">// std::shared_mutex</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// for_each</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span>    <span class="comment">// class ratio</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// unique_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// result_of</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">// accumulate</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>   <span class="comment">// mem_fn</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>   <span class="comment">// std::chrono, time point, time duration</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span>    <span class="comment">// copy_exception renamed to make_exception_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span>   <span class="comment">// put_time</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*================ header ================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN std::cout &lt;&lt; <span class="string">&quot;|------ begin ------|&quot;</span> &lt;&lt; std::endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   std::cout &lt;&lt; <span class="string">&quot;|------- end -------|&quot;</span> &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::mutex some_mutex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>



<h2 id="B-std-atomic"><a href="#B-std-atomic" class="headerlink" title="B std::atomic"></a>B std::atomic</h2><h3 id="0-reference"><a href="#0-reference" class="headerlink" title="0. reference"></a>0. reference</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7086226046931959838">ref1</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/haippy/p/3284540.html">ref2</a></p>
<p><a target="_blank" rel="noopener" href="https://subingwen.cn/cpp/atomic/">ref3</a></p>
<h3 id="1-introduce"><a href="#1-introduce" class="headerlink" title="1. introduce"></a>1. introduce</h3><p><code>#include &lt;atomic&gt;</code></p>
<p>原子类型(<code>std::atoimic&lt;T&gt;</code>)是封装了一个值的类型，它的访问保证不会导致数据的竞争，并且可以用于在不同的线程之间同步内存访问。</p>
<p>原子类型主要用于避免加锁解锁时的程序开销，从而提高性能。(互斥量加锁一般针对的是一个代码段，而原子操作针对的一般是一个变量)。</p>
<p>原子类型是“指令”层面上的支持，因此它的性能相比锁和消息传递会好很多。</p>
<p>std::atomic 内部使用了 CAS(compare and swap) 自旋锁：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CompareAndSwap</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> expceted, <span class="type">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> actual = *ptr;</span><br><span class="line">    <span class="keyword">if</span>(actual == expected) *ptr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> *actual;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*===================================*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">CompareAndSwap</span>(&amp;lock-&gt;flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>) </span><br><span class="line">        	; <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-std-atomic-flag"><a href="#2-std-atomic-flag" class="headerlink" title="2. std::atomic_flag"></a>2. std::atomic_flag</h3><p><code>std::atomic_flag</code>是原子布尔类型，它保证是免锁（lock-free）的。只支持两种操作：<code>test-andset</code> 和 <code>clear</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须使用 ATOMIC_FLAG_INIT 初始化，否则值是 UB</span></span><br><span class="line"><span class="comment">// 即，既不是 set 也不是 clear</span></span><br><span class="line"><span class="comment">// 该宏将使得 atomic_flag 处于 clear 状态</span></span><br><span class="line">std::atomic_flag alock = ATOMIC_FLAG_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(alock.<span class="built_in">test_and_set</span>(std::memory_order_acquire)) <span class="comment">// 获得锁</span></span><br><span class="line">            ;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Output from thread &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        alock.<span class="built_in">clear</span>(std::memory_order_release);  <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    std::vector&lt;std::thread&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(f, i); <span class="comment">// 通过 emplace 传入线程和参数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it : v)   </span><br><span class="line">        it.<span class="built_in">join</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>自旋锁</p>
<blockquote>
<p>自旋锁是<strong>计算机科学用于多线程同步的一种锁</strong>，线程反复检查锁变量是否可用。 由于线程在这一过程中保持执行，因此是一种<strong>忙等待</strong>。 一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。 自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。</p>
</blockquote>
<p>C++ 是系统级别的编程语言，标准委员会的目标是不需要比C++还要底层的高级语言。C++ 应该向程序员提供足够的灵活性，无障碍的去做他们想要做的事情。需要时，也可以“接触硬件”。原子类型和原子操作就可以<strong>“接触硬件”</strong>，并提供底层同步操作，通常会将指令数缩减到 1～2 个CPU指令。</p>
<p><font color = blue> TODO ⌛️⌛️⌛️ </font></p>
<p>一个简单的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread_pool_cpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_COUNT 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> </span><br><span class="line">&#123;</span><br><span class="line">    mutex m;</span><br><span class="line">    <span class="comment">// int value;</span></span><br><span class="line">    atomic&lt;<span class="type">int</span>&gt; value;</span><br><span class="line">    <span class="built_in">Counter</span>(<span class="type">int</span> _value = <span class="number">0</span>) : <span class="built_in">value</span>(_value) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_COUNT; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            value ++ ;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;increment number: &quot; &lt;&lt; value </span></span><br><span class="line">            <span class="comment">//     &lt;&lt; &quot;, threadID: &quot; &lt;&lt; hex &lt;&lt; this_thread::get_id() &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">            <span class="comment">// this_thread::sleep_for(chrono::milliseconds(100));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">consume</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_COUNT; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            value -- ;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;decrement number: &quot; &lt;&lt; value </span></span><br><span class="line">            <span class="comment">//     &lt;&lt; &quot;, threadID: &quot; &lt;&lt; hex &lt;&lt; this_thread::get_id() &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">            <span class="comment">// this_thread::sleep_for(chrono::milliseconds(100));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Counter <span class="title">c</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> increment = <span class="built_in">bind</span>(&amp;Counter::produce, &amp;c);</span><br><span class="line">    <span class="keyword">auto</span> decrement = <span class="built_in">bind</span>(&amp;Counter::consume, &amp;c);</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(decrement)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t4</span><span class="params">(decrement)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; c.value &lt;&lt; endl;</span><br><span class="line">;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h1 id="C-thread-pool"><a href="#C-thread-pool" class="headerlink" title="C:thread_pool"></a>C:thread_pool</h1><h2 id="站在巨人的肩膀上"><a href="#站在巨人的肩膀上" class="headerlink" title="站在巨人的肩膀上"></a>站在巨人的肩膀上</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://subingwen.cn/categories/Linux/">document</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1sv41177e4/?p=19">multiple thread</a>    <a target="_blank" rel="noopener" href="https://subingwen.cn/linux/threadpool/#1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86">document</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jV411J795/?spm_id_from=333.999.0.0&vd_source=38033fe3a1f136728a1d6f8acf710b51">thread pool in C</a></p>
</blockquote>
<h2 id="一、-多线程"><a href="#一、-多线程" class="headerlink" title="一、 多线程"></a>一、 多线程</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><blockquote>
<p>可以通过sleep稍微控制线程的执行顺序。。。</p>
</blockquote>
<p>一个线程就是一个“任务”，当我们创建一个线程时，它就开始执行这个任务。</p>
<h3 id="2-创建线程"><a href="#2-创建线程" class="headerlink" title="2. 创建线程"></a>2. 创建线程</h3><p>我们创建的线程一般称为子线程，为啥不是主线程呢？因为主线程一般是默认存在的！当我们在一个进程中创建线程时，主进程会变成主线程。</p>
<p>因此，当主线程退出时，也就意味着主进程结束了，也就意味着分配的虚拟内存空间要释放，因此其余线程也要销毁。</p>
<p>但是，我们可以通过调用相关API，使得主线程退出后，子线程也可以正常运行。</p>
<p><code>pthread_create();</code></p>
<h3 id="3-线程退出"><a href="#3-线程退出" class="headerlink" title="3. 线程退出"></a>3. 线程退出</h3><p>在上面提到，如果主线程退出，子线程没执行完也会结束。我们也提到，只需要使用（线程退出函数）就可以让当前线程“马上退出”，并且不会影响其他线程的正常运行。</p>
<p>如果所有线程都使用了线程退出函数，那么当所有线程执行结束之后，系统资源（虚拟地址空间）会被操作系统回收。</p>
<p><code>pthread_exit();</code></p>
<p>当线程退出时，还可以通过该函数传出一些数据（其实是这些数据的地址）。 注意不能传出栈中的数据。</p>
<p>可以通过下面三种方式：</p>
<ol>
<li>heap</li>
<li>全局&#x2F;static</li>
<li>接受主线程（调用线程）中的数据，并传出接受的数据。</li>
</ol>
<p>子线程是不能访问主线程的栈空间的，但是主线程可以主动传入。</p>
<h3 id="4-线程回收"><a href="#4-线程回收" class="headerlink" title="4. 线程回收"></a>4. 线程回收</h3><p>主线程回收子线程资源。</p>
<p>回收什么资源呢？</p>
<p>我们知道，线程独占stack等，当线程结束时，stack资源会自动释放，heap，data和text等共享资源由操作系统自动回收。</p>
<p>主线程回收的主要是“内核资源”。这件事子线程自己干不了。</p>
<p><code>pthread_join(tid, **retval);</code></p>
<p>为什么第二个参数接受一个二级指针呢？</p>
<p>因为我们如果要接受<code>pthread_exit();</code> 返回的数据，就要使用一个指针（<code>void*</code>）接受。因为 <code>pthread_exit</code> 返回的数据类型就是 <code>void*</code>。</p>
<p>如果我们要修改一个指针（注意不是指针指向的数据），就要传入一个指针的地址，所以我们就要用指向指针的指针。</p>
<p>注意 join 是一个阻塞函数。</p>
<h3 id="5-线程分离"><a href="#5-线程分离" class="headerlink" title="5. 线程分离"></a>5. 线程分离</h3><p>detach：分离</p>
<p>默认情况下，主线程和子线程是有联系的，即，主线程需要释放子线程拥有的资源。</p>
<p>调用这个函数之后，指定的子线程和主线程分离。当子线程推出的时候，其占用的内核资源就被系统的其他进程接管并回收了。（这意味着 <code>pthread_join()</code> 无法回收子线程资源）</p>
<p>可能你会问，我们已经有了 <code>join</code> 了啊，他已经可以完成线程内核资源回收的任务了，为什么还有有 <code>detach</code> 呢，这是因为 <code>join</code> 是阻塞性函数，也就是说，当子线程不 <code>exit</code> 时，主线程就会一直处于阻塞状态。</p>
<p><code>detach</code> 就是给主线程减负的，当子线程结束时，其资源不需要主线程来回收。</p>
<p>但是当主线程结束时，子线程仍然会结束，即使子线程处于 <code>detach</code> 状态。如果我们希望主线程结束时不影响子线程的执行，应该调用 <code>exit</code> 函数。 </p>
<h2 id="二、线程同步"><a href="#二、线程同步" class="headerlink" title="二、线程同步"></a>二、线程同步</h2><h3 id="1-为什么要同步"><a href="#1-为什么要同步" class="headerlink" title="1. 为什么要同步"></a>1. 为什么要同步</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX (25)</span></span><br><span class="line"><span class="type">int</span> sum;    </span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">add</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch = *(<span class="type">char</span>*)arg;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> old = sum;</span><br><span class="line">        old ++ ;</span><br><span class="line">        <span class="comment">// do something to make thread run currency worse</span></span><br><span class="line">        usleep(<span class="number">5</span>);</span><br><span class="line">        sum = old;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%c]sum = %d\n&quot;</span>, ch, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2;</span><br><span class="line">    <span class="type">char</span> c1 = <span class="string">&#x27;A&#x27;</span>, c2 = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    pthread_create(&amp;p1, <span class="literal">NULL</span>, add, (<span class="type">void</span>*)&amp;c1);</span><br><span class="line">    pthread_create(&amp;p2, <span class="literal">NULL</span>, add, (<span class="type">void</span>*)&amp;c2);</span><br><span class="line">    pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;End, sum = %d\n&quot;</span>, sum);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码希望通过两个线程实现对 sum 的累加，并希望结果为50，但是却不是。</p>
<h3 id="2-互斥锁"><a href="#2-互斥锁" class="headerlink" title="2. 互斥锁"></a>2. 互斥锁</h3><p>如其名，互斥锁只能被一个线程使用。</p>
<p>通过互斥锁，让线程线性执行，这样就不会有并发问题。</p>
<p>锁的个数取决于临界资源而不是线程个数。</p>
<p>另外，可以发现使用互斥锁的函数都是用的mutex指针，这就说明我们的mutex不能分配在 局部内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create mutex</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// init</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// destory</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destory</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">// lock，已经lock会阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">// 已经lock会失败</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<p>key :strict</p>
<blockquote>
<p>用来修饰指针，只有这个关键字修饰的指针才能访问指向的内存地址，其他指针都是不行的（类型匹配也不行）。</p>
<p><strong>TODO:</strong> 但是我测试不行？？</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> *restrict p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ++ *p;</span><br><span class="line">    <span class="type">int</span> *q = (<span class="type">int</span>*)p;</span><br><span class="line">    ++ *q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">add</span>(&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-读写锁"><a href="#3-读写锁" class="headerlink" title="3. 读写锁"></a>3. 读写锁</h3><p>读写锁是互斥锁的升级版。在做读操作的时候可以提高程序的执行效率，如果所有的线程都是读操作，那么都是并行的。而使用互斥锁，读操作是串行的。</p>
<p>其与互斥锁的区别主要在于读操作可以并行，因此，当线程涉及到大量读操作，读写锁的效率比互斥锁高。</p>
<p>读写锁虽然有读锁和写锁，但他是「一把锁」。</p>
<p>写锁的优先级比读锁高。</p>
<p>API:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declare</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">// init</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *restrict rolock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *restrict attr)</span></span>;</span><br><span class="line"><span class="comment">// destory</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_destory</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// read lock，如果已经加了写锁，线程阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// try read lock，如果已经写了写锁，失败返回，不会阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// write lock，只要加了锁（读/写）就会失败，阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// try write lock</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_tryrwlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// unlock</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Example：下面是，5个线程执行读操作，3个线程执行写操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX (20)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_COUNT  (5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_COUNT (3)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum;    </span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func_read</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread read, id = %lu, sum = %d\n&quot;</span>, <span class="built_in">pthread_self</span>(), sum);</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="built_in">rand</span>() % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func_write</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="type">int</span> cur = sum;</span><br><span class="line">        cur ++ ;   </span><br><span class="line">        sum = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread write, id = %lu, sum = %d\n&quot;</span>, <span class="built_in">pthread_self</span>(), sum);</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_rwlock_init</span>(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">pthread_t</span> rd[READ_COUNT], wr[READ_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; READ_COUNT; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        rd[i] = <span class="built_in">pthread_create</span>(&amp;rd[i], <span class="literal">NULL</span>, func_read, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; WRITE_COUNT; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        wr[i] = <span class="built_in">pthread_create</span>(&amp;wr[i], <span class="literal">NULL</span>, func_write, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; READ_COUNT; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(rd[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; WRITE_COUNT; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(wr[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// expect sum = 60</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Father thread id = %ld\n, sum = %d&quot;</span>, <span class="built_in">pthread_self</span>(), sum);</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_rwlock_destroy</span>(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后，我们可以发现，所有打印出来的 sum 是升序的，这说明我们的读写锁没有问题，另外，我们可以发现，有大量读操作在最后才执行，这是因为前面说的，当一个读操作和一个写操作同时访问同一个临界资源时，写操作的优先级更高。</p>
<h3 id="4-条件变量"><a href="#4-条件变量" class="headerlink" title="4. 条件变量"></a>4. 条件变量</h3><p>严格意义上来说，条件变量的主要作用不是处理线程同步，<strong>而是进行线程的阻塞。</strong></p>
<p>如果多线程下只使用条件变量无法完成线程的同步，必须要配合互斥锁来使用。</p>
<p>那既然有了互斥锁，为什么还要用条件变量呢？主要是为了处理「生产者和消费者模型」。（常规的临界资源只有一份，只允许一个线程访问，而有时候临界资源可能有多份，可以分给多个线程，这就是条件变量的用处）</p>
<p>APIs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declare</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// create</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *restrict cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *restrict atrt)</span></span>;</span><br><span class="line"><span class="comment">// destroy</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// wait，会阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *restrict cond, <span class="type">pthread_mutex_t</span> *restrict mutex)</span></span>; <span class="comment">// 可以发现，这里使用了一个互斥锁;其中，互斥锁是用来同步的，条件变量是用来阻塞线程的。</span></span><br><span class="line"><span class="comment">// time wait，将线程阻塞一段时间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_timewait</span><span class="params">(<span class="type">pthread_cond_t</span> *restrict cond, <span class="type">pthread_mutex_t</span> *restrict mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *restrict abstime)</span></span>; <span class="comment">// 阻塞时间为 sec + nsec。</span></span><br><span class="line"><span class="comment">// signal specific one，至少有一个被解除阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cont_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// signal all，唤醒阻塞在条件变量伤的线程，被阻塞的线程全部解除阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>; 	<span class="comment">// 将所有线程唤醒之后，只有wait成功的线程才会执行，剩下的wait失败的线程会继续阻塞。</span></span><br></pre></td></tr></table></figure>

<p>为什么 pthread_cond_wait() 的参数有一个 mutex？</p>
<blockquote>
<p>首先，我们需要知道 wait 做了什么？</p>
<ol>
<li>释放自己占据的 mutex（作为参数传入）</li>
<li>阻塞，等待被别的线程唤醒</li>
<li>被唤醒后，再次获取 mutex（作为参数传入）</li>
</ol>
<p>现在明白了吧，一般来说，我们执行 cond_wait 的时候，都是已经 mutex_lock 的，如果我们不 unlock 的话，其他线程就无法进入临界区，也就无法 cond_signal，那么被阻塞的线程也就不会被唤醒。也就发生了死锁。</p>
</blockquote>
<p>example1：生产者消费者模型 - 链表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT (5)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node_t</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node_t</span> *next;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line">Node *head;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">produce</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> id = (<span class="type">unsigned</span> <span class="type">long</span>)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 链表不可能满，除非malloc错误</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> val = <span class="built_in">rand</span>() % <span class="number">1000</span>;</span><br><span class="line">        Node *newNode = (Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">        newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        newNode-&gt;val = val;</span><br><span class="line">        <span class="keyword">if</span>(newNode == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[Producer] id = %ld, malloc Wrong\n&quot;</span>, id);</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[Producer%d] id = %lu, val = %d\n&quot;</span>, id, <span class="built_in">pthread_self</span>(), val);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">        <span class="comment">// pthread_cond_broadcast(&amp;mutex);</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">consume</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> id = (<span class="type">unsigned</span> <span class="type">long</span>)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 阻塞消费者进程，并释放它的锁，否则，它既占据着mutex，又占据cond，就会死锁</span></span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);   </span><br><span class="line">        &#125;</span><br><span class="line">        Node *cur = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[Consumer%d] id = %lu, val = %d\n&quot;</span>, id, <span class="built_in">pthread_self</span>(), cur-&gt;val);</span><br><span class="line">        <span class="built_in">free</span>(cur);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">pthread_t</span> t1[COUNT], t2[COUNT];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;t1[i], <span class="literal">NULL</span>, produce, (<span class="type">void</span>*)i);</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;t2[i], <span class="literal">NULL</span>, consume, (<span class="type">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(t1[i], <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_join</span>(t2[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;cond);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这个生产者消费者模型中，我们使用链表储存产品，因为理论上可以存储无限个产品，所以只需要使用一个条件变量判断产品队列是否为空。</p>
<p>如果使用数组，即产品是有限的，那么我们还需要一个新的条件变量来判断产品是否满了。</p>
<p>注意我们不能同时使用同一个条件变量判断是否为满和是否为空。</p>
</blockquote>
<p>example2：生产者消费者模型 - 数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="5-信号量"><a href="#5-信号量" class="headerlink" title="5. 信号量"></a>5. 信号量</h3><p>同条件变量一样，信号量主要用于阻塞线程，不能完全保证线程安全，如果要保证线程安全，需要信号量和互斥锁一起使用。</p>
<p>另外，需要注意信号量的wait和条件变量的wait是不同的，这从参数列表就可以发现，信号量的wait参数列表中并没有 mutex 参数，因此，当线程阻塞时，他不会释放获取的 mutex 资源，因此，我们必须通过手工的方式控制信号量和锁的获取顺序：先获取信号量，再获取锁，以避免死锁。</p>
<p><code>&lt;semaphore.h&gt;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declare</span></span><br><span class="line"><span class="type">sem_t</span> sem;</span><br><span class="line"><span class="comment">// create</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br><span class="line">	<span class="comment">// pshared</span></span><br><span class="line">		<span class="comment">// 0: 线程同步</span></span><br><span class="line">		<span class="comment">// !0:进程同步</span></span><br><span class="line">	<span class="comment">// value:初始化当前信号量拥有的资源数，如果资源数为0，线程就会被阻塞了。</span></span><br><span class="line"><span class="comment">// destroy</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="type">se_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">// wait，if value==0，阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">// trywait，不会阻塞，直接失败</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">// timewait，资源数为0时，阻塞线程，在阻塞 abs_timeout 对应的时间之后，解除阻塞线程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec, *abs_timeout)</span></span>;</span><br><span class="line"><span class="comment">// post</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">// get shared value</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span></span>;</span><br><span class="line">	<span class="comment">// 第二个参数返回 shared-value，返回值是用来错误检查的</span></span><br></pre></td></tr></table></figure>

<p>example：生产者和消费者模型</p>
<h3 id="6-timespec"><a href="#6-timespec" class="headerlink" title="6. timespec"></a>6. timespec</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> tv_sec;	<span class="comment">// 秒</span></span><br><span class="line">    <span class="type">long</span> tv_nsec;	<span class="comment">// 纳秒</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line">time mytim = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span> tmsp;</span><br><span class="line">tmsp.tv.nsec = <span class="number">0</span>;</span><br><span class="line">tmsp.tv_sec = <span class="built_in">time</span>(<span class="literal">NULL</span>) + <span class="number">100</span>;	<span class="comment">// 线程阻塞100秒s</span></span><br></pre></td></tr></table></figure>

<h2 id="三、线程池"><a href="#三、线程池" class="headerlink" title="三、线程池"></a>三、线程池</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h3><p>为什么要有线程池</p>
<blockquote>
<p>同内存池的设计需求一样，线程池也是用来避免线程的大量创建和销毁所带来的巨大开销。</p>
</blockquote>
<p>线程池的组成部分</p>
<ol>
<li>任务队列：线程就是用来处理任务的，但是可能任务的个数要远大于线程的个数，因此无法一次性处理完所有的任务，因此我们就需要用一个 data struct（一般为数组 or 链表） 将任务存起来。</li>
<li>工作的线程：处理任务队列的任务的消费者，通常有多个。</li>
<li>管理者线程：不处理任务队列的任务，负责管理工作的线程（增加或者销毁线程），只有一个。</li>
</ol>
<p>任务队列的存在也意味着，线程池就差不多是一个生产者消费者模型。线程池负责为负消费者线程和任务队列，而使用者负责维护生产者线程（通过线程池提供的 API 接口）。</p>
<p>任务队列存储的是任务，而任务通常是一个个（回调）函数，因此任务队列需要存储函数的地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">工作线程是一直不停的干活，管理线程是间隔检测的。</span><br><span class="line">如何“销毁”线程？让他们自杀</span><br><span class="line">没干活的线程在哪呢？通过worker函数可以发现，没工作的线程都阻塞在了条件变量里面，那么我们可以唤醒所有线程。</span><br></pre></td></tr></table></figure>

<h3 id="2-虚假唤醒"><a href="#2-虚假唤醒" class="headerlink" title="2. 虚假唤醒"></a>2. 虚假唤醒</h3><p><font color=blue>TODO</font></p>
<h1 id="C-thread-pool-1"><a href="#C-thread-pool-1" class="headerlink" title="C++:thread_pool"></a>C++:thread_pool</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jyyyx</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/qaqowoqaq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qaqowoqaq" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2407217576@qq.com" title="E-Mail → 2407217576@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jyyyx</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
