<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qaqowoqaq.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="jyyyyyyyyyx">
<meta property="og:url" content="https://qaqowoqaq.github.io/page/2/index.html">
<meta property="og:site_name" content="jyyyyyyyyyx">
<meta property="og:locale">
<meta property="article:author" content="jyyyx">
<meta property="article:tag" content="cs">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://qaqowoqaq.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'cn'
  };
</script>

  <title>jyyyyyyyyyx</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">jyyyyyyyyyx</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">后来居上</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">csapp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-15 20:20:57 / Modified: 20:26:29" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/csapp/" itemprop="url" rel="index"><span itemprop="name">csapp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h1><h2 id="0x-ff-杂项"><a href="#0x-ff-杂项" class="headerlink" title="0x ff 杂项"></a>0x ff 杂项</h2><p>Instruction set Architecture：ISA,指令集体系架构</p>
<p>软件和硬件之间的一层抽象层</p>
<p>冯诺依曼计算机，即程序<strong>存储型</strong>计算机</p>
<p>重要思想：程序就是一系列被编码了的字节序列（看上去和数据一模一样）</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/SovietPower/p/14877143.html">https://www.cnblogs.com/SovietPower/p/14877143.html</a></p>
<h2 id="0x-00-参考资料-amp-amp-lab"><a href="#0x-00-参考资料-amp-amp-lab" class="headerlink" title="0x 00 参考资料 &amp;&amp; lab"></a>0x 00 参考资料 &amp;&amp; lab</h2><p>official：</p>
<p><a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/students.html">官网</a></p>
<p><a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/labs.html">实验</a></p>
<hr>
<p>note:</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17K4y1N7Q2?spm_id_from=333.999.0.0&vd_source=38033fe3a1f136728a1d6f8acf710b51">视频详解</a> </p>
<p><a target="_blank" rel="noopener" href="https://github.com/yangminz/bcst_csapp">笔记参考视频的源码</a></p>
<hr>
<p>lab：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/wuxueqian14/CSAPP-Lab#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">比较详细的Attack，Data，Boom Lab参考</a></p>
<p><a target="_blank" rel="noopener" href="https://kazamayc.github.io/2021/02/05/csapp-lab/">Boom，Attack，Shell Lab</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/505497911">全部实验的详细参考–知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43362650/article/details/122890142">全部实验的详细参考–CSDN</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Exely/CSAPP-Labs">全部实验的详细参考–Github</a></p>
<hr>
<p>video:</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1RK4y1R7Kf?spm_id_from=333.999.0.0&vd_source=38033fe3a1f136728a1d6f8acf710b51">导读</a>        <a target="_blank" rel="noopener" href="https://fengmuzi2003.gitbook.io/csapp3e/">导读笔记</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cD4y1D7uR?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click&vd_source=38033fe3a1f136728a1d6f8acf710b51">小视频复习</a></p>
<hr>
<p>book：</p>
<p><a target="_blank" rel="noopener" href="https://hansimov.gitbook.io/csapp/">学生版重点知识</a></p>
<p><a href="instructor">讲师版重点知识</a></p>
<hr>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lab操作流程</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.datalab：</span></span><br><span class="line">在源文件 bits.c 中完善函数即可</span><br><span class="line">./dlc bits.c 	 // 用于检查程序是否合法，是否使用了程序规定的符号</span><br><span class="line">make btest   	 // btest是评分(检查对错工具)，每次执行btets前都要重新make一下</span><br><span class="line">./btest bits.c   // 评分</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.bomblab</span></span><br><span class="line">./bomb</span><br><span class="line">输入答案</span><br><span class="line">导读P3-52分钟有第一关的实操</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.attacklab</span></span><br><span class="line">./hex2raw &lt; att1.txt &gt; attraw1.txt // 将字节序列at t1转换为字符串attraw1</span><br><span class="line">./ctarget -q -i attraw1.txt     //测试答案</span><br><span class="line">// (https://github.com/wuxueqian14/csapp-lab/tree/master/Attack%20Lab)</span><br></pre></td></tr></table></figure>



<h2 id="0x-01-二进制"><a href="#0x-01-二进制" class="headerlink" title="0x 01 二进制"></a>0x 01 二进制</h2><p>内存中存储的是电压，然后通过（不知道）某种方式<strong>抽象</strong>为数字01，然而计算机的内存太大了，以致于01的个数实在太多了，于是，我们把原有的0和1分块，并再次抽象为0,1…。</p>
<p><img src="file:///C:\Users\24072\AppData\Roaming\Tencent\Users\2407217576\QQ\WinTemp\RichOle\7E[W6J9]YPX$8MS~3CCM[DG.png" alt="img"></p>
<p>加入内存中有n bit,每m bit分为一块，则最多可以分为2^m块，因为m bit的排列组合数为2 ^ n个序列（sequence）</p>
<p>例如十进制数字123，它应该表示为<code>1*10^2 + 2*10^1 + 3*10^0</code>，所以这里的123准确来说应该是一个sequence，而不是一个数。</p>
<p>数是一个比较唯心的抽象的概念，你说一个数3，它可以是十进制序列3，也可以是二进制序列11…，3和11都是这个真正的（唯心的）3，这些序列之间是一一对应的，不仅如此，他们的运算也是一一对应的。十进制的序列1+2，对应的二进制下序列为1+01</p>
<p><strong>取反对称</strong>：对称轴的两侧是相反数</p>
<p>对于1,2,3,4，他们分别取反对称于-1，-2，-3，-4</p>
<p>对于二进制000,001,010,011，他们分别取反对称于111,110,101,100</p>
<p><img src="https://s1.328888.xyz/2022/08/29/CrzXC.png" alt="IMAGE"></p>
<h2 id="0x-02-二进制运算"><a href="#0x-02-二进制运算" class="headerlink" title="0x 02 二进制运算"></a>0x 02 二进制运算</h2><p><strong>位运算的循环圈：</strong></p>
<p><img src="https://s1.328888.xyz/2022/09/06/5OAqi.png" alt="IMG"></p>
<p>​										（int类型有符号数）</p>
<p><img src="https://s1.328888.xyz/2022/09/06/5jEa0.png" alt="img"></p>
<p>​										(int类型无符号数)</p>
<p>通过这张图，你可能会更好地理解补码和无符号数运算是在mod 2^n 下计算的意义。</p>
<p>看一下树状数组lowbit函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x; <span class="comment">// &lt;==&gt; x &amp; (~x + 1);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数为什么能求得最后一个1所在位置的代表的权值呢？</p>
<p>首先 -x，其实就是x的补码。关于补码，我们有一个求补码的方法：从右到左直到第一个1保持不变，后面的位取反，我们将x和x的补码做与运算，最后得到的结果一定是这样的形式：00..010..0，最后一个1左侧全为0，右侧也全为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">func1</span><span class="params">(<span class="type">unsigned</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 输出一个无符号数x，判断x在十六进制下的的每一位是不是字母</span></span><br><span class="line">    <span class="comment">// 如果该位是字母就返回1，否则返回0</span></span><br><span class="line">    <span class="comment">// 并以一个16进制数的形式返回</span></span><br><span class="line">    <span class="type">unsigned</span> x1 = (x &amp; <span class="number">0x22222222</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> x2 = (x &amp; <span class="number">0x44444444</span>) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> x3 = (x &amp; <span class="number">0x88888888</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;[1]:%04x\n[2]:%04x\n[3]:%04x\n&quot;, x1, x2, x3);</span></span><br><span class="line">    <span class="keyword">return</span> x3 &amp; (x2 | x1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">func2</span><span class="params">(<span class="type">unsigned</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 输出一个无符号数x，判断x在十六进制下的每一位是不是字母</span></span><br><span class="line">    <span class="comment">// 如果所有位都是字母返回1，否则返回0</span></span><br><span class="line">    x = func1(x); <span class="comment">//得到了每一位的结果</span></span><br><span class="line">    x = x &amp; (x &gt;&gt; <span class="number">16</span>); <span class="comment">// 每次判断一半</span></span><br><span class="line">    x = x &amp; (x &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">    x = x &amp; (x &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">func3</span><span class="params">(<span class="type">unsigned</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// bigCount</span></span><br><span class="line">    <span class="type">unsigned</span> c;</span><br><span class="line">    c = (x &amp; <span class="number">0x55555555</span>) + ((x &gt;&gt;  <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    c = (c &amp; <span class="number">0x33333333</span>) + ((c &gt;&gt;  <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    c = (c &amp; <span class="number">0x0f0f0f0f</span>) + ((c &gt;&gt;  <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>);</span><br><span class="line">    c = (c &amp; <span class="number">0x00ff00ff</span>) + ((c &gt;&gt;  <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>);</span><br><span class="line">    c = (c &amp; <span class="number">0x0000ffff</span>) + ((c &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> x = <span class="number">0x1</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;0x%X = %X\n&quot;, x, func1(x));</span></span><br><span class="line">    <span class="comment">// printf(&quot;0x%X = %X\n&quot;, x, func2(x));</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%X = %d\n&quot;</span>, x, func3(x));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0x-03-浮点数"><a href="#0x-03-浮点数" class="headerlink" title="0x 03 浮点数"></a>0x 03 浮点数</h2><p>为什么 IEEE 754浮点数Float类型的bias&#x3D;127而不是128？</p>
<p>其实这也没有一个官方的说法，不过为了让自己接受这个设定，我们可以从两个角度考虑：</p>
<ol>
<li>首先，bias采用127时绝对值的范围比较对称</li>
<li>其次，bias采用127时最大的指数是127比bias&#x3D;128时的126大，虽然只大1，但是我们直到指数的增长是“爆炸”的，因此其表示的范围也大得多。</li>
</ol>
<p>浮点的根据exp和frac分为三种情况：</p>
<ol>
<li>exp&#x3D;111..1，指数全1。此时又分为两种情况：（1）当frac全0时表示无穷大，根据符号位又分为正无穷和负无穷。（2）frac不全为0，表示NaN，一种未定义行为。（可以这样区分无穷和NaN，由于未定义的行为有很多，因此需要根据frac进一步区分，所以frac不是固定的全0，（胡乱猜的），可以这样记忆）。</li>
<li>exp&#x3D;000..0，指数全0。表示不规格化的浮点数。这里的主要目的是为了拓展精度和范围（往值小的方向）。</li>
<li>else，规格化浮点数。</li>
</ol>
<p>将一个无符号数转换为一个浮点数的表示形式并保存在一个无符号数字中</p>
<p><a target="_blank" rel="noopener" href="https://lostphp.com/hexconvert/">IEEE 754浮点数十六进制相互转换</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/68131179">关于浮点数舍入的讨论</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">uint2float</span><span class="params">(<span class="type">uint32_t</span> u)</span>&#123; <span class="comment">// 将一个服务号数u转换成浮点数存储的形式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 特判</span></span><br><span class="line">    <span class="keyword">if</span> (u == <span class="number">0x00000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x00000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到最后一个1的后面的一个位置，求得该1后面还有多少个数</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">0</span> &amp;&amp; (((u &gt;&gt; n) &amp; <span class="number">0x1</span>) == <span class="number">0x0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        n = n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n: &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint32_t</span> e, f; <span class="comment">// exp, frac</span></span><br><span class="line">    <span class="comment">// &lt;= 0000 0000 1.111 1111 1111 1111 1111 1111 : 32位</span></span><br><span class="line">    <span class="comment">// u的位数&lt;=24，此时再隐藏一个1，就&lt;=23位，于是frac就可以保存所有位，不需要舍入</span></span><br><span class="line">    <span class="keyword">if</span> (u &lt;= <span class="number">0x00ffffff</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// no need rounding</span></span><br><span class="line">        <span class="type">uint32_t</span> mask = <span class="number">0xffffffff</span> &gt;&gt; (<span class="number">32</span> - n); <span class="comment">// mask就是frac的掩码</span></span><br><span class="line">        f = (u &amp; mask) &lt;&lt; (<span class="number">23</span> - n);             <span class="comment">// f = u &amp; mask得到frac，但还需要左移移动到最右侧[frac00..0]，而不是[00..0frac]</span></span><br><span class="line">        e = n + <span class="number">127</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;e: 0x%x, f: 0x%x\n&quot;</span>, e, f);</span><br><span class="line">        <span class="keyword">return</span> (e &lt;&lt; <span class="number">23</span>) | f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;= 0000 0001 0000 0000 0000 0000 0000 0000 </span></span><br><span class="line">    <span class="comment">// 总位数&gt;=25，一位可以隐藏，还剩下至少24位，frac无法全部保存，需要舍入(rounding)</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// expand to 64 bit for situations like 0xffffffff</span></span><br><span class="line">        <span class="type">uint64_t</span> a = <span class="number">0</span>;</span><br><span class="line">        a += u;</span><br><span class="line">        <span class="comment">// compute g, r, s</span></span><br><span class="line">        <span class="type">uint32_t</span> g = (a &gt;&gt; (n - <span class="number">23</span>)) &amp; <span class="number">0x1</span>;</span><br><span class="line">        <span class="type">uint32_t</span> r = (a &gt;&gt; (n - <span class="number">23</span> - <span class="number">1</span>)) &amp; <span class="number">0x1</span>;</span><br><span class="line">        <span class="type">uint32_t</span> s = <span class="number">0x0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">23</span> - <span class="number">1</span>; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            s = s | ((u &gt;&gt; j) &amp; <span class="number">0x1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// compute carry</span></span><br><span class="line">        a = a &gt;&gt; (n - <span class="number">23</span>);</span><br><span class="line">        <span class="comment">// 0    1    ?    ... ?</span></span><br><span class="line">        <span class="comment">// [24] [23] [22] ... [0]</span></span><br><span class="line">        <span class="keyword">if</span> (r &amp; (g | s) == <span class="number">0x1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = a + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check carry</span></span><br><span class="line">        <span class="keyword">if</span> ((a &gt;&gt; <span class="number">23</span>) == <span class="number">0x1</span>) /</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 0    1    ?    ... ?</span></span><br><span class="line">            <span class="comment">// [24] [23] [22] ... [0]</span></span><br><span class="line">            f = a &amp; <span class="number">0x007fffff</span>; <span class="comment">// 0x0000 0000 0111 1111 1111 1111 1111 1111只保留frac</span></span><br><span class="line">            e = n + <span class="number">127</span>;</span><br><span class="line">            <span class="keyword">return</span> (e &lt;&lt; <span class="number">23</span>) | f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((a &gt;&gt; <span class="number">23</span>) == <span class="number">0x2</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1    0    0    ... 0</span></span><br><span class="line">            <span class="comment">// [24] [23] [22] ... [0]</span></span><br><span class="line">            e = n + <span class="number">1</span> + <span class="number">127</span>;</span><br><span class="line">            <span class="keyword">return</span> (e &lt;&lt; <span class="number">23</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// INF as default error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x7f800000</span>; <span class="comment">// 0 1111 1111 000 0000 0000 0000 0000 0000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;  <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, uint2float(<span class="number">0x10000000</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0x-04-时序电路和组合电路"><a href="#0x-04-时序电路和组合电路" class="headerlink" title="0x 04 时序电路和组合电路"></a>0x 04 时序电路和组合电路</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_20265495/article/details/41314577">原文链接：</a></p>
<hr>
<p><strong>数字电路</strong>根据逻辑功能的不同特点，可以分成两大类，一类叫<strong>组合逻辑电路</strong>（简称组合电路），另一类叫做<strong>时序逻辑电路</strong>（简称时序电路）。组合逻辑电路在逻辑功能上的特点是任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关。而时序逻辑电路在逻辑功能上的特点是任意时刻的输出不仅取决于当时的输入信号，而且还取决于电路原来的状态，或者说，还与以前的输入有关。</p>
<p>时序电路，是由最基本的逻辑门电路加上反馈逻辑回路（输出到输入）或器件组合而成的电路，与组合电路最本质的区别在于时序电路具有记忆功能。</p>
<p>时序电路的特点是：输出不仅取决于当时的输入值，而且还与电路过去的状态有关。它类似于含储能元件的电感或电容的电路，如触发器、锁存器、计数器、移位寄存器、存储器等电路都是时序电路的典型器件，时序逻辑电路的状态是由存储电路来记忆和表示的。</p>
<p>时序电路和组合电路的区别：<br>时序电路具有<strong>记忆功能</strong>。时序电路的特点是：输出不仅取决于当时的输入值，而且还与电路过去的状态有关。组合逻辑电路在逻辑功能上的特点是任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关</p>
<p>时序电路是 时序 逻辑 电路。时序，时间 顺序，是在时钟的推动下工作的，cpu就是一个复杂的时序电路。</p>
<p>组合逻辑电路和时序逻辑电路的最根本区别在于：组合逻辑电路的输出在任一时刻只取决于当时的输入信号；而时序逻辑电路的输出，不仅和当前的输入有关，还和上时刻的输出有关，它具有记忆元件（触发器），可以记录前一时刻的输出状态，它可以没有输入，仅在时钟的驱动下，给出输出。</p>
<p>时序电路的基本结构：</p>
<p><img src="https://img-blog.csdn.net/20151210201333026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>结构特征：<em>电路由组合电路和存储电路组成</em>，电路存在反馈 </p>
<h2 id="0x-05-缓冲区漏洞实验"><a href="#0x-05-缓冲区漏洞实验" class="headerlink" title="0x 05 缓冲区漏洞实验"></a>0x 05 缓冲区漏洞实验</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//bomb.c</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">4</span>];</span><br><span class="line">	gets(buffer); <span class="comment">//缓冲区溢出的关键</span></span><br><span class="line">	<span class="built_in">puts</span>(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;pls input: &quot;</span>);</span><br><span class="line">	echo();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">操作步骤：</span><br><span class="line">1. gcc bomb.c -o main -fno-stack-protector -g</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-fno-stack-protector取消栈保护？</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-g调试模式，因为后面还需要调试</span></span><br><span class="line"></span><br><span class="line">2. gdb main</span><br><span class="line">2.1 在echo函数的gets函数加上一个断点：b 6</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span>函数位于main.c的第六行</span></span><br><span class="line">2.2 r</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">run运行程序，此时会在断点gets函数停下</span></span><br><span class="line">2.3 info f </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示栈信息，如下方图-栈信息所示</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在这些信息中，我们需要注意三个地址：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(1)frame at 0x7ff.f3d0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(2)rbp at   0x7ff.f3c0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(3)bip at.  0x7ff.f3c8</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中frame at的地址是函数<span class="built_in">echo</span>占用栈的地址</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时，返回地址rip和旧的栈顶指针rbp已经入栈</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">由此可见，程序还没运行，返回地址和旧的栈顶指针就会入栈</span></span><br><span class="line">2.4 p/a &amp;buffer[0]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印数组buffer的首地址</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过结构图，我们可以发现，数组与返回地址rip之间差了12（c8-bc）字节，如果我们gets的数组大于等于12字节，那么返回地址的数据就会被破坏，</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>![image-20220907100422585](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220907100422585.png)</p>
<p>(图-栈信息)</p>
<p>![13C288AA-6A07-463D-A689-CC7FEF2DCB91](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;13C288AA-6A07-463D-A689-CC7FEF2DCB91.png)</p>
<p>(图-数组地址)</p>
<p><img src="https://1484576603-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MV9vJFv4kmvRLgEog6g%2F-MZuBW3GNKr5zld5JHFH%2F-MZuER6OHxdJ7z3gtPNL%2Fimage.png?alt=media&token=ecba360a-06d3-4734-9430-aab5fd84cbee" alt="img"></p>
<p>(图-视频测试运行gets前的栈)</p>
<p><img src="https://1484576603-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MV9vJFv4kmvRLgEog6g%2F-MZrajFxkCIYEw7i-1-F%2F-MZrrKB09-F7NqAWNBKB%2Finitpintu_%E5%89%AF%E6%9C%AC.jpg?alt=media&token=35b89f3f-e6d2-4aa9-b7d0-2da8ad86450b" alt="img"></p>
<p>（图-视频测试运行gets后的栈）</p>
<h2 id="0x-06-Computer-English"><a href="#0x-06-Computer-English" class="headerlink" title="0x 06 Computer English"></a>0x 06 Computer English</h2><hr>
<p>common：注释</p>
<p>override：覆盖</p>
<p>entry：入口，条目，输入</p>
<p>Place holder：站位</p>
<p>ascending：升序</p>
<p>descending：降序</p>
<p>comma：逗号</p>
<p>brackets：括号</p>
<p>determine: 确定，决定，判定，下决心</p>
<p>deterministic: 确定行</p>
<p>finite: 有限的</p>
<p>infinite: 无限的</p>
<p>automaton: 自动机</p>
<p>positive: 正数</p>
<p>negative: 负数</p>
<p>decimal: 十进制</p>
<p>hexadecimal：十六进制</p>
<p>octal: 八进制</p>
<p>optimazation：优化</p>
<p>pruning：剪枝</p>
<p>decode:译码</p>
<p>instance: 例子，实例</p>
<p>cpu和memory 就组成了一个状态机</p>
<p>operand 操作数</p>
<p>opreator：操作符</p>
<p>memory：内存&#x2F;存储器</p>
<p>recursion：递归</p>
<p>reduce：归约</p>
<p>iterate: 迭代</p>
<p>transistor：晶体管</p>
<p>complement：补充，补运算(～)，辅</p>
<p>parse: 解析</p>
<p>simulator: 模拟器</p>
<p>simulate: 模拟，仿真，假装</p>
<p>converter：转换器</p>
<p>verbose: 冗长的，啰嗦</p>
<p>handler: 管理者，处理程序</p>
<p>illustrate: 说明</p>
<p>universal: 通用的</p>
<p>pecuilar:  特有，奇特，一场</p>
<hr>
<h2 id="0x-07-makefile"><a href="#0x-07-makefile" class="headerlink" title="0x 07 makefile"></a>0x 07 <a target="_blank" rel="noopener" href="https://subingwen.cn/linux/makefile/#3-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F">makefile</a></h2><h3 id="1-规则"><a href="#1-规则" class="headerlink" title=".1 规则"></a>.1 规则</h3><p>（1）make命令具有<strong>自动推导</strong>的功能，例如依赖中的.o文件，即使不存在，make会使用内部默认的构造规则生成这些.o文件。</p>
<p>（2）make后面<strong>不带参数</strong>默认执行第一条命令</p>
<p>（3）mak的<strong>时间戳规则</strong>：</p>
<blockquote>
<p>make 命令执行的时候会根据文件的时间戳判定是否执行 makefile 文件中相关规则中的命令。</p>
<ol>
<li>目标是通过依赖生成的，因此正常情况下：目标时间戳 &gt; 所有依赖的时间戳 , 如果执行 make 命令的时候检测到规则中的目标和依赖满足这个条件，那么规则中的命令就不会被执行。</li>
<li>当依赖文件被更新了，文件时间戳也会随之被更新，这时候 目标时间戳 &lt; 某些依赖的时间戳 , 在这种情况下目标文件会通过规则中的命令被重新生成。</li>
<li>如果规则中的目标对应的文件根本就不存在， 那么规则中的命令肯定会被执行。</li>
</ol>
</blockquote>
<p>（4）对于不生成目标文件的目标称为伪目标，为了避免微伪目标的名字和真实的文件名重复，我们可以在伪目标的前面加上关键字：.PHONY(假) 例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean: </span></span><br><span class="line">	rm *.o</span><br></pre></td></tr></table></figure>

<p>声明位伪目标主要是避免这种情况：</p>
<blockquote>
<p>如果目标不存在规则的命令肯定被执行， 如果目标文件存在了就需要比较规则中目标文件和依赖文件的时间戳，满足条件才执行规则的命令，否则不执行。</p>
<p>加入目标是clean，而恰好有一个真实的clean文件，只要clean文件不更新，那么clean目标就无法执行。</p>
</blockquote>
<p>（提醒）<strong>目录连接到博客中的实例6可以好好看看👀</strong></p>
<h3 id="2-变量"><a href="#2-变量" class="headerlink" title=".2 变量"></a>.2 变量</h3><p>make中的变量分为三种：</p>
<p><strong>1.自定义变量</strong>：即用户自己定义的变量，makefile中的变量是<strong>没有类型</strong>的，直接创建变量然后给其赋值就可以了。通过$(obj) 可以取出自定义的obj变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">obj = main.c</span><br><span class="line">target = main</span><br><span class="line">depend = main.o</span><br><span class="line"></span><br><span class="line">$(target): $(depend)</span><br><span class="line">	gcc $(obj) -o $(target)</span><br><span class="line"></span><br><span class="line"># --------------</span><br><span class="line"># 上面的命令等价于下面：</span><br><span class="line"></span><br><span class="line">main: main.o</span><br><span class="line">	gcc main.c -o main</span><br></pre></td></tr></table></figure>

<p><strong>2.预定义变量：</strong>在makefile中有一些已经定义好的变量，用户可以直接使用这些变量，不用进行定义，预定义变量的名字一般是大写的。</p>
<p>![96D31374-3040-4B27-8A65-B9DE685E3351](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;96D31374-3040-4B27-8A65-B9DE685E3351.png)</p>
<p><strong>3.自动变量：</strong>makefile智能鼓的规则语句经常会出现目标文件和依赖文件，<strong>自动变量用来代表这些规则中的目标文件和依赖文件，并且衙门只能在规则的命令总使用。</strong></p>
<p>![DC05ED8E-B70B-44FB-A799-E6D0C938CF7F](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;DC05ED8E-B70B-44FB-A799-E6D0C938CF7F.png)</p>
<h3 id="3-模式匹配"><a href="#3-模式匹配" class="headerlink" title=".3 模式匹配"></a>.3 模式匹配</h3><p>模式匹配常常与自动变量结合使用，用来简化makefile，减少冗余和重复书写。</p>
<h3 id="4-函数"><a href="#4-函数" class="headerlink" title=".4 函数"></a>.4 函数</h3><p>1.wildcard：通配符，用来匹配制定目录下的文件</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用举例: 分别搜索三个不同目录下的 .c 格式的源文件</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> /home/robin/a/*.c /home/robin/b/*.c *.c)</span>  <span class="comment"># *.c == ./*.c</span></span><br><span class="line"><span class="comment"># 返回值: 得到一个大的字符串, 里边有若干个满足条件的文件名, 文件名之间使用空格间隔</span></span><br><span class="line">/home/robin/a/a.c /home/robin/a/b.c /home/robin/b/c.c /home/robin/b/d.c e.c f.c</span><br></pre></td></tr></table></figure>



<p>2.patsubst：pattern subsitude，匹配代替，用来替换文件名的后缀</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src = a.cpp b.cpp c.cpp e.cpp</span><br><span class="line"><span class="comment"># 把变量 src 中的所有文件名的后缀从 .cpp 替换为 .o</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(src)</span>)</span> </span><br><span class="line"><span class="comment"># obj 的值为: a.o b.o c.o e.o</span></span><br></pre></td></tr></table></figure>



<h2 id="0x-08-gdb"><a href="#0x-08-gdb" class="headerlink" title="0x 08 gdb"></a>0x 08 gdb</h2><h3 id="0-参考"><a href="#0-参考" class="headerlink" title=".0 参考"></a>.0 参考</h3><p>![9523F5A0-416A-4635-99DB-47685282748F](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;9523F5A0-416A-4635-99DB-47685282748F.png)</p>
<p><a target="_blank" rel="noopener" href="https://subingwen.cn/linux/gdb/#5-3-3-next">本文档参考来源，功能基础而简单</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/XxPIfrQ3E0GR88UsmQNggg">设计多线程，多进城等高级功能，较为复杂</a></p>
<p><a target="_blank" rel="noopener" href="https://www.yanbinghu.com/2019/04/20/41283.html">知乎</a></p>
<h3 id="1-添加命令行参数"><a href="#1-添加命令行参数" class="headerlink" title=".1 添加命令行参数"></a>.1 添加命令行参数</h3><figure class="highlight plaintext"><figcaption><span>args …```	启动gdb后，在程序启动之前设置参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```show args```	查看设置的命令行参数</span><br><span class="line"></span><br><span class="line">### .2 启动程序</span><br><span class="line"></span><br><span class="line">在整个gdb调试过程中，启动饮用程序的命令只能使用一次。</span><br><span class="line"></span><br><span class="line">```run```		可以缩写为 `r`，如果程序中设置了断点会停在第一个断点的位置，如果没有设置断点，程序就执行完了。</span><br><span class="line"></span><br><span class="line">`start` 	启动程序，最终会阻塞在main函数的第一行，等待输入后续其他 gdb 命令。</span><br><span class="line"></span><br><span class="line">&gt; start 是要开始运行， run 是真的运行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### .3 退出 gdb</span><br><span class="line"></span><br><span class="line">`quit`  缩写为 `q`</span><br><span class="line"></span><br><span class="line">### .4 查看代码</span><br><span class="line"></span><br><span class="line">`list`	可以缩写为 `l` ，通过这个命令可以查看项目中任意一个文件中的内容，并且还可以通过文件行号，函数名等方式查看。</span><br><span class="line"></span><br><span class="line">``` shell</span><br><span class="line">(gdb) list</span><br><span class="line">(gdb) list 行号</span><br><span class="line">(gdb) list 函数名</span><br></pre></td></tr></table></figure>

<p>一个项目通常由多个源文件构成，默认情况下通过 list 查看的是程序入口 main 函数对应的文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list 文件名：行号</span><br><span class="line">(gdb) list 文件名：函数名</span><br></pre></td></tr></table></figure>

<p>默认情况下 list 之显示 10 行的内容。如果想显示更多，可以通过 <code>set listsize</code> 设置，同时如果想查看当前显示的行数可以通过 <code>show listsize</code> 查看。这里的 	<code>listsize</code> 可以缩写为 <code>list</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set listsize 行号</span><br><span class="line">(gdb) show listsize</span><br></pre></td></tr></table></figure>



<h3 id="5-断点操作"><a href="#5-断点操作" class="headerlink" title=".5 断点操作"></a>.5 断点操作</h3><p>如果想通过 gdb 掉时某一行或者得到某个变量在运行状态下的实际值，就需要在这一行设置断点，程序指定到断点的位置就会阻塞。我们就可以通过 gdb 的调试命令得到我们想要的信息了。</p>
<p>设置断点：<code>break</code> 缩写为 <code>b</code></p>
<p>断点的设置方式由两种：</p>
<ol>
<li>常规断点：程序只要运行到这个位置就会阻塞</li>
<li>条件断点：只有指定的条件被满足了程序才会在断点处阻塞</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置普通断点到当前文件</span></span><br><span class="line">(gdb) b 行号</span><br><span class="line">(gdb) b 函数名 # 停在函数的第一行</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置普通断点到某个非当前文件</span></span><br><span class="line">(gdb) b 文件名：行号</span><br><span class="line">(gdb) b 问价名：函数名 # 停在函数的第一行</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置条件断点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通常情况下，在循环中条件断点用的比较多</span></span><br><span class="line">(gdb)  b 行号 if 变量名 == 某个值</span><br></pre></td></tr></table></figure>

<hr>
<p>查看断点：<code>info break</code> ，其中 <code>info</code> 可以缩写为 <code>i</code> , <code>break</code> 可以缩写为 <code>b</code></p>
<blockquote>
<p>info break 查看断点信息时的一些常用的属性：Num:   断点的编号，删除断点或者设置断点状态的时候都需要使用<br>Enb:    当前断点的状态，y 表示断点可用，n 表示断点不可用<br>What:  描述断点被设置在了哪个文件的哪一行或者哪个函数上</p>
</blockquote>
<hr>
<p>如果确定设置的某个断点不再被使用了，可用将其删除，删除命令是 <code>delete</code> 断点编号 , 这个 <code>delete</code> 可以简写为 <code>del</code> 也可以再简写为 <code>d</code>。</p>
<p>删除断点的方式有两种: <strong>删除(一个或者多个)指定断点</strong>或者<strong>删除一个连续的断点区间</strong>，具体操作如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">delete == del == d</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要 info b 查看断点的信息, 第一列就是编号</span></span><br><span class="line">(gdb) d 断点的编号1 [断点编号2 ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例:</span> </span><br><span class="line">(gdb) d 1          # 删除第1个断点</span><br><span class="line">(gdb) d 2 4 6      # 删除第2,4,6个断点</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除一个范围, 断点编号 num1 - numN 是一个连续区间</span></span><br><span class="line">(gdb) d num1-numN</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例, 删除第1到第5个断点</span></span><br><span class="line">(gdb) d 1-5</span><br></pre></td></tr></table></figure>



<hr>
<p>如果某个断点只是临时不需要了，我们可以将其设置为不可用状态，设置命令为 <code>disable</code> 断点编号，当需要的时候再将其设置回可用状态，设置命令为 <code>enable</code> 断点编号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 让断点失效之后, gdb调试过程中程序是不会停在这个位置的</span><br><span class="line"># disable == dis</span><br><span class="line"># 设置某一个或者某几个断点无效</span><br><span class="line">(gdb) dis 断点1的编号 [断点2的编号 ...]</span><br><span class="line"></span><br><span class="line"># 设置某个区间断点无效</span><br><span class="line">(gdb) dis 断点1编号-断点n编号</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 查看断点信息</span><br><span class="line">(gdb) i b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       breakpoint     keep y   0x0000000000400cce in main() at test.cpp:14</span><br><span class="line">4       breakpoint     keep y   0x0000000000400cdd in main() at test.cpp:16</span><br><span class="line">5       breakpoint     keep y   0x0000000000400d46 in main() at test.cpp:23</span><br><span class="line">6       breakpoint     keep y   0x0000000000400d4e in main() at test.cpp:25</span><br><span class="line">7       breakpoint     keep y   0x0000000000400d6e in main() at test.cpp:28</span><br><span class="line">8       breakpoint     keep y   0x0000000000400d7d in main() at test.cpp:30</span><br><span class="line"></span><br><span class="line"># 设置第2, 第4 个断点无效</span><br><span class="line">(gdb) dis 2 4</span><br><span class="line"></span><br><span class="line"># 查看断点信息</span><br><span class="line">(gdb) i b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       breakpoint     keep n   0x0000000000400cce in main() at test.cpp:14</span><br><span class="line">4       breakpoint     keep n   0x0000000000400cdd in main() at test.cpp:16</span><br><span class="line">5       breakpoint     keep y   0x0000000000400d46 in main() at test.cpp:23</span><br><span class="line">6       breakpoint     keep y   0x0000000000400d4e in main() at test.cpp:25</span><br><span class="line">7       breakpoint     keep y   0x0000000000400d6e in main() at test.cpp:28</span><br><span class="line">8       breakpoint     keep y   0x0000000000400d7d in main() at test.cpp:30</span><br><span class="line"></span><br><span class="line"># 设置 第5,6,7,8个 断点无效</span><br><span class="line">(gdb) dis 5-8</span><br><span class="line"></span><br><span class="line"># 查看断点信息</span><br><span class="line">(gdb) i b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       breakpoint     keep n   0x0000000000400cce in main() at test.cpp:14</span><br><span class="line">4       breakpoint     keep n   0x0000000000400cdd in main() at test.cpp:16</span><br><span class="line">5       breakpoint     keep n   0x0000000000400d46 in main() at test.cpp:23</span><br><span class="line">6       breakpoint     keep n   0x0000000000400d4e in main() at test.cpp:25</span><br><span class="line">7       breakpoint     keep n   0x0000000000400d6e in main() at test.cpp:28</span><br><span class="line">8       breakpoint     keep n   0x0000000000400d7d in main() at test.cpp:30</span><br></pre></td></tr></table></figure>

<p>让无效的断点生效：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">enable</span> == ena</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置某一个或者某几个断点有效</span></span><br><span class="line">(gdb) ena 断点1的编号 [断点2的编号 ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置某个区间断点有效</span></span><br><span class="line">(gdb) ena 断点1编号-断点n编号</span><br></pre></td></tr></table></figure>



<h3 id="6-调试命令"><a href="#6-调试命令" class="headerlink" title=".6 调试命令"></a>.6 调试命令</h3><p>如果调试的程序被断点阻塞了又想让程序继续执行，这时候就可以使用 <code>continue</code> 命令。程序会继续运行，直到遇到下一个有效的断点。&#96;&#96;continue<code>可以缩写为</code>c&#96;。</p>
<p>在 gdb 调试的时候如果需要打印变量的值， 使用的命令是 <code>print</code>, 可缩写为 <code>p</code>。如果打印的变量是整数还可以指定输出的整数的格式，格式化输出的整数对应的字符表如下：</p>
<p>![9BDD57D6-6D87-4080-B269-951C45DEC259](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;9BDD57D6-6D87-4080-B269-951C45DEC259.png)</p>
<p><code>printf</code> 的语法格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">print</span> == p</span></span><br><span class="line">(gdb) p 变量名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果变量是一个整形, 默认对应的值是以10进制格式输出, 其他格式请参考上表</span></span><br><span class="line">(gdb) p/fmt 变量名</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例</span></span><br><span class="line">(gdb) p i       # 10进制</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">5 = 3</span></span><br><span class="line">(gdb) p/x i     # 16进制</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">6 = 0x3</span></span><br><span class="line">(gdb) p/o i     # 8进制</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">7 = 03</span></span><br></pre></td></tr></table></figure>

<p>如果在调试过程中需要查看某个变量的类型，可以使用命令 <code>ptype</code>, 语法格式如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法格式</span></span><br><span class="line">(gdb) ptype 变量名</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印变量类型</span></span><br><span class="line">(gdb) ptype i</span><br><span class="line">type = int</span><br><span class="line">(gdb) ptype array[i]</span><br><span class="line">type = int</span><br><span class="line">(gdb) ptype array</span><br><span class="line">type = int [12]</span><br></pre></td></tr></table></figure>

<hr>
<p>单步调试</p>
<p><code>step</code> 命令可以缩写为 <code>s</code>, 命令被执行一次代码被向下执行一行，如果这一行是一个函数调用，那么程序会进入到函数体内部。</p>
<p>如果通过 <code>s</code> 单步调试进入到函数内部，<strong>想要跳出这个函数体， 可以执行 <code>finish</code> 命令。如果想要跳出函数体必须要保证函数体内不能有有效断点，否则无法跳出。</strong></p>
<p><code>next</code> 命令和 <code>step</code> 命令功能是相似的，只是在使用 <code>next</code> 调试程序的时候不会进入到函数体内部，<code>next</code> 可以缩写为 <code>n</code></p>
<p>通过 <code>until</code> 命令可以直接跳出某个循环体，这样就能提高调试效率了。如果想直接从循环体中跳出，必须要满足以下的条件，否则命令不会生效：</p>
<h2 id="0x-e5-结构体字节对齐规则"><a href="#0x-e5-结构体字节对齐规则" class="headerlink" title="0x e5 结构体字节对齐规则"></a>0x e5 结构体字节对齐规则</h2><p>结构体的大小绝大部分情况下不会直接等于各个成员大小的总和，编译器为了优化对结构体成员的访问总会在结构体中插入一些空白字节，有如下结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">align_basic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么此时<code>sizeof(align_basic)</code>的值会是<code>sizeof(char)+sizeof(int)+sizeof(double)</code>的值么？</p>
<p><img src="https://pic3.zhimg.com/80/v2-dca7f4f607fdbc884079e30c10ceb7ae_1440w.png" alt="img"></p>
<p>如上图经过测试我们发现其大小为16个字节并不等于1+4+8&#x3D;13个字节，可知编译器给align_basic结构体插入了另外3个字节，接下来我们将分析编译器对齐字节的规则以及结构体在内存中的结构，首先感谢<a href="https://link.zhihu.com/?target=http://blog.csdn.net/liukun321/article/details/6974282">结构体在内存中的对齐规则 - 咕唧咕唧shubo.lk的专栏 - 博客频道 - CSDN.NET</a>这篇文章的作者，在此之前我对内存对齐也是一知半解，很多时候也解释不明白。</p>
<p>&#x3D;&#x3D;规则一：结构体中元素按照定义顺序依次置于内存中，但并不是紧密排列。从结构体首地址开始依次将元素放入内存时，元素会被放置在其自身对齐大小的整数倍地址上。&#x3D;&#x3D;这里说的地址是元素在结构体中的偏移量，结构体首地址偏移量为0。</p>
<p>在align_basic中元素c是第一个元素，那么它的地址为0，第二个元素i不会被放在地址1处，int的对齐大小为4个字节，此时虽然元素c只占据一个字节，但是由于i的地址必须在4字节的整数倍上，所以地址必须再向后在移动三个字节，故而需要放在地址4上，此时前两个元素已经占据了8个字节的空间，第三个元素d会被直接放在地址8上，因为double的对齐大小为8个字节，而前面两个元素已经占据了8个字节，正好是double对齐大小的整数倍，所以元素d不需要再往后移动。说了这么多也不如让机器给我们验证下有说服力：</p>
<p><code>printf(&quot;%d %d %d %d\n&quot;, sizeof(align_basic), &amp;align_basic::c, &amp;align_basic::i, &amp;align_basic::d);</code></p>
<p><img src="https://pic3.zhimg.com/80/v2-d729bea11322919cc59e03e03d3e221a_1440w.png" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-25407fa9c8f77c2f3d17a12546793a0d_1440w.png" alt="img"></p>
<p>那么这样就够了吗，会不会太简单？我们把元素i和d的位置交换下，此时结构体的大小会是20吗，我们仍然先让机器说话，(⊙o⊙)…毕竟后面打脸有证据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">align_basic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">double</span> d;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(align_basic));</span><br></pre></td></tr></table></figure>

<p><img src="https://pic4.zhimg.com/80/v2-cbfea1a547f205a2d4b2306748da3953_1440w.png" alt="img"></p>
<p>我们发现此时结构体的大小并不是20而是24，那么多出来的这4个字节如何解释？我们引出第二条规则。</p>
<p>&#x3D;&#x3D;规则二：如果结构体大小不是所有元素中最大对齐大小的整数倍，则结构体对齐到最大元素对齐大小的整数倍，填充空间放置到结构体末尾。&#x3D;&#x3D;</p>
<p>运用规则一，此时c仍然是第一个元素，其地址为0，第二个元素地址为8， 第三个元素地址为16，然后运用规则二，c，d，i中d的对齐大小为8最大所以整个结构必须对齐到8的整数倍，前面是三个元素已经占据了20个字节的空间，只需要在结构体的尾部填充4个字节的空间就是8的倍数了，所以此时整个结构体的大小为24个字节。</p>
<p><code>printf(&quot;%d %d %d %d\n&quot;, sizeof(align_basic), &amp;align_basic::c, &amp;align_basic::d, &amp;align_basic::i);</code></p>
<p><img src="https://pic3.zhimg.com/80/v2-c66b0aa643b60eecb9dbf06916c56482_1440w.png" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-0294208ed70bb94feb9868310a191eb3_1440w.png" alt="img"></p>
<p>&#x3D;&#x3D;规则三：基本数据类型的对齐大小为其自身的大小，结构体数据类型的对齐大小为其元素中最大对齐大小元素的对齐大小。&#x3D;&#x3D; 规则三可以由规则二推导出来。</p>
<p>char类型的对齐大小为1字节，short类型的对齐大小为2字节，int类型的大小为4字节，double的对齐大小为8字节，align_basic结构体中最大对齐大小元素为d是double类型，所以align_basic的对齐大小是8。有人会问如果结构体中有数组呢？很简单将数组看做是连续数个相同类型的元素即可。</p>
<h2 id="0x-e6-第一章小结"><a href="#0x-e6-第一章小结" class="headerlink" title="0x e6 第一章小结"></a>0x e6 第一章小结</h2><p>深入理解计算机系统的“系统”，并不是操作系统，这个系统包括了硬件，操作系统，网络，编译等等</p>
<p>学习计算机系统应该具备的三个<strong>抽象能力</strong>：问题抽象，系统抽象（csapp），数据抽象</p>
<p>计算机系统是由硬件和<strong>系统软件</strong>组成的。</p>
<p>数字的机器表示方法是对真值的<strong>有限近似值</strong>。</p>
<p>指令的执行：</p>
<ol>
<li>从磁盘读取指令和数据到内存</li>
<li>从内存送到cpu中去执行</li>
<li>将返回的数据送到屏幕</li>
</ol>
<h2 id="0x-e7-bomb-lab"><a href="#0x-e7-bomb-lab" class="headerlink" title="0x e7 bomb lab"></a>0x e7 bomb lab</h2><h3 id="1-phase1"><a href="#1-phase1" class="headerlink" title=".1 phase1"></a>.1 phase1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">disas main，可以发现我们输入的字符串赋值给了 $rdi</span><br><span class="line">并且之后调用了函数&lt;phase_1&gt;</span><br><span class="line">disas phase_1</span><br><span class="line">发现没有修改寄存器 $rdi 的值</span><br><span class="line">然后把一个立即数 0x402400 传给了寄存器 $esi</span><br><span class="line">之后调用函数 &lt;strings_not_euqal&gt;</span><br><span class="line">在之后test $eax $eax</span><br><span class="line">如果 je，即 $eax = 0</span><br><span class="line">调用函数 &lt;eoplode_bomb&gt;，炸弹爆炸</span><br><span class="line">否则正常返回</span><br><span class="line"></span><br><span class="line">进入函数 &lt;strings_not_equal&gt;</span><br><span class="line">该函数又会调用 &lt;string_length&gt; 函数</span><br><span class="line">这个函数会计算 $rdi 内字符串的长度</span><br><span class="line"></span><br><span class="line">p/x $rdx :以x(16进制)方式打印寄存器$rdx的值</span><br><span class="line">x $rdx 检查(examine) $rdx内存中的值</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/36809923">watch &#x3D; sepcial break</a></p>
<h3 id="2-phase2"><a href="#2-phase2" class="headerlink" title=".2 phase2"></a>.2 phase2</h3><h3 id="3-phase3"><a href="#3-phase3" class="headerlink" title=".3 phase3"></a>.3 phase3</h3><p>![78E9B95E-D7EC-4E49-8A30-94EF4B0A4D48](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;78E9B95E-D7EC-4E49-8A30-94EF4B0A4D48.png)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># phase_3</span><br><span class="line"><span class="title function_">if</span><span class="params">(eax &gt; <span class="number">1</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">7</span> &lt; rsp + <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        eax = rsp + <span class="number">0x8</span>; <span class="comment">// first input</span></span><br><span class="line">        <span class="keyword">switch</span>(eax)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">                eax = <span class="number">0xcf</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                eax = <span class="number">0x137</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                eax = <span class="number">0x2c3</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                eax = <span class="number">0x100</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                eax = <span class="number">0x185</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                eax = <span class="number">0xce</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                eax = <span class="number">0x2aa</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">        &#125;</span><br><span class="line">        	<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        		eax = <span class="number">0x147</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;       		</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BOOM!!!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有多组答案：注意第二个参数不能输入十六进制数，只能输入10进制数，因为这里的数据的读如是采用sscanf，把我们的输入作为str,如果我们的第二个参数是个十六进制数，那么一定以0x开头，结果0会被读取到第二个参数，读到x不合法就结束了。</p>
<table>
<thead>
<tr>
<th>第一个参数</th>
<th>第二个参数</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>207</td>
</tr>
<tr>
<td>1</td>
<td>311</td>
</tr>
<tr>
<td>2</td>
<td>707</td>
</tr>
<tr>
<td>3</td>
<td>256</td>
</tr>
<tr>
<td>4</td>
<td>389</td>
</tr>
<tr>
<td>5</td>
<td>206</td>
</tr>
<tr>
<td>6</td>
<td>682</td>
</tr>
<tr>
<td>7</td>
<td>327</td>
</tr>
</tbody></table>
<h3 id="4-phase4"><a href="#4-phase4" class="headerlink" title=".4 phase4"></a>.4 phase4</h3><p>第一个参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.func4:</span><br><span class="line">eax = edx</span><br><span class="line">eax -= edx</span><br><span class="line">ecx = eax</span><br><span class="line">ecx &gt;&gt;= <span class="number">0x1f</span> <span class="comment">// unsigned</span></span><br><span class="line">eax += ecx</span><br><span class="line">eax &gt;&gt;= <span class="number">1</span></span><br><span class="line">ecx = &amp;(rax+rso+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span>(ecx &lt;= edi)  </span><br><span class="line">&#123;</span><br><span class="line">    eax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(exc &gt;= edi)  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 只有当 ecx&lt;=edi&lt;=ecx，即edi=ecx=7时可以正常退出并返回0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        。。。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    edx = &amp;(rcx - <span class="number">1</span>)</span><br><span class="line">    call func4</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// goal: make eax = 0</span></span><br></pre></td></tr></table></figure>



<p>第二个参数看phrase4的汇编很容易得出为0</p>
<h3 id="5-phase5"><a href="#5-phase5" class="headerlink" title=".5 phase5"></a>.5 phase5</h3><p><a target="_blank" rel="noopener" href="https://github.com/wuxueqian14/csapp-lab/tree/master/Bomb%20Lab">reference</a></p>
<h3 id="6-phase6"><a href="#6-phase6" class="headerlink" title=".6 phase6"></a>.6 phase6</h3><p>不想做了</p>
<h3 id="7-phase7"><a href="#7-phase7" class="headerlink" title=".7 phase7"></a>.7 phase7</h3><p>no</p>
<h3 id="8-answer-2016"><a href="#8-answer-2016" class="headerlink" title=".8 answer(2016)"></a>.8 answer(2016)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">7 327</span><br><span class="line">7 0</span><br><span class="line">)/.%&amp;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="0x-09-Assembly实验"><a href="#0x-09-Assembly实验" class="headerlink" title="0x 09 Assembly实验"></a>0x 09 Assembly实验</h2><p><img src="/Users/epoch/Library/Containers/com.tencent.qq/Data/Library/Caches/Images/BE9A5FC6EBB55797FF78C5D5105D31DF.png" alt="BE9A5FC6EBB55797FF78C5D5105D31DF"></p>
<p>如上图，我们用(gdb) x mingling打印 0x7fffffffe3b0附近的值，这个地址是个虚拟地址，它在内存中的值为0x0</p>
<p>栈指针是会浮动的！但是rsp和rbp的差值应该是不变的。</p>
<p>gdb(ni) ：会跳出函数执行</p>
<p>gdb(si)：会进入函数执行</p>
<p>![A44D5C36-2816-49B3-9E01-23E15BC5DA72](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;A44D5C36-2816-49B3-9E01-23E15BC5DA72.png)</p>
<p>小端存储的又一个例子啊，我们把寄存器 %rbp(0x7fffffffe3d0) 放入 %rsp，观察可以发现，0x00007ffff倍放在了后面的地址，而0xffffe3d0被放在了前面的地址。x命令打印的地址从左到右，从上到下是以4为单位递增的，</p>
<h2 id="0x-0a-ld-preload环境变量劫持函数"><a href="#0x-0a-ld-preload环境变量劫持函数" class="headerlink" title="0x 0a ld_preload环境变量劫持函数"></a>0x 0a ld_preload环境变量劫持函数</h2><p>首先在目录下创建两个文件 main.c 和 txt</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> <span class="comment">// main.c</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE *fd = fopen(<span class="string">&quot;txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;*** open file error!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;open file success!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常来说最后程序会正确执行</p>
<p>但如果我们更改动态链接库</p>
<p>先创建一个trik动态链接库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">// trik.c</span></span></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*** Always open error!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC trik.c -o trik.so</span><br><span class="line">LD_PRELOAD=$PWD/trik.so ./a.out</span><br></pre></td></tr></table></figure>

<p>最后文件会打开失败</p>
<p>![53DE4182-359A-4F3E-80BB-4B97508E7F9B](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;53DE4182-359A-4F3E-80BB-4B97508E7F9B.png)</p>
<p>原理就是通过自己写的库函数劫持系统的库函数，使得程序执行我们的库函数。</p>
<h2 id="0x-0b-attack-lab"><a href="#0x-0b-attack-lab" class="headerlink" title="0x 0b attack lab"></a>0x 0b attack lab</h2><h2 id="0x0c-链接-points"><a href="#0x0c-链接-points" class="headerlink" title="0x0c 链接 points"></a>0x0c 链接 points</h2><p>1.引入哑节点dummy</p>
<p>2.引入数据结构–elf</p>
<p>3.静态链接的过程：elf定位到符号-&gt;符号解析-&gt;重定位</p>
<p>4.*.o, elf 都是二进制文件</p>
<p>5.unix下大部分工具都在&#x2F;usr&#x2F;bin或者&#x2F;bin目录下的。使用hexdump可以查看二进制文件</p>
<p>6.第一个section的name为空（其实叫做 undefine section），且数据全为0，里面存放的内容是undefine的数据。</p>
<p>7.将函数定义为一个弱符号：<code>attribute__((weak)) int add*() &#123;&#125;</code> ,这里的 <code>add</code> 函数被定义为一个弱符号，它可以被强符号函数 <code>add</code> 覆盖。</p>
<p>8.对于 <code>C Language</code> 来说，出现 <code>Warning</code> 说明你的语句有<strong>歧义</strong> ，但是 C 语言为你选择了一种结果，注意这种结果可能与你的本意不同！</p>
<p>9.对于初始化为 <code>0</code> 的全局变量和静态变量，也被划分到 <code>.bss</code>，这是因为全局变量和静态变量默认初始化就是 <code>0</code>。</p>
<p>10.为什么在可重定位目标文件中有 <code>COMMON</code>，在可执行目标文件中就没有 <code>COMMON</code> 了呢。</p>
<blockquote>
<p> 回想一下<code>COMMON</code>的定义，对于未初始化的全局变量， 属于<code>COMMON</code>。</p>
<p>对于未初始化的全局变量， 在链接之后它有三种可能的情况（假设这里有两个文件 <code>s1.c</code>, <code>s2.c</code>，在 <code>s1.c</code> 中定义有未初始化的全局变量 <code>g</code>）</p>
<ol>
<li><p>如果在 <code>s2.c</code> 中也定义了一个全局变量 <code>g</code> 并且初始化为 <code>0</code>，则 <code>g</code> 属于 <code>.bss</code> 节</p>
</li>
<li><p>如果初始化不是 <code>0</code>，就属于 <code>.data</code></p>
</li>
<li><p>如果 <code>s2.c</code> 没有定义 <code>g</code> ，那么 s2 就属于 <code>.bss</code></p>
<p>因为有如上三种（合法）情况，所以把它划分到 <code>COMMON</code>，而之所以在可执行目标文件中没有了 <code>COMMON</code> ,是因为此时已经链接完了，<code>g</code> 属于那个节已经很明确了，因此也就不需要了。</p>
</li>
</ol>
</blockquote>
<ol start="11">
<li></li>
</ol>
<h2 id="0x0d-修改-ROF-信息的实验"><a href="#0x0d-修改-ROF-信息的实验" class="headerlink" title="0x0d 修改 ROF 信息的实验"></a>0x0d 修改 ROF 信息的实验</h2><p>首先编译源文件 <code>add.c</code> 生成可重定位目标文件 <code>add.o</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> addcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	addcnt ++ ;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用 <code>hexdump -S add.o</code> 查看 <code>Section Headers</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000003c  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000228</span><br><span class="line">       0000000000000060  0000000000000018   I       9     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  0000007c</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  0000007c</span><br><span class="line">       0000000000000004  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .comment          PROGBITS         0000000000000000  0000007c</span><br><span class="line">       0000000000000027  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  000000a3</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .eh_frame         PROGBITS         0000000000000000  000000a8</span><br><span class="line">       0000000000000030  0000000000000000   A       0     0     8</span><br><span class="line">  [ 8] .rela.eh_frame    RELA             0000000000000000  00000288</span><br><span class="line">       0000000000000018  0000000000000018   I       9     7     8</span><br><span class="line">  [ 9] .symtab           SYMTAB           0000000000000000  000000d8</span><br><span class="line">       0000000000000138  0000000000000018          10    11     8</span><br><span class="line">  [10] .strtab           STRTAB           0000000000000000  00000210</span><br><span class="line">       0000000000000018  0000000000000000           0     0     1</span><br><span class="line">  [11] .shstrtab         STRTAB           0000000000000000  000002a0</span><br><span class="line">       0000000000000059  0000000000000000           0     0     1</span><br></pre></td></tr></table></figure>

<p>可以发现下标为 <code>1</code> 的节是 <code>.text</code> 节</p>
<p>我们现在要修改 <code>add.o</code> 使其显示为 <code>.ext</code> 节</p>
<p>首先需要下载 <code>hexedit</code></p>
<p>然后拷贝一份 <code>add.o</code> 的副本 <code>badadd.o</code></p>
<p>（不在源文件上直接修改是个好习惯）</p>
<p>然后执行命令<code>hexdump -c badadd.o</code> 找到 <code>.text</code> 的位置。</p>
<p>通过 <code>elf header</code> 中的信息可以得到 <code>Section header table</code> 的 <code>offset</code> 为 <code>0x300</code>，其中每个条目(<code>entry</code>) 的 <code>size</code> 为 <code>0x40</code> ，由此可以得到第二个条目（下标为1）的 <code>.text</code> 节的位置为 <code>0x340</code>，并通过 <code>struct elf64_shdr</code> 得到前 <code>4</code> 个字节为 <code>name</code>。</p>
<p><code>00000340  20 00 00 00 01 00 00 00  06 00 00 00 00 00 00 00  | ...............|</code></p>
<p><code>name = 0x00000020</code> ,我们只需要修改其为 <code>0x00000022</code>，就可以实现 <code>name</code> 往后偏移两个字节</p>
<p>这样 <code>name</code> 就从 &#96;&#96;.text<code>变成了</code>ext&#96;</p>
<p>执行命令：<code>hexedit badadd.o</code> 找到位置并修改即可。</p>
<p>按 <code>F10</code> 退出</p>
<p>最后结果如下：</p>
<p><code>readelf -S badadd.o</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] ext               PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000003c  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000228</span><br><span class="line">       0000000000000060  0000000000000018   I       9     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  0000007c</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  0000007c</span><br><span class="line">       0000000000000004  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .comment          PROGBITS         0000000000000000  0000007c</span><br><span class="line">       0000000000000027  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  000000a3</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .eh_frame         PROGBITS         0000000000000000  000000a8</span><br><span class="line">       0000000000000030  0000000000000000   A       0     0     8</span><br><span class="line">  [ 8] .rela.eh_frame    RELA             0000000000000000  00000288</span><br><span class="line">       0000000000000018  0000000000000018   I       9     7     8</span><br><span class="line">  [ 9] .symtab           SYMTAB           0000000000000000  000000d8</span><br><span class="line">       0000000000000138  0000000000000018          10    11     8</span><br><span class="line">  [10] .strtab           STRTAB           0000000000000000  00000210</span><br><span class="line">       0000000000000018  0000000000000000           0     0     1</span><br><span class="line">  [11] .shstrtab         STRTAB           0000000000000000  000002a0</span><br><span class="line">       0000000000000059  0000000000000000           0     0     1</span><br></pre></td></tr></table></figure>







<h2 id="0x0e-vim-tabe"><a href="#0x0e-vim-tabe" class="headerlink" title="0x0e vim tabe"></a>0x0e vim tabe</h2><p>vim中的分页命令，多窗口vim</p>
<p>通过<code>help tab-page-intro</code>命令，可以获得关于标签页使用的更多信息。</p>
<table>
<thead>
<tr>
<th><code>:tabnew</code></th>
<th align="left">新建标签页</th>
</tr>
</thead>
<tbody><tr>
<td><code>:tabs</code></td>
<td align="left">显示已打开标签页的列表</td>
</tr>
<tr>
<td><code>:tabc</code></td>
<td align="left">关闭当前标签页</td>
</tr>
<tr>
<td><code>:tabe &lt;filename&gt;</code></td>
<td align="left">打开新文件(tabedit)</td>
</tr>
<tr>
<td><code>:tabp</code></td>
<td align="left">移动到上一个标签页</td>
</tr>
<tr>
<td><code>:tabn</code></td>
<td align="left">移动到下一个标签页(tabnext)</td>
</tr>
<tr>
<td><code>:gt</code></td>
<td align="left">移动到下一个标签页</td>
</tr>
<tr>
<td><code>:tabr</code></td>
<td align="left">移动到第一个标签页(tabrewind,tabfirst)</td>
</tr>
<tr>
<td><code>:tabl</code></td>
<td align="left">移动到最后一个标签页(tablast)</td>
</tr>
<tr>
<td><code>$vim -p &lt;f1&gt; &lt;f2&gt; &lt;f3&gt;</code></td>
<td align="left">vim开启多个标签页</td>
</tr>
</tbody></table>
<h2 id="0x0f-bilbili-链接"><a href="#0x0f-bilbili-链接" class="headerlink" title="0x0f bilbili 链接"></a>0x0f bilbili 链接</h2><p>链接步骤：</p>
<blockquote>
<ol>
<li>parse text</li>
<li>symbol parse</li>
<li>Relocation</li>
</ol>
<p>2 和 3 都依赖于 1 的 text</p>
</blockquote>
<h1 id="Csapp-Link"><a href="#Csapp-Link" class="headerlink" title="Csapp Link"></a>Csapp Link</h1><h2 id="English"><a href="#English" class="headerlink" title="::English"></a>::English</h2><p>separate compliation：分离编译</p>
<p>mangling：重整</p>
<h2 id="Tool"><a href="#Tool" class="headerlink" title=":: Tool"></a>:: Tool</h2><p>GNU READELF：查看目标文件内容的很方便的工具。</p>
<h2 id="0x00-introduce"><a href="#0x00-introduce" class="headerlink" title="0x00 introduce"></a>0x00 introduce</h2><h3 id="1-链接的执行阶段"><a href="#1-链接的执行阶段" class="headerlink" title="1. 链接的执行阶段"></a>1. 链接的执行阶段</h3><ol>
<li>compile time</li>
<li>load time</li>
<li>run time</li>
</ol>
<h3 id="2-why-learn-link"><a href="#2-why-learn-link" class="headerlink" title="2. why learn link"></a>2. <strong>why</strong> learn link</h3><ol>
<li>理解链接器将帮助你构造大型程序</li>
<li>理解链接器将帮助你避免一些危险的编程错误。</li>
<li>理解链接器将帮助你理解语言的作用域规则是如何实现的。</li>
<li>理解链接将帮助你理解其他重要的系统概念。（加载和运行程序，虚拟内存，分页，内存映射）</li>
<li>理解链接将使你能够利用共享库。</li>
</ol>
<h2 id="0x01-compiler-driver"><a href="#0x01-compiler-driver" class="headerlink" title="0x01 compiler driver"></a>0x01 compiler driver</h2><p>compiler dirver：编译器驱动程序</p>
<p>它代表用户在需要的时候调用：</p>
<ol>
<li>cpp</li>
<li>cc1</li>
<li>as</li>
<li>ld</li>
</ol>
<p>可以使用 -v 选项查看这个过程</p>
<p>当我们在 Linux 命令行输入：<code>./proc</code></p>
<p>shell 调用操作系统中一个叫做<strong>加载器</strong>的函数，它将可执行文件 proc 中的代码和数据复制到内存，然后将控制转移到这个程序的开头。</p>
<h2 id="0x02-static-link"><a href="#0x02-static-link" class="headerlink" title="0x02 static link"></a>0x02 static link</h2><p>Relocaable object file: 由各种不同的代码和数据节（section）组成，每一节都是一个连续的字节序列。</p>
<p>为了构造 executable file，linker 必须完成两个主要任务：</p>
<ol>
<li>Symbol resolution（符号解析）：符号解析的目的是将每个符号引用正好和一个符号定义关联起来。</li>
<li>relocation（重定位）。</li>
</ol>
<p>Symbol（符号）：目标文件定义和引用符号，每个符号对应于一个函数，一个局部变量或一个静态变量（即C语言任何非 static 属性声明的变量）。</p>
<p>Compiler and Assembly generate code and data section start at address 0, linker connect every symbol define with one memory address, so can relocate those sections, and then modify all the symbol define, make them point the address. Linker use the detailed instructions of relocation entry(重定位条目) which generated by assembly to execute those relocation with no check.</p>
<h2 id="0x03-object-file"><a href="#0x03-object-file" class="headerlink" title="0x03 object file"></a>0x03 object file</h2><p>object file（目标文件） types:</p>
<ol>
<li>relocatable object file：在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li>
<li>executable object file</li>
<li>Share object file（共享目标文件）: 一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。</li>
</ol>
<p>Compiler and Assembly generate relocatable object file.  Linker generate executable  object file.</p>
<p>Technically talking, a object module(目标模块) is a byte sequence,  and a object file is a object module which storage in disk as a type of file.</p>
<p>目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。</p>
<ol>
<li>Unix: a.out</li>
<li>Windows: PE(Portable Executable)(可移植可执行)</li>
<li>MacOS-X: Mach-O </li>
<li>Modern x86-64 and Unix: ELF(Executable and Linkable Format)(可执行可链接格式)</li>
</ol>
<h2 id="0x04-relocatable-object-file"><a href="#0x04-relocatable-object-file" class="headerlink" title="0x04 relocatable object file"></a>0x04 relocatable object file</h2><p>典型的ELF可重定位目标文件</p>
<p><img src="https://s1.328888.xyz/2022/09/28/spfaF.png" alt="IMG"></p>
<p>ELF contains:   ELF header，Sections，Section header table(节头部表)。</p>
<p>(1) ELF header：</p>
<ol>
<li>以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的<strong>字的大小</strong>和<strong>字节顺序。</strong></li>
<li>剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包含：<ul>
<li>ELF 头的大小</li>
<li>目标文件的类型（可重定位、可执行或者共享）</li>
<li>机器类型（x86-64）</li>
<li>节头部表的文件偏移</li>
<li>节头部表中条目的大小和数量</li>
</ul>
</li>
</ol>
<p>(2) Section headere table: 不同 Section 的位置和大小是由节头部表描述的，其中目标文件中的每个节都有一个固定大小的条目（entry）。</p>
<p>(3) Section:</p>
<ol>
<li>.text：已编译程序的<strong>机器代码。</strong></li>
<li>.rodata：只读数据。</li>
<li>.data：已初始化的全局和静态 C 变量。（局部变量在栈中，既不出现在 .data中，也不出现在 .bss汇总）</li>
<li>.bss：未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量（默认初始化）。在目标文件中<strong>这个节不占用实际的空间，它仅仅是一个占位符。</strong> 目标文件中区分 .bss 和 .data 是为了<strong>空间效率</strong>：在目标文件中，未初始化变量不需要占用任何实际的磁盘空间。运行时，在内存中分配这些变量，初始化为0。</li>
<li>.symtab；符号表。存放在程序中<strong>引用</strong>和<strong>定义</strong>的函数和全局变量的信息。（不包含局部变量的条目）。</li>
<li>.rel.text：relocation。一个 .text 节总位置的列表。当 Linker 把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的<strong>指令</strong>都需要修改。</li>
<li>.rel.data：被模块定义或引用的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的值是一个全局变量地址或者外部定义的函数的<strong>地址</strong>，都需要被修改。</li>
<li>.debug：调试符号表。只有使用 -g 选项时才会得到这张表。</li>
<li>.line：原始 C 源程序中的行好和 .text 节 中机器指令之间的<strong>映射</strong>。只有使用 -g 选项时才会得到这张表。</li>
<li>.strtab：字符串表。其内容包含 .symbol 和 .debug节中的符号表，已经节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。</li>
</ol>
<p>为什么未初始化的数据成为  .bss</p>
<blockquote>
<p>起始于 IMB 704 汇编语言（大约在1957年） Block Storage Start(块存储开始)指令的首字母缩写。并沿用至今。</p>
<p>你可以这样理解并区分于 .data：Better Save Space（更好的节省空间）的缩写。</p>
</blockquote>
<h2 id="0x05-symbol-and-symbol-table"><a href="#0x05-symbol-and-symbol-table" class="headerlink" title="0x05 symbol and symbol table"></a>0x05 symbol and symbol table</h2><p>​			 	</p>
<p>每个 relocatable object module m 都有一个符号表，它包含 m 定义和引用的符号的信息。在 Linker 的上下文中，有三种不同的符号：</p>
<ol>
<li>m 定义的并且能被其他 module 引用的全局符号。</li>
<li>其他 module 定义并被模块 m 引用的全局符号，</li>
<li>只被 m 定义和引用的局部符号。</li>
</ol>
<p>符号表是由 Assembly 构造的，使用 Compiler 输出到汇编语言 .s 文件中的符号。</p>
<p>.symtab 节的内容是一个数组，数组的元素是一个符号条目：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="type">char</span> type: <span class="number">4</span>,</span><br><span class="line">    	binding: <span class="number">4</span>;</span><br><span class="line">    <span class="type">char</span> reserved;</span><br><span class="line">    <span class="type">short</span> section;</span><br><span class="line">    <span class="type">long</span> value;</span><br><span class="line">    <span class="type">long</span> size;</span><br><span class="line">&#125; Elf_64_Symbol;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>name：是字符串表中的字节串，指向符号的以 null 结尾的字符串名字。</p>
<p>section（base_address）：到节头部表的索引，指明被分配到那个节。</p>
<p>value（offset_address）：是符号的地址。对于可重定位的 module 来说，value 是距定义目标的节的其实地址的 offset。</p>
<p>size：是目标的大小（byte）。</p>
<p>type：data or function。</p>
<p>binding：static or global</p>
<p>有三个特殊的<strong>伪节</strong>，它们在节头部表中是没有条目的（只有可重定位目标模块才有）：</p>
<ol>
<li>ABS：不应该被重定位的符号。</li>
<li>UNDEF：未定义的符号，也就是在本目标模块中引用，但是在其它地方定义的符号。</li>
<li>COMMON：还未被分配位置的未初始化的数据目标。对于 common u符号，value 字段给出<strong>对其要求</strong>。</li>
</ol>
<p>common 和 .bss 的区别很细微，现代的 GCC 根据以下规则分配符号：</p>
<ol>
<li>Common: 未初始化的全局变量</li>
<li>.bss：未初始化的静态变量，及其初始化为0的全局变量和静态变量</li>
</ol>
</blockquote>
<h2 id="0x06-symbol-parse"><a href="#0x06-symbol-parse" class="headerlink" title="0x06 symbol parse"></a>0x06 symbol parse</h2><h3 id="1-链接器解析符号引用的方法"><a href="#1-链接器解析符号引用的方法" class="headerlink" title="1.链接器解析符号引用的方法"></a>1.链接器解析符号引用的方法</h3><p>链接器解析符号引用的方法是将每个引用于它输入的可重定位目标文件的符号表的一个确定的符号定义关联起来。</p>
<p>对那些和引用定义在相同模块中的局部符号的引用，符号解析是非常简单明了的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保他们拥有唯一的名字。</p>
<p>不过，对全局符号的引用解析就棘手的多。当编译器遇到一个不是在当前模块中定义的符号（变量或者函数名）时，会假设该符号是在其它某个模块中定义的，升成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条（通常很难阅读的）错误信息并终止。</p>
<h3 id="2-c-和-java-中的重整和恢复"><a href="#2-c-和-java-中的重整和恢复" class="headerlink" title="2.c++ 和 java 中的重整和恢复"></a>2.c++ 和 java 中的<strong>重整</strong>和<strong>恢复</strong></h3><p>C++ 和 Java 都允许重载方法，这些方法在源代码中有相同名字，却有着不同的参数列表。那么链接器是如何区别这些不同的重载函数之间的差异呢？</p>
<p>因此编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。这种编码过程叫做重整（mangling），而相反的过程叫做恢复（demangling）。</p>
<p>幸运的事，C++ 和 Java使用兼容的重整策略。一个被重整的类名字是由名字中字符的整数数量，后面跟上原始名字组成的。例如：类 Foo 被编码成 3Foo。方法被编码为原始方法名，后面加上‘__’（下划线），加上被重整的雷鸣，再加上每个参数的单字母编码。比如：Foo::bar(int, long) 被编码为 bar_3fooil。</p>
<p>重整全局变量和模版名字的策略是相似的。</p>
<p>例如 C++程序 ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> sum1, sum2;</span><br><span class="line">	sum1 = <span class="built_in">get</span>(a, b, c);</span><br><span class="line">	sum2 = <span class="built_in">get</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum1: &quot;</span> &lt;&lt; sum1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum2: &quot;</span> &lt;&lt; sum2 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<p><code>readelf mangling.o --syms</code></p>
<p>得到如下符号表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Symbol table &#x27;.symtab&#x27; contains 30 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS mangling.cpp</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text</span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 .data</span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 .bss</span><br><span class="line">     5: 0000000000000000     1 OBJECT  LOCAL  DEFAULT    4 _ZStL8__ioinit</span><br><span class="line">     6: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    4 $d</span><br><span class="line">     7: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    1 $x</span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 .rodata</span><br><span class="line">     9: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    5 $d</span><br><span class="line">    10: 00000000000000fc    96 FUNC    LOCAL  DEFAULT    1 _Z41__static_ini[...]</span><br><span class="line">    11: 000000000000015c    28 FUNC    LOCAL  DEFAULT    1 _GLOBAL__sub_I__[...]</span><br><span class="line">    12: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 .init_array</span><br><span class="line">    13: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    6 $d</span><br><span class="line">    14: 0000000000000000     0 SECTION LOCAL  DEFAULT    9 .note.GNU-stack</span><br><span class="line">    15: 0000000000000014     0 NOTYPE  LOCAL  DEFAULT   10 $d</span><br><span class="line">    16: 0000000000000000     0 SECTION LOCAL  DEFAULT   10 .eh_frame</span><br><span class="line">    17: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 .comment</span><br><span class="line">    18: 0000000000000000    32 FUNC    GLOBAL DEFAULT    1 _Z3getii</span><br><span class="line">    19: 0000000000000020    44 FUNC    GLOBAL DEFAULT    1 _Z3getiii</span><br><span class="line">    20: 000000000000004c   176 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    21: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZSt4cout</span><br><span class="line">    22: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZStlsISt11char_[...]</span><br><span class="line">    23: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSolsEi</span><br><span class="line">    24: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZSt4endlIcSt11c[...]</span><br><span class="line">    25: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSolsEPFRSoS_E</span><br><span class="line">    26: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSt8ios_base4I[...]</span><br><span class="line">    27: 0000000000000000     0 NOTYPE  GLOBAL HIDDEN   UND __dso_handle</span><br><span class="line">    28: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSt8ios_base4I[...]</span><br><span class="line">    29: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND __cxa_atexit</span><br></pre></td></tr></table></figure>

<p>可以观察到，两个 get 函数分别被标识为：<code>_Z3getii</code> 和 <code>_Z3getiii</code></p>
<h3 id="3-Linux-处理多重定义的符号"><a href="#3-Linux-处理多重定义的符号" class="headerlink" title="3. Linux 处理多重定义的符号"></a>3. Linux 处理多重定义的符号</h3><p>强符号：函数和已初始化的全局变量</p>
<p>弱符号：未初始化的全局变量</p>
<p>Linux 处理多重定义的符号名的三个规则：</p>
<ol>
<li>不允许多个同名的强符号。</li>
<li>如果有一个强符号和多个弱符号同名，选择强符号。</li>
<li>如果有多个弱符号同名，任意选择一个。</li>
</ol>
<h3 id="4-静态库"><a href="#4-静态库" class="headerlink" title="4. 静态库"></a>4. 静态库</h3><h4 id="4-1-为什么要引入静态库？"><a href="#4-1-为什么要引入静态库？" class="headerlink" title="4.1 为什么要引入静态库？"></a>4.1 为什么要引入静态库？</h4><p>如果不引入静态库的话，试想一下编译器开发人员会使用什么方法来向用户提供这些函数。</p>
<blockquote>
<p>编译器代劳！</p>
</blockquote>
<p>一种方法是让编译器辨认出对标准函数的调用，并直接生成相应的代码。对于那些提供了一小部分标准函数的语言（例如 Pascal）是可以的，但是对于 C 这种标准定义了大量的标准函数是不可以的。因为每次添加、修改或删除一个标准库函数时，就需要一个新的编译器版本。然而，对于应用程序猿而言，这种方法是非常方便的，因为标准函数将总是可用（只需要你编译器开发人员搞定就行了，管我什么事 - -</p>
<blockquote>
<p>所有函数对应一个可重定位目标模块！</p>
</blockquote>
<p>另一种方法是将所有的 C 函数都放在一个单独的可重定位目标模块中（比如说 libc.a），应用程序猿可以把这个模块连接到他们的可执行文件中：</p>
<p><code>gcc main.c /usr/lib/libc.o</code></p>
<p>IOS C99 定义的 C库：libc.a; 数学函数库：libm.a</p>
<p>通过把函数放在目标模块中，可以把编译器的实现与标准函数的实现分离开来。但是，现在每个可执行文件都包含着一份标准函数集合的副本（除非你不链接它，但这怎么可能呢？），这是对<strong>磁盘的极度浪费</strong>！在一个典型的系统中，libc.a 大约是 5MB，llib.a 大约是 2MB）。另外，每个运行的程序都将它的这些函数的副本放在内存中，这是<strong>对内存的极大浪费</strong>。此外，只要标准库修改了一个小小的地方，无论多么小，你都要重新编译整个源文件，非常<strong>耗时</strong>。</p>
<blockquote>
<p>每个函数对应一个可重定位目标模块！</p>
</blockquote>
<p>我们可以通过为每个库函数创建一个独立的可重定位模块，把他们放在一个为大家都知道的目录中来解决其中的一些问题。然而，问题也是相当明显的：</p>
<ol>
<li>那你要手写多少模块啊？</li>
<li>太多了不小心写错名字了怎么办？从头再检查一遍吧！</li>
<li>太多了，你得写到什么时候？</li>
<li>。。。</li>
<li>真是一个麻烦又耗时又糟心的过程！</li>
</ol>
<p><code> gcc main.c /usr/lib/printf.o /usr/lib/scanf.o ........</code></p>
<blockquote>
<p>静态库！</p>
</blockquote>
<p>于是，为了解决这些问题，静态库诞生了！！！</p>
<p>我们可以结合上面的方法，既不把所有函数划分到一个模块，也不每个函数对应一个模块，而是把一些相关的函数划分到一个模块（例如 C 标准库和数学库等），然后封装成一个单独的静态库文件。而不是每个函数对应一个模块。</p>
<p><code>gcc main.c /usr/lib/libc.a /usr/lib/libm.a .. </code></p>
<p>你可能会问：这个静态库和前面把所有函数放在一个可重定位目标模块有什么区别吗？不就是一个叫（模块 .o)，一个叫静态库（.a）罢了！</p>
<p>那我可就得给你好好讲讲了：当所有函数封装在一个模块中，那我们链接的时候，就不得不链接所有库函数了。</p>
<p>但是！接下来好好听了！</p>
<p>如果说模块是函数的集合，那么静态库就是模块的集合！所以，你可能想到了，虽然我们链接到了静态库，但并不链接静态库中的所有模块，而是只链接需要用到的模块，这样既避免了类似于一个函数一个模块那样链接模块太多的问题，又避免了链接所有模块的问题。</p>
<p>你可能会问：这怎么实现呢？</p>
<p>答案是：暴力出奇迹，循环判断是否用到就好了。用不到的模块就舍弃掉。</p>
<p>妙不妙！再看一看静态库的定义吧。</p>
<blockquote>
<p>在 Linux 中，静态库是以一种称为 <strong>存档(archive)</strong> 的特殊文件形式存放在<strong>磁盘</strong>中的。存档是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件由后缀（.a)标识。</p>
</blockquote>
<h3 id="4-2-创建静态库"><a href="#4-2-创建静态库" class="headerlink" title="4.2 创建静态库"></a>4.2 创建静态库</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/x_wukong/p/5713437.html">静态库和动态库创建参考</a></p>
<blockquote>
<p>(1) 首先，我们需要源文件（.c）</p>
<p>这里为 mul.c 和 add.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mulcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	mulcnt ++ ;</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125;<span class="comment">// mul.c</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> addcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	addcnt ++ ;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;<span class="comment">// add.c</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>(2) 然后，我们需要将源文件处理成可重定位目标文件</p>
</blockquote>
<p><code>gcc -c add.c mul.c</code></p>
<blockquote>
<p>(3) 最后，将需要的可重定位目标文件封装到静态库中。</p>
<p>例如： <code>ar rcs mylib.a a.o b.o...</code></p>
<p>r: replace and insert</p>
<p>c : create</p>
<p>s: add index</p>
</blockquote>
<p><code>ar rcs mylib.a add.o mul.o</code></p>
<blockquote>
<p>(4) 别以为就这样结束了，编写个 main 程序测试你下你的库吧！</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> s1 = add(x, y);</span><br><span class="line">	<span class="type">int</span> s2 = mul(x, y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;x = %d, y = %d\nsum = %d, mul = %d\n&quot;</span>, x, y, s1, s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c testar.c # 先编译生成可执行文件</span><br><span class="line">gcc --static -o main testar.o -L. mylib.a # 与静态库链接</span><br></pre></td></tr></table></figure>

<blockquote>
<p>–static 参数告诉编译器驱动程序，链接器应该构建一个完全链接的可执行目标文件，它可以加载到内存并运行，在加载时无需更进一步的链接。所以说不加也是可以的。</p>
<p>-Ldir 指明了链接器在那个目录下查找 mylib.a，dot就表示当前目录。</p>
</blockquote>
<h2 id="0x07-relocation"><a href="#0x07-relocation" class="headerlink" title="0x07 relocation"></a>0x07 relocation</h2><h3 id="1-重定位的任务："><a href="#1-重定位的任务：" class="headerlink" title="1. 重定位的任务："></a>1. 重定位的任务：</h3><p>重定位合并输入模块，并为每个符号分配运行时地址。</p>
<p>由两步组成：</p>
<ol>
<li><p>重定位节和符号定义：</p>
<ol>
<li>将所有相同类型的节合并为一个节</li>
<li>将运行时内存地址赋给新的聚合节</li>
<li>赋给输入模块定义的每个符号</li>
</ol>
<p>完成后，程序中的每条指令和全局变量都有唯一的运行时内存地址了。</p>
</li>
<li><p>重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为<strong>重定位条目</strong>的数据结构。</p>
</li>
</ol>
<h3 id="2-重定位条目"><a href="#2-重定位条目" class="headerlink" title="2. 重定位条目"></a>2. 重定位条目</h3><p>为什么需要重定位条目？</p>
<blockquote>
<p>当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。</p>
<p>它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。</p>
<p>所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个 <strong>“重定位条目”</strong>，告诉链接器在将目标文件合并成可执行文件时许和修改这个引用。</p>
<p>代码的重定位条目放在 .rel.text 中，已初始化数据的重定位条目放在 .rel.data 中。</p>
</blockquote>
<p>ELF 重定位条目的格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> offset;	<span class="comment">// 我在那</span></span><br><span class="line">    <span class="type">long</span> type: <span class="number">32</span>;	<span class="comment">// 怎么引用</span></span><br><span class="line">    	smybol: <span class="number">32</span>; <span class="comment">// 我引用了谁</span></span><br><span class="line">    <span class="type">long</span> addend;	<span class="comment">// 我的偏移量</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>offset 是需要被修改的引用的在节内的偏移。（一般是一个地址）</p>
<p>symbol 标识被修改引用应该指向的符号。</p>
<p>type 告知链接器如何修改新的引用。</p>
<p>addend 是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。（addend的值一般是当前引用的地址距离下一条指令的偏移）（讲的标准一点就是对 rip 的修正，因为重定位所在的地址并不是下一条指令的 rip 地址）</p>
</blockquote>
<p>两种最基本的重定位类型（type）：</p>
<ol>
<li><p>R_X86_64_PC32：重定位一个使用 32 位 PC 相对地址的引用。（一个 PC 相对地址就是距程序计数器(PC)的当前运行时值的偏移量。当 CPU 执行一条使用 PC 相对寻址的指令时，它就将在指令中编码的 32 位值加上 PC 的当前运行时值，得到有效地址， PC 值通常是<strong>下一条</strong>指令在内存中的地址）。</p>
<blockquote>
<p>简而言之，<strong>相对</strong>的意思就是，相对于<strong>下一条指令</strong>的偏移量。</p>
</blockquote>
</li>
<li><p>R_X86_64_32：重定位一个 32 位绝对地址的引用。通过绝对寻址，CPU 直接使用在指令中编码的 32 位值作为有效地址。</p>
</li>
</ol>
<h3 id="3-重定位符号引用"><a href="#3-重定位符号引用" class="headerlink" title="3. 重定位符号引用"></a>3. 重定位符号引用</h3><blockquote>
<p> 相对引用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call addr </span><br><span class="line">	sym.offset: R_X86_64_PC32 sym</span><br></pre></td></tr></table></figure>

<p>首先，要清楚我们的目标：通过 addr 的<strong>相对偏移</strong>得到该符号的运行时地址，这个地址我们是已知的。（我们用ADDR(x)表示符号 x 的运行时地址）</p>
<p>当前引用的地址 + 距离下一条指令的偏移量 +  addr &#x3D; 目标符号的运行时地址</p>
<p>addr &#x3D; ADDR(sym) - （当前引用的地址 + 距离下一条指令的偏移量）</p>
<p>不过，距离下一条指令的偏移量通常以 sym.addend 的形式存在，于是，上式变成了：</p>
<p>addr &#x3D; ADDR(sym) - 当前引用的地址 + sym.addend</p>
<blockquote>
<p>我们发现，公式在经过转换后，由 “距离” 下一条指令的偏移量变成了 “加上”  sym.addend。</p>
<p>而偏移量肯定是一个正数（不然怎么偏移到下一条指令），所以说 sym.addend 肯定是个负数。</p>
<p>自己推导的，不一定对？？</p>
</blockquote>
<p>而当前引用的地址 &#x3D; 引用所在节的运行时地址 + 引用的偏移(sym.offset)</p>
<p>所以，上式最终等于如下：</p>
<p>addr &#x3D; ADDR(sym) - （ADDR(Section) + sym.offset）+ sym.addend</p>
<hr>
<blockquote>
<p>绝对引用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call addr</span><br><span class="line">	sym.offset: R-X86_64_32 sym</span><br></pre></td></tr></table></figure>

<p>addr &#x3D; ADDR(sym) + sym.addend</p>
<p>在绝对引用中，我们依然需要加上偏移量addend，只不过 sym.addend&#x3D;0。</p>
<p>可以发现，相较于绝对引用，相对引用只需要减去当前引用的地址即可，距离下一条指令的偏移保存在了 addend 中。</p>
<h2 id="0x08-executable-object-file"><a href="#0x08-executable-object-file" class="headerlink" title="0x08 executable object file"></a>0x08 executable object file</h2><p>典型的 ELF 可执行目标文件（EOF，段和节）：</p>
<p><img src="https://s1.328888.xyz/2022/09/28/spsQp.png" alt="img"></p>
<p>ELF头还包括了程序的入口点？也就是程序的第一条指令的地址。</p>
<p>通过图可以发现，EOF 文件中还多了 .init 节。.init节定义了一个小函数，叫做 _init_，程序的初始化代码会调用它。</p>
<p>.text，.data，.rodata 与可重定位目标文件的节是相似的，除了这些节已经被重定位到它们最终的运行时内存地址以外。</p>
<p>因为 EOF 文件是<strong>完全链接</strong>的（已被重定位），所以它不再需要 .rel 节。</p>
<blockquote>
<p>EOF 文件还有对其要求。这主要与虚拟内存有关</p>
</blockquote>
<h2 id="0x09-load-EOF"><a href="#0x09-load-EOF" class="headerlink" title="0x09 load EOF"></a>0x09 load EOF</h2><p>我们通常在 Linux Shell 命令行输入可执行目标文件的名字 (例如prog) 来执行它:</p>
<p><code>Linux&gt; ./prog</code></p>
<p>因为 prog 不是一个内置的 shell 命令，所以 shell 会认为 prog 是一个可执行目标文件。</p>
<p>通过调用某个驻留在内存中称为<strong>加载器（loader）</strong>的操作系统代码来运行它。</p>
<p>任何 Linux 程序都可以通过调用 <strong>execve()</strong> 调用加载器。</p>
<p>加载器将 EOF 文件的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序从磁盘复制到内存并运行的过程叫做 “加载”。</p>
<p><img src="https://s1.328888.xyz/2022/10/12/8jGhJ.png" alt="img"></p>
<h2 id="0x0a-dynamic-link-shared-library"><a href="#0x0a-dynamic-link-shared-library" class="headerlink" title="0x0a dynamic link shared library"></a>0x0a dynamic link shared library</h2><h3 id="1-为什么引入动态库"><a href="#1-为什么引入动态库" class="headerlink" title="1. 为什么引入动态库"></a>1. 为什么引入动态库</h3><p>当然是因为静态库有一些缺点了。</p>
<p>第一个问题，静态库不方便后续的更新和维护。</p>
<blockquote>
<p>静态库和所有软件一样，需要定期维护和更新。</p>
<p>如果应用程序员想要使用一个库的最新版本，他们必须以某种方式了解到该库的更新情况，然后显式的将他们的程序与更新了的库重新链接。</p>
</blockquote>
<p>第二个问题，静态户仍然会造成对内存资源的极大浪费。 </p>
<blockquote>
<p>虽然在上面 “引入静态库” 一节中我们已经说明了，静态库已经是一种比较节约内存资源的方式。</p>
<p>但那仅仅是在只针对一个文件的情况下，我们尽可能只引用必须用到的模块而避免引用了许多不会用到的模块造成内存浪费。</p>
<p>但试想一下，如果我们存在许多文件呢，几乎每个文件都会用到 printf() 函数等标准 IO 函数。在运行时，这些函数的代码会被复制到每个运行进程的文本段中（试想一下如果我们 printf() 了几百次，难道每一次调用都要复制一份 printf() 的代码吗？那也太浪费内存了！）。</p>
<p>特别是在一个运行上百个金层的典型系统上，这将是对稀缺的内存资源的极大浪费。</p>
<p><strong>（内存的一个有趣属性就是无论系统的内存多大，他总是一种奇缺资源。磁盘空间和厨房的垃圾桶具有同样的属性）。</strong></p>
</blockquote>
<p>于是，为了致力解决静态库的缺憾，共享库诞生了。</p>
<p><strong>共享库是一个目标模块</strong>，在运行或加载时，<strong>可以加载到任意的内存空间</strong>，并和一个在内存中的程序<strong>链接</strong>起来。这个链接的过程就叫做 <strong>“动态链接”</strong>，是由一个叫做动态链接器的程序来执行的。</p>
<p>共享库也称为 **“共享目标”(shared object)**。在 Linux 系统中用 <strong>.so</strong> 后缀来标识。微软的操作系统大量的使用了共享库，它们称为 **DLL(动态链接库)**。</p>
<h3 id="2-共享库的工作方式"><a href="#2-共享库的工作方式" class="headerlink" title="2. 共享库的工作方式"></a>2. 共享库的工作方式</h3><p>共享库是以两种不同的方式来实现 “共享”的。</p>
<p>首先，在任何给定的文件系统中，对于一个酷只有一个 .so 文件，所有引用该库的可执行目标文件分享这个 .so 文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行目标文件中。（解决了静态库内存浪费的问题）</p>
<p>其次，再内存中，一个共享库的 .text 节的一个副本可以被不同的正在运行的进程共享（与虚拟内存有关）。</p>
<p><img src="https://s1.328888.xyz/2022/10/12/86kb0.png" alt="img"></p>
<p>如何构造一个共享库：</p>
<p><code>gcc -shared -fpic -o libname.so module1.o module2.o ....</code></p>
<blockquote>
<p>-fpic 选项指示编译器生成与位置无关的代码。</p>
<p>-shared 选项指示编译器创建一个共享的目标文件。</p>
</blockquote>
<p>下面将将这个共享库链接到程序当中：</p>
<p><code>gcc -o prog main.c ./libname.so</code></p>
<p>根据上图(7-16)我们可以发现，可执行目标文件 prog21 在加载之后，也就是运行时可以和动态库 livvector.so 链接。基本的思路就是当创建可执行文件时，静态执行一些链接，然后在程序加载时，<strong>动态完成链接过程</strong>。</p>
<blockquote>
<p>by xjy：</p>
<p>注意上面的话并不矛盾，前一句话说程序运行时和动态库链接，下一句又说在程序加载时动态完成链接。一个是在运行时，一个是在加载时。</p>
<p>这可能是因为程序并不是直接全部加载到内存的（操作系统），它用到一点就加载一点，所以说，加载和运行是交叉的。</p>
</blockquote>
<p>注意，再整个链接的过程当没有任何动态库的代码和数据真的被复制到可执行文件 prog21 当中。反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对动态库中代码和数据的引用。</p>
<h3 id="3-小实验"><a href="#3-小实验" class="headerlink" title="3. 小实验"></a>3. 小实验</h3><p>下面是一个小实验，1.c，2.c 用来构建动态库和静态库，main.c 是测试函数。</p>
<p>app 是链接静态库生成的可执行文件。</p>
<p>prog 是链接动态库生成的可执行文件。</p>
<p>可以发现，prog 的大小比 app 小的多（小了50多倍）。</p>
<p><img src="https://s1.328888.xyz/2022/10/12/86JI6.png" alt="IMG"></p>
<h1 id="csapp-memory"><a href="#csapp-memory" class="headerlink" title="csapp memory"></a>csapp memory</h1><h2 id="一、cache"><a href="#一、cache" class="headerlink" title="一、cache"></a>一、cache</h2><h3 id="0x01-一种初始化方式"><a href="#0x01-一种初始化方式" class="headerlink" title="0x01 一种初始化方式"></a>0x01 一种初始化方式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">&#125; <span class="type">node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">node_t</span> p = &#123;</span><br><span class="line">        .l = <span class="number">100</span>,</span><br><span class="line">        .r = <span class="number">200</span>,</span><br><span class="line">        .s = <span class="string">&quot;hello,world!&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;node: %d %d %s\n&quot;</span>, p.l, p.r, p.s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="0x02-note"><a href="#0x02-note" class="headerlink" title="0x02 note"></a>0x02 note</h3><p>我们知道内存是分页的，cache的 line 只会存在于某一个页，它不会跨页存在。</p>
<h3 id="0x03-true-x2F-fake-sharing"><a href="#0x03-true-x2F-fake-sharing" class="headerlink" title="0x03 true&#x2F;fake sharing"></a>0x03 true&#x2F;fake sharing</h3><p>罪魁祸首：MESI 协议</p>
<p>false sharing有一个问题，就是对于sum求和这个例子，虽然我们设置sum1和sum2分别求和，但是sum1和sum2都是分配在栈上的，并且地址十分接近，所以它们可能在同一个cache当中，这样不管是sum1修改还是sum2修改，都会触法 MESI 的同步协议，这样 false sharing的速度和true sharing相差几乎无几。</p>
<h3 id="0x04-MESI-protocol"><a href="#0x04-MESI-protocol" class="headerlink" title="0x04 MESI protocol"></a>0x04 MESI protocol</h3><p>exclusive：独有的</p>
<p>exclusive 和 shared 不能共存</p>
<p>四种状态：（由于读数据不会产生数据一致性问题，因此这里只考虑写数据操作）</p>
<p>M: (exclusive) modify, like dirty. 物理地址被缓存到某一个 cache，并且数据已经被修改</p>
<p>E:  exclusive (clean).物理地址被缓存到某一个 cache，并且数据没有被修改</p>
<p>S:  (exclusive) shared clean.物理地址被缓存到 cache，并且多个 cache 共享。</p>
<blockquote>
<p>如果修改一个状态为 s 的 cache，它会发送一个广播，将所有其他状态为 s 的 cache 的状态修改为 invalid（具体方法是将其拥有数据写入到 dram，然后修改状态为 invalid），然后将自己的状态修改为 M，这样就可以保证全局状态下只有一个 M，也就是 exclusive的。</p>
</blockquote>
<p>I: invalid.物理地址并没有缓存到 cache。</p>
<blockquote>
<p>此时如果发生 cache write</p>
<ol>
<li>如果其他 cache 的状态都是 invalid，从内存 load 数据，修改器状态为 M。</li>
<li>如果存在 (shared)S状态 的 cache，将它们的数据写入到 dram，然后修改状态为 invalid。</li>
</ol>
</blockquote>
<p>每个处理器的cache line都是 dram 的 cache line 的拷贝</p>
<h2 id="二、page-table"><a href="#二、page-table" class="headerlink" title="二、page table"></a>二、page table</h2><h3 id="0x01-tips"><a href="#0x01-tips" class="headerlink" title="0x01 tips"></a>0x01 tips</h3><p>地址翻译由硬件实现，操作系统为应用提供这个功能。</p>
<p>TLB 也是一个 cache。</p>
<p>现在 64 位的处理器(cpu)的虚拟地址一般其实只有 48 位，剩下的 16 位属于内核。</p>
<p>虚拟地址空间呈现局部密集，整体稀疏的特征。</p>
<p>多级页表在最坏的情况下（满映射，每页都必须有有效数据）是一棵完全二叉树，此时页表条目会比朴素页表多出来一倍。但这种情况几乎不可能出现（虚拟地址空间的稀疏性和程序的局部性）。</p>
<p>页表分配在操作系统的内核态。</p>
<p>在windows下，资源管理器的内存中可以看到：分页缓冲池和非分页缓冲池。分页缓冲池指的是可以和磁盘进行换入(page in)和换出(page out)的页，而非分页并不是指不分页，而是不能喝磁盘进行 swap。</p>
<h3 id="0x02-how-to-reflect-va2pa"><a href="#0x02-how-to-reflect-va2pa" class="headerlink" title="0x02 how to reflect va2pa"></a>0x02 how to reflect va2pa</h3><p>在我们编写的地址转换函数中，我们简单的通过去模数将物理地址转换为虚拟地址，然而，这是极为不合理的，例如：</p>
<ol>
<li>产生不合法的地址（地址越界）。例如：0x200(1024)%0x200&#x3D;0x000，它产生了一个地址为 0 的地址，这显然是错误的。</li>
<li>不同进程间地址冲突的问题。因为每个进程的地址都是从 0x00400000 开始的，而相同地址取模之后的值是相同的，这就会导致地址冲突。</li>
</ol>
<p>一种可行的方法是使用 hashmap 完成物理地址到虚拟地址地址映射。它解决了使用取模方法产生的冲突和越界问题，但是，它又会产生以下两个问题：</p>
<ol>
<li>内存浪费严重。在 hashmap 中，我们需要额外的两份空间来分别存储物理地址和虚拟地址以记录他们的映射关系，并且，由于 hashmap 并不是全部使用的，它的内部会有空闲，因此我们还需要乘上一个空闲率 k(k&gt;&#x3D;1)，因此 hashmap 就需要额外的 2k 倍的额外内存空间要保存映射信息。</li>
<li>破坏程序的局部性。由于 hashmap 的映射是离散的，这就会导致程序会被离散化，破坏程序的局部性。</li>
</ol>
<p>但是，hashmap 产生的这两个问题属于 性能 问题，它只是导致程序运行效率不好，并不会导致程序运行错误。而取模方法则会导致程序运行出错。</p>
<p>现在我们再来想，hashmap 中记录如此之多的映射信息是否有必要？</p>
<p>肯定是有必要的，不然我们就无法找到物理地址了。但是！如果我们通过虚拟地址映射到物理地址不是离散的，例如：</p>
<blockquote>
<p>虚拟地址 0x1,0x2，通过 hashmap 地址映射为物理地址：0xa, 0xabcd。如果我们想找到这两个物理地址，我们必须保存映射信息，因为 0xa, 0xabcd 之间毫无关联。但是这种离散性是毫无必要的，如果我们将地址映射为 0xa, 0xb 这种连续的地址的话，它不仅可以避免破坏程序的局部性，还能减少地址映射需要保存的信息。</p>
<p>比如虚拟地址 [0x0, 0xffff] 这一块区域，如果我们采用 hashmap，它需要 0xffff 份映射信息，这也太多了。但是，如果 hashmap 映射的地址是连续的，我们就可以通过三元组(va0, pa0, offset) （offset表示偏移量）来找到这个区域内任意一个地址的映射，并且仅仅只需要一份映射信息，对于任意 va，pa&#x3D;pa0+va-va0（va &gt;&#x3D; va0 &amp;&amp; va &lt;&#x3D; va0 + offset）。</p>
<p>现在， 完成地址映射需要的额外信息由 2k 变成了 3M，M 就是上述三元组的数量，这个 M 远小于地址的数量。</p>
</blockquote>
<p>这就是分段思想。</p>
<p>当然，分段也是有问题的，例如：</p>
<ol>
<li>碎片。内部碎片和外部碎片。</li>
<li>每次计算都需要比较 va 是否越界。(va &gt;&#x3D; va0 &amp;&amp; va &lt;&#x3D; va0 + offset)</li>
<li>不方便拓展。当我们的段太大或者或许频繁拓展的时候，寻找一个合适的空间比较麻烦。</li>
</ol>
<p>所以说，我们需要把 offset 变成一个较小且固定的数值，这就是分页思想。</p>
<h3 id="0x03-address-transfer"><a href="#0x03-address-transfer" class="headerlink" title="0x03 address transfer"></a>0x03 address transfer</h3><p><a target="_blank" rel="noopener" href="http://www.wowotech.net/memory_management/arm64-memory-addressing.html">ARM64架构下地址翻译相关的宏定义</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/muahao/p/10297852.html">else</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1374439">else</a></p>
<h3 id="0x04-page-falult"><a href="#0x04-page-falult" class="headerlink" title="0x04 page falult"></a>0x04 page falult</h3><p>MM: main memory，主存</p>
<p>page table is the <strong>cache</strong> from disk to main memory</p>
<p>交换空间：当我们页表缓存的页满了之后，我们想再往内存映射一页，此时需要将该页 page out，但是如果该页的数据被修改了 dirty，我们该怎么办？</p>
<ol>
<li>不管它，这肯定不行</li>
<li>将该页写回文件 program file，这也肯定不行，我们不应该修改源文件。</li>
<li>放到别的地方 – swap space。</li>
</ol>
<p>将一页从 mm 放到 swap space 的过程就叫做 swap out</p>
<p>相反的，将页从 swap space 再放到 mm 的过程叫做 swap in</p>
<p>所以说，一个文件占用的空间包括了 mm 和 swap</p>
<p>swap space 也在磁盘</p>
<p><strong>demand paging</strong>:  waiting until the miss to copy the page to DRAM is konwn as deman paging</p>
<p>程序的代码文件，例如 .data 段它是存储在磁盘当中的，所以它与内存之间可以存在映射关系，但是 .data 段，stack, heap 不是存储在磁盘当中的，当我们需要把这些短存放在磁盘当中时，我们需要放入 swap space 中。它们又称为<strong>“匿名页”</strong>(在磁盘中没有文件与它对应)。 </p>
<h2 id="三、virtual-memory-overview"><a href="#三、virtual-memory-overview" class="headerlink" title="三、virtual memory overview"></a>三、virtual memory overview</h2><p>​       virtual memory 主要是为了解决物理内存和进程所看到的虚拟内存不匹配的问题，所以说每个 virtual memory 肯定是提供给每一个<strong>进程</strong>的。</p>
<p>每个进程就是一段 active 的内存，例如：</p>
<ol>
<li>.text 是死的</li>
<li>.data 是活的，因为它需要写入操作等</li>
</ol>
<p>如果区分 user 的虚拟地址空间和 kernel 的虚拟地址空间：kernel 的64位虚拟地址的最高位是1，user 的64位虚拟地址的最高位是 0。</p>
<p>我们通常看到的程序的虚拟地址空间图中， user 的虚拟地址空间地址的高部分都被 stack 占用了，但是这通常是作者的简化，实际上地址的最高部分被 kernel 部分占用了，只不过一半不标识出来。</p>
<p>只有第一级页表可以区分user mode or kernel mode，因为只有第一级页表可以得到地址的最高位。</p>
<p>用户的虚拟地址空间中的 user 部分映射到程序的虚拟地址空间的user 部分，映射方法为：0x0 + addr，kernel mode 部分的映射方法为：0xffff + addr，user的虚拟地址空间的地址最高为2^48。0xffff正好是16位。</p>
<p>pgb 在 kernel 中只有唯一一份。</p>
<p>kernel 的虚拟地址从 2^47？</p>
<p>内核的地址翻译全局一致。</p>
<h2 id="四、TLB"><a href="#四、TLB" class="headerlink" title="四、TLB"></a>四、TLB</h2><p>hardware acceleration：硬件加速</p>
<p>TLB is the cache of va2pa</p>
<p>我们可以把 cache 看作一个 key-value 库</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">C++ concurrency programming</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-15 20:20:57" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-16 09:44:08" itemprop="dateModified" datetime="2023-06-16T09:44:08+08:00">2023-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-Concurrency-In-Action"><a href="#C-Concurrency-In-Action" class="headerlink" title="C++ Concurrency In Action"></a>C++ Concurrency In Action</h1><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/Cpp_Concurrency_In_Action/README.md#C++%20Concurrency%20In%20Action">Book开源处,感觉翻译很烂</a></p>
<p>关于异常：</p>
<blockquote>
<p><strong>出现异常并不意味着程序本身出了问题，而是程序外部的输入无法让正常业务继续执行，这时应该执行的是异常业务，而异常就是这两种业务转接的桥梁——它提供一种机制，使得程序员在遵守一定规则之下，这个异常业务能够正确完成。</strong></p>
<p>异常安全的三个级别：noexcept,  basic, strong</p>
<p><a target="_blank" rel="noopener" href="https://01io.tech/error-handling-cpp-exception-safety/">ref</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/how-to-design-for-exception-safety?view=msvc-170">ref</a></p>
</blockquote>
<h2 id="P0-English"><a href="#P0-English" class="headerlink" title="P0 English"></a>P0 English</h2><p>spin：自旋转</p>
<p>unary predicate：一元谓词s</p>
<p>binary predicate：二元谓词</p>
<p>predicate：谓词</p>
<p>snapshot：快照</p>
<p>nice-to-have：可有可无</p>
<p>parallelism: 并行</p>
<p>serialization：串形</p>
<p>RAII: Resource Acqusition Is Initialization，资源获取即初始化</p>
<p>Abstraction penalty：抽象代价</p>
<p>daemon thread: 守护线程</p>
<p>invariants:不变量</p>
<p>race condition：条件竞争</p>
<p>grammar：语法</p>
<p>semantics：语义</p>
<p>malicious_function：恶意函数</p>
<p>hierarchical: 分层的</p>
<p>granularity: 粒度</p>
<p>idiom：惯用法</p>
<p>nest: 嵌套</p>
<p>recursive：互斥</p>
<p>synchronization：同步</p>
<p>condition variable：条件变量</p>
<p>future：期望</p>
<p>spurious wakeup：伪唤醒</p>
<p>asynchronization：异步</p>
<p>pivot：枢纽</p>
<p>chrono：时间</p>
<h2 id="P1-Hello-concurrency"><a href="#P1-Hello-concurrency" class="headerlink" title="P1 Hello, concurrency"></a>P1 Hello, concurrency</h2><p><strong>contest switch</strong></p>
<blockquote>
<p>save cpu state and instruction pointer, calculate which task should we switched, and load new cpu state. then, cpu will load the instruction and data in cache</p>
</blockquote>
<p><strong>hardware concurrency</strong></p>
<blockquote>
<p>truly concurrency</p>
</blockquote>
<p><strong>the way of concurrency</strong></p>
<blockquote>
<ol>
<li><p>Multiprocessing concurrency: need to IPC, so more complex and more slowly, but it has good isolation and more safety</p>
</li>
<li><p>Multithreading concurrency: need to solve concurrency problem carefully</p>
</li>
</ol>
</blockquote>
<p>**Warning: **this book base on multiply thread concurrency</p>
<p><strong>why need to concurrency:</strong> only one for code <strong>ioslation</strong> and other for <strong>prefomance</strong></p>
<p><strong>test code:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, Concurrency!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(hello)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="P2-Thread-management"><a href="#P2-Thread-management" class="headerlink" title="P2 Thread management"></a>P2 Thread management</h2><h3 id="2-1-preface"><a href="#2-1-preface" class="headerlink" title="2.1 preface"></a>2.1 preface</h3><h4 id="2-1-1-generalize"><a href="#2-1-1-generalize" class="headerlink" title="2.1.1 generalize"></a>2.1.1 generalize</h4><blockquote>
<ol>
<li>create and run a new thread</li>
<li>join or detain thread</li>
<li>unique identify of thread</li>
</ol>
</blockquote>
<h4 id="2-1-2-start-thread"><a href="#2-1-2-start-thread" class="headerlink" title="2.1.2 start thread"></a>2.1.2 start thread</h4><p>thread run when you create a object of <code>std::thread</code></p>
<p><code>std::thread</code> can create a object by <code>function object</code>, like this example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, Concurrency!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">background_task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Hello, I am a new thread!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// do something else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Good bye~&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    background_task f;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(f)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>But, if you want to pass a tempate object to <code>std::thread</code>, in this way:<code>thread my_t(background_task());</code></p>
<p>You will found this run with error: <code>my_t is a declaration of funtion</code></p>
<p>This is because C++’s <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Most_vexing_parse">most vexing parse</a>, in that declaration, my_t will be parsed in a funtion but a object, you can solve this by following way:</p>
<ol>
<li>use of an extra parenthesis: <code>thread t(( background_task() ));</code></li>
<li>use C++11 initialization: <code>thread t&#123; background_task() &#125;;</code></li>
<li>use C++11 lambda:</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread <span class="title">t</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    cout &lt;&lt; <span class="string">&quot;Hello, this is a thread!&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    cout &lt;&lt; <span class="string">&quot;byt~&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>If you doesn’t decide join or detain your thread, then it will call dtor(<code>std::terminate()</code>).</p>
<h4 id="2-1-2-join-thread"><a href="#2-1-2-join-thread" class="headerlink" title="2.1.2 join thread"></a>2.1.2 join thread</h4><p>If you detach a thread like this way:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> &amp;i;</span><br><span class="line">    <span class="built_in">func</span>(<span class="type">int</span> &amp;_i) : <span class="built_in">i</span>(_i) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">1024</span> * <span class="number">1024</span>; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; j &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;-Hello,World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oops</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> local_state = <span class="number">1024</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(local_state)</span></span>;</span><br><span class="line">    <span class="built_in">my_func</span>();</span><br><span class="line">    <span class="function">thread <span class="title">my_thread</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    my_thread.<span class="built_in">detach</span>(); <span class="comment">// wrong!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">oops</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>In <code>std::thread my_thread</code>, we pass by value of <code>my_func</code> and access local object in <code>func::operator()</code> , if funtion <code>oops</code> exit before thread <code>my_thread</code> exit, then <code>my_thread</code> will access local value which is destoryed, and the behaviour when it happened is UB. </p>
<blockquote>
<p>so it is important to choose a valid way to wait you thread.</p>
<p>and a programming habit is <strong>do not create a thread which can access local object</strong></p>
</blockquote>
<p>A easy and rude way to wait a thread until exit is <code>join</code></p>
<p>if you call <code>join</code>, the resoures about thread will clean automatilly, and you cant call <code>join</code> double times and more.</p>
<p>you can call <code>joinable()</code> to get if you can join, it return false if you haved joined </p>
<h4 id="2-1-3-join-in-special-condition"><a href="#2-1-3-join-in-special-condition" class="headerlink" title="2.1.3 join in special condition"></a>2.1.3 join in special condition</h4><p>Look the next code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(thread &amp;<span class="type">_t</span>)</span> : t(_t) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">thread_guard</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~ thread_guard&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(t.<span class="built_in">joinable</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~ end&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">thread_guard</span>(thread_guard <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    thread_guard&amp; <span class="keyword">operator</span>=(thread_guard <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    thread &amp;t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;function f() do something here..&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span>(<span class="built_in">string</span>(<span class="string">&quot;No reason exception&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> local_state = <span class="number">1024</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(local_state)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">    <span class="comment">// if do_something() throw exception</span></span><br><span class="line">    <span class="comment">// then t.join will be skiped and t would call terminate</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(string &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch in main: &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>In function <code>f()</code>, if <code>do_something()</code> throw exception, and not catched, then <code>f()</code> wiil exit and skiped <code>join()</code></p>
<p>A solution is followings:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;function f() do something here..&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span>(<span class="built_in">string</span>(<span class="string">&quot;No reason exception&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> local_state = <span class="number">1024</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(local_state)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">do_something</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(string &amp;e) <span class="comment">// (1)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch in f: &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(string &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch in main: &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>But, a better way is in RAII</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">thread_guard</span>(thread&amp; <span class="type">_t</span>) : <span class="built_in">t</span>(<span class="type">_t</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">thread_guard</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~thread_guard&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(t.<span class="built_in">joinable</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~thread_guard end&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">thread_guard</span>(<span class="type">const</span> thread&amp; <span class="type">_t</span>)=<span class="keyword">delete</span>;</span><br><span class="line">    thread_guard&amp; <span class="keyword">operator</span>=(<span class="type">const</span> thread&amp; <span class="type">_t</span>) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    thread &amp;t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;function f() do something here..&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span>(<span class="built_in">string</span>(<span class="string">&quot;No reason exception&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> local_state = <span class="number">1024</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(local_state)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="function">thread_guard <span class="title">g</span><span class="params">(t)</span></span>;</span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">    <span class="comment">// the next will skiped if do_something() throw exception</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;f() end&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(string &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch in main: &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this way, although <code>do_something()</code> will throw exception and skip <code>join</code>, the object <code>g</code> will call <code>dtor</code> to <code>join</code> the thread he managed</p>
<h4 id="2-1-4-detach-thread"><a href="#2-1-4-detach-thread" class="headerlink" title="2.1.4 detach thread"></a>2.1.4 detach thread</h4><h3 id="2-2-pass-value"><a href="#2-2-pass-value" class="headerlink" title="2.2 pass value"></a>2.2 pass value</h3><p>Whaterver the parameters type you set(reference or value), thread will <strong>copy</strong> always! Just copy all arguments in the memory space itself.</p>
<p>In the following code, function <code>f()</code> receive a int pass by value and a string pass by reference</p>
<p>And because we detach the thread <code>t</code>, so we would can’t receiver it’s output.</p>
<blockquote>
<p>在下面的代码中，函数 f 打印的 s 可能会乱码，这是因为函数 buf 实际上是一个指针变量，它指向局部变量。</p>
<p>并且它的类型是 <code>const char *</code>，当我们把它传递给 <code>string</code> 时，会执行一个隐式类型转换。</p>
<p>但是，我们无法确保隐式类型转换与 thread 传递参数时进行 copy 的执行顺序问题， 也就是说，有可能传递给 string 的事转换前的变量（buf 只想的指针）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i, string <span class="type">const</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;string: &quot;</span> &lt;&lt; s &lt;&lt; endl; <span class="comment">// string s will chaos</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;value = %i&quot;</span>, value);</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(f, value, buf)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func end&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So, the solution is easy, explicit call type convention</p>
<p><code>thread t(f, value, string(buf));</code></p>
<hr>
<p>But, sometimes, we actually want to pass by refernece, the solution is use <code>std::ref</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread: &quot;</span> &lt;&lt; &amp;i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1024</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func: &quot;</span> &lt;&lt; &amp;value &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(f, ref(value))</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func end&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Also, you can pass class funtion and it’s this object</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;val: &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X x;</span><br><span class="line">    x.val = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// pass pointer </span></span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(&amp;X::do_work, &amp;x)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func end&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>But, for some type, the operator assignment or operator copy is deleted, like <code>unique_ptr&lt;&gt;</code>, so should <code>move</code> but copy.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(unique_ptr&lt;<span class="type">int</span>&gt; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(f, move(q))</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func() end&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It would CE If you not use <code>std::move</code>.</p>
<blockquote>
<p>Thread cant copt too.</p>
</blockquote>
<h3 id="2-3-transfer-possessiveness"><a href="#2-3-transfer-possessiveness" class="headerlink" title="2.3 transfer possessiveness"></a>2.3 transfer possessiveness</h3><h4 id="2-3-1-preface"><a href="#2-3-1-preface" class="headerlink" title="2.3.1 preface"></a>2.3.1 preface</h4><p>你不能通过赋新值操作来“丢弃”一个线程，即：你不能将一个线程 move 到一个已经分配了任务的线程。</p>
<p>你也不可以将一个线程 copy 到另一个线程，但是你可以将一个线程 move 到另一个空线程。</p>
<p>对于下面的形式（1）是合法的，因为 <code>thread(f)</code> 是一个临时对象 – 移动操作会隐式的调用，如果是一个 <code>具名对象</code>， 就需要显示的调用 <code>move</code>，如 (2) 所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">thread t;</span><br><span class="line">t = <span class="built_in">thread</span>(f); <span class="comment">// (1)</span></span><br><span class="line">thread t2 = <span class="built_in">move</span>(f); <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure>

<p>但是对于 (3) 所示就会 CE：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread t;</span><br><span class="line">t = <span class="built_in">thread</span>(f);</span><br><span class="line">thread t2 = <span class="built_in">move</span>(t);</span><br><span class="line">t = <span class="built_in">thread</span>(f);</span><br><span class="line">t2 = <span class="built_in">move</span>(t);   <span class="comment">// (3) t2 已经被分配</span></span><br><span class="line">t2.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>



<h4 id="2-3-2-scoped-thread"><a href="#2-3-2-scoped-thread" class="headerlink" title="2.3.2 scoped_thread"></a>2.3.2 scoped_thread</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">scoped_thread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_thread</span><span class="params">(std::thread <span class="type">_t</span>)</span> </span></span><br><span class="line"><span class="function">        : t(std::move(_t)) </span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="keyword">if</span>(!t.<span class="built_in">joinable</span>())</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;No thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">scoped_thread</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scoped_thread</span>(<span class="type">const</span> scoped_thread&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    scoped_thread&amp; <span class="keyword">operator</span>=(<span class="type">const</span> scoped_thread&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    thread t;   <span class="comment">// 不能是引用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> local_value = <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">// 下面药多加一对括号，否则会被认定为函数的声明</span></span><br><span class="line">    <span class="comment">// 通过 move，我们就无需创建具名对象来创建 thread</span></span><br><span class="line">    <span class="function">scoped_thread <span class="title">t</span><span class="params">((std::thread(func(local_value))))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func() end&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>疑问？</p>
<p>为啥不把 ctor 里的 t 设置为右值引用呢？</p>
</blockquote>
<h4 id="2-3-3-jpthread"><a href="#2-3-3-jpthread" class="headerlink" title="2.3.3 jpthread"></a>2.3.3 jpthread</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thread_guard</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">scoped_thread</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">joining_thread</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">joining_thread</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>; <span class="comment">// ??</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">joining_thread</span><span class="params">(Callable &amp;&amp;func, Args&amp;&amp; ...args)</span></span></span><br><span class="line"><span class="function">        :t(std::forward&lt;Callable&gt;(func), std::forward&lt;Args&gt;(args) ...) // ???</span></span><br><span class="line"><span class="function">        &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">joining_thread</span>(joining_thread &amp;&amp;other) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">t</span>(std::<span class="built_in">move</span>(other.t))</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">joining_thread</span>(thread <span class="type">_t</span>) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">t</span>(std::<span class="built_in">move</span>(<span class="type">_t</span>))</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">    joining_thread&amp; <span class="keyword">operator</span>=(joining_thread &amp;&amp;other) <span class="keyword">noexcept</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">joinable</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        t = std::<span class="built_in">move</span>(other.t);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为啥不是 thread &amp;&amp;t</span></span><br><span class="line">    joining_thread&amp; <span class="keyword">operator</span>=(thread t) <span class="keyword">noexcept</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">joinable</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        t = std::<span class="built_in">move</span>(t);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">joining_thread</span>() <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">joinable</span>())</span><br><span class="line">            <span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(joining_thread &amp;other)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        t.<span class="built_in">swap</span>(other.t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="function">thread::id <span class="title">get_id</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">get_id</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">joinable</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">joinable</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::thread&amp; <span class="title">as_thread</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread&amp; <span class="title">as_thread</span><span class="params">()</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 将 const thread&amp; 的 const 属性去掉</span></span><br><span class="line">        <span class="comment">// 去掉 const 属性必须用 const_cast</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;thread&amp;&gt;(</span><br><span class="line">            <span class="comment">// 将 &amp;this 转换为 const 类型</span></span><br><span class="line">            <span class="comment">// 加上 const 属性用 static_cast</span></span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">const</span> joining_thread&amp;&gt;(*<span class="keyword">this</span>).<span class="built_in">as_thread</span>()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::thread t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>疑问？</p>
<p>为啥不把 ctor 中的 <code>thread t</code> 改为 <code>thread &amp;&amp;t</code> 呢？</p>
</blockquote>
<h3 id="2-4-determin-count-of-thread"><a href="#2-4-determin-count-of-thread" class="headerlink" title="2.4 determin count of thread"></a>2.4 determin count of thread</h3><p><code>thread::hardware_concurrency()</code> ：返回并发线程的数量。</p>
<p>并行版的 <code>std::accumulate</code></p>
<blockquote>
<p>因为数据范围并不大，因此得出的时间消耗意义不大！</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========================*/</span></span><br><span class="line"><span class="comment">/*      std::accumulate      */</span></span><br><span class="line"><span class="comment">/*    concurrency version    */</span></span><br><span class="line"><span class="comment">/*===========================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// just the warpped function of std::accumulate</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">accumulate_block</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator first, Iterator last, T&amp; result)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        result = std::<span class="built_in">accumulate</span>(first, last, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">parallel_accumulate</span><span class="params">(Iterator first, Iterator last, T init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">cul_t</span> = <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">ul_t</span> = <span class="type">unsigned</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">cul_t</span> length = std::<span class="built_in">distance</span>(first, last);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// special check</span></span><br><span class="line">    <span class="keyword">if</span>(!length)</span><br><span class="line">        <span class="keyword">return</span> init;</span><br><span class="line"></span><br><span class="line">    <span class="type">cul_t</span> min_pre_thread = <span class="number">25</span>; <span class="comment">// 一个线程至少处理 25 个任务</span></span><br><span class="line">    <span class="comment">// 最大线程数为：任务总数 / 每个线程处理的任务数量，上取整</span></span><br><span class="line">    <span class="type">cul_t</span> max_threads = (length + min_pre_thread - <span class="number">1</span>) / min_pre_thread;</span><br><span class="line">    </span><br><span class="line">    <span class="type">cul_t</span> hardware_thread = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为上下文切换的成本也很高，因此和系统真正的并发量取 min</span></span><br><span class="line">    <span class="type">cul_t</span> num_threads = std::<span class="built_in">min</span>(hardware_thread != <span class="number">0</span> ? hardware_thread : <span class="number">2</span>, max_threads);</span><br><span class="line">    <span class="comment">// 每个线程处理一个任务块</span></span><br><span class="line">    <span class="type">cul_t</span> block_size = length / num_threads;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;T&gt; <span class="title">results</span><span class="params">(num_threads)</span></span>; <span class="comment">// result[num_threads-1] uesed to save finally result</span></span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(num_threads - <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分块 </span></span><br><span class="line">    Iterator block_start = first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">ul_t</span> i = <span class="number">0</span>; i &lt; num_threads - <span class="number">1</span>; ++ i )</span><br><span class="line">    &#123;</span><br><span class="line">        Iterator block_end = block_start;</span><br><span class="line">        std::<span class="built_in">advance</span>(block_end, block_size);</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(</span><br><span class="line">            <span class="built_in">accumulate_block</span>&lt;Iterator, T&gt;(),</span><br><span class="line">            block_start, block_end, std::<span class="built_in">ref</span>(results[i])</span><br><span class="line">        );</span><br><span class="line">        block_start = block_end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最终可能不满一个整块，即可能不能切好分为一个块</span></span><br><span class="line">    <span class="built_in">accumulate_block</span>&lt;Iterator, T&gt;()(</span><br><span class="line">        block_start, last, results[num_threads - <span class="number">1</span>]</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计最终结果</span></span><br><span class="line">    for_each(threads.<span class="built_in">begin</span>(), threads.<span class="built_in">end</span>(), <span class="built_in">mem_fn</span>(&amp;thread::join));</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(results.<span class="built_in">begin</span>(), results.<span class="built_in">end</span>(), init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    vector&lt;ull&gt; num;</span><br><span class="line">    ull sum;</span><br><span class="line">    <span class="type">clock_t</span> cur;</span><br><span class="line">    <span class="type">const</span> ull MAX_REP = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span>(ull i = <span class="number">0</span>; i &lt; MAX_REP; i ++ )</span><br><span class="line">        num.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test std::accumulate</span></span><br><span class="line">    cur = <span class="built_in">clock</span>();</span><br><span class="line">    sum = <span class="built_in">accumulate</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>(), (ull)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;time = %.4lf\n&quot;</span>, (<span class="built_in">clock</span>()-cur) * <span class="number">1.0</span> / CLOCKS_PER_SEC);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sum: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// test concurrency accumulate</span></span><br><span class="line">    cur = <span class="built_in">clock</span>();</span><br><span class="line">    sum = <span class="built_in">parallel_accumulate</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>(), (ull)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;time = %.4lf\n&quot;</span>, (<span class="built_in">clock</span>()-cur) * <span class="number">1.0</span> / CLOCKS_PER_SEC);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sum: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="2-5-thread-id"><a href="#2-5-thread-id" class="headerlink" title="2.5 thread id"></a>2.5 thread id</h3><p><code>thread::get_id()</code>：如果线程没有执行，会打印：<code>thread::id of a non-executing thread</code></p>
<p><code>this_thread::get_id()</code> ： 返回当前线程的 id</p>
<p>线程标识符可以用来比较，排序，哈希等。</p>
<p>通过线程标识符可以实现不同的线程执行不同的任务。</p>
<p><code>get_id()</code> 的输出是依赖于实现的，但是C++ 标准规定相同 ID 的线程必须有相同的输出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================*/</span></span><br><span class="line"></span><br><span class="line">thread::id master_thread_id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(this_thread::<span class="built_in">get_id</span>() == master_thread_id)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am master&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am slaver&quot;</span> &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    vector&lt;thread&gt; threads;</span><br><span class="line">    <span class="comment">// create master</span></span><br><span class="line">    <span class="function">thread <span class="title">master</span><span class="params">(fun, <span class="number">0</span>)</span></span>;</span><br><span class="line">    master_thread_id = master.<span class="built_in">get_id</span>();</span><br><span class="line">    threads.<span class="built_in">push_back</span>(<span class="built_in">move</span>(master));    <span class="comment">// must add move!</span></span><br><span class="line">    <span class="comment">// create slaver</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++ )    threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(fun, i + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// join</span></span><br><span class="line">    for_each(threads.<span class="built_in">begin</span>(), threads.<span class="built_in">end</span>(), <span class="built_in">mem_fn</span>(&amp;thread::join));</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="P3-data-share"><a href="#P3-data-share" class="headerlink" title="P3 data share"></a>P3 data share</h2><h3 id="3-1-problems"><a href="#3-1-problems" class="headerlink" title="3.1 problems"></a>3.1 problems</h3><h4 id="3-1-1-race-condition"><a href="#3-1-1-race-condition" class="headerlink" title="3.1.1 race condition"></a>3.1.1 race condition</h4><p>条件竞争分为恶性条件竞争和良性条件竞争，良性条件竞争不会对系统有什么影响。</p>
<p>避免恶性条件竞争的方法：</p>
<ol>
<li>对数据结构采用某种保护机制，例如：mutex</li>
<li>无锁数据结构</li>
<li>事务</li>
</ol>
<h4 id="3-1-2-use-mutex-to-avoid-RC"><a href="#3-1-2-use-mutex-to-avoid-RC" class="headerlink" title="3.1.2 use mutex to avoid RC"></a>3.1.2 use mutex to avoid RC</h4><p>C++ 为我们提供了互斥量用来避免恶性条件竞争，我们可以通过实例化 <code>std::mutex</code> 创建互斥量，并通过 <code>lock()</code> 和 <code>unlock()</code> 进行上锁和解锁，但并不推荐你这么做，认为人总会犯错 😭</p>
<p>所以，类似智能指针，C++ 标准库为互斥量提供了一个 RAII 语法的模板类 <code>std::lock_guard</code>，其会在构造的时候自动上锁，并在析构的时候自动解锁。</p>
<p>他们都在 <code>&lt;mutex&gt;</code> 头文件当中。</p>
<p>示例程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========================*/</span></span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt; L; <span class="comment">// shared data</span></span><br><span class="line">mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_list</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">guard</span><span class="params">(m)</span></span>;</span><br><span class="line">    L.<span class="built_in">push_back</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">list_contains</span><span class="params">(<span class="type">int</span> value_to_find)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">guard</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(L.<span class="built_in">begin</span>(), L.<span class="built_in">end</span>(), value_to_find) != L.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )    L.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">list_contains</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但互斥量也不总是安全的，例如我们在一个类中返回了被保护数据的指针或引用时，会破坏对数据的保护，并且不会被互斥锁限制。</p>
<p>因此，对接口的设计需要相当谨慎，要确保互斥量能锁住任何对保护数据的访问，并且“不留后门”。</p>
<p>例如，在下面的程序当中，我们通过引用把被保护数据传递到互斥锁作用于之外，从而造成一个潜在的陷阱：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">some_data</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    string b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;You are a fool man😄...\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">data_wrapper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    some_data data;</span><br><span class="line">    std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">process_data</span><span class="params">(Function func)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">l</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="built_in">func</span>(data); <span class="comment">// 传递“保护”数据给用户函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">some_data *unprotected;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">malicious_function</span><span class="params">(some_data&amp; protected_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unprotected = &amp;protected_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data_wrapper x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.<span class="built_in">process_data</span>(malicious_function);</span><br><span class="line">    <span class="comment">// 现在，我么将一个被保护的数据拿出来了，并且可以随意处理</span></span><br><span class="line">    unprotected-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">Foo</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-mutex"><a href="#3-2-mutex" class="headerlink" title="3.2 mutex"></a>3.2 mutex</h3><h4 id="3-2-1-RC-between-interface"><a href="#3-2-1-RC-between-interface" class="headerlink" title="3.2.1 RC between interface"></a>3.2.1 RC between interface</h4><p>使用互斥量对数据进行保护并不能万事大吉。</p>
<p>例一：删除双链表中的一个节点</p>
<blockquote>
<p>当我们要删除双链表中的节点 <code>P</code> 时，仅仅对 P 添加互斥量是不行的，还需要对 <code>P-&gt;next</code>, <code>P-&gt;prev</code> 同时添加互斥锁。</p>
</blockquote>
<p>例二：堆栈</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s.<span class="built_in">empty</span>()) <span class="comment">// (1)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> value = s.<span class="built_in">top</span>(); <span class="comment">// (2)</span></span><br><span class="line">        s.<span class="built_in">pop</span>();             <span class="comment">// (3)</span></span><br><span class="line">        <span class="built_in">do_something</span>(value); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，当堆栈非空时，我们希望从中取出栈顶素，再调用 <code>pop()</code>，但其实 (1) 和 (2) 之间是有竞争条件的，也就是说，可能存在一个线程在 (1) 与 (2) 之间也掉用了 <code>pop()</code>。</p>
<p>另一个潜在的竞争条件发正在 (2) 和 (3) 之间，可能有两个线程先后执行了 <code>top()</code>，但没有执行 <code>pop()</code>，此时两个线程处理后 <code>value</code> 的值可能是相同的，这种错误很难定位，因为程序没有出错，出错的是你的逻辑。</p>
<blockquote>
<p>这就需要接口设计上有较大的改动，提议之一就是使用同一互斥量来保护 top()和 pop()。Tom Cargill[1]指出当一个对象的拷贝构造函数在栈中抛出一个异常，这样的处理方式就会有问题。在 Herb Sutter[2]看来，这个问题可以从“异常安全”的角度完美解决，不过潜在的条件竞争，可能会组成一些新的组合。</p>
</blockquote>
<p>一个很有意思的事情是，我们可能不得不面临例二中的竞争条件。在堆栈的 pop 操作中（有返回值），如果我们直接把容器元素 ”移动“ 到目标位置，可能会因为 <code>bad_alloc</code> 异常，也就是内存不足而导致数据没有拷贝出去，并且栈中的数据也杯破坏了。</p>
<p>因此，设计人员通常把这个操作操作分为两部分：</p>
<ol>
<li>top()</li>
<li>pop()</li>
</ol>
<p>由此来确保数据不会在内存不足时出错，但我们之前讨论过了，在 1 和 2 之间，有竞争条件。</p>
<p>但幸好，我们还有其它选项，尽管他们也不是完美的。</p>
<p><strong>solution1：将变量的引用作为参数，传入 pop() 函数中取得想要的”弹出值“</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; stk;</span><br><span class="line"><span class="comment">/*------------------------*/</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">stk.<span class="built_in">pop</span>(result);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种方法有明显的缺点：</p>
<ol>
<li>需要构造出一个栈中类型的实例用于接受目标值，这会导致空间和空间的额外开销等</li>
<li>要求类型必须支持赋值操作，很多类型即使支持移动构造和拷贝构造，可能也不支持赋值</li>
</ol>
</blockquote>
<p><strong>solution2：无异常抛出的拷贝构造函数或移动构造函数</strong></p>
<p><strong>solution3：返回指向弹出值的指针</strong></p>
<p><strong>solution4：“选项1 + 选项2”或 “选项1 + 选项3”</strong></p>
<p><strong>Example： thread safe stack</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN test_begin()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   test_end()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_end</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_begin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*===========================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">empty_stack</span> : exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[Error] empty stack!&quot;</span>; <span class="comment">// 不要添加格式控制符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsaft_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsaft_stack</span>() : <span class="built_in">data</span>(std::<span class="built_in">stack</span>&lt;T&gt;()) &#123;&#125;</span><br><span class="line">    <span class="built_in">threadsaft_stack</span>(<span class="type">const</span> threadsaft_stack &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在函数体而不是成员初始化列表中copy可以确保数据的正确性</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;</span><br><span class="line">        data = other.m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不提供太多接口</span></span><br><span class="line">    threadsaft_stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsaft_stack &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        data.<span class="built_in">push</span>(new_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>())    <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();    <span class="comment">// 检查是否为空</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在修改的堆栈前，分配出返回值</span></span><br><span class="line">        <span class="function"><span class="type">const</span> std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(std::make_shared&lt;T&gt;(data.top())))</span></span>;</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>())    <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">        <span class="comment">// 注意下面调用的都是 stack 的内置函数</span></span><br><span class="line">        value = data.<span class="built_in">top</span>();</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;T&gt; data;</span><br><span class="line">    std::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    threadsaft_stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++ )  s.<span class="built_in">push</span>(i);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;push done&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    s.<span class="built_in">pop</span>(x);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    <span class="built_in">Foo</span>();</span><br><span class="line">    <span class="comment">/*======================*/</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实本质上就是将原本的两个函数（top 和 pop）实现的操作集成到一个函数（pop）当中，这样就可以通过互斥量完成数据的保护。</p>
<p>通过一个函数修改我们的参数，很自然的有两种方式，一是返回值，而是传引用。</p>
<p>在返回值这种方式中，return 一个引用是危险的，这我们前面提到过。直接 return 值的话开销可能很大，因此我们考虑传出一个动态对象，而手动 new&#x2F;delete 不安全，因此使用智能指针。</p>
</blockquote>
<h4 id="3-2-2-deadlock"><a href="#3-2-2-deadlock" class="headerlink" title="3.2.2 deadlock"></a>3.2.2 deadlock</h4><p>避免死锁的方法：</p>
<ol>
<li>指定获得锁的顺序</li>
<li>一次性加全部锁</li>
<li>…</li>
</ol>
<p>C++ 标准库的 <code>std::lock</code> 可以一次性锁住多个互斥量并且没有死锁风险。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bank_account</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">bank_account</span><span class="params">(<span class="type">int</span> _balance)</span> : balance(_balance) &#123;</span>&#125;</span><br><span class="line">    <span class="type">int</span> balance;</span><br><span class="line">    std::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less_amount</span> : std::exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Too little money in your amount ^ ^ !&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transfer</span><span class="params">(bank_account &amp;from, bank_account &amp;to, <span class="type">int</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;from == &amp;to)    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(from.balance &lt; amount)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span>(<span class="built_in">less_amount</span>());</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">lock</span>(from.m, to.m);</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock1</span><span class="params">(from.m, std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock2</span><span class="params">(to.m, std::adopt_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    from.balance -= amount;</span><br><span class="line">    to.balance += amount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">bank_account <span class="title">my_account</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">bank_account <span class="title">your_account</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(transfer, std::ref(my_account), std::ref(your_account), <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(transfer, std::ref(your_account), std::ref(my_account), <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(transfer, std::ref(my_account), std::ref(my_account), <span class="number">100</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;my_account.balance = &quot;</span> &lt;&lt; my_account.balance &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;your_account.balance = &quot;</span> &lt;&lt; your_account.balance &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然规定一个获得锁的顺序可以避免死锁，但他不是万能的，甚至说，会起到适得其反的效果，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bank_account</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">bank_account</span><span class="params">(<span class="type">int</span> _balance)</span> : balance(_balance) &#123;</span>&#125;</span><br><span class="line">    <span class="type">int</span> balance;</span><br><span class="line">    std::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less_amount</span> : std::exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Too little money in your amount ^ ^ !&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bank_swap</span><span class="params">(bank_account &amp;from, bank_account &amp;to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;from == &amp;to)    <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::lock(from.m, to.m);</span></span><br><span class="line">    from.m.<span class="built_in">lock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I get From, balance: &quot;</span> &lt;&lt; from.balance &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);   </span><br><span class="line">    </span><br><span class="line">    to.m.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock1</span><span class="params">(from.m, std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock2</span><span class="params">(to.m, std::adopt_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(from.balance, to.balance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">bank_account <span class="title">my_account</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">bank_account <span class="title">your_account</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(bank_swap, std::ref(my_account), std::ref(your_account))</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(bank_swap, std::ref(your_account), std::ref(my_account))</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;my_account.balance = &quot;</span> &lt;&lt; my_account.balance &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;your_account.balance = &quot;</span> &lt;&lt; your_account.balance &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们虽然在 <code>swap()</code> 中规定了获得锁的顺序，但是如果我们交换了 <code>swap()</code> 的参数顺序，那么结果就很可怕了！</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/lock_tag">std::defer_lock, std::try_to_lock, std::adopt_lock</a></p>
<table>
<thead>
<tr>
<th><code>defer_lock_t</code></th>
<th>不获得互斥的所有权</th>
</tr>
</thead>
<tbody><tr>
<td>try_to_lock_t</td>
<td>尝试获得互斥的所有权而不阻塞</td>
</tr>
<tr>
<td>adopt_lock_t</td>
<td>假设调用方线程已拥有互斥的所有权</td>
</tr>
</tbody></table>
</blockquote>
<p><strong>Advise to avoid deadlock：</strong></p>
<ol>
<li>避免嵌套锁，尽量只使用一个锁</li>
<li>避免在持有锁时调用用户提供的代码</li>
<li>使用固定顺序获取锁</li>
<li>使用层级锁</li>
</ol>
<h4 id="3-2-3-hierarchical-mutex"><a href="#3-2-3-hierarchical-mutex" class="headerlink" title="3.2.3 hierarchical_mutex"></a>3.2.3 hierarchical_mutex</h4><blockquote>
<p> <a target="_blank" rel="noopener" href="https://mysteriouspreserve.com/blog/2021/09/15/Hierarchical-Mutex/">reference</a></p>
</blockquote>
<p>层级锁的意义在于：在运行时约定是否进行检查，这个建议需要对应用层进行分层，并且识别在给定层上所有互斥量。</p>
<p>层级锁的核心就是：每个互斥量有一个层级值，线程只能以层级值递减的顺序获取锁，由此实现顺序性。</p>
<p>**Sample complement: **</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hierarchical_mutex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">hierarchical_mutex</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> value)</span></span></span><br><span class="line"><span class="function">        : hierarchichy_value(value), </span></span><br><span class="line"><span class="function">          previous_hierarchichy_value(<span class="number">0</span>)</span></span><br><span class="line"><span class="function">        &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">        internal_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">// 备份层级值</span></span><br><span class="line">        <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 恢复层级值</span></span><br><span class="line">        this_thread_hierarchy_value = previous_hierarchichy_value;</span><br><span class="line">        internal_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">        <span class="keyword">if</span>(!internal_mutex.<span class="built_in">try_lock</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex internal_mutex;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 需要构造的锁的层级值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hierarchichy_value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this_thread_hierarchy_value 的备份</span></span><br><span class="line">    <span class="comment">// 因为在 unlock 之后需要恢复上一次的值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> previous_hierarchichy_value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前的层级值，第二个锁的层级值必须小于该值</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">long</span> this_thread_hierarchy_value; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_for_hierarchy_violation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 如果需要构造的锁的层级值大于等于当前锁的层级值，不合法</span></span><br><span class="line">        <span class="keyword">if</span>(this_thread_hierarchy_value &lt;= hierarchichy_value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;mutex hierarchy violated&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update_hierarchy_value</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 更新当前锁的层级值</span></span><br><span class="line">        previous_hierarchichy_value = this_thread_hierarchy_value;</span><br><span class="line">        this_thread_hierarchy_value = hierarchichy_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能加 static</span></span><br><span class="line"><span class="function"><span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title">hierarchical_mutex::this_thread_hierarchy_value</span><span class="params">(ULONG_MAX)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">m1</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">m2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;F2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">lock_guard&lt;hierarchical_mutex&gt; <span class="title">lock</span><span class="params">(m1)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;F1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">lock_guard&lt;hierarchical_mutex&gt; <span class="title">lock</span><span class="params">(m2)</span></span>;</span><br><span class="line">    <span class="built_in">f2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">f1</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>初始化 static 成员时不能加 static，避免与 class 之外的 static 变量混淆</li>
<li>为什么将 this_thread_hierarchy_value 设置为 thread_local static ? 只有这样才能实现动态更新层级，当我们更新了 this_thread_hierarchy_value 的值之后，下一个创建的 hierarchical_mutex 对象使用的是更新之后的值。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Foo::x</span><span class="params">(<span class="number">1024</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo f;</span><br><span class="line">    cout &lt;&lt; f.x &lt;&lt; endl;    <span class="comment">// 1024</span></span><br><span class="line">    f.x = <span class="number">233</span>;</span><br><span class="line">    cout &lt;&lt; f.x&lt;&lt; endl;     <span class="comment">// 233</span></span><br><span class="line">    Foo g;</span><br><span class="line">    cout &lt;&lt; g.x &lt;&lt; endl;    <span class="comment">// 233</span></span><br><span class="line">    cout &lt;&lt; Foo::x &lt;&lt; endl; <span class="comment">// 233</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="3-2-4-std-uniqie-lock"><a href="#3-2-4-std-uniqie-lock" class="headerlink" title="3.2.4 std::uniqie_lock"></a>3.2.4 std::uniqie_lock</h4><p>对 swap 函数的改写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bank_account</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">bank_account</span><span class="params">(<span class="type">int</span> balance)</span> : balance&#123;</span>balance&#125; &#123;&#125;</span><br><span class="line">    <span class="type">int</span> balance;</span><br><span class="line">    std::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_swap</span><span class="params">(bank_account &amp;from, bank_account &amp;to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;from == &amp;to) <span class="keyword">return</span>; <span class="comment">// avoid deadlock in case of self transfer</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将互斥量传入 unique 表示该互斥量应该保持解锁状态（不应该再被其他线程上锁）</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(from.m, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock_b</span><span class="params">(to.m, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="comment">// std::defer_lock 留下未上锁的互斥量</span></span><br><span class="line">    std::<span class="built_in">lock</span>(lock_a, lock_b);</span><br><span class="line">    std::<span class="built_in">swap</span>(from.balance, to.balance);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bank_account my_account&#123;<span class="number">100</span>&#125;;</span><br><span class="line">    bank_account your_account&#123;<span class="number">50</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    std::thread t1&#123;my_swap, std::<span class="built_in">ref</span>(my_account), std::<span class="built_in">ref</span>(your_account)&#125;;</span><br><span class="line">    std::thread t2&#123;my_swap, std::<span class="built_in">ref</span>(your_account), std::<span class="built_in">ref</span>(my_account)&#125;;</span><br><span class="line">    std::thread t3&#123;my_swap, std::<span class="built_in">ref</span>(my_account), std::<span class="built_in">ref</span>(your_account)&#125;;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;my_account.balance = &quot;</span> &lt;&lt; my_account.balance &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;your_account.balance = &quot;</span> &lt;&lt; your_account.balance &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="3-2-5-Passing-of-mutex-ownership-in-different-domains"><a href="#3-2-5-Passing-of-mutex-ownership-in-different-domains" class="headerlink" title="3.2.5  Passing of mutex ownership in different domains"></a>3.2.5  Passing of mutex ownership in different domains</h4><p><code>std::unique_lock</code> 实例没有与自身相关的互斥量，互斥量的所有权可以通过<strong>移动操作</strong>， 在不同的实例间传递。</p>
<p>… 看不懂在干啥 😭</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">get_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> std::mutex some_mutex;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(some_mutex)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;get_lock()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> lock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(get_lock())</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;process_data()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(process_data)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="3-2-5-Lock-Granularity"><a href="#3-2-5-Lock-Granularity" class="headerlink" title="3.2.5 Lock Granularity"></a>3.2.5 Lock Granularity</h4><p>锁的粒度用来描述通过一个锁保护着的数据量大小。一个细粒度锁(a fine-grained lock) 能够保护较小的数据量，一个粗粒度锁(a coarse-grained lock)能保护较多的数据量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// private:</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> some_detail;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_detail</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> some_detail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Y</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Y</span>(<span class="type">int</span> _sd) : <span class="built_in">some_detail</span>(_sd) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Y &amp;lhs, <span class="type">const</span> Y &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(&amp;lhs == &amp;rhs)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> lhs_value = lhs.<span class="built_in">get_detail</span>(); <span class="comment">// (1)</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I get lhs value:&quot;</span> &lt;&lt; lhs_value &lt;&lt; endl;;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 锁的粒度小，在得到lhs_value之后</span></span><br><span class="line">        <span class="comment">// rhs_value可能不是获取lhs_value瞬间的值</span></span><br><span class="line">        <span class="comment">// 他的值可能被修改</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> rhs_value = rhs.<span class="built_in">get_detail</span>();  <span class="comment">// (2)</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I get rhs value!: &quot;</span> &lt;&lt; rhs_value &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> lhs_value == rhs_value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::thread::id master_id;</span><br><span class="line"></span><br><span class="line">Y a[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(this_thread::<span class="built_in">get_id</span>() == master_id) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]I am master!: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; (a[<span class="number">0</span>] == a[<span class="number">1</span>] ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]I am slaver: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class="line">            a[id].some_detail = <span class="built_in">rand</span>() % <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    a[<span class="number">0</span>].some_detail = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>].some_detail = <span class="number">2</span>;</span><br><span class="line">    <span class="function">thread <span class="title">master</span><span class="params">(process, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    master_id = master.<span class="built_in">get_id</span>();</span><br><span class="line">    cout &lt;&lt; master.<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    thread slaver[<span class="number">2</span>];</span><br><span class="line">    slaver[<span class="number">0</span>] = <span class="built_in">thread</span>(process, <span class="number">0</span>);</span><br><span class="line">    slaver[<span class="number">1</span>] = <span class="built_in">thread</span>(process, <span class="number">1</span>);</span><br><span class="line">    master.<span class="built_in">join</span>();</span><br><span class="line">    slaver[<span class="number">0</span>].<span class="built_in">join</span>();</span><br><span class="line">    slaver[<span class="number">1</span>].<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-3-subsititute-of-shared-data-protect"><a href="#3-3-subsititute-of-shared-data-protect" class="headerlink" title="3.3 subsititute of shared data protect"></a>3.3 subsititute of shared data protect</h3><h4 id="3-3-1-protect-initialization-process-of-data"><a href="#3-3-1-protect-initialization-process-of-data" class="headerlink" title="3.3.1 protect initialization process of data"></a>3.3.1 protect initialization process of data</h4><p>假设我们有一个共享源，构建代价很昂贵，他可能会打开一个数据库连接或分配出很多的资源。</p>
<p>Lazy Initialization 在单线程代码中很常见 —— 没一个操作都需要对源进行检查，了解数据是否被初始化，然后在其使用前决定，数据是否需要初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">some_resources</span>;</span><br><span class="line">std::shared_ptr&lt;some_resources&gt; resources_ptr;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!resources_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// lazy initialization</span></span><br><span class="line">        resources_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resources);</span><br><span class="line">    &#125;</span><br><span class="line">    resources_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多线程中，一种大粒度锁方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">some_resources</span>;</span><br><span class="line">std::shared_ptr&lt;some_resources&gt; resources_ptr;</span><br><span class="line">std::mutex resource_mutex;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(resource_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!resources_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        resources_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resources);</span><br><span class="line">    &#125;</span><br><span class="line">    resources_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声名狼藉的“双重检查锁模式”:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resources&gt; resources_ptr;</span><br><span class="line">std::mutex resource_mutex;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!resources_ptr)	<span class="comment">// 第一次检查</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在 if 与加锁之间，resources_ptr 可能被修改了</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(resource_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(!resources_ptr) <span class="comment">// 第二次检查</span></span><br><span class="line">        &#123;</span><br><span class="line">            resources_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resources); <span class="comment">// (1)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resources_ptr-&gt;<span class="built_in">do_something</span>(); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个模式声名狼藉的原因在于，存在潜在的条件竞争。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf">具体的可以参考这里</a></p>
</blockquote>
<p>论文太长，我粗略的看了一下，我们知道，new 是分为两步的：</p>
<ol>
<li>operator new(size_of_object)</li>
<li>ctor</li>
<li>assign</li>
</ol>
<p>文章给出代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Singleton *<span class="title">Singleton::instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pInstance == <span class="number">0</span>) &#123;</span><br><span class="line">        Lock lock;</span><br><span class="line">        <span class="keyword">if</span> (pInstance == <span class="number">0</span>) &#123;</span><br><span class="line">            pInstance =               <span class="comment">// Step 3</span></span><br><span class="line">            <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(Singleton)); <span class="comment">// Step 1</span></span><br><span class="line">            <span class="keyword">new</span> (pInstance) Singleton;    <span class="comment">// Step 2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文章的意思应该是，在 ctor 之前，对象还没被构建，此时指向它的指针为空，即使 ctor 完成了，我们还需要将其地址赋值给指向它的指针，而在ctor与assign之间，指针依然为空。</p>
<p>指针为空就意味着，第二次检查不一定是有效的，也即，仍然可能有多个线程进入 (1) 从而破坏数据，并且行为是未定义的！</p>
<hr>
<p>为了解决这种条件竞争，C++ 标准库提供了 <code>std::once_flag</code> 和 <code>std::call_once</code> ，并且使用 <code>std::call_one</code> 比使用互斥量消耗的资源更少。</p>
<blockquote>
<p><code>std::call_once</code> : 顾名思义，可以准确执行一次 callable object，其通过 <code>std::once_flag</code> 来判断是否被执行过，如果多次调用，会抛出异常。</p>
<p>call_one 分为:</p>
<ol>
<li>active call：第一次调用</li>
<li>passive call：后序调用</li>
<li>exceptional call：抛出异常的调用，不会修改 once_flag</li>
</ol>
</blockquote>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::once_flag flag1, flag2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simple_do_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(flag1, []()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Simple example: call one\n&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">may_throw_function</span><span class="params">(<span class="type">bool</span> do_throw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(do_throw)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;throw: call once will retry\n&quot;</span>;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Do no throw: call once will not attempt retry\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_once</span><span class="params">(<span class="type">bool</span> do_throw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">call_once</span>(flag2, may_throw_function, do_throw);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;get exception\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">st1</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">st2</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">st3</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">st4</span><span class="params">(simple_do_once)</span></span>;</span><br><span class="line">    st1.<span class="built_in">join</span>();</span><br><span class="line">    st2.<span class="built_in">join</span>();</span><br><span class="line">    st3.<span class="built_in">join</span>();</span><br><span class="line">    st4.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(do_once, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t4</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Foo</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此，可以将上面的例子修改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr;</span><br><span class="line">std::once_flag resource_flag;  <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_resource</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	resource_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::<span class="built_in">call_once</span>(resource_flag,init_resource); <span class="comment">// 可以完整的进行一次初始化</span></span><br><span class="line">	resource_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    std::once_flag flag;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;do once&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        std::<span class="built_in">call_once</span>(flag, &amp;X::do_once, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f2&quot;</span> &lt;&lt; endl;</span><br><span class="line">        std::<span class="built_in">call_once</span>(flag, &amp;X::do_once, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X x;</span><br><span class="line">    x.<span class="built_in">f1</span>();</span><br><span class="line">    x.<span class="built_in">f2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Foo</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1</span><br><span class="line">do once</span><br><span class="line">f2</span><br></pre></td></tr></table></figure>

<hr>
<p>局部 static 变量的线程安全的初始化方式（<code>std::call_once</code> 的替代方案）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span>;</span><br><span class="line"><span class="function">my_class&amp; <span class="title">get_my_class_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> my_class instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化和定义完全在一个线程中发生，并且没有其他线程可在初始化完成前对其进行处理。</p>
<p>其实这个就是例子设计模式(<strong>Singleton</strong>)的思路，让 static 变量在函数内部完成初始化，从而使得调用该对象时，该对象一定被初始化。</p>
<p>但是为什么呢？</p>
<p>其实主要是因为<strong>“C++只能保证在同一个文件中声明的static变量的初始化顺序与其变量声明的顺序一致。但是不能保证不同的文件中的static变量的初始化顺序。”</strong></p>
<p>然后对于单例模式而言，不同的单例对象之间进行调用也是常见的场景。比如我有一个单例，存储了程序启动时加载的配置文件的内容。另外有一个单例，掌管着一个全局的日志管理器。在日志管理初始化的时候，要通过配置文件的单例对象来获取到某个配置项，实现日志打印。</p>
<p>这时候两个单例在不同文件中各自实现，很有可能在日志管理器的单例使用配置文件单例的时候，配置文件的单例对象是没有被初始化的。这个未初始化可能产生的风险指的是C++变量的未初始化，而不是说配置文件未加载的之类业务逻辑上的未初始化导致的问题。</p>
<p>而<code>Meyers&#39; Singleton</code>写法中，单例对象是次访问的时候（也就是次调用<code>getInstance()</code>函数的时候）才初始化的，但也是恰恰因为如此，因而能保证如果没有初始化，在该函数调用的时候，是能完成初始化的。所以先<code>getInstance()</code>再访问 这种形式的单例 其关键并不是在于这个形式。而是在于其内容，局部static变量能保证通过函数来获取static变量的时候，该函数返回的对象是肯定完成了初始化的！</p>
<p>另外，该写法需要 C++11 的支持，因为在 C++11 之后，static 变量的初始化是线程安全的。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://z.itpub.net/article/detail/DC3250F681713244F01A546413CC2828">「详细信息参考这里—reference」</a></p>
</blockquote>
<h4 id="3-3-2-protect-data-struct-which-updatelessly"><a href="#3-3-2-protect-data-struct-which-updatelessly" class="headerlink" title="3.3.2 protect data struct which updatelessly"></a>3.3.2 protect data struct which updatelessly</h4><p>对于更新比较少，读取频繁的数据结构，使用 <code>std::mutex</code> 显得有些反应过激了，因为在没有修改时，它将削弱并发读取数据的可能性，因此，这里需要一种不同的互斥量 – 读写锁：一个“写”线程独立访问，多个 “读” 线程并发访问。</p>
<p>C++ 标准库暂时没有提供“读者-写者锁”，但是 Boost 库提供了支持 <code>boost::shared_lock</code> (读写锁)，通常用于读操作比较频繁的，而写操作比较少的情况。</p>
<p>读写锁比起mutex具有更高的适用性，具有更高的并行性，可以有多个线程同时占用读模式的读写锁，但是只能有一个线程占用写模式的读写锁，读写锁的基本规则可以总结为<strong>“write first，read shared，cross mutex(交叉互斥)”</strong>，具体表现为读写锁的三种状态：</p>
<ol>
<li>当读写锁是写加锁状态时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞。（交叉互斥）</li>
<li>当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是以写模式对它进行加锁的线程将会被阻塞。（读共享，交叉互斥）</li>
<li>当读写锁在读模式的锁状态时，如果有另外的线程试图以写模式加锁，读写锁通常会阻塞随后的读模式锁的请求，这样可以避免读模式锁长期占用，而等待的写模式锁请求则长期阻塞。（写优先）</li>
</ol>
<p>注：其实在读者-写者问题中，有读者优先和写者优先两种模式，只是在 <strong>shared_mutex which in boost library default complement in writing first</strong>，这其实也是有道理的，<strong>because we always want to read the least data</strong>，这就得保证写者优先。</p>
<p>例子：模拟 dns 缓存的修改和查询</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/thread/shared_mutex.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dns_entry</span></span><br><span class="line">&#123;</span><br><span class="line">    string domain;</span><br><span class="line">    string ip_addr;</span><br><span class="line">    <span class="comment">/*....*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dns_cache</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;std::string, dns_entry&gt; entries;   <span class="comment">// 缓存 dns 数据</span></span><br><span class="line">    <span class="keyword">mutable</span> boost::shared_mutex entry_mutex;    <span class="comment">// 对数据进行保护</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// from domin name to IP addr</span></span><br><span class="line">    <span class="function">dns_entry <span class="title">find_entry</span><span class="params">(<span class="type">const</span> std::string &amp;domain)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">boost::shared_lock&lt;boost::shared_mutex&gt; <span class="title">lk</span><span class="params">(entry_mutex)</span></span>; <span class="comment">// 加读锁</span></span><br><span class="line">        <span class="keyword">auto</span> it = entries.<span class="built_in">find</span>(domain);</span><br><span class="line">        <span class="keyword">return</span> (it == entries.<span class="built_in">end</span>()) ? <span class="built_in">dns_entry</span>() : it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update_or_addr_entry</span><span class="params">(<span class="type">const</span> std::string &amp;domain, <span class="type">const</span> dns_entry &amp;dns_details)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;boost::shared_mutex&gt; <span class="title">lock</span><span class="params">(entry_mutex)</span></span>; <span class="comment">// 加写锁</span></span><br><span class="line">        <span class="comment">// or add unique_lock&lt;boost::shared_mutex&gt;</span></span><br><span class="line">        entries[domain] = dns_details;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="3-3-3-nested-lock"><a href="#3-3-3-nested-lock" class="headerlink" title="3.3.3 nested lock"></a>3.3.3 nested lock</h4><p><code>std::recursive_mutex</code></p>
<h2 id="P4-synchronization"><a href="#P4-synchronization" class="headerlink" title="P4 synchronization"></a>P4 synchronization</h2><p>单单将数据保护起来并不能满足我们的需求。通常情况下，我们还想对单独的线程进行同步。例如，某个线程作为另一个线程的输入。</p>
<p>通过条件变量(<strong>condition variables</strong>)和期望(<strong>futures</strong>)实现线程之间的同步。</p>
<h3 id="4-1-wait-event-or-condition"><a href="#4-1-wait-event-or-condition" class="headerlink" title="4.1 wait event or condition"></a>4.1 wait event or condition</h3><h4 id="4-1-1-introduce"><a href="#4-1-1-introduce" class="headerlink" title="4.1.1 introduce"></a>4.1.1 introduce</h4><p>情景：我们需要等待一个事件。</p>
<p>最笨的方法是一直加锁，然后时间来临之后，处理事件，解锁。但是这种方法是很低效的，因为等待事件时我们持有锁但什么也不做。</p>
<p>进步的方法是下面这种（<code>std::this_thread::sleep_for()</code>），每隔一段时间就进行一次检查，但是这种方法的问题是，很难确定中间间隔的时间，太短或者太长了都不好！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex, std::mutex_guard</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/thread/shared_mutex.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag;</span><br><span class="line">std::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait_for_flag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(!flag)</span><br><span class="line">    &#123;</span><br><span class="line">        lk.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));    <span class="comment">// 100ms</span></span><br><span class="line">        lk.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">wait_for_flag</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好的办法就是使用条件变量，当时间发生时，广播“条件达成”的信息，由此出发等待该事件的线程。</p>
<h4 id="4-1-2-condition-variable"><a href="#4-1-2-condition-variable" class="headerlink" title="4.1.2 condition variable"></a>4.1.2 condition variable</h4><p>C++标准库对条件变量有两套实现：<code>std::condition_variable</code>和<code>std::condition_variable_any</code>。这两个实现都包含在<code>&lt;condition_variable&gt;</code>头文件的声明中。两者都需要与一个互斥量一起才能工作(互斥量是为了同步)；前者仅限于与<code>std::mutex</code>一起工作，而后者可以和任何满足最低标准的互斥量一起工作，从而加上了*_any*的后缀。因为<code>std::condition_variable_any</code>更加通用，这就可能从体积、性能，以及系统资源的使用方面产生额外的开销，所以<code>std::condition_variable</code>一般作为首选的类型，当对灵活性有硬性要求时，我们才会去考虑<code>std::condition_variable_any</code>。</p>
<p>下面是使用 <code>std::condition_variable</code> 处理等待数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">data_chunk</span> &#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">more_data_to_prepare</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> data_chunk&amp; <span class="title">prepare_data</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_last_chunk</span><span class="params">(<span class="type">const</span> data_chunk&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(data_chunk&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">std::mutex mut;</span><br><span class="line">std::queue&lt;data_chunk&gt; data_queue;</span><br><span class="line">std::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">more_data_to_prepare</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> data_chunk data = <span class="built_in">prepare_data</span>();</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(data);</span><br><span class="line">        data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">data_preocessing_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lock, []&#123; <span class="comment">// (1) 在这上锁 类似 try_lock</span></span><br><span class="line">            <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        data_chunk data = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        lock.<span class="built_in">unlock</span>();	<span class="comment">// (2) 记得解锁</span></span><br><span class="line">        <span class="built_in">process</span>(data);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">is_last_chunk</span>(data))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 (1) 中，如果条件不满足(<code>lambda</code> 返回 <code>false</code>)，<code>wait()</code> 函数将解锁互斥量，并将这个线程置于阻塞或等待状态。</p>
<p>当在 <code>data_preparation_thread</code> 中调用 <code>notify_one</code> 通知条件变量之后，处理数据的线程从睡眠状态中苏醒，重新获得互斥锁，并且对条件再次检查，当条件不满足时，线程将对互斥量解锁，并且重新开始等待，当条件满足时，从 <code>wait()</code> 返回并继续持有锁。</p>
<blockquote>
<p>注意在唤醒之后需要再次检查条件，因为可能还有其他线程也被唤醒，此时会有竞争。这就是所谓的**伪唤醒(spurious wakeup)**，</p>
</blockquote>
<p>这也是为甚么要使用 <code>std::unique_lock</code> 而不是 <code>std::lock_guard</code> 的原因 —— 等待中的线程必须在等待期间解锁互斥量，并在这之后对互斥量再次上锁，而 <code>std::lock_guard</code> 没有这么灵活。</p>
<blockquote>
<p>其实这也说明了 <code>std::unique_lock</code> 的主要用途 —— 和 <code>std::condition_variable</code> 配合使用，做到多次 <code>lock()</code> 和 <code>unlock()</code>。</p>
</blockquote>
<h4 id="4-1-3-thread-safety-queue"><a href="#4-1-3-thread-safety-queue" class="headerlink" title="4.1.3 thread safety queue"></a>4.1.3 thread safety queue</h4><p><code>std::queue</code> 接口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Container</span> = std::deque&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">queue</span>(<span class="type">const</span> Container&amp;);</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">queue</span><span class="params">(Container&amp;&amp; = Container())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="function"><span class="keyword">explicit</span> <span class="title">queue</span><span class="params">(<span class="type">const</span> Alloc&amp;)</span></span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="built_in">queue</span>(<span class="type">const</span> Container&amp;, <span class="type">const</span> Alloc&amp;);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="built_in">queue</span>(Container&amp;&amp;, <span class="type">const</span> Alloc&amp;);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="built_in">queue</span>(queue&amp;&amp;, <span class="type">const</span> Alloc&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(queue &amp;q)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T&amp;&amp; x)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt; <span class="type">void</span> <span class="title">emplace</span><span class="params">(Args&amp;&amp;... args)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>线程安全的队列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mut; <span class="comment">// 互斥量必须是可变的</span></span><br><span class="line">    std::queue&lt;T&gt; data_queue;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_queue</span>(<span class="type">const</span> threadsafe_queue&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;std::mutex&gt; <span class="title">my_lock</span><span class="params">(mut)</span></span>;    <span class="comment">// 为什么不对自己上锁呢？</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.mut)</span></span>;</span><br><span class="line">        data_queue = other.data_queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_queue</span>(threadsafe_queue&amp;&amp; other) <span class="comment">// 自己写的，可能有误？</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;std::mutex&gt; <span class="title">my_lock</span><span class="params">(mut)</span></span>;    <span class="comment">// 为什么不对自己上锁呢？</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.mut)</span></span>;</span><br><span class="line">        data_queue = <span class="built_in">move</span>(other.data_queue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    threadsafe_queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_queue&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(new_value);</span><br><span class="line">        data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T &amp;value)</span> <span class="comment">// 通过传引用获得 front 并 pop</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 防止 front-pop 接口之间存在的竞争条件</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = data_queue.<span class="built_in">front</span>(); <span class="comment">// get value</span></span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();    <span class="comment">// NULL</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        value = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        std::shared_ptr&lt;T&gt; res = (std::<span class="built_in">make_shared</span>&lt;T&gt;(data_queue.<span class="built_in">front</span>()));</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data_queue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line"></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同之前提到的一样，当我们执行 <code>front()-pop()</code> 时，会有接口之间的条件竞争，因此我们需要将这两个函数放到同一个函数中。</p>
<h3 id="4-2-future"><a href="#4-2-future" class="headerlink" title="4.2 future"></a>4.2 future</h3><h4 id="4-2-1-introdece"><a href="#4-2-1-introdece" class="headerlink" title="4.2.1 introdece"></a>4.2.1 introdece</h4><p>C++ 标准库模型将这种一次性事件成为**期望(future)**。当事件发生时，这个“期望”就不能被重置。</p>
<p>在C++标准库中，有两种“期望”，使用两种类型模板实现，声明在头文件中: 唯一<em>期望</em>(unique futures)(<code>std::future&lt;&gt;</code>)和<em>共享期望</em>(shared futures)(<code>std::shared_future&lt;&gt;</code>)。这是仿照<code>std::unique_ptr</code>和<code>std::shared_ptr</code>。<code>std::future</code>的实例只能与一个指定事件相关联，而<code>std::shared_future</code>的实例就能关联多个事件。后者的实现中，所有实例会在同时变为就绪状态，并且他们可以访问与事件相关的任何数据。这种数据关联与模板有关，比如<code>std::unique_ptr</code> 和<code>std::shared_ptr</code>的模板参数就是相关联的数据类型。在与数据无关的地方，可以使用<code>std::future&lt;void&gt;</code>与<code>std::shared_future&lt;void&gt;</code>的特化模板。虽然，我希望用于线程间的通讯，但是“期望”对象本身并不提供同步访问。当多个线程需要访问一个独立“期望”对象时，他们必须使用互斥量或类似同步机制对访问进行保护，如在第3章提到的那样。不过，在你将要阅读到的4.2.5节中，多个线程会对一个<code>std::shared_future&lt;&gt;</code>实例的副本进行访问，而不需要期望同步，即使他们是同一个异步结果。</p>
<p>最基本的一次性事件，就是一个后台运行出的计算结果。在第2章中，你已经了解了<code>std::thread</code> 执行的任务不能有返回值，并且我能保证，这个问题将在使用“期望”后解决——现在就来看看是怎么解决的。</p>
<h4 id="4-2-2-background-task-with-return-value-—-async"><a href="#4-2-2-background-task-with-return-value-—-async" class="headerlink" title="4.2.2 background task with return value — async"></a>4.2.2 background task with return value — async</h4><p>假设，你现在有一个需要长时间的运算，你需要能计算出一个有效的值，但是你现在并不迫切需要这个值。因为 <code>std::thread</code> 并不提供接受返回值的机制，这里就需要 <code>std::async</code> 函数模板（也就是在 <code>&lt;future&gt;</code> 中声明）</p>
<p>当不着急得到任务的结果时，你可以使用 <code>std::async</code> 启动一个<strong>异步</strong>任务，与 <code>std::thread</code> 对象等待的方式不同，<code>std::async</code> 会返回一个 <code>std::future</code> 对象，这个对象持有最终计算出来的结果，你只需要调用这个对象的 <code>get()</code> 成员函数；并且会阻塞线程直到“期望”状态未就绪为止。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_the_answer_to_ltuae</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; the_answer = std::<span class="built_in">async</span>(find_the_answer_to_ltuae);</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The answer is &quot;</span> &lt;&lt; the_answer.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>std::thread</code> 方式一样，<code>std::async</code> 允许通过添加额外的调用参数，想函数传递额外的参数。</p>
<p>例如，第一个参数是指向成员函数的指针，第二个参数是提供这个函数成员类的具体对象。</p>
<p>和 <code>std::thread</code> 一样，当参数是右值时，拷贝操作将使用移动的方式转移原始数据。</p>
<p>我们还可以在调用之前向 <code>std::async</code> 传递一个额外参数，这个参数的类型是 <code>std::launch</code>，它提供了两种策略可供选择：</p>
<ul>
<li><code>std::launch::async</code> ：在调用 <code>std::async</code> 之后就开始创建线程</li>
<li><code>std::launch::deferred</code> ： 延迟加载方式创建线程。调用 <code>std::async</code> 不创建线程，直到调用了 <code>future</code> 的 <code>get()</code> 或者 <code>wait()</code> 时才创建线程。（<strong>lazy calculate</strong>）</li>
</ul>
<p>默认策略是 <code>std::launch::async | std::launch::deferred</code></p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> std::string&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        i ++ ;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;] id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">bar</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;] id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f1 和 f2 可能在 main 结束之后才执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过指向 x 的指针调用 foo</span></span><br><span class="line"><span class="keyword">auto</span> f1 = std::<span class="built_in">async</span>(&amp;X::foo, &amp;x, <span class="number">42</span>, <span class="string">&quot;f1&quot;</span>);</span><br><span class="line"><span class="comment">// 通过 x 的拷贝调用 bar</span></span><br><span class="line"><span class="keyword">auto</span> f2 = std::<span class="built_in">async</span>(&amp;X::bar, x, <span class="string">&quot;f2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=============================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; d &lt;&lt; std::endl;</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;] id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 y 的移动构造函数调用 operator()</span></span><br><span class="line"><span class="keyword">auto</span> f3 = std::<span class="built_in">async</span>(<span class="built_in">Y</span>(), <span class="string">&quot;f3&quot;</span>);</span><br><span class="line"><span class="comment">// 通过 y 的引用调用 operator()</span></span><br><span class="line"><span class="keyword">auto</span> f4 = std::<span class="built_in">async</span>(std::<span class="built_in">ref</span>(y), <span class="string">&quot;f4&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=============================================*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">move_only</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">move_only</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">move_only</span>(move_only&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">move_only</span>(<span class="type">const</span> move_only&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    move_only&amp; <span class="keyword">operator</span>=(move_only&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    move_only&amp; <span class="keyword">operator</span>=(<span class="type">const</span> move_only&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string s)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;] id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move only!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f5 = std::<span class="built_in">async</span>(<span class="built_in">move_only</span>(), <span class="string">&quot;f5&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=============================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在新线程上执行</span></span><br><span class="line"><span class="keyword">auto</span> f6 = std::<span class="built_in">async</span>(std::launch::async, <span class="built_in">Y</span>(), <span class="string">&quot;f6&quot;</span>);</span><br><span class="line"><span class="comment">// 在 wait() 或 get() 调用时执行</span></span><br><span class="line"><span class="keyword">auto</span> f7 = std::<span class="built_in">async</span>(std::launch::deferred, &amp;X::bar, std::<span class="built_in">ref</span>(x), <span class="string">&quot;f7&quot;</span>);</span><br><span class="line"><span class="comment">// 实现选择执行方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std::string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;] id: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> f8 = std::<span class="built_in">async</span>(std::launch::deferred | std::launch::async, f, <span class="string">&quot;f8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="comment">// f7.wait();</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; hex &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// f8.get();</span></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::future</code> 有三种状态：</p>
<ul>
<li><code>future_status::deferred</code>：异步操作还未完成</li>
<li><code>future_status::ready</code> ：异步操作已经完成</li>
<li><code>future_status::timeout</code> ：异步操作超时，主要用于 <code>std::future&lt;T&gt;.wait_for()</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;step1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;step2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;step3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    std::future_status status;</span><br><span class="line">    <span class="keyword">auto</span> f = std::<span class="built_in">async</span>(std::launch::deferred ,process);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        status = f.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(status == std::future_status::deferred) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;deferred&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// f.wait();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(status == std::future_status::timeout) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;timeout&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(status == std::future_status::ready) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;ready&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(status != std::future_status::ready);</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039083151">reference</a></p>
</blockquote>
<h4 id="4-2-3-task-and-future"><a href="#4-2-3-task-and-future" class="headerlink" title="4.2.3 task and future"></a>4.2.3 task and future</h4><p><code>std::packaged_task&lt;&gt;</code> 会将 <code>future</code> 与函数或可调用对象进行绑定。当调用 <code>package_task&lt;&gt;</code> 时，就会调用相关函数或可调用对象，当 <code>future</code> 状态未就绪时，会存储返回值。</p>
<p><code>std::packaged_task&lt;&gt;</code> 的模板参数是一个函数签名。我们传入对象的签名可以与模板参数中指定的签名不一致，但是必须能隐式转换到目标类型。</p>
<p>例如，一种便特化的 <code>packaged_task</code> 的意义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">packaged_task</span>&lt;std::<span class="built_in">string</span>(std::vector&lt;<span class="type">char</span>*&gt;, <span class="type">int</span>)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">packaged_task</span><span class="params">(Callable &amp;&amp;f)</span></span>;</span><br><span class="line">    <span class="function">std::future&lt;std::string&gt; <span class="title">get_future</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::vector&lt;<span class="type">char</span>*&gt;, <span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>std::packaged_task</code> 是一个可调用对象，可以封装在 <code>std::function</code> 对象中，从而作为汉城函数传递到 <code>std::thread</code> 对象中，或作为可调用物对象传递到另一个函数中或直接调用。</p>
<p>例子1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line">std::mutex m;</span><br><span class="line">std::deque&lt;std::packaged_task&lt;<span class="type">void</span>()&gt; &gt; tasks;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">gui_shutdown_message_received</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_and_process_gui_message</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gui_thread</span><span class="params">()</span>  <span class="comment">// 1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">gui_shutdown_message_received</span>())  <span class="comment">// 2</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">get_and_process_gui_message</span>();  <span class="comment">// 3</span></span><br><span class="line">    std::packaged_task&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">      <span class="keyword">if</span>(tasks.<span class="built_in">empty</span>())  <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      task=std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());  <span class="comment">// 5</span></span><br><span class="line">      tasks.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">task</span>();  <span class="comment">// 6</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">gui_bg_thread</span><span class="params">(gui_thread)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function">std::future&lt;<span class="type">void</span>&gt; <span class="title">post_task_for_gui_thread</span><span class="params">(Func f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::packaged_task&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(f)</span></span>;  <span class="comment">// 7</span></span><br><span class="line">  std::future&lt;<span class="type">void</span>&gt; res=task.<span class="built_in">get_future</span>();  <span class="comment">// 8</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;  <span class="comment">// 9</span></span><br><span class="line">  tasks.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(task));  <span class="comment">// 10</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c++ reference 上的例子 2：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task_lambda</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">([](<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">return</span> a + b;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; res = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="built_in">task</span>(<span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;task_lambda: &quot;</span> &lt;&lt; res.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task_bind</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意下面packaged_task的函数签名对应的参数要与bind对应 </span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(std::bind(my_add, <span class="number">2</span>, <span class="number">11</span>))</span></span>;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; res = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="built_in">task</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;task_bind: &quot;</span> &lt;&lt; res.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(my_add)</span></span>;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; res = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="comment">// move 到线程当中</span></span><br><span class="line">    <span class="function">std::thread <span class="title">task_td</span><span class="params">(std::move(task), <span class="number">2</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">    task_td.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;task_thread: &quot;</span> &lt;&lt; res.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">task_lambda</span>();</span><br><span class="line">    <span class="built_in">task_lambda</span>();</span><br><span class="line">    <span class="built_in">task_thread</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释一下：<code>std::future&lt;int&gt; result = task.get_future();</code> 这条语句并不会导致 <code>task</code> 封装的可调用对象的执行，它仅仅是将 <code>task</code> 的返回值存储到 <code>result</code> 这个对象当中。</p>
<blockquote>
<p>参考： </p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/611029683">Zhihu</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/thread/packaged_task">Cpp-reference</a></p>
</blockquote>
<h4 id="4-2-4-std-promises"><a href="#4-2-4-std-promises" class="headerlink" title="4.2.4 std::promises"></a>4.2.4 std::promises</h4><p>cppreference 例1:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">accumulate</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;::iterator first, std::vector&lt;<span class="type">int</span>&gt;::iterator last, </span></span></span><br><span class="line"><span class="params"><span class="function">                std::promise&lt;<span class="type">int</span>&gt; accumulate_promise)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = std::<span class="built_in">accumulate</span>(first, last, <span class="number">0</span>);</span><br><span class="line">    accumulate_promise.<span class="built_in">set_value</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_work</span><span class="params">(std::promise&lt;<span class="type">void</span>&gt; barrier)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    barrier.<span class="built_in">set_value</span>(); <span class="comment">// 注释掉改行不会阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; accumulate_promise;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; accumulate_future = accumulate_promise.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="comment">// 加上 :: ，防止识别为 std::accumulate</span></span><br><span class="line">    <span class="function">std::thread <span class="title">work_thread</span><span class="params">(::accumulate, numbers.begin(), numbers.end(), std::move(accumulate_promise))</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// future::get() 将等待直至该 future 拥有合法结果并取得它</span></span><br><span class="line">    <span class="comment">// 无需在 get() 前调用 wait()</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; accumulate_future.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    work_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 primise&lt;void&gt; 在线程间对状态发信号</span></span><br><span class="line">    std::promise&lt;<span class="type">void</span>&gt; barrier;</span><br><span class="line">    std::future&lt;<span class="type">void</span>&gt; barrier_future = barrier.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">new_work_thread</span><span class="params">(do_work, std::move(barrier))</span></span>;</span><br><span class="line">    barrier_future.<span class="built_in">wait</span>();</span><br><span class="line">    new_work_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例2: 线程等待另一个线程的数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promise = std::<span class="built_in">promise</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> t1 = std::<span class="built_in">thread</span>([&amp;promise]&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread running\n&quot;</span>;</span><br><span class="line">        <span class="comment">// do something ~</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// write data and invoke the threads which are waiting for that</span></span><br><span class="line">        promise.<span class="built_in">set_value</span>(<span class="number">42</span>);	<span class="comment">// 注释掉改行会阻塞</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread end\n&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// block until get value</span></span><br><span class="line">    cout &lt;&lt; promise.<span class="built_in">get_future</span>().<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>[TODO]</strong></p>
<p>在这里我发现了一个神奇的事情，如果是按照上面的形式（例2）即，lambda 表达式的形式创建线程，如果不 set_value() 的话，future::wait() 会一直等待，而使用显式的函数则不会（例1），为什么呢？</p>
</blockquote>
<blockquote>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6300e02d0625#">JianShu</a></p>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/promise">Cpp-reference</a></p>
</blockquote>
<h4 id="4-2-5-exception-and-future"><a href="#4-2-5-exception-and-future" class="headerlink" title="4.2.5 exception and future"></a>4.2.5 exception and future</h4><p>如果我们抛出一个异常，那么这个异常会存储到 <code>future</code> 中，然后 <code>future</code> 的状态设置为 <code>ready</code>，之后调用 <code>get()</code> 会抛出已存储的异常。</p>
<blockquote>
<p>注意！标准并未规定重新抛出的这个异常是原对象还是一份拷贝，这取决于山西i安</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">my_sqrt</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;out of range ^ ^\n&quot;</span>;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;x &lt; 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将 promise 与 future 绑定起来</span></span><br><span class="line">    std::promise&lt;<span class="type">double</span>&gt; promise;</span><br><span class="line">    std::future&lt;<span class="type">double</span>&gt; future = promise.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;pls input a number: &quot;</span>;</span><br><span class="line">        <span class="type">double</span> x;       </span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        promise.<span class="built_in">set_value</span>(<span class="built_in">my_sqrt</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(<span class="type">const</span> exception &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// promise.set_exception(current_exception());</span></span><br><span class="line">        promise.<span class="built_in">set_exception</span>(std::<span class="built_in">make_exception_ptr</span>(<span class="built_in">logic_error</span>(<span class="string">&quot;sqrt() error ^ ^&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; future.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="4-2-6-waiting-of-multiple-thread"><a href="#4-2-6-waiting-of-multiple-thread" class="headerlink" title="4.2.6 waiting of multiple thread"></a>4.2.6 waiting of multiple thread</h4><p>如果并行代码没办法让多个线程等待同一个事件， <code>std::shared_future </code>可以帮你解决这个问题。因为<code>future</code>是只 <strong>move</strong> 的，所以其所有权可以在不同的实例中互相传递，但只有一个实例可以获得特定的同步结果，而 <code>std::shared_future</code>实例是可 <strong>copy</strong> 的，所以多个对象可以引用同一关联期望值的结果。</p>
<p>例: std::shared_future</p>
<p><code>std::shared_future</code> 顾名思义，就是多个线程共享一个 <code>std::shared_future</code>。可用在一个线程传递数据给多个线程的时候，多个线程在自身的线程空间内通过 <code>std::shared_future</code> 共享一个 <code>future</code>，这是线程安全的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line">    <span class="keyword">auto</span> promise = std::<span class="built_in">promise</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> t1 = std::<span class="built_in">thread</span>([&amp;promise]&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread 1 running\n&quot;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">4</span>));</span><br><span class="line">        <span class="comment">// 写入数据，这回唤醒那些正在等待数据的线程</span></span><br><span class="line">        promise.<span class="built_in">set_value</span>(<span class="number">42</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread 1 end\n&quot;</span>; </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> shared_future = std::<span class="built_in">shared_future</span>&lt;<span class="type">int</span>&gt;(promise.<span class="built_in">get_future</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> t2 = std::<span class="built_in">thread</span>([shared_future]&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread 2 running\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取数据，如果数据还没准备好就会阻塞</span></span><br><span class="line">        <span class="comment">// 这里使用 std::printf 而不是 std::cout 是为了保证输出在同一行</span></span><br><span class="line">        std::<span class="built_in">printf</span>(<span class="string">&quot;thread: 2 %d\n&quot;</span>, shared_future.<span class="built_in">get</span>());</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread 2 end\n&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::<span class="built_in">printf</span>(<span class="string">&quot;Test: %d\n&quot;</span>, shared_future.<span class="built_in">get</span>());</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>std::shared_future::get</code> 可以无限次调用，而 <code>std::future::get</code> 仅能调用一次。</p>
<p><code>std::shared_future::get</code> 返回的一定是引用（模板参数是 <code>void</code> 的除外）</p>
</blockquote>
<p>在每一个<code>std::shared_future</code>的独立对象上成员函数调用返回的结果还是不同步的，所以为了在多个线程访问一个独立对象时，避免数据竞争，必须使用锁来对访问进行保护。优先使用的办法：为了替代只有一个拷贝对象的情况，可以让每个线程都拥有自己对应的拷贝对象。这样，当每个线程都通过自己拥有的<code>std::shared_future</code>对象获取结果，那么多个线程访问共享同步结果就是安全的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line">    <span class="comment">// 注意 promise 只能 set 一次</span></span><br><span class="line">    <span class="keyword">auto</span> promise = std::<span class="built_in">promise</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="keyword">auto</span> shared_future = std::<span class="built_in">shared_future</span>&lt;<span class="type">int</span>&gt;(promise.<span class="built_in">get_future</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;promise, shared_future](<span class="type">int</span> x)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; running\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(x)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; shared_future.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            promise.<span class="built_in">set_value</span>(x);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; end\n&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = std::<span class="built_in">thread</span>(f, i);</span><br><span class="line">        threads.<span class="built_in">push_back</span>(<span class="built_in">move</span>(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">printf</span>(<span class="string">&quot;Test: %d\n&quot;</span>, shared_future.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t : threads)  t.<span class="built_in">join</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-time-limited-wait"><a href="#4-3-time-limited-wait" class="headerlink" title="4.3 time limited wait"></a>4.3 time limited wait</h3><h4 id="4-3-1-introduce"><a href="#4-3-1-introduce" class="headerlink" title="4.3.1 introduce"></a>4.3.1 introduce</h4><p>Sometimes, it is needed to limited the wating time of the wait thread.</p>
<p>There are two ways to signated if timeout:</p>
<ol>
<li>time duration(relative): you are expected to signated a duration of time like: 30s</li>
<li>time point(absolute): you are expected to signated a concrete  time like: <code>[UTC] 17:40:15.034583458</code>, <code>2011-11-30</code></li>
</ol>
<p>The variable which used for relative time  suffixed by <code>_for</code>, and other used for absolute time suffixed by <code>_until</code></p>
<p>Before observe the usage of timeout funtion, let’s check the way to signated the time in C++</p>
<h4 id="4-3-2-clock"><a href="#4-3-2-clock" class="headerlink" title="4.3.2 clock"></a>4.3.2 clock</h4><p><code>#include &lt;chrono&gt;</code></p>
<p>对于 C++ 来说，时钟就是时间信息源。并且，时钟是一个 <code>class</code>，提供了四种不同的信息：</p>
<ol>
<li>当前时间：<code>std::chrono::system_clock::now()</code> 会返回系统的当前时间，它属于 <code>time point</code>.</li>
<li>时间类型</li>
<li>时钟节拍：<code>std::chrono::high_resolution_clock</code> 可能是标准库中提供的具有最小节拍周期（因此具有最高的精度）的时钟。</li>
<li>稳定时钟：<code>std::chrono::steady_clock</code></li>
</ol>
<h4 id="4-3-3-ratio"><a href="#4-3-3-ratio" class="headerlink" title="4.3.3 ratio"></a>4.3.3 ratio</h4><p>先介绍一下 <code>std::ratio</code>，他定义在 <code>&lt;ratio&gt;</code> 头文件当中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">intmax_t</span> N, <span class="type">intmax_t</span> D = <span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">class</span> ratio &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> ratio&lt;num, den&gt; type;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">intmax_t</span> num;  <span class="comment">// 分子</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">intmax_t</span> den;  <span class="comment">// 分母</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>具体的可以参考 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/header/ratio">cppreference</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span> <span class="comment">// !</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="keyword">using</span> two_third = std::ratio&lt;<span class="number">2</span>, <span class="number">3</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> one_six   = std::ratio&lt;<span class="number">1</span>, <span class="number">6</span>&gt;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">using</span> sum = std::ratio_add&lt;two_third, one_six&gt;;</span><br><span class="line">    <span class="comment">// exppect print 5/6</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2/3 + 1/6 = &quot;</span> &lt;&lt; sum::num &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; sum::den &lt;&lt; endl;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-4-literal"><a href="#4-3-4-literal" class="headerlink" title="4.3.4 literal"></a>4.3.4 literal</h4><p>在 C++14 中的 <code>namespace std::chrono_literals</code> 中预定义了许多后缀操作符用来表示时长中的常用单位来简化代码。同样，还用用于表示字符串的 <code>namespace std::string_literals</code> 等。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// d 和 y 是 C++20 提供的</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> string_literals;</span><br><span class="line">    <span class="keyword">auto</span> one_day = <span class="number">24</span>h;</span><br><span class="line">    <span class="keyword">auto</span> half_an_hour = <span class="number">30</span>min;</span><br><span class="line">    <span class="keyword">auto</span> half_a_minuter = <span class="number">30</span>s;</span><br><span class="line">    <span class="comment">// 不常用的还有 ms（微秒）, us（微秒）, nm（纳秒）, </span></span><br><span class="line">    <span class="comment">// 1s = 1e3ms(毫秒) = 1e6us(微秒) = 1e9ns(纳秒) = 1e12ps(皮秒)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// auto 的类型是：</span></span><br><span class="line">    std::chrono::milliseconds ms = <span class="number">1</span>s;</span><br><span class="line">    cout &lt;&lt; ms.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> chrono_literals;</span><br><span class="line">    string s = <span class="string">&quot;hello&quot;</span>s; <span class="comment">// suffix by x</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test1</span>();</span><br><span class="line">    <span class="built_in">Test2</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-5-time-duration"><a href="#4-3-5-time-duration" class="headerlink" title="4.3.5 time duration"></a>4.3.5 time duration</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span> = std::ratio&lt;<span class="number">1</span>&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> duration;</span><br><span class="line"><span class="comment">// Rep: 表示计数的算数类型</span></span><br><span class="line"><span class="comment">// Period：表示计次周期的 std::ratio(即每秒的次数)</span></span><br></pre></td></tr></table></figure>

<p>通俗来讲，<code>Period</code> 指定的是 <code>duration</code> 的单位，默认是 <code>1s</code>,例如，如果 <code>Period</code> 指定的是 <code>ratio&lt;3600,1&gt;</code> ，那么单位就相当于 <code>h</code>，那么 <code>10</code> 个 <code>duration</code> 就是 <code>10h</code><br><code>Rep</code> 参数指定了传入的时间单位的类型，可以为 <code>float</code>, <code>int</code>, <code>int64</code> 等，如果为 <code>float</code> 则可以表示传入时间单位的“一部分”，比如传入 <code>1.2</code> 表示 <code>1.2</code> 倍个时间单位。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::chrono::duration;</span><br><span class="line">    <span class="keyword">using</span> std::chrono::duration_cast;</span><br><span class="line">    <span class="keyword">using</span> std::ratio;</span><br><span class="line"> </span><br><span class="line">    duration&lt;<span class="type">long</span> <span class="type">long</span>, ratio&lt;<span class="number">1</span>, <span class="number">1</span>&gt;&gt; tick_s&#123;<span class="number">15</span>&#125;; <span class="comment">// 15s</span></span><br><span class="line">    duration&lt;<span class="type">long</span> <span class="type">long</span>, ratio&lt;<span class="number">1</span>, <span class="number">1000</span>&gt;&gt; tick_ms&#123;<span class="number">15</span>&#125;; <span class="comment">// 1500ms</span></span><br><span class="line">    duration&lt;<span class="type">long</span> <span class="type">long</span>, ratio&lt;<span class="number">60</span>&gt;&gt; tick_min&#123;<span class="number">15</span>&#125;; <span class="comment">// 15min</span></span><br><span class="line">    duration&lt;<span class="type">float</span>, ratio&lt;<span class="number">3600</span>&gt;&gt; tick_h&#123;<span class="number">1.5</span>&#125;; <span class="comment">// 1.5h</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// count()方法可以返回我们设置的数值</span></span><br><span class="line">    cout &lt;&lt; tick_h.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;h&quot;</span> &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; tick_min.<span class="built_in">count</span>() &lt;&lt;  <span class="string">&quot;min&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// duration_cast </span></span><br><span class="line">    <span class="keyword">auto</span> min = <span class="built_in">duration_cast</span>&lt;std::chrono::minutes&gt;(tick_h);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1.5h = &quot;</span> &lt;&lt; min.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;min&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以隐式类型转换</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;15min = &quot;</span> &lt;&lt; chrono::<span class="built_in">seconds</span>(tick_min).<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以自定义转换类型</span></span><br><span class="line">    <span class="keyword">using</span> _day = duration&lt;<span class="type">double</span>, ratio&lt;<span class="number">24</span> * <span class="number">3600</span>&gt;&gt;;</span><br><span class="line">    <span class="keyword">auto</span> hour = duration&lt;<span class="type">long</span> <span class="type">long</span>, ratio&lt;<span class="number">3600</span>&gt;&gt;&#123;<span class="number">8</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;8h = &quot;</span> &lt;&lt; <span class="built_in">duration_cast</span>&lt;_day&gt;(hour).<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;day&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// duration 还可以支持算数运算和比较运算</span></span><br><span class="line">    <span class="comment">// 这里就不展示了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>例如：等待 <code>future</code> 状态变为就绪需要 35ms</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">task</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">40</span>ms);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f = std::<span class="built_in">async</span>(task);</span><br><span class="line">    <span class="keyword">if</span>(f.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">35</span>ms)) == std::future_status::ready)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ready&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;deferred&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-3-4-time-point"><a href="#4-3-4-time-point" class="headerlink" title="4.3.4 time point"></a>4.3.4 time point</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span> = <span class="keyword">typename</span> Clock::duration&gt;</span><br><span class="line"><span class="keyword">class</span> time_point;</span><br><span class="line"><span class="comment">// time_point 表示时间中的一个点</span></span><br><span class="line"><span class="comment">// Clock 表示时钟的类型</span></span><br><span class="line"><span class="comment">// Duration 存储一个自 Clock 的纪元起开始的时间间隔</span></span><br><span class="line"><span class="comment">// Unix 的纪元为 1970/1/1/00/00/00（epoch）</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slow_motion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">do</span>&#123;&#125; <span class="comment">// 生成 12! 个排列</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(a, a + <span class="number">12</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Test 1 */</span></span><br><span class="line">    <span class="type">const</span> time_point&lt;system_clock&gt; now = system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">time_t</span> t_c = system_clock::<span class="built_in">to_time_t</span>(now - <span class="number">24</span>h);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;24 hour ago, the time was &quot;</span> &lt;&lt; <span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;t_c), <span class="string">&quot;%F %T.\n&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Test 2 */</span></span><br><span class="line">    <span class="type">const</span> time_point&lt;steady_clock&gt; start = steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">slow_motion</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> end = steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Slow calculation took &quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(end - start).<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;us = &quot;</span></span><br><span class="line">         &lt;&lt; (end - start) / <span class="number">1</span>ms &lt;&lt; <span class="string">&quot;ms = &quot;</span></span><br><span class="line">         &lt;&lt; (end - start) / <span class="number">1</span>s &lt;&lt; <span class="string">&quot;s.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例2: 等待条件变量满足条件 —— 有超时功能</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> chrono_literals;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> done;</span><br><span class="line">std::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait_loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wait_loop running\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(<span class="number">100</span>ms);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wait loop sleep done.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> timeout = <span class="comment">// now + xms</span></span><br><span class="line">        std::chrono::steady_clock::<span class="built_in">now</span>() </span><br><span class="line">        + std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>);   </span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(!done)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cv.<span class="built_in">wait_until</span>(lock, timeout) == std::cv_status::timeout)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;timeout.\n&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do something or done = true</span></span><br><span class="line">        <span class="comment">// done = true;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wait_loop end\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread running.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(<span class="number">1000</span>ms);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread sleep done.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;thread end.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function">thread <span class="title">tl</span><span class="params">(wait_loop)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(signal)</span></span>;</span><br><span class="line">    tl.<span class="built_in">join</span>();</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">if</span>(done)    cout &lt;&lt; <span class="string">&quot;done.\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-3-5-use-timeout"><a href="#4-3-5-use-timeout" class="headerlink" title="4.3.5 use timeout"></a>4.3.5 use timeout</h4><p>使用超时机制的函数</p>
<table>
<thead>
<tr>
<th>类型&#x2F;命名空间</th>
<th>函数</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>std::this_thread[namespace]</td>
<td>sleep_for(duration)</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>sleep_until(time_point)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>std::condition_variable 或 std::condition_variable_any</td>
<td>wait_for(lock, duration)</td>
<td>std::cv_status::time_out 或 std::cv_status::no_timeout</td>
</tr>
<tr>
<td>wait_until(lock, time_point)</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>wait_for(lock, duration, predicate)</td>
<td>bool —— 当唤醒时，返回谓词的结果</td>
</tr>
<tr>
<td>wait_until(lock, duration, predicate)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>std::timed_mutex 或 std::recursive_timed_mutex</td>
<td>try_lock_for(duration)</td>
<td>bool —— 获取锁时返回true，否则返回fasle</td>
</tr>
<tr>
<td>try_lock_until(time_point)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>std::unique_lock<TimedLockable></td>
<td>unique_lock(lockable, duration)</td>
<td>N&#x2F;A —— 对新构建的对象调用owns_lock();</td>
</tr>
<tr>
<td>unique_lock(lockable, time_point)</td>
<td>当获取锁时返回true，否则返回false</td>
<td></td>
</tr>
<tr>
<td></td>
<td>try_lock_for(duration)</td>
<td>bool —— 当获取锁时返回true，否则返回false</td>
</tr>
<tr>
<td>try_lock_until(time_point)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>std::future<ValueType>或std::shared_future<ValueType></td>
<td>wait_for(duration)</td>
<td>当等待超时，返回std::future_status::timeout</td>
</tr>
<tr>
<td>wait_until(time_point)</td>
<td>当“期望”准备就绪时，返回std::future_status::ready</td>
<td></td>
</tr>
<tr>
<td>当“期望”持有一个为启动的延迟函数，返回std::future_status::deferred</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>现在，我们讨论的机制有：<strong>condition variable</strong>、“<strong>future</strong>”、“<strong>promise</strong>”还有 <strong>packaged_task</strong>。是时候从更高的角度去看待这些机制，怎么样使用这些机制，简化线程的同步操作。</p>
<h3 id="4-4-simplify-code"><a href="#4-4-simplify-code" class="headerlink" title="4.4 simplify code"></a>4.4 simplify code</h3><p>同步工具在本章成为“构建块”。</p>
<p>比起在多个线程间共享数据，每个任务最好拥有自己的数据，并且其他线程可以通过使用 <code>future</code> 获取运行结果。</p>
<h4 id="4-4-1-funtional-programming-by-future"><a href="#4-4-1-funtional-programming-by-future" class="headerlink" title="4.4.1 funtional programming by future"></a>4.4.1 funtional programming by future</h4><blockquote>
<p><strong>functional programming(FP)</strong> is a programming way which the function_return_value only depend on the arguments and you will get the same result always if you pass the same arguments</p>
</blockquote>
<p>串形版针对 <code>list</code> 的 <code>qsort</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">std::list&lt;T&gt; <span class="title">sequential_quick_sort</span><span class="params">(std::list&lt;T&gt; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(input.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">    std::list&lt;T&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::list::splice 实现将元素从一个list转移到另一个list</span></span><br><span class="line">    <span class="comment">// 并且仅仅通过 pointer move 实现，而不 copy or move elements</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// splice(const_iterator pos, list &amp;other, const_iterator it)</span></span><br><span class="line">    <span class="comment">// 从 other 转移 it 所指向的元素到 [*this](calleer) 当中，元素被插入到 pos 所指向的元素之前</span></span><br><span class="line">    <span class="comment">// 即，将 input 的第一个元素转移到 reesult 的 begin 之前</span></span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(), input, input.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="comment">// 选取一个“中间元素”</span></span><br><span class="line">    <span class="type">const</span> T&amp; pivot = *result.<span class="built_in">begin</span>();   <span class="comment">// pivot: 枢纽</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// paration 返回第一个不满足条件的元素的迭代器，正好是开区间</span></span><br><span class="line">    <span class="comment">// 方便 [) 的设计</span></span><br><span class="line">    <span class="comment">// 根据“中间元素”划分为左右去见</span></span><br><span class="line">    <span class="keyword">auto</span> divide_point = std::<span class="built_in">partition</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(),</span><br><span class="line">        [&amp;](<span class="type">const</span> T&amp; t)&#123;<span class="keyword">return</span> t &lt; pivot;&#125; <span class="comment">// 以 t&lt;pivot 划分元素，input左侧都是小于pivot，右侧大于pivot</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    std::list&lt;T&gt; lower_part;</span><br><span class="line">    lower_part.<span class="built_in">splice</span>(lower_part.<span class="built_in">end</span>(), input, input.<span class="built_in">begin</span>(), divide_point);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursion</span></span><br><span class="line">    <span class="comment">// 分别对左右区间的元素递归sort</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">new_lower</span><span class="params">(sequential_quick_sort(std::move(lower_part)))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">new_higher</span><span class="params">(sequential_quick_sort(std::move(input)))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// left, middle(privot), right</span></span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">end</span>(), new_higher);</span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(), new_lower);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; l&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    l = <span class="built_in">sequential_quick_sort</span>(l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;val : l)</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>qsort —— FP pattern with thread strongthen（并行版本）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">parallel_quick_sort</span><span class="params">(std::list&lt;T&gt; input)</span> -&gt; <span class="keyword">auto</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(input.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    </span><br><span class="line">    std::list&lt;T&gt; result;</span><br><span class="line">    </span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(), input, input.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="type">const</span> T&amp; pivot = *result.<span class="built_in">begin</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> divide_point = std::<span class="built_in">partition</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), </span><br><span class="line">        [&amp;](<span class="type">const</span> T&amp; t)&#123;</span><br><span class="line">            <span class="keyword">return</span> t &lt; pivot;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::list&lt;T&gt; lower_part;</span><br><span class="line">    lower_part.<span class="built_in">splice</span>(lower_part.<span class="built_in">end</span>(), input, </span><br><span class="line">        input.<span class="built_in">begin</span>(), divide_point);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的线程进行排序</span></span><br><span class="line">    std::future&lt;std::list&lt;T&gt;&gt; <span class="built_in">new_lower</span>(</span><br><span class="line">        std::<span class="built_in">async</span>(&amp;parallel_quick_sort&lt;T&gt;, std::<span class="built_in">move</span>(lower_part))</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 在当前线程中执行，无需一个新的线程</span></span><br><span class="line">    <span class="keyword">auto</span> new_higher = (</span><br><span class="line">        <span class="built_in">parallel_quick_sort</span>(std::<span class="built_in">move</span>(input))</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">end</span>(), new_higher);;</span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(), new_lower.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; l&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    l = <span class="built_in">parallel_quick_sort</span>(l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;val : l)</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，每调用一次 <code>parallel_quich_sort</code>，我们便创建一个新的线程，由于递归执行的缘故，线程的创建是指数级别的，也就是说，如果递归执行 10 次，那么就会创建 1024 个线程！但创建太多线程显然是不好的，因此 <code>async()</code> 会自动执行某些操作，避免创建太多线程。这也符合 <code>async()</code> 的策略（既可立马创建新线程，也可以以延迟加载的方式创建线程）。</p>
<p>其实，如果 <code>async()</code> 以延迟加载的方式执行，也就是直到在 <code>std::async()</code> 返回的 <code>future</code> 对象调用 <code>get()</code> 或者 <code>wait()</code> 时才执行。</p>
<p>然鹅，当调用 <code>get/wait</code> 时，函数会同步执行，即调用者会阻塞直到函数运行结束，如果 <code>get/wait</code> 没有被调用，函数就绝对不会执行。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039083151">ref here</a></p>
</blockquote>
<p>比起使用<code>std::async()</code>，你可以写一个spawn_task()函数对<code>std::packaged_task</code>和<code>std::thread</code>做简单的包装，如下面代码所示；你需要为函数结果创建一个<code>std::packaged_task</code>对象， 可以从这个对象中获取“期望”，或在线程中执行它，返回“期望”。</p>
<p>其本身并不提供太多的好处(并且事实上会造成大规模的超额任务)，但是它会为转型成一个更复杂的实现铺平道路，将会实现向一个队列添加任务，而后使用线程池的方式来运行它们。我们将在第9章再讨论线程池。使用<code>std::async</code>更适合于当你知道你在干什么，并且要完全控制在线程池中构建或执行过任务的线程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> A&gt;</span><br><span class="line">std::future&lt;std::result_of&lt;<span class="built_in">F</span>(A&amp;&amp;)&gt;::type&gt; <span class="built_in">spawn_task</span>(F &amp;&amp;f, A &amp;&amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::result_of&lt;<span class="built_in">F</span>(A&amp;&amp;)&gt;::type result_type;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">result_type</span><span class="params">(A&amp;&amp;)</span>&gt; <span class="title">task</span><span class="params">(std::move(f))</span></span>;</span><br><span class="line">    <span class="function">std::future&lt;result_type&gt; <span class="title">res</span><span class="params">(task.get_future())</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task), std::move(a))</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-2-synchronization-by-message-passing"><a href="#4-4-2-synchronization-by-message-passing" class="headerlink" title="4.4.2 synchronization by message passing"></a>4.4.2 synchronization by message passing</h4><blockquote>
<p> <strong>MPI：</strong>Message Passing Interface，消息传递接口</p>
<p><strong>CSP：</strong>Communicating Sequentiasl Processer，通讯顺序进程</p>
</blockquote>
<p><font color=blue>???????  THIS SECTION AND NEXT SECTION TODO</font></p>
<p>TODO …</p>
<h3 id="4-5-summary"><a href="#4-5-summary" class="headerlink" title="4.5 summary"></a>4.5 summary</h3><p>同步操作对于使用并发编写一款多线程应用来说，是很重要的一部分：如果没有同步，线程基本上就是独立的，也可写成单独的应用，因其任务之间的相关性，它们可作为一个群体直接执行。</p>
<p>本章，我们讨论了各式各样的同步操作，从基本的<strong>条件变量，到“期望”、“承诺”，再到打包任务</strong>。</p>
<p>我们也讨论了替代同步的解决方案：<strong>函数化模式编程，完全独立执行的函数，不会受到外部环境的影响；还有，消息传递模式，以消息子系统为中介，向线程异步的发送消息。</strong></p>
<h2 id="P5-memory-model-and-atomatic-operation"><a href="#P5-memory-model-and-atomatic-operation" class="headerlink" title="P5 memory model and atomatic operation"></a>P5 memory model and atomatic operation</h2><h2 id="P6-data-struct-with-mutex"><a href="#P6-data-struct-with-mutex" class="headerlink" title="P6 data struct with mutex"></a>P6 data struct with mutex</h2><p>本章主要内容：</p>
<ul>
<li>设计并发数据结构</li>
<li>如何设计</li>
<li>实现数据结构</li>
</ul>
<p>设计并发数据结构时，可以使用多线程中的构建块，比如：<code>condition_variable</code> 和 <code>mutex</code>。当然也要保证并发块在并发环境下的线程安全。</p>
<h3 id="6-1-the-significance-of-concurrency-design"><a href="#6-1-the-significance-of-concurrency-design" class="headerlink" title="6.1 the significance of concurrency design"></a>6.1 the significance of concurrency design</h3><p>设计并发数据结构是为了让多线程并发访问，并且线程可对数据结构做相同或不同的操作。</p>
<p>多线程环境下，无数据丢失和损坏，苏哟偶的数据都维持原样，且无竞争条件的数据结构，称之为“线程安全”的数据结构。</p>
<p>实际上，我们要通过设计线程安全的数据结构为线程提供并发访问数据结构的机会。因为就本质来说，互斥量为了保护数据，会显示阻止线程对数据的并发访问。</p>
<h4 id="6-1-1-guideline-of-desiging-the-concurrency-DB"><a href="#6-1-1-guideline-of-desiging-the-concurrency-DB" class="headerlink" title="6.1.1 guideline of desiging the concurrency DB"></a>6.1.1 guideline of desiging the concurrency DB</h4><p>设计并发数据结构时，需要两方面的考量：</p>
<ol>
<li>确保访问安全</li>
<li>真正并发访问</li>
</ol>
<p>第三章已经对如何保证数据安全做过简单的描述：</p>
<ul>
<li>确保无线程能够看到“不变量”变化时的状态</li>
<li>小心会引起条件竞争的接口，提供完整操作的函数，而非操作步骤（top-pop）</li>
<li>注意数据结构的行为是否会产生异常，从而确保“不变量”的状态</li>
<li>将死锁的概率降到最低。限制锁的范围，避免嵌套锁等</li>
</ul>
<p><strong>还需要考虑数据结构对于使用者有什么限制</strong>，当线程通过特殊的函数对数据结构进行访问时，其他的线程还有哪些函数能安全调用?</p>
<p>这是一个很重要的问题，普通的构造函数和析构函数需要独立访问数据结构，所以用户使用时，就不能在构造函数完成前或析构函数完成后对数据结构进行访问。当数据结构支持赋值操作swap()或拷贝构造时，作为 数据结构的设计者，即使线程操纵数据结构中有大量的函数，也需要保证这些操作在并发下是安全的(或确保 这些操作能够独立访问)，以保证并发访问时不会出错。</p>
<p>第二个方面是确保真正的并发，需要考虑一下问题：</p>
<ol>
<li>操作在锁的范围中进行，是否允许在锁外执行？</li>
<li>数据结构中不同的互斥能否保护不同的区域？</li>
<li>所有操作都需要同级互斥量的保护吗？</li>
<li>能否对数据结构进行简单的修改，增加并发访问的概率？</li>
</ol>
<p>这些问题都源于一个指导思想:<strong>如何让序列化访问最小化，让真实并发最大化?😊？？😭</strong></p>
<p>允许线程并发读取的数据结构并不少见，但修改必须是单线程的，这种结构类似于 <code>std::shared_mutex</code> 。同样，这种数据结构也很常见—— 支持多线程的不同操作时，也能串行执行相同的操作。</p>
<p>最简单的线程安全结构通常会对数据使用互斥量或锁。虽然，这么做还有问题，不过这样做相对简单，并且能保证只有一个线程在同一时间对数据结构进行独立访问。为了更轻松的设计线程安全的数据结构，接下来了解一下基于锁的数据结构。</p>
<h3 id="6-2-DS-based-on-mutex"><a href="#6-2-DS-based-on-mutex" class="headerlink" title="6.2 DS based on mutex"></a>6.2 DS based on mutex</h3><p>基于锁的并发数据结构确保访问线程持有锁的时间最短；对于只有一个互斥量的数据结构，需要锁之外的操作不能访问数据；使用多个互斥量保护数据结构不同的区域时要避免死锁。</p>
<h4 id="6-2-1-threadsafe-stack"><a href="#6-2-1-threadsafe-stack" class="headerlink" title="6.2.1 threadsafe stack"></a>6.2.1 threadsafe stack</h4><p>在 push() 操作中，无论如何都无法避免新数据的创建，除非你直接 move 原来的数据（右值引用 + move），但是直接 move 原来的数据有一个问题，那就是如果内存不足，move 一半异常了，那么原来的数据就会被破坏，因此，使用传值的方式拷贝初始数据，在 move 到容器中，更为稳妥。</p>
<p>这里的 “异常 - 安全” 好恶心😭</p>
<p>另外，这里的代码是可能发生死锁的;</p>
<p>用户要对栈负责，当栈未对一个数据进行拷贝或分配时，用户就不能想当然的将其添加到栈中。</p>
<p>所有成员函数都使用 std::lock_guard&lt;&gt; 保护数据，所以栈成员函数才是“线程安全”的。当然，构造与析构函数不是“线程安全”的，但构造与析构只有一次。调用不完全构造对象或是已销毁对象的成员函数，无论在哪种编程方式下都不可取。所以，用户就要保证在栈对象完成构造前，其他线程无法对其进行访问。并且，要保证在栈对象销毁后，停止所有线程的访问操作。</p>
<p>串形化的线程会隐性的限制程序性能。例如我们需要 pop 一个元素，那么当栈为空时我们只能等待，但这种等待时无意义的，我们希望它不这么闲着等，而是去做一些其他事，因此，这需要用户编写等待和提示的代码（例如：条件变量）。下面的队列就是如此。</p>
<h4 id="6-2-2-threadsafe-queue-–-mutex-amp-amp-condition-variable"><a href="#6-2-2-threadsafe-queue-–-mutex-amp-amp-condition-variable" class="headerlink" title="6.2.2 threadsafe queue – mutex &amp;&amp; condition_variable"></a>6.2.2 threadsafe queue – mutex &amp;&amp; condition_variable</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mut;</span><br><span class="line">    std::queue&lt;T&gt; data_queue;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; mut;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(std::<span class="built_in">move</span>(data));</span><br><span class="line">        data_cond.<span class="built_in">notify_one</span>(); <span class="comment">// 不为空，通知等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 因为wait可能假唤醒，因此这里需要多次lock&amp;&amp;unlock</span></span><br><span class="line">        <span class="comment">// 因此unique_lock用来搭配condition_variable是更好的选择</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        value = std::<span class="built_in">move</span>(data_queue.<span class="built_in">top</span>());</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* [TOOD]</span></span><br><span class="line"><span class="comment">    * 感觉这里可以把两个pop中判断queue是否为空的部分拿出来</span></span><br><span class="line"><span class="comment">    * 放到一个单独的函数里面，这样岂不是更好？</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T &amp;value)</span></span></span><br><span class="line"><span class="function">   </span>&#123;    </span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的代码在有一个问题，就是当 push() 执行 notice_one() 之后，如果唤醒的那个线程发生了异常死了，例如构造新的 shared_ptr 对象时发生异常，那么所有线程都将永眠，因为此时没有其它条件能将他们唤醒，解放方案有如下几种：</p>
<ol>
<li>notice_all()，但是这么做的开销太大了，因为往往只有一个线程最终唤醒，而其他线程仍然需要沉睡</li>
<li>当唤醒的线程异常时，调用 notice_one() 去唤醒另一个线程</li>
<li>将<code>std::shared_ptr&lt;&gt;</code>的初始化过程移到push()中，并且存储<code>std::shared_ptr&lt;&gt;</code>实例，而非直接使用数据的值。将<code>std::shared_ptr&lt;&gt;</code>拷贝到内部<code>std::queue&lt;&gt;</code>中，就不会抛出异常了，这样wait_and_pop()又是安全的了。</li>
</ol>
<p>下面是使用第三种方案修改后的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mut;</span><br><span class="line">    std::queue&lt;std::shared_ptr&lt;T&gt;&gt; data_queue;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 这样即使发生了异常也不会导致所有线程沉睡</span></span><br><span class="line">        <span class="comment">// 因为构造对象并不涉及对共享对象的访问</span></span><br><span class="line">        <span class="comment">// 因此它实际上不需要加锁</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">data</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(new_value))</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">        <span class="comment">// 分配完才加锁，减少锁持有的时间，提高并发能力</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(data);</span><br><span class="line">        data_cond.<span class="built_in">notify_one</span>(); <span class="comment">// 不为空，通知等待的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        value = std::<span class="built_in">move</span>(*data_queue.<span class="built_in">top</span>());</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123;</span><br><span class="line">            <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        std::shared_ptr&lt;T&gt; res = data_queue.<span class="built_in">front</span>(); <span class="comment">// 改为赋值而不是创建</span></span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* [TOOD]</span></span><br><span class="line"><span class="comment">    * 感觉这里可以把两个pop中判断queue是否为空的部分拿出来</span></span><br><span class="line"><span class="comment">    * 放到一个单独的函数里面，这样岂不是更好？</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T &amp;value)</span></span></span><br><span class="line"><span class="function">   </span>&#123;    </span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = std::<span class="built_in">move</span>(*data_queue.<span class="built_in">front</span>());</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line">        std::shared_ptr&lt;T&gt; res = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-2-3-threadsaft-queue-small-granularity-amp-amp-condition-variable"><a href="#6-2-3-threadsaft-queue-small-granularity-amp-amp-condition-variable" class="headerlink" title="6.2.3 threadsaft queue -  small granularity &amp;&amp; condition_variable"></a>6.2.3 threadsaft queue -  small granularity &amp;&amp; condition_variable</h4><p>下面是一个单线程环境下简单队列的实现，它是一个有头尾节点的单链表，当链表为空时，头尾指针为空。</p>
<blockquote>
<p>头节点 !&#x3D; 头指针</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">    &#123;</span><br><span class="line">        T data;</span><br><span class="line">        std::unique_ptr&lt;node&gt; next; <span class="comment">//  使用智能指针</span></span><br><span class="line">        <span class="built_in">node</span>(T _data) : <span class="built_in">data</span>(<span class="built_in">move</span>(_data)) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::unique_ptr&lt;node&gt; head;</span><br><span class="line">    node *tail; <span class="comment">// 因为这里的tail并不从堆上分配内存，他只是指向一个地址，因此不需要使用智能指针代替</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Queue</span>(<span class="type">const</span> Queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回节点并删除</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">/* 这里的const是顶层const，指定res不能再指向别的东西了，但是数据仍然可以修改</span></span><br><span class="line"><span class="comment">        * 你可能疑惑，既然res不能修改，但是接受返回值的变量不一定有这个限制的，他是可以修改的，没错，可以修改，但要记住了，shared_ptr 是有引用计数的，你修改了指向，其实就相当于在修改引用计数（创建了一个新指针），这并不会修改原来的指针，顶多导致她引用计数为0从而被销毁了。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分别取得头节点的数据和next指针</span></span><br><span class="line">        <span class="function"><span class="type">const</span> std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(head-&gt;data))</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">        <span class="type">const</span> std::unique_ptr&lt;node&gt; old_head = std::<span class="built_in">move</span>(head);</span><br><span class="line">        <span class="comment">// 头指针指向下一个节点</span></span><br><span class="line">        head = std::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建新节点</span></span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node(std::move(new_value)))</span></span>;</span><br><span class="line">        <span class="type">const</span> node* new_tail = p.<span class="built_in">get</span>();</span><br><span class="line">        <span class="comment">// 2. 让尾节点的next指向新节点</span></span><br><span class="line">        <span class="keyword">if</span>(tail)</span><br><span class="line">            tail-&gt;next = std::<span class="built_in">move</span>(p);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            head = std::<span class="built_in">move</span>(p);</span><br><span class="line">        <span class="comment">// 3. 更新尾节为当前节点</span></span><br><span class="line">        tail = new_tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码在单线程下没问题，但是在多线程下问题就太多了！</p>
<p>因为在给定的实现中有两个数据项(head①和tail②)；即使，使用两个互斥量，来保护头指针和尾指针，也会出现问题。</p>
<p>显而易见的问题就是push()可以同时修改头指针⑤和尾指针⑥，所以push()函数会同时获取两个互斥量。虽然会将两个互斥量都上锁，但这还不是太糟糕的问题。糟糕的问题是push()和pop()都能访问next指针指向的节点：push()可更新tail-&gt;next④，而后try_pop()读取head-&gt;next③。当队列中只有一个元素时，head&#x3D;&#x3D;tail，所以head-&gt;next和tail-&gt;next是同一个对象，并且这个对象需要保护。不过，“在同一个对象在未被head和tail同时访问时，push()和try_pop()锁住的是同一个锁”，就不对了。所以，你就没有比之间实现更好的选择了。这里会“柳暗花明又一村”吗？</p>
<p>可以通过<strong>分离数据</strong>实现并发。</p>
<p>通过“预分配虚拟节点（无数据）”，确保这个节点永远在队列的最后，用来分离头尾指针能访问的节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;T&gt; data;</span><br><span class="line">        std::unique_ptr&lt;node&gt; next; <span class="comment">//  使用智能指针</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;node&gt; head;</span><br><span class="line">    node *tail; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>() <span class="comment">// 预分配一个虚拟节点</span></span><br><span class="line">    : <span class="built_in">head</span>(<span class="keyword">new</span> node), <span class="built_in">tail</span>(head.<span class="built_in">get</span>()) </span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    initialization: </span></span><br><span class="line"><span class="comment">        [head(taial)] -&gt; NULL </span></span><br><span class="line"><span class="comment">    push value a</span></span><br><span class="line"><span class="comment">        [head] -&gt; [a(tail)] -&gt; NULL</span></span><br><span class="line"><span class="comment">    push value b</span></span><br><span class="line"><span class="comment">        [head] -&gt; [a] -&gt; [b(tail)] -&gt; NULL</span></span><br><span class="line"><span class="comment">    pop value</span></span><br><span class="line"><span class="comment">        [head] -&gt; [a(tail)] -&gt; NULL</span></span><br><span class="line"><span class="comment">    这样，除了队列为空状态下 head-&gt;next == tail-&gt;next == NULL</span></span><br><span class="line"><span class="comment">    任何时候他们不会为同一个元素，而队列为空时，不会同时发生 push 和 pop</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">Queue</span>(<span class="type">const</span> Queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    Queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Queue&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.<span class="built_in">get</span>() == tail) <span class="comment">// head与tail指向同一元素，队列为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 队列不为空，先 front() 再 pop()</span></span><br><span class="line">        <span class="function"><span class="type">const</span> std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(head-&gt;data)</span></span>; <span class="comment">// shared_ptr 不需要 move</span></span><br><span class="line">        <span class="type">const</span> std::unique_ptr&lt;node&gt; old_head = std::<span class="built_in">move</span>(head);</span><br><span class="line">        head = std::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 因为 tail 是我们预分配的节点，因此直接修改 tail 的 dat 即可</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">new_data</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(new_value))</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>; </span><br><span class="line">        tail-&gt;data = new_data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们已经把上次预分配的使用了，因此需要重新预分配并作为尾节点</span></span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node)</span></span>; </span><br><span class="line">        <span class="type">const</span> node* new_tail = p.<span class="built_in">get</span>();</span><br><span class="line">        tail-&gt;next = std::<span class="built_in">move</span>(p);</span><br><span class="line">        tail = new_tail;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过修改之后，push 便只需要访问 tail，而原来还需要访问 head，try_pop 需要访问 head 和 tail，但是 head 只在开始时用了一下，所以存在的时间很短。</p>
<p>不过，最重大的提升在于，try_pop 和 push 不能对同一节点进行操作，也就不需要互斥了。因此，现在只需要一个互斥量来保护 head 和 tail 就行了。</p>
<p>那么，该如何加锁呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsaft_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;T&gt; data;</span><br><span class="line">        std::unique_ptr&lt;node&gt; next;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::mutex head_mutex, tail_mutex;</span><br><span class="line">    std::unique_ptr&lt;node&gt; head;</span><br><span class="line">    node *tail;</span><br><span class="line"></span><br><span class="line">    <span class="function">node* <span class="title">get_tail</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">pop_head</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(head.<span class="built_in">get</span>() == <span class="built_in">get_tail</span>()) <span class="comment">// 队列为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::unique_ptr&lt;node&gt; old_head = std::<span class="built_in">move</span>(head_mutex);</span><br><span class="line">        <span class="comment">// move 掉 next 也是个好事，用户想得到的应该只是数据而不是 next 指针</span></span><br><span class="line">        head = std::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> old_head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsaft_queue</span>(): <span class="built_in">head</span>(<span class="keyword">new</span> node), <span class="built_in">tail</span>(head.<span class="built_in">get</span>()) &#123;&#125;</span><br><span class="line">    <span class="built_in">threadsaft_queue</span>(<span class="type">const</span> threadsaft_queue&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    threadsaft_queue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsaft_queue&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::unique_ptr&lt;node&gt; old_head = <span class="built_in">pop_head</span>();</span><br><span class="line">        <span class="keyword">return</span> old_head ? old_head-&gt;data : std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">new_data</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(new_value))</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node)</span></span>;</span><br><span class="line">        <span class="type">const</span> node *new_tail = p.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">        tail-&gt;data = new_data;</span><br><span class="line">        tail-&gt;next = std::<span class="built_in">move</span>(p);</span><br><span class="line">        tail = new_tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>多线程环境下，节点及数据的分配时“并发安全”的。</p>
</blockquote>
<p>下面是可上锁和等待的线程安全队列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsaft_queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;T&gt; data;</span><br><span class="line">        std::unique_ptr&lt;node&gt; next;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex head_mutex, tail_mutex;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line">    std::unique_ptr&lt;node&gt; head;</span><br><span class="line">    node *tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">node* <span class="title">get_tail</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">pop_head</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">wait_for_data</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">wait_pop_head</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">wait_pop_head</span><span class="params">(T &amp;value)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">try_pop_head</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">try_pop_head</span><span class="params">(T&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T &amp;value)</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T &amp;value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*====================*</span></span><br><span class="line"><span class="comment">*       function      *</span></span><br><span class="line"><span class="comment">*=====================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; threadsaft_queue&lt;T&gt;::<span class="built_in">try_pop</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_ptr&lt;node&gt; old_head = <span class="built_in">try_pop_head</span>();</span><br><span class="line">    <span class="keyword">return</span> old_head ? old_head-&gt;data : std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> threadsaft_queue&lt;T&gt;::<span class="built_in">try_pop</span>(T &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_ptr&lt;node&gt; old_head = <span class="built_in">try_pop_head</span>();</span><br><span class="line">    <span class="keyword">return</span> old_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::shared_ptr&lt;T&gt; threadsaft_queue&lt;T&gt;::<span class="built_in">wait_and_pop</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> std::unique_ptr&lt;node&gt; old_head = <span class="built_in">wait_pop_head</span>();</span><br><span class="line">    <span class="keyword">return</span> old_head-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> threadsaft_queue&lt;T&gt;::<span class="built_in">wait_and_pop</span>(T &amp;new_value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> std::unique_ptr&lt;node&gt; old_head = <span class="built_in">wait_and_pop</span>(new_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> threadsaft_queue&lt;T&gt;::<span class="built_in">push</span>(T new_value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">new_data</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        std::make_shared&lt;T&gt;(std::move(new_value))</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node)</span></span>;</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// use &#123;&#125; to unlock early </span></span><br><span class="line">        <span class="type">const</span> node *new_tail = p.<span class="built_in">get</span>();</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">        tail-&gt;data = new_data;</span><br><span class="line">        tail-&gt;next = std::<span class="built_in">move</span>(p);</span><br><span class="line">        tail = new_tail;</span><br><span class="line">    &#125;</span><br><span class="line">    data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> threadsaft_queue&lt;T&gt;::<span class="built_in">empty</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> (head.<span class="built_in">get</span>() == <span class="built_in">get_tail</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*====================*</span></span><br><span class="line"><span class="comment">*   helper function   *</span></span><br><span class="line"><span class="comment">*=====================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> threadsaft_queue&lt;T&gt;::node* </span><br><span class="line">threadsaft_queue&lt;T&gt;::<span class="built_in">get_tail</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">tail_lock</span><span class="params">(tail_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// execute within head mutex</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::unique_ptr&lt;<span class="keyword">typename</span> threadsaft_queue&lt;T&gt;::node&gt; </span><br><span class="line">threadsaft_queue&lt;T&gt;::<span class="built_in">pop_head</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_ptr&lt;node&gt; old_head = std::<span class="built_in">move</span>(head);</span><br><span class="line">    head = std::<span class="built_in">move</span>(old_head-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> old_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::unique_lock&lt;std::mutex&gt; </span><br><span class="line">threadsaft_queue&lt;T&gt;::<span class="built_in">wait_for_data</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 因为获取了 head_lock，所以下面调用 head.get() 并发安全</span></span><br><span class="line">    data_cond.<span class="built_in">wait</span>(head_lock, [&amp;]&#123;</span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">get</span>() != <span class="built_in">get_tail</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(head_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::unique_ptr&lt;<span class="keyword">typename</span> threadsaft_queue&lt;T&gt;::node&gt; </span><br><span class="line">threadsaft_queue&lt;T&gt;::<span class="built_in">wait_pop_head</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. [wait] until queue is not empty</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(wait_for_data())</span></span>;</span><br><span class="line">    <span class="comment">// 2. [pop] head</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::unique_ptr&lt;<span class="keyword">typename</span> threadsaft_queue&lt;T&gt;::node&gt; </span><br><span class="line">threadsaft_queue&lt;T&gt;::<span class="built_in">wait_pop_head</span>(T &amp;value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. [wait] until queue is not empty</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(wait_for_data())</span></span>;</span><br><span class="line">    <span class="comment">// get data</span></span><br><span class="line">    value = std::<span class="built_in">move</span>(*head-&gt;data);</span><br><span class="line">    <span class="comment">// 2. [pop] head</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::unique_ptr&lt;<span class="keyword">typename</span> threadsaft_queue&lt;T&gt;::node&gt; </span><br><span class="line">threadsaft_queue&lt;T&gt;::<span class="built_in">try_pop_head</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(head.<span class="built_in">get</span>() == <span class="built_in">get_tail</span>())</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;node&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::unique_ptr&lt;<span class="keyword">typename</span> threadsaft_queue&lt;T&gt;::node&gt; </span><br><span class="line">threadsaft_queue&lt;T&gt;::<span class="built_in">try_pop_head</span>(T&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">head_lock</span><span class="params">(head_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(head.<span class="built_in">get</span>() == <span class="built_in">get_tail</span>())</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;node&gt;();</span><br><span class="line">    value = std::<span class="built_in">move</span>(*head-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pop_head</span>();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-3-design-more-complex-DS"><a href="#6-3-design-more-complex-DS" class="headerlink" title="6.3 design more complex DS"></a>6.3 design more complex DS</h3><p>栈和队列的设计太 easy 啦（然而我也招架不住😭），下面来点大的。😠😠😠</p>
<h4 id="6-3-1-threadsafe-dictionary"><a href="#6-3-1-threadsafe-dictionary" class="headerlink" title="6.3.1 threadsafe dictionary"></a>6.3.1 threadsafe dictionary</h4><p>和栈和队列一样，标准容器的接口不适合多线程进行并发访问，因为这些接口都存在固有的条件竞争，所以这些接口需要砍掉或者重新修订。</p>
<p>并发访问时，<code>std::map&lt;&gt;</code> 最大的问题在于 —— 迭代器。例如当迭代器引用的元素被其它线程删除时，迭代器就会失效，但我们不知道。</p>
<p>查询表（字典）基本操作：</p>
<ol>
<li>（增）添加 key-value</li>
<li>（删）删除 key-value</li>
<li>（改）修改指定 key 所对应的 value</li>
<li>（查）查询指定 key 所对应的 value</li>
<li>so on…</li>
</ol>
<p>如果你坚持之前的线程安全指导意见，例如：<strong>不要返回一个引用</strong>，并且用一个简单的互斥锁对每一个成员函数进行上锁，以确保每一个函数线程安全。最有可能的条件竞争在于，当一对“键值-数据”加入时；当两个线程都添加一个数据，那么肯定一个先一个后。一种方式是合并“添加”和“修改”操作为一个成员函数，就像清单3.13对域名系统缓存所做的那样。</p>
<p>区别多线程环境下一下容器的并发能力：</p>
<ol>
<li>二叉树，比如：红黑树</li>
<li>有序数组</li>
<li>哈希表</li>
</ol>
<p>其中哈希表并发性能最好，因为哈希表可以设计为同 bucket+list(或有序数组)，而每一个 bucket 可以独立加锁，bucket 与 bucket 之间独立</p>
<p>下面是基于哈希表，使用读写锁，线程安全的，字典：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [TODO] separate bucket_t from threadsafe_lookup_table</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> threadsafe_lookup_table </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="type">bucket_t</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">/* [BUG]</span></span><br><span class="line"><span class="comment">            if you don&#x27;t add this, in the function of get_map()</span></span><br><span class="line"><span class="comment">            you cant access the number of data typed bucket_data</span></span><br><span class="line"><span class="comment">            .... </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> threadsafe_lookup_table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">typedef</span> std::pair&lt;Key,Value&gt;                 bucket_value;</span><br><span class="line">        <span class="keyword">typedef</span> std::list&lt;bucket_value&gt;              bucket_data;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> bucket_data::iterator       bucket_iterator;</span><br><span class="line">        <span class="comment">/* [BUG]</span></span><br><span class="line"><span class="comment">            author use iterator, but it is go CE</span></span><br><span class="line"><span class="comment">            we should use const_iterator</span></span><br><span class="line"><span class="comment">            ... ?</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> bucket_data::const_iterator bucket_const_iterator;</span><br><span class="line"></span><br><span class="line">        bucket_data data;</span><br><span class="line">        <span class="keyword">mutable</span> std::shared_mutex mutex;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// helper function</span></span><br><span class="line">        <span class="function">bucket_const_iterator <span class="title">find_entry_for</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">/* [BUG]</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">find_if</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), </span><br><span class="line">                [&amp;](<span class="type">const</span> bucket_value &amp;items)&#123;</span><br><span class="line">                    <span class="keyword">return</span> items.first == key;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// Advise: do not return by reference</span></span><br><span class="line">        <span class="comment">// this function return the value which mapped to the key</span></span><br><span class="line">        <span class="comment">// if ther is no item match, then return default value</span></span><br><span class="line">        <span class="comment">// and the default value is designated by the caller</span></span><br><span class="line">        <span class="function">Value <span class="title">value_for</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> Value &amp;default_value)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>; <span class="comment">// read lock</span></span><br><span class="line">            bucket_const_iterator found_entry = <span class="built_in">find_entry_for</span>(key);</span><br><span class="line">            <span class="keyword">return</span> (found_entry == data.<span class="built_in">end</span>()) ? </span><br><span class="line">                default_value : found_entry-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update if this key is existed otherwise add this K-V</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">add_or_update_mapping</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> Value &amp;value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>; <span class="comment">// write lock</span></span><br><span class="line">            bucket_const_iterator found_entry = <span class="built_in">find_entry_for</span>(key);</span><br><span class="line">            <span class="keyword">if</span>(found_entry == data.<span class="built_in">end</span>())</span><br><span class="line">                data.<span class="built_in">push_back</span>(<span class="built_in">bucket_value</span>(key, value));</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* [BUG]</span></span><br><span class="line"><span class="comment">                    because we use the const_iterator(lower const for the data which pointed on)</span></span><br><span class="line"><span class="comment">                    so we cant&#x27;t modify the data</span></span><br><span class="line"><span class="comment">                    otherwise ust the type convertion</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">auto</span> &amp;data = <span class="built_in">const_cast</span>&lt;bucket_value&amp;&gt;(*found_entry);</span><br><span class="line">                data.second = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">reomove_mapping</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>; <span class="comment">// write lock</span></span><br><span class="line">            bucket_const_iterator found_entry = <span class="built_in">find_entry_for</span>(key);</span><br><span class="line">            <span class="keyword">if</span>(found_entry != data.<span class="built_in">end</span>())</span><br><span class="line">                data.<span class="built_in">erase</span>(found_entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;<span class="type">bucket_t</span>&gt;&gt; buckets;</span><br><span class="line">    Hash hasher;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bucket_t</span>&amp; <span class="title">get_bucket</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">const</span> std::<span class="type">size_t</span> bucket_index = <span class="built_in">hasher</span>(key) % buckets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// buckets[idx] is a object of unique_ptr </span></span><br><span class="line">        <span class="comment">// so use operator* to get the object which ptr pointed on</span></span><br><span class="line">        <span class="keyword">return</span> *buckets[bucket_index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key   key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value mapped_type;    </span><br><span class="line">    <span class="keyword">typedef</span> Hash  hash_type;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;Key, Value&gt; value_type;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_lookup_table</span>(</span><br><span class="line">        <span class="comment">// the _num_bucket should be a prime so that it will have the best performance</span></span><br><span class="line">        <span class="type">unsigned</span> _num_buckets = <span class="number">19</span>, <span class="type">const</span> Hash &amp;_hasher = <span class="built_in">Hash</span>()</span><br><span class="line">    ) : <span class="built_in">buckets</span>(_num_buckets), <span class="built_in">hasher</span>(_hasher) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; _num_buckets; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            buckets[i].<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="type">bucket_t</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_lookup_table</span>(<span class="type">const</span> threadsafe_lookup_table&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    threadsafe_lookup_table&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_lookup_table&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*        DO NOT NEED MUTEX</span></span><br><span class="line"><span class="comment">    *  because the count of buckets can&#x27;t changed</span></span><br><span class="line"><span class="comment">    *  so it is needn&#x27;t to lock in the following functions </span></span><br><span class="line"><span class="comment">    *  -- when they call get_bucket() </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// caller, should designated the default value</span></span><br><span class="line">    <span class="function">Value <span class="title">value_for</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> Value &amp;default_value = Value())</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_bucket</span>(key).<span class="built_in">value_for</span>(key, default_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_or_update_mapping</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> Value &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">get_bucket</span>(key).<span class="built_in">add_or_update_mapping</span>(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove_mapping</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">get_bucket</span>(key).<span class="built_in">reomove_mapping</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// snapshot, return the backup in std::map</span></span><br><span class="line">    <span class="comment">// because we need to lock all buckets</span></span><br><span class="line">    <span class="comment">// if we add unique_lock, it would much wasty</span></span><br><span class="line">    <span class="comment">// so a bettery way is to use shared_mutex(read-lock)</span></span><br><span class="line">    <span class="comment">// so that other threads can also read meanwhile when we have locked a bucket</span></span><br><span class="line">    <span class="comment">// and then, we want to get the current state</span></span><br><span class="line">    <span class="comment">// so we should lock all buckets at one time</span></span><br><span class="line">    <span class="comment">// it is bad to lock and copy bucket one by one</span></span><br><span class="line">    <span class="comment">// because eg. when we lock A, and B will be modified</span></span><br><span class="line">    <span class="comment">// so the state is not consistency</span></span><br><span class="line">    <span class="function">std::map&lt;Key,Value&gt; <span class="title">get_map</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::vector&lt;std::unique_lock&lt;std::shared_mutex&gt;&gt; locks;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            locks.<span class="built_in">push_back</span>(</span><br><span class="line">                std::<span class="built_in">unique_lock</span>&lt;std::shared_mutex&gt;(buckets[i]-&gt;mutex)</span><br><span class="line">            );</span><br><span class="line">        &#125;   </span><br><span class="line">        std::map&lt;Key,Value&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;map_item : buckets[i]-&gt;data)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">insert</span>(map_item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">using</span> _map = threadsafe_lookup_table&lt;Key, Value&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _map&lt;<span class="type">int</span>,string&gt; table;</span><br><span class="line">    table.<span class="built_in">add_or_update_mapping</span>(<span class="number">1</span>, <span class="string">&quot;jyyyx&quot;</span>);</span><br><span class="line">    cout &lt;&lt; table.<span class="built_in">value_for</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    table.<span class="built_in">add_or_update_mapping</span>(<span class="number">2</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    cout &lt;&lt; table.<span class="built_in">value_for</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    table.<span class="built_in">add_or_update_mapping</span>(<span class="number">1</span>, <span class="string">&quot;sbg&quot;</span>);</span><br><span class="line">    cout &lt;&lt; table.<span class="built_in">value_for</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        table.<span class="built_in">add_or_update_mapping</span>(i, <span class="string">&quot;jyyyx: &quot;</span> + <span class="built_in">to_string</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> mp = table.<span class="built_in">get_map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : mp)</span><br><span class="line">        cout &lt;&lt; x.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⚠️⚠️⚠️    <strong>[BUG]</strong>    ⚠️⚠️⚠️</p>
</blockquote>
<p>在上面的代码中出现了很恶心的 bug（也可能是我太蠢了）， 导致我排查了好长好长时间，其实错误原因很简单。</p>
<p>在成员函数中，如果我们添加了 const 函数修饰符，那么如果我们返回一个迭代器的话，其实返回的是 const_iterator 而不是 iterator，const_iterator 有底层修饰，不能修改指向的对象。</p>
<p>例如下面的代码会报错：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> list&lt;PII&gt; L;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> L::iterator       L_iterator;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> L::const_iterator L_const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    L l;</span><br><span class="line">    <span class="function">L_iterator <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> <span class="comment">// (1)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">find_if</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> PII &amp;it)&#123;</span><br><span class="line">            <span class="keyword">return</span> it.first == x;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_val</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        L_iterator entry = <span class="built_in">get</span>(x);</span><br><span class="line">        <span class="keyword">return</span> entry-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo f;</span><br><span class="line">    L &amp;l = f.l; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )   l.<span class="built_in">push_back</span>(&#123;i, i + <span class="number">10</span>&#125;);</span><br><span class="line">    L_iterator it = f.<span class="built_in">get</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    it-&gt;second = <span class="number">1000</span>;</span><br><span class="line">    cout &lt;&lt; f.<span class="built_in">get_val</span>(<span class="number">2</span>) &lt;&lt; endl;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="built_in">test</span>();&#125;</span><br></pre></td></tr></table></figure>

<p>报错信息主要内容如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> std::<span class="built_in">find_if</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> PII &amp;it)&#123;</span><br><span class="line">      |                ~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">      |                            |</span><br><span class="line">      |                            std::_List_const_iterator&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;</span><br><span class="line">   <span class="number">20</span> |             <span class="keyword">return</span> it.first == x;</span><br><span class="line">      |             ~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">   <span class="number">21</span> |         &#125;);</span><br><span class="line">      |         ~~</span><br></pre></td></tr></table></figure>

<p>很明显的发现，编译器提示我们，我们的返回值是一个 <code>list::const_iterator</code> 类型，而不是 <code>list::iterator</code>。</p>
<p>那你可能会说，如果我们不希望返回 const_ierator 的话，把 (1) 处的 const 去掉不久行了？</p>
<p>那你就得好好看了，下面的错误更隐蔽和恶心，去掉 (1) 处的 const 之后，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a.cpp: In member function <span class="string">&#x27;int Foo::get_val(int) const&#x27;</span>:</span><br><span class="line">a.cpp:<span class="number">25</span>:<span class="number">33</span>: error: passing <span class="string">&#x27;const Foo&#x27;</span> as <span class="string">&#x27;this&#x27;</span> argument discards qualifiers [-fpermissive]</span><br><span class="line">   <span class="number">25</span> |         L_iterator entry = <span class="built_in">get</span>(x);</span><br><span class="line">      |                                 ^</span><br><span class="line">a.cpp:<span class="number">17</span>:<span class="number">16</span>: note:   in call to <span class="string">&#x27;L_iterator Foo::get(int)&#x27;</span></span><br><span class="line">   <span class="number">17</span> |     <span class="function">L_iterator <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// (1)</span></span></span><br><span class="line"><span class="function">      |                ^~~</span></span><br></pre></td></tr></table></figure>

<p>上面的报错信息不认真看，理解着看的话，有可能不知道他说的是什么意思！其实这种错误在 《Effective C++》 系列都是强调过的！由此可见，光理论，不实践，掌握的知识不牢固，容易忘！</p>
<p>其实人话来说，就是 get_val() 是一个 const 成员函数，所以，在这个函数中， **this 指针是 this *const(底层 const)**，想必如果你很敏感的话，那么你应该知道错在哪了！我们把一个 this *const 传入到一个非 const 的成员函数 get() 当中，那么在 get() 当中就可能修改我们的 this，从而间接的破坏了 get_val() 的 const 属性！</p>
<blockquote>
<p>实际上，上面的 bug 正是 《effective STL》的一条 item:</p>
<p>“const_iterator fist!”</p>
</blockquote>
<p>那么，作者为什么会写出如此不严谨的代码呢？是选，有意思的一点是，如果不进行测试，上面的代码是没有问题的！那么，到底是作者写这本时的 C++ 和编译器的版本问题，还是作者偷懒没有进行测试呢？大概是前者吧！😊</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangdamingll/article/details/107086966">最终在这篇博客找到了 bug 的解决方案，感恩！</a></p>
</blockquote>
<p>最后，给出使用 iterator 的版本，只需要把所有 const 成员函数修饰去掉就行了。</p>
<blockquote>
<p>解决问题的方法就是不让问题产生 😭</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key,<span class="keyword">typename</span> Value,<span class="keyword">typename</span> Hash=std::hash&lt;Key&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> threadsafe_lookup_table</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">class</span> bucket_type</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::pair&lt;Key,Value&gt; bucket_value;</span><br><span class="line">    <span class="keyword">typedef</span> std::list&lt;bucket_value&gt; bucket_data;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> bucket_data::iterator bucket_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> bucket_data::const_iterator bucket_const_iterator;</span><br><span class="line">    </span><br><span class="line">    bucket_data data;</span><br><span class="line">    <span class="keyword">mutable</span> shared_mutex mutex;  <span class="comment">// 1</span></span><br><span class="line">    <span class="function">bucket_iterator <span class="title">find_entry_for</span><span class="params">(Key <span class="type">const</span>&amp; key)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">find_if</span>(data.<span class="built_in">begin</span>(),data.<span class="built_in">end</span>(),</span><br><span class="line">      [&amp;](bucket_value <span class="type">const</span>&amp; item)</span><br><span class="line">      &#123;<span class="keyword">return</span> item.first==key;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Value <span class="title">value_for</span><span class="params">(Key <span class="type">const</span>&amp; key,Value <span class="type">const</span>&amp; default_value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="function">shared_lock&lt;shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;  <span class="comment">// 3</span></span><br><span class="line">      bucket_iterator <span class="type">const</span> found_entry=<span class="built_in">find_entry_for</span>(key);</span><br><span class="line">      <span class="keyword">return</span> (found_entry==data.<span class="built_in">end</span>())?</span><br><span class="line">        default_value:found_entry-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_or_update_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key,Value <span class="type">const</span>&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;  <span class="comment">// 4</span></span><br><span class="line">      bucket_iterator <span class="type">const</span> found_entry=<span class="built_in">find_entry_for</span>(key);</span><br><span class="line">      <span class="keyword">if</span>(found_entry==data.<span class="built_in">end</span>())</span><br><span class="line">      &#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(<span class="built_in">bucket_value</span>(key,value));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        found_entry-&gt;second=value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;  <span class="comment">// 5</span></span><br><span class="line">      bucket_iterator <span class="type">const</span> found_entry=<span class="built_in">find_entry_for</span>(key);</span><br><span class="line">      <span class="keyword">if</span>(found_entry!=data.<span class="built_in">end</span>())</span><br><span class="line">      &#123;</span><br><span class="line">        data.<span class="built_in">erase</span>(found_entry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;bucket_type&gt; &gt; buckets;  <span class="comment">// 6</span></span><br><span class="line">  Hash hasher;</span><br><span class="line">  <span class="function">bucket_type&amp; <span class="title">get_bucket</span><span class="params">(Key <span class="type">const</span>&amp; key)</span>   <span class="comment">// 7</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::<span class="type">size_t</span> <span class="type">const</span> bucket_index=<span class="built_in">hasher</span>(key)%buckets.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> *buckets[bucket_index];</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">  <span class="keyword">typedef</span> Value mapped_type;</span><br><span class="line">  <span class="keyword">typedef</span> Hash hash_type;</span><br><span class="line">  <span class="built_in">threadsafe_lookup_table</span>(</span><br><span class="line">    <span class="type">unsigned</span> num_buckets=<span class="number">19</span>,Hash <span class="type">const</span>&amp; hasher_=<span class="built_in">Hash</span>()):</span><br><span class="line">    <span class="built_in">buckets</span>(num_buckets),<span class="built_in">hasher</span>(hasher_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> i=<span class="number">0</span>;i&lt;num_buckets;++i)</span><br><span class="line">    &#123;</span><br><span class="line">      buckets[i].<span class="built_in">reset</span>(<span class="keyword">new</span> bucket_type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">threadsafe_lookup_table</span>(threadsafe_lookup_table <span class="type">const</span>&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  threadsafe_lookup_table&amp; <span class="keyword">operator</span>=(</span><br><span class="line">    threadsafe_lookup_table <span class="type">const</span>&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  <span class="function">Value <span class="title">value_for</span><span class="params">(Key <span class="type">const</span>&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                  Value <span class="type">const</span>&amp; default_value=Value())</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_bucket</span>(key).<span class="built_in">value_for</span>(key,default_value);  <span class="comment">// 8</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add_or_update_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key,Value <span class="type">const</span>&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_bucket</span>(key).<span class="built_in">add_or_update_mapping</span>(key,value);  <span class="comment">// 9</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_bucket</span>(key).<span class="built_in">remove_mapping</span>(key);  <span class="comment">// 10</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    threadsafe_lookup_table&lt;<span class="type">int</span>,string&gt; table;</span><br><span class="line">    table.<span class="built_in">add_or_update_mapping</span>(<span class="number">1</span>, <span class="string">&quot;jyyyx&quot;</span>);</span><br><span class="line">    cout &lt;&lt; table.<span class="built_in">value_for</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    table.<span class="built_in">add_or_update_mapping</span>(<span class="number">2</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    cout &lt;&lt; table.<span class="built_in">value_for</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    table.<span class="built_in">add_or_update_mapping</span>(<span class="number">1</span>, <span class="string">&quot;sbg&quot;</span>);</span><br><span class="line">    cout &lt;&lt; table.<span class="built_in">value_for</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-3-2-threadsafe-list"><a href="#6-3-2-threadsafe-list" class="headerlink" title="6.3.2 threadsafe list"></a>6.3.2 threadsafe list</h4><p>同上面谈到的，容器中的迭代器在并发时会产生麻烦，除非让迭代器持有锁，但这是个很槽糕的做法。因此这意味着迭代器受限于锁，而不是容器。</p>
<p>替代方案是使用迭代函数，例如：将 for_each 作为容器本身的一部分。这就能让容器对迭代的部分进行负责和锁定。</p>
<p>。。。</p>
<p>链表应该提供的操作：（增删改查）</p>
<ul>
<li>向列表添加一个元素</li>
<li>当某个条件满足时，就从链表中删除某个元素</li>
<li>当某个条件满足时，从链表中查找某个元素</li>
<li>当某个条件满足时，更新链表中的某个元素</li>
<li>（more）将当前容器中链表中的每个元素，复制到另一个容器中</li>
<li>（more）插入元素到某个指定的位置</li>
</ul>
<p>使用细粒度锁最初的想法，是为了<strong>让链表每个节点都拥有一个互斥量</strong>。当链表很长时，那么就会有很多的互斥量!这样的好处是对于链表中每一个独立的部分，都能实现真实的并发：其真正感兴趣的是对持有的节点群进行上锁，并且在移动到下一个节点的时，对当前节点进行释放。下面的清单中将展示这样的一个链表实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a list with head-node</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_list</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">    &#123;</span><br><span class="line">        std::mutex m;</span><br><span class="line">        std::shared_ptr&lt;T&gt; data;</span><br><span class="line">        std::unique_ptr&lt;node&gt; next;</span><br><span class="line">        <span class="built_in">node</span>() : <span class="built_in">next</span>() &#123;&#125; <span class="comment">// default NULL</span></span><br><span class="line">        <span class="built_in">node</span>(<span class="type">const</span> T &amp;value) : <span class="built_in">data</span>(std::<span class="built_in">make_shared</span>&lt;T&gt;(value)) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    node head; <span class="comment">// default head node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_list</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">threadsafe_list</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">remove_if</span>([](<span class="type">const</span> node&amp;)&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_list</span>(<span class="type">const</span> threadsafe_list&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    threadsafe_list&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_list&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// the construction of new node neeedn&#x27;t to lock</span></span><br><span class="line">        <span class="function">std::unique_ptr&lt;node&gt; <span class="title">new_node</span><span class="params">(<span class="keyword">new</span> node(value))</span></span>;</span><br><span class="line">        <span class="comment">// lock head</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(head.m)</span></span>;</span><br><span class="line">        new_node-&gt;next = std::<span class="built_in">move</span>(head.next);</span><br><span class="line">        head.next = std::<span class="built_in">move</span>(new_node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">for_each</span><span class="params">(Function f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// the node of head is a fixed and virtual node</span></span><br><span class="line">        <span class="comment">// it means no one can change it, so there is no &quot;race condition&quot;</span></span><br><span class="line">        <span class="comment">// -- when multiple threads execute the follow sentense</span></span><br><span class="line">        node *current = &amp;head; </span><br><span class="line">        <span class="comment">// because we need do unlock by self, so unique_lock does</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(head.m)</span></span>; </span><br><span class="line">        <span class="keyword">while</span>(node *next = current-&gt;next.<span class="built_in">get</span>()) <span class="comment">// declare a local variable </span></span><br><span class="line">                            <span class="comment">// -- next in the while&#x27;s check ????</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// lock the next first and unlock the past succession</span></span><br><span class="line">            <span class="comment">// there is a beautiful name for this process: hand to hand lock ^_^</span></span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">next_lock</span><span class="params">(next-&gt;m)</span></span>;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="comment">// because head is a virtual node(no data)</span></span><br><span class="line">            <span class="comment">// we should call funtion start at head-&gt;next</span></span><br><span class="line">            <span class="built_in">f</span>(*next-&gt;data);</span><br><span class="line">            current = next;</span><br><span class="line">            lock = std::<span class="built_in">move</span>(next_lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expect for unary Predicate</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</span></span><br><span class="line"><span class="function">    std::shared_ptr&lt;T&gt; <span class="title">find_first_if</span><span class="params">(Predicate p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node *current = &amp;head;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(head.m)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(node *next = current-&gt;next.<span class="built_in">get</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">next_lock</span><span class="params">(next-&gt;m)</span></span>;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">p</span>(*next-&gt;data))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> next-&gt;data;</span><br><span class="line">            &#125;</span><br><span class="line">            current = next;</span><br><span class="line">            lock = std::<span class="built_in">move</span>(next_lock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">remove_if</span><span class="params">(Predicate p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node *current = &amp;head;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(head.m)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(node *next = current-&gt;next.<span class="built_in">get</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">next_lock</span><span class="params">(next-&gt;m)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">p</span>(*next-&gt;data))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// usage of smart_ptr and move() can avoid to execute big copy</span></span><br><span class="line">                std::unique_ptr&lt;node&gt; old_next = std::<span class="built_in">move</span>(current-&gt;next);</span><br><span class="line">                current-&gt;next = std::<span class="built_in">move</span>(next-&gt;next);</span><br><span class="line">                next_lock.<span class="built_in">unlock</span>();</span><br><span class="line">                <span class="comment">// needn&#x27;t to move current to next node</span></span><br><span class="line">                <span class="comment">// because the new next node will satisfiy Predicate, too</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                lock.<span class="built_in">unlock</span>();</span><br><span class="line">                current = next;</span><br><span class="line">                lock = std::<span class="built_in">move</span>(next_lock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    threadsafe_list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )   </span><br><span class="line">        L.<span class="built_in">push_front</span>(i % <span class="number">5</span>);</span><br><span class="line">    L.for_each([](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    L.<span class="built_in">remove_if</span>([](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;<span class="keyword">return</span> x == <span class="number">4</span>;&#125;);</span><br><span class="line">    L.for_each([](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> it = L.<span class="built_in">find_first_if</span>([](<span class="type">const</span> <span class="type">int</span> x)&#123;<span class="keyword">return</span> x == <span class="number">1</span>;&#125;);</span><br><span class="line">    *it = <span class="number">1024</span>;</span><br><span class="line">    L.for_each([](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    it = L.<span class="built_in">find_first_if</span>([](<span class="type">const</span> <span class="type">int</span> x)&#123;<span class="keyword">return</span> x == <span class="number">1</span>;&#125;);</span><br><span class="line">    *it = <span class="number">666</span>;</span><br><span class="line">    L.for_each([](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    L.<span class="built_in">remove_if</span>([](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;<span class="keyword">return</span> x == <span class="number">1</span>;&#125;);</span><br><span class="line">    L.for_each([](<span class="type">const</span> <span class="type">int</span> &amp;x)&#123;cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;&#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>学到了个新东西</p>
</blockquote>
<p>可以在 while 的条件判断里面声名一个局部变量，并且可以在 while body 里面使用，但是有个限制，就是只能使用默认比价方式（0，nullptr），如果你想使用特殊的比较方式，例如：<code>while((int y = x + 1) != 3)</code>，那么局部变量 y 的作用域实际上是 <code>(int y = x + 1)</code> 这个括号里面，除了括号就死了，因此在 while body 里面也就无法使用，这时候，就得在 while 外面声明这个变量了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="type">int</span> y = x + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        x ++ ;</span><br><span class="line">        <span class="keyword">if</span>(y &gt; <span class="number">10</span>)  <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="P7-data-struct-without-mutex"><a href="#P7-data-struct-without-mutex" class="headerlink" title="P7 data struct without mutex"></a>P7 data struct without mutex</h2><p><font color=blue> TODO</font></p>
<h2 id="P8-concurrency-design"><a href="#P8-concurrency-design" class="headerlink" title="P8 concurrency design"></a>P8 concurrency design</h2><p><font color=blue> TODO</font></p>
<p>文章主要内容包括：</p>
<ul>
<li>线程间划分数据的技术</li>
<li>影响并发代码性能的因素</li>
<li>性能因素是如何影响数据结构的设计</li>
<li>多线程代码中的异常安全</li>
<li>可拓展性</li>
<li>并行算法的实现</li>
</ul>
<h3 id="8-1-divide-work-among-threads"><a href="#8-1-divide-work-among-threads" class="headerlink" title="8.1 divide work among threads"></a>8.1 divide work among threads</h3><p> 最直白的，对于一个线程，是让他充当一个“全能”线程来完成所有工作，还是充当一个“专业”线程完成一件事情，还是两者混合。等等。诸如此类的选择至关重要。</p>
<h4 id="8-1-1-prepare-divide"><a href="#8-1-1-prepare-divide" class="headerlink" title="8.1.1 prepare divide"></a>8.1.1 prepare divide</h4><p>思想很简单，就是在创建线程之前，把多个任务分为一组，一个线程处理一组任务。</p>
<p>但是这样做仍然有一个不太好的地方，如代码2.8 所示，最后一步仍然是串行的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">accumulate_block</span>&lt;Iterator,T&gt;()</span><br><span class="line">(block_start,last,results[num_threads<span class="number">-1</span>]); </span><br></pre></td></tr></table></figure>

<p>不过，accumulate 实际上是一个递减操作（即任务的个数是逐渐减少的），因此当线程数量大于一个线程上最小处理项时，可以对函数递归调用，这样就可以最大化并行的程度。</p>
<blockquote>
<p>原本递归是等一个子函数执行完，再执行另一个子函数。但是通过线程，我们可以同时递归执行多个子函数，自函数再递归执行多个自函数，每个子函数占用一个线程。</p>
<p>可以发现，这对线程数量的要求比较高！</p>
</blockquote>
<h4 id="8-1-2-recursion-divide"><a href="#8-1-2-recursion-divide" class="headerlink" title="8.1.2 recursion divide"></a>8.1.2 recursion divide</h4><p>快速排序就用到了递归！</p>
<p>下面是 list 的快速排序算法的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO</span></span><br></pre></td></tr></table></figure>



<h4 id="8-1-3-work-divide"><a href="#8-1-3-work-divide" class="headerlink" title="8.1.3 work divide"></a>8.1.3 work divide</h4><p>多线程下有两个危险需要分离。</p>
<ol>
<li>第一个是对错误的担忧（主要表现为线程间共享着很多的数据）</li>
<li>第二个是不同的线程需要相互等待。</li>
</ol>
<p>这两种情况都是因为线程间很密切的交互。如果这种情况发生，就需要看一下为什么发生这么多交互。当所有交互都有相同的问题，就应该使用但线程来解决，并将引用同一源的线程提取出来。或者当有两个线程需要频繁的交流，在没有其它线程时，就可以将这两个线程合为一个线程。</p>
<p>当任务会应用到相同的任务序列，去处理独立的数据项时，就可以使用 pipeline 系统进行并发。</p>
<p>使用这种方式划分工作，可以为流水线中的每一阶段操作创建一个独立线程。</p>
<h3 id="8-2-performance-of-concurrency"><a href="#8-2-performance-of-concurrency" class="headerlink" title="8.2 performance of concurrency"></a>8.2 performance of concurrency</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34074740/article/details/92960920">关于cpu的核和芯</a></p>
<p>原生多核，封装多芯</p>
<p>作者说，四核两芯的cpu可以有16个线程，是因为超线程吗？</p>
</blockquote>
<h4 id="8-2-1-cpu-count"><a href="#8-2-1-cpu-count" class="headerlink" title="8.2.1 cpu count"></a>8.2.1 cpu count</h4><p>为了拓展线程的数量，且与硬件所支持的并发线程数一致，C++ 标准库提供了 <code>std::thread::hardware_concurrency()</code>，使用这个函数可以知道在给定硬件上可以拓展的线程数量。</p>
<blockquote>
<p>我的 MacBook M1 Air 才是 8</p>
</blockquote>
<p>使用的线程个数不是越多越好，太多线程进行切换会导致 oversubscription(超额请求)</p>
<h4 id="8-2-2-race-data-and-cache-ping-pong"><a href="#8-2-2-race-data-and-cache-ping-pong" class="headerlink" title="8.2.2 race data and cache ping-pong"></a>8.2.2 race data and cache ping-pong</h4><p>当多个线程在不同的处理器上时，对数据的读取通常不会有问题，因为数据会拷贝到每个线程的缓存中，并让多个处理器同时处理。然鹅，当有线程对数据进行修改，并且需要同步到其它核心的缓存时，需要浪费一定的时间。这样的修改可能会让其它处理情停下来，等待硬件内存更新缓存的数据。并且，根据 cpu 指令，这是一个特别慢的操作。</p>
<blockquote>
<p><strong>high contention</strong>：处理器之间经常需要等待数据的更改</p>
<p><strong>low contention</strong>：处理器之间很少需要相互等待</p>
<p><strong>cache ping-pong</strong>：在多个处理器的缓存之间来回传递的数据</p>
</blockquote>
<p>避免 cache ping-pong 的方法就是减少两个线程对同一个内存为止的竞争</p>
<h4 id="8-2-3-false-sharing"><a href="#8-2-3-false-sharing" class="headerlink" title="8.2.3 false sharing"></a>8.2.3 false sharing</h4><p>cache line sharing</p>
<p>其实就是减少缓存的刷新次数，降低数据伪共享缓存的概率。</p>
<h4 id="…"><a href="#…" class="headerlink" title="…."></a>….</h4><h3 id="8-3-design-data-struct-for-multiple-thread-environment"><a href="#8-3-design-data-struct-for-multiple-thread-environment" class="headerlink" title="8.3 design data struct for multiple thread environment"></a>8.3 design data struct for multiple thread environment</h3><p>当为多线程设计数据结构时，需要考虑：contention, false sharing, data proximity(数据临近)，这些对性能都有重大影响。</p>
<h2 id="P9-advance-thread-management"><a href="#P9-advance-thread-management" class="headerlink" title="P9 advance thread management"></a>P9 advance thread management</h2><h2 id="P10-parallel-algorithm"><a href="#P10-parallel-algorithm" class="headerlink" title="P10 parallel algorithm"></a>P10 parallel algorithm</h2><h2 id="P11-test-and-debug-in-multiple-thread-environment"><a href="#P11-test-and-debug-in-multiple-thread-environment" class="headerlink" title="P11 test and debug in multiple thread environment"></a>P11 test and debug in multiple thread environment</h2><p><strong>[TODO]</strong></p>
<h2 id="A-Myheader"><a href="#A-Myheader" class="headerlink" title="A Myheader"></a>A Myheader</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">@copyright jyyyx</span></span><br><span class="line"><span class="comment">    __</span></span><br><span class="line"><span class="comment">.__(.)&lt; (qaq ~~~)</span></span><br><span class="line"><span class="comment">\____)</span></span><br><span class="line"><span class="comment">~~~~~~~~~~~~~~~~~--&gt;</span></span><br><span class="line"><span class="comment">When I write this, only god and me konw what the program mean</span></span><br><span class="line"><span class="comment">Now, only god konws QAQ</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_HEADER_GUARD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_HEADER_GUARD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// C++ Concurrency Library for thread&#x27;s management</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> <span class="comment">// std::mutex &amp; std::mutex_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// condition_variable &amp; condition_variable_any</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> <span class="comment">// future &amp; async</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span> <span class="comment">// std::shared_mutex</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// for_each</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span>    <span class="comment">// class ratio</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// unique_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span> <span class="comment">// result_of</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">// accumulate</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>   <span class="comment">// mem_fn</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>   <span class="comment">// std::chrono, time point, time duration</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span>    <span class="comment">// copy_exception renamed to make_exception_ptr</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span>   <span class="comment">// put_time</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*================ header ================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_BEGIN std::cout &lt;&lt; <span class="string">&quot;|------ begin ------|&quot;</span> &lt;&lt; std::endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_END   std::cout &lt;&lt; <span class="string">&quot;|------- end -------|&quot;</span> &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::mutex some_mutex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>



<h2 id="B-std-atomic"><a href="#B-std-atomic" class="headerlink" title="B std::atomic"></a>B std::atomic</h2><h3 id="0-reference"><a href="#0-reference" class="headerlink" title="0. reference"></a>0. reference</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7086226046931959838">ref1</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/haippy/p/3284540.html">ref2</a></p>
<p><a target="_blank" rel="noopener" href="https://subingwen.cn/cpp/atomic/">ref3</a></p>
<h3 id="1-introduce"><a href="#1-introduce" class="headerlink" title="1. introduce"></a>1. introduce</h3><p><code>#include &lt;atomic&gt;</code></p>
<p>原子类型(<code>std::atoimic&lt;T&gt;</code>)是封装了一个值的类型，它的访问保证不会导致数据的竞争，并且可以用于在不同的线程之间同步内存访问。</p>
<p>原子类型主要用于避免加锁解锁时的程序开销，从而提高性能。(互斥量加锁一般针对的是一个代码段，而原子操作针对的一般是一个变量)。</p>
<p>原子类型是“指令”层面上的支持，因此它的性能相比锁和消息传递会好很多。</p>
<p>std::atomic 内部使用了 CAS(compare and swap) 自旋锁：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CompareAndSwap</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> expceted, <span class="type">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> actual = *ptr;</span><br><span class="line">    <span class="keyword">if</span>(actual == expected) *ptr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> *actual;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*===================================*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">CompareAndSwap</span>(&amp;lock-&gt;flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>) </span><br><span class="line">        	; <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-std-atomic-flag"><a href="#2-std-atomic-flag" class="headerlink" title="2. std::atomic_flag"></a>2. std::atomic_flag</h3><p><code>std::atomic_flag</code>是原子布尔类型，它保证是免锁（lock-free）的。只支持两种操作：<code>test-andset</code> 和 <code>clear</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;myheader.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须使用 ATOMIC_FLAG_INIT 初始化，否则值是 UB</span></span><br><span class="line"><span class="comment">// 即，既不是 set 也不是 clear</span></span><br><span class="line"><span class="comment">// 该宏将使得 atomic_flag 处于 clear 状态</span></span><br><span class="line">std::atomic_flag alock = ATOMIC_FLAG_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(alock.<span class="built_in">test_and_set</span>(std::memory_order_acquire)) <span class="comment">// 获得锁</span></span><br><span class="line">            ;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Output from thread &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        alock.<span class="built_in">clear</span>(std::memory_order_release);  <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    std::vector&lt;std::thread&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(f, i); <span class="comment">// 通过 emplace 传入线程和参数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it : v)   </span><br><span class="line">        it.<span class="built_in">join</span>();</span><br><span class="line">    PRINT_END;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>自旋锁</p>
<blockquote>
<p>自旋锁是<strong>计算机科学用于多线程同步的一种锁</strong>，线程反复检查锁变量是否可用。 由于线程在这一过程中保持执行，因此是一种<strong>忙等待</strong>。 一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。 自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。</p>
</blockquote>
<p>C++ 是系统级别的编程语言，标准委员会的目标是不需要比C++还要底层的高级语言。C++ 应该向程序员提供足够的灵活性，无障碍的去做他们想要做的事情。需要时，也可以“接触硬件”。原子类型和原子操作就可以<strong>“接触硬件”</strong>，并提供底层同步操作，通常会将指令数缩减到 1～2 个CPU指令。</p>
<p><font color = blue> TODO ⌛️⌛️⌛️ </font></p>
<p>一个简单的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread_pool_cpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_COUNT 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> </span><br><span class="line">&#123;</span><br><span class="line">    mutex m;</span><br><span class="line">    <span class="comment">// int value;</span></span><br><span class="line">    atomic&lt;<span class="type">int</span>&gt; value;</span><br><span class="line">    <span class="built_in">Counter</span>(<span class="type">int</span> _value = <span class="number">0</span>) : <span class="built_in">value</span>(_value) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">produce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_COUNT; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            value ++ ;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;increment number: &quot; &lt;&lt; value </span></span><br><span class="line">            <span class="comment">//     &lt;&lt; &quot;, threadID: &quot; &lt;&lt; hex &lt;&lt; this_thread::get_id() &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">            <span class="comment">// this_thread::sleep_for(chrono::milliseconds(100));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">consume</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_COUNT; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            value -- ;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;decrement number: &quot; &lt;&lt; value </span></span><br><span class="line">            <span class="comment">//     &lt;&lt; &quot;, threadID: &quot; &lt;&lt; hex &lt;&lt; this_thread::get_id() &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">            <span class="comment">// this_thread::sleep_for(chrono::milliseconds(100));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Counter <span class="title">c</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> increment = <span class="built_in">bind</span>(&amp;Counter::produce, &amp;c);</span><br><span class="line">    <span class="keyword">auto</span> decrement = <span class="built_in">bind</span>(&amp;Counter::consume, &amp;c);</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(decrement)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t4</span><span class="params">(decrement)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; c.value &lt;&lt; endl;</span><br><span class="line">;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PRINT_BEGIN;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    PRINT_END;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h1 id="C-thread-pool"><a href="#C-thread-pool" class="headerlink" title="C:thread_pool"></a>C:thread_pool</h1><h2 id="站在巨人的肩膀上"><a href="#站在巨人的肩膀上" class="headerlink" title="站在巨人的肩膀上"></a>站在巨人的肩膀上</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://subingwen.cn/categories/Linux/">document</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1sv41177e4/?p=19">multiple thread</a>    <a target="_blank" rel="noopener" href="https://subingwen.cn/linux/threadpool/#1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86">document</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jV411J795/?spm_id_from=333.999.0.0&vd_source=38033fe3a1f136728a1d6f8acf710b51">thread pool in C</a></p>
</blockquote>
<h2 id="一、-多线程"><a href="#一、-多线程" class="headerlink" title="一、 多线程"></a>一、 多线程</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><blockquote>
<p>可以通过sleep稍微控制线程的执行顺序。。。</p>
</blockquote>
<p>一个线程就是一个“任务”，当我们创建一个线程时，它就开始执行这个任务。</p>
<h3 id="2-创建线程"><a href="#2-创建线程" class="headerlink" title="2. 创建线程"></a>2. 创建线程</h3><p>我们创建的线程一般称为子线程，为啥不是主线程呢？因为主线程一般是默认存在的！当我们在一个进程中创建线程时，主进程会变成主线程。</p>
<p>因此，当主线程退出时，也就意味着主进程结束了，也就意味着分配的虚拟内存空间要释放，因此其余线程也要销毁。</p>
<p>但是，我们可以通过调用相关API，使得主线程退出后，子线程也可以正常运行。</p>
<p><code>pthread_create();</code></p>
<h3 id="3-线程退出"><a href="#3-线程退出" class="headerlink" title="3. 线程退出"></a>3. 线程退出</h3><p>在上面提到，如果主线程退出，子线程没执行完也会结束。我们也提到，只需要使用（线程退出函数）就可以让当前线程“马上退出”，并且不会影响其他线程的正常运行。</p>
<p>如果所有线程都使用了线程退出函数，那么当所有线程执行结束之后，系统资源（虚拟地址空间）会被操作系统回收。</p>
<p><code>pthread_exit();</code></p>
<p>当线程退出时，还可以通过该函数传出一些数据（其实是这些数据的地址）。 注意不能传出栈中的数据。</p>
<p>可以通过下面三种方式：</p>
<ol>
<li>heap</li>
<li>全局&#x2F;static</li>
<li>接受主线程（调用线程）中的数据，并传出接受的数据。</li>
</ol>
<p>子线程是不能访问主线程的栈空间的，但是主线程可以主动传入。</p>
<h3 id="4-线程回收"><a href="#4-线程回收" class="headerlink" title="4. 线程回收"></a>4. 线程回收</h3><p>主线程回收子线程资源。</p>
<p>回收什么资源呢？</p>
<p>我们知道，线程独占stack等，当线程结束时，stack资源会自动释放，heap，data和text等共享资源由操作系统自动回收。</p>
<p>主线程回收的主要是“内核资源”。这件事子线程自己干不了。</p>
<p><code>pthread_join(tid, **retval);</code></p>
<p>为什么第二个参数接受一个二级指针呢？</p>
<p>因为我们如果要接受<code>pthread_exit();</code> 返回的数据，就要使用一个指针（<code>void*</code>）接受。因为 <code>pthread_exit</code> 返回的数据类型就是 <code>void*</code>。</p>
<p>如果我们要修改一个指针（注意不是指针指向的数据），就要传入一个指针的地址，所以我们就要用指向指针的指针。</p>
<p>注意 join 是一个阻塞函数。</p>
<h3 id="5-线程分离"><a href="#5-线程分离" class="headerlink" title="5. 线程分离"></a>5. 线程分离</h3><p>detach：分离</p>
<p>默认情况下，主线程和子线程是有联系的，即，主线程需要释放子线程拥有的资源。</p>
<p>调用这个函数之后，指定的子线程和主线程分离。当子线程推出的时候，其占用的内核资源就被系统的其他进程接管并回收了。（这意味着 <code>pthread_join()</code> 无法回收子线程资源）</p>
<p>可能你会问，我们已经有了 <code>join</code> 了啊，他已经可以完成线程内核资源回收的任务了，为什么还有有 <code>detach</code> 呢，这是因为 <code>join</code> 是阻塞性函数，也就是说，当子线程不 <code>exit</code> 时，主线程就会一直处于阻塞状态。</p>
<p><code>detach</code> 就是给主线程减负的，当子线程结束时，其资源不需要主线程来回收。</p>
<p>但是当主线程结束时，子线程仍然会结束，即使子线程处于 <code>detach</code> 状态。如果我们希望主线程结束时不影响子线程的执行，应该调用 <code>exit</code> 函数。 </p>
<h2 id="二、线程同步"><a href="#二、线程同步" class="headerlink" title="二、线程同步"></a>二、线程同步</h2><h3 id="1-为什么要同步"><a href="#1-为什么要同步" class="headerlink" title="1. 为什么要同步"></a>1. 为什么要同步</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX (25)</span></span><br><span class="line"><span class="type">int</span> sum;    </span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">add</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch = *(<span class="type">char</span>*)arg;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> old = sum;</span><br><span class="line">        old ++ ;</span><br><span class="line">        <span class="comment">// do something to make thread run currency worse</span></span><br><span class="line">        usleep(<span class="number">5</span>);</span><br><span class="line">        sum = old;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%c]sum = %d\n&quot;</span>, ch, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2;</span><br><span class="line">    <span class="type">char</span> c1 = <span class="string">&#x27;A&#x27;</span>, c2 = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    pthread_create(&amp;p1, <span class="literal">NULL</span>, add, (<span class="type">void</span>*)&amp;c1);</span><br><span class="line">    pthread_create(&amp;p2, <span class="literal">NULL</span>, add, (<span class="type">void</span>*)&amp;c2);</span><br><span class="line">    pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;End, sum = %d\n&quot;</span>, sum);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码希望通过两个线程实现对 sum 的累加，并希望结果为50，但是却不是。</p>
<h3 id="2-互斥锁"><a href="#2-互斥锁" class="headerlink" title="2. 互斥锁"></a>2. 互斥锁</h3><p>如其名，互斥锁只能被一个线程使用。</p>
<p>通过互斥锁，让线程线性执行，这样就不会有并发问题。</p>
<p>锁的个数取决于临界资源而不是线程个数。</p>
<p>另外，可以发现使用互斥锁的函数都是用的mutex指针，这就说明我们的mutex不能分配在 局部内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create mutex</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// init</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// destory</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destory</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">// lock，已经lock会阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">// 已经lock会失败</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<p>key :strict</p>
<blockquote>
<p>用来修饰指针，只有这个关键字修饰的指针才能访问指向的内存地址，其他指针都是不行的（类型匹配也不行）。</p>
<p><strong>TODO:</strong> 但是我测试不行？？</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> *restrict p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ++ *p;</span><br><span class="line">    <span class="type">int</span> *q = (<span class="type">int</span>*)p;</span><br><span class="line">    ++ *q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">add</span>(&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-读写锁"><a href="#3-读写锁" class="headerlink" title="3. 读写锁"></a>3. 读写锁</h3><p>读写锁是互斥锁的升级版。在做读操作的时候可以提高程序的执行效率，如果所有的线程都是读操作，那么都是并行的。而使用互斥锁，读操作是串行的。</p>
<p>其与互斥锁的区别主要在于读操作可以并行，因此，当线程涉及到大量读操作，读写锁的效率比互斥锁高。</p>
<p>读写锁虽然有读锁和写锁，但他是「一把锁」。</p>
<p>写锁的优先级比读锁高。</p>
<p>API:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declare</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">// init</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *restrict rolock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *restrict attr)</span></span>;</span><br><span class="line"><span class="comment">// destory</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_destory</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// read lock，如果已经加了写锁，线程阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// try read lock，如果已经写了写锁，失败返回，不会阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// write lock，只要加了锁（读/写）就会失败，阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// try write lock</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_tryrwlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">// unlock</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Example：下面是，5个线程执行读操作，3个线程执行写操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX (20)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_COUNT  (5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_COUNT (3)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum;    </span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func_read</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread read, id = %lu, sum = %d\n&quot;</span>, <span class="built_in">pthread_self</span>(), sum);</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="built_in">rand</span>() % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func_write</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="type">int</span> cur = sum;</span><br><span class="line">        cur ++ ;   </span><br><span class="line">        sum = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread write, id = %lu, sum = %d\n&quot;</span>, <span class="built_in">pthread_self</span>(), sum);</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_rwlock_init</span>(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">pthread_t</span> rd[READ_COUNT], wr[READ_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; READ_COUNT; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        rd[i] = <span class="built_in">pthread_create</span>(&amp;rd[i], <span class="literal">NULL</span>, func_read, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; WRITE_COUNT; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        wr[i] = <span class="built_in">pthread_create</span>(&amp;wr[i], <span class="literal">NULL</span>, func_write, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; READ_COUNT; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(rd[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; WRITE_COUNT; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(wr[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// expect sum = 60</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Father thread id = %ld\n, sum = %d&quot;</span>, <span class="built_in">pthread_self</span>(), sum);</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_rwlock_destroy</span>(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后，我们可以发现，所有打印出来的 sum 是升序的，这说明我们的读写锁没有问题，另外，我们可以发现，有大量读操作在最后才执行，这是因为前面说的，当一个读操作和一个写操作同时访问同一个临界资源时，写操作的优先级更高。</p>
<h3 id="4-条件变量"><a href="#4-条件变量" class="headerlink" title="4. 条件变量"></a>4. 条件变量</h3><p>严格意义上来说，条件变量的主要作用不是处理线程同步，<strong>而是进行线程的阻塞。</strong></p>
<p>如果多线程下只使用条件变量无法完成线程的同步，必须要配合互斥锁来使用。</p>
<p>那既然有了互斥锁，为什么还要用条件变量呢？主要是为了处理「生产者和消费者模型」。（常规的临界资源只有一份，只允许一个线程访问，而有时候临界资源可能有多份，可以分给多个线程，这就是条件变量的用处）</p>
<p>APIs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declare</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// create</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *restrict cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *restrict atrt)</span></span>;</span><br><span class="line"><span class="comment">// destroy</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// wait，会阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *restrict cond, <span class="type">pthread_mutex_t</span> *restrict mutex)</span></span>; <span class="comment">// 可以发现，这里使用了一个互斥锁;其中，互斥锁是用来同步的，条件变量是用来阻塞线程的。</span></span><br><span class="line"><span class="comment">// time wait，将线程阻塞一段时间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_timewait</span><span class="params">(<span class="type">pthread_cond_t</span> *restrict cond, <span class="type">pthread_mutex_t</span> *restrict mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *restrict abstime)</span></span>; <span class="comment">// 阻塞时间为 sec + nsec。</span></span><br><span class="line"><span class="comment">// signal specific one，至少有一个被解除阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cont_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// signal all，唤醒阻塞在条件变量伤的线程，被阻塞的线程全部解除阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>; 	<span class="comment">// 将所有线程唤醒之后，只有wait成功的线程才会执行，剩下的wait失败的线程会继续阻塞。</span></span><br></pre></td></tr></table></figure>

<p>为什么 pthread_cond_wait() 的参数有一个 mutex？</p>
<blockquote>
<p>首先，我们需要知道 wait 做了什么？</p>
<ol>
<li>释放自己占据的 mutex（作为参数传入）</li>
<li>阻塞，等待被别的线程唤醒</li>
<li>被唤醒后，再次获取 mutex（作为参数传入）</li>
</ol>
<p>现在明白了吧，一般来说，我们执行 cond_wait 的时候，都是已经 mutex_lock 的，如果我们不 unlock 的话，其他线程就无法进入临界区，也就无法 cond_signal，那么被阻塞的线程也就不会被唤醒。也就发生了死锁。</p>
</blockquote>
<p>example1：生产者消费者模型 - 链表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT (5)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node_t</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node_t</span> *next;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line">Node *head;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">produce</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> id = (<span class="type">unsigned</span> <span class="type">long</span>)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 链表不可能满，除非malloc错误</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> val = <span class="built_in">rand</span>() % <span class="number">1000</span>;</span><br><span class="line">        Node *newNode = (Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">        newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        newNode-&gt;val = val;</span><br><span class="line">        <span class="keyword">if</span>(newNode == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[Producer] id = %ld, malloc Wrong\n&quot;</span>, id);</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[Producer%d] id = %lu, val = %d\n&quot;</span>, id, <span class="built_in">pthread_self</span>(), val);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">        <span class="comment">// pthread_cond_broadcast(&amp;mutex);</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">consume</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> id = (<span class="type">unsigned</span> <span class="type">long</span>)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 阻塞消费者进程，并释放它的锁，否则，它既占据着mutex，又占据cond，就会死锁</span></span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);   </span><br><span class="line">        &#125;</span><br><span class="line">        Node *cur = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[Consumer%d] id = %lu, val = %d\n&quot;</span>, id, <span class="built_in">pthread_self</span>(), cur-&gt;val);</span><br><span class="line">        <span class="built_in">free</span>(cur);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">pthread_t</span> t1[COUNT], t2[COUNT];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;t1[i], <span class="literal">NULL</span>, produce, (<span class="type">void</span>*)i);</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;t2[i], <span class="literal">NULL</span>, consume, (<span class="type">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_join</span>(t1[i], <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_join</span>(t2[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;cond);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这个生产者消费者模型中，我们使用链表储存产品，因为理论上可以存储无限个产品，所以只需要使用一个条件变量判断产品队列是否为空。</p>
<p>如果使用数组，即产品是有限的，那么我们还需要一个新的条件变量来判断产品是否满了。</p>
<p>注意我们不能同时使用同一个条件变量判断是否为满和是否为空。</p>
</blockquote>
<p>example2：生产者消费者模型 - 数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="5-信号量"><a href="#5-信号量" class="headerlink" title="5. 信号量"></a>5. 信号量</h3><p>同条件变量一样，信号量主要用于阻塞线程，不能完全保证线程安全，如果要保证线程安全，需要信号量和互斥锁一起使用。</p>
<p>另外，需要注意信号量的wait和条件变量的wait是不同的，这从参数列表就可以发现，信号量的wait参数列表中并没有 mutex 参数，因此，当线程阻塞时，他不会释放获取的 mutex 资源，因此，我们必须通过手工的方式控制信号量和锁的获取顺序：先获取信号量，再获取锁，以避免死锁。</p>
<p><code>&lt;semaphore.h&gt;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declare</span></span><br><span class="line"><span class="type">sem_t</span> sem;</span><br><span class="line"><span class="comment">// create</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br><span class="line">	<span class="comment">// pshared</span></span><br><span class="line">		<span class="comment">// 0: 线程同步</span></span><br><span class="line">		<span class="comment">// !0:进程同步</span></span><br><span class="line">	<span class="comment">// value:初始化当前信号量拥有的资源数，如果资源数为0，线程就会被阻塞了。</span></span><br><span class="line"><span class="comment">// destroy</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="type">se_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">// wait，if value==0，阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">// trywait，不会阻塞，直接失败</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">// timewait，资源数为0时，阻塞线程，在阻塞 abs_timeout 对应的时间之后，解除阻塞线程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec, *abs_timeout)</span></span>;</span><br><span class="line"><span class="comment">// post</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">// get shared value</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span></span>;</span><br><span class="line">	<span class="comment">// 第二个参数返回 shared-value，返回值是用来错误检查的</span></span><br></pre></td></tr></table></figure>

<p>example：生产者和消费者模型</p>
<h3 id="6-timespec"><a href="#6-timespec" class="headerlink" title="6. timespec"></a>6. timespec</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> tv_sec;	<span class="comment">// 秒</span></span><br><span class="line">    <span class="type">long</span> tv_nsec;	<span class="comment">// 纳秒</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// -------</span></span><br><span class="line">time mytim = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timespec</span> tmsp;</span><br><span class="line">tmsp.tv.nsec = <span class="number">0</span>;</span><br><span class="line">tmsp.tv_sec = <span class="built_in">time</span>(<span class="literal">NULL</span>) + <span class="number">100</span>;	<span class="comment">// 线程阻塞100秒s</span></span><br></pre></td></tr></table></figure>

<h2 id="三、线程池"><a href="#三、线程池" class="headerlink" title="三、线程池"></a>三、线程池</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h3><p>为什么要有线程池</p>
<blockquote>
<p>同内存池的设计需求一样，线程池也是用来避免线程的大量创建和销毁所带来的巨大开销。</p>
</blockquote>
<p>线程池的组成部分</p>
<ol>
<li>任务队列：线程就是用来处理任务的，但是可能任务的个数要远大于线程的个数，因此无法一次性处理完所有的任务，因此我们就需要用一个 data struct（一般为数组 or 链表） 将任务存起来。</li>
<li>工作的线程：处理任务队列的任务的消费者，通常有多个。</li>
<li>管理者线程：不处理任务队列的任务，负责管理工作的线程（增加或者销毁线程），只有一个。</li>
</ol>
<p>任务队列的存在也意味着，线程池就差不多是一个生产者消费者模型。线程池负责为负消费者线程和任务队列，而使用者负责维护生产者线程（通过线程池提供的 API 接口）。</p>
<p>任务队列存储的是任务，而任务通常是一个个（回调）函数，因此任务队列需要存储函数的地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">工作线程是一直不停的干活，管理线程是间隔检测的。</span><br><span class="line">如何“销毁”线程？让他们自杀</span><br><span class="line">没干活的线程在哪呢？通过worker函数可以发现，没工作的线程都阻塞在了条件变量里面，那么我们可以唤醒所有线程。</span><br></pre></td></tr></table></figure>

<h3 id="2-虚假唤醒"><a href="#2-虚假唤醒" class="headerlink" title="2. 虚假唤醒"></a>2. 虚假唤醒</h3><p><font color=blue>TODO</font></p>
<h1 id="C-thread-pool-1"><a href="#C-thread-pool-1" class="headerlink" title="C++:thread_pool"></a>C++:thread_pool</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">C++ note</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-15 20:20:57" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-16 09:43:45" itemprop="dateModified" datetime="2023-06-16T09:43:45+08:00">2023-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="EssentialC"><a href="#EssentialC" class="headerlink" title="EssentialC++"></a>EssentialC++</h1><h2 id="0x00-附录"><a href="#0x00-附录" class="headerlink" title="0x00 附录"></a>0x00 附录</h2><h3 id="1-站在巨人的肩膀上"><a href="#1-站在巨人的肩膀上" class="headerlink" title="1. 站在巨人的肩膀上"></a>1. 站在巨人的肩膀上</h3><h3 id="2-英语"><a href="#2-英语" class="headerlink" title="2. 英语"></a>2. 英语</h3><p>parameter：参数列表</p>
<p>classes hierarchy：类层次体系</p>
<p>string literal：字符串常量</p>
<p>character literal：字符常量</p>
<p>dereferencing：(指针)解引用，提领</p>
<p>placehold：占位符</p>
<p>function prototype：函数原型</p>
<p>debugger：调试器</p>
<p>scopre：作用域</p>
<p>predicate：谓词</p>
<p>unary：一元</p>
<p>partition：分区</p>
<p>populate：填充 </p>
<h3 id="3-基于对象的编程风格"><a href="#3-基于对象的编程风格" class="headerlink" title="3. 基于对象的编程风格"></a>3. 基于对象的编程风格</h3><p>基于对象（Object Based）：使用了“对象“的概念，把状态和行为封装在一个对象的内部。</p>
<p>面向对象（Object Oriented）：使用了“对象”的概念，同时还有“继承”和“多态”的概念。</p>
<p>所以，<strong>面向对象</strong>基本上是<strong>基于对象</strong>的一个子集。同时由于面向对象很重视“继承”和“多态”，所以也可以认为面向对象更多是“<strong>面向类</strong>”的。</p>
<p>候捷：基于对象中，类之间的关系比较弱，而面向对象中，类之间的关系很密切。</p>
<h2 id="0xf2-函数与头文件"><a href="#0xf2-函数与头文件" class="headerlink" title="0xf2 函数与头文件"></a>0xf2 函数与头文件</h2><h3 id="1-随机数"><a href="#1-随机数" class="headerlink" title="1. 随机数"></a>1. 随机数</h3><p>如果希望使用(伪)随机数，可以通过 C 标准库的 srand() 和 rand() 函数实现。srand() 用来初始化随机数种子(seed)，一般使用时间来初始化：<code>srand(time(NULL));</code> 。而 rand() 则返回一个 int 范围内的随机数。这两个函数的声明位于头文件 <code>&lt;cstdlib&gt;</code> 中。</p>
<h3 id="2-exit"><a href="#2-exit" class="headerlink" title="2. exit()"></a>2. exit()</h3><p>exit() 的声明在 <code>&lt;cstdlib&gt;</code> 头文件中。 </p>
<h3 id="3-最值"><a href="#3-最值" class="headerlink" title="3. 最值"></a>3. 最值</h3><p>在头文件 <code>&lt;limits&gt;</code> 中的 <strong>class</strong> numeric_limits 中，由很多返回最值的函数。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="type">int</span> b = numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">    <span class="type">double</span> c = numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="type">double</span> d = numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">    <span class="type">double</span> e = numeric_limits&lt;<span class="type">char</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="type">double</span> f = numeric_limits&lt;<span class="type">char</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; e &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-string"><a href="#4-string" class="headerlink" title="4. string"></a>4. string</h3><p>string 居然还有 empty() 函数</p>
<h2 id="0x01-C-编程基础"><a href="#0x01-C-编程基础" class="headerlink" title="0x01 C++ 编程基础"></a>0x01 C++ 编程基础</h2><p>简要介绍了一些 C++ 的基础知识。</p>
<h3 id="1-1-类"><a href="#1-1-类" class="headerlink" title="1.1 类"></a>1.1 类</h3><p>class 机制，赋予了我们增加 <strong>“程序内之类型抽象化层次”</strong> 的能力。</p>
<blockquote>
<p>例如，如果我们要表示一个立方体的特征（体积特征和颜色特征），在最原始最基本的情况下，我们可以用三个浮点数来表示长宽高，一个整数表示颜色。以这么低级的方式来编程，势必让我们的思考不断在 “立方体的抽象类型” 和 “相应于立方体的三个浮点数和一个整数” 之间反复来回。</p>
<p>class 机制，赋予了我们增加 <strong>“程序内之类型抽象化层次”</strong> 的能力。我们可以定义一个 Volumn class 用来表示体积特征，定义一个 Color class 用来表示颜色特征，最后，用一个 Rectangle class 来包含这两个 class。这样，虽然我们同样使用三个浮点数和一个整数，但是我们的思考不在直接面对七个浮点数，而是转为对 Rectangle class 的思考。</p>
<p><strong>我们要记住，数据类型虽然为我们的编程任务提供了基石，但它们并非程序的重心所在。</strong></p>
</blockquote>
<p>一般来说，class 的定义分为两部分，分别写在不同的文件中。其一是所谓 “头文件”，用来声明该 class 的各种操作行为。另一个文件，程序代码文件，则包含了这些操作行为的实现内容。既，<strong>“机制与策略分离的思想”</strong></p>
<p><strong>delete 是语言关键字。</strong> 这也正是 string class 采用 erase() 而非 delete() 来表示 “删去一个字符” 的原因。</p>
<h3 id="1-2-输入和输出"><a href="#1-2-输入和输出" class="headerlink" title="1.2 输入和输出"></a>1.2 输入和输出</h3><p>数据的输入和输出，并非 C++ 语言本身定义的一部分（次精神同 C 语言），而是由 C++ 的一套面向对象的类层次体系（classes hierarchy）提供支持，并作为 C++ 标准库的一员。</p>
<p><strong>无论是标准输入输出，还是文件的输入输出，都是通过对象进行的。</strong></p>
<p>例如标准输入对象（cin），标准输出对象（cout）和标准错误输出对象（cerr）。我们的内容都是对对象执行读入和写入操作的。</p>
<p>标准错误输出和标准输出一样，都将输出结果定向到用户的终端。两者的唯一差别是：cerr 的输出结果并无缓冲区 —- 它会立即显示到用户的终端。（使用 iostream library 提供的操作符 ‘endl’ 可以输出并刷新缓冲区）。</p>
<p>C++ 中用于实现数据输入输出的流类及其继承关系。 </p>
<p><img src="https://s1.328888.xyz/2022/10/09/gk6tw.png" alt="img"></p>
<blockquote>
<p>istream：常用于接收从键盘输入的数据；<br>        ostream：常用于将数据输出到屏幕上；<br>        ifstream：用于读取文件中的数据；<br>        ofstream：用于向文件中写入数据；<br>        iostream：继承自 istream 和 ostream 类，因为该类的功能兼两者于一身，既能用于输入，也能用于输出；<br>        fstream：兼 ifstream 和 ofstream 类功能于一身，既能读取文件中的数据，又能向文件中写入数据。</p>
</blockquote>
<p>因此，如果我们需要使用文件来进行输入输出，我们首先需要实例化相应的文件输入输出对象。然后将标准输入输出对象换成文件输入输出对象即可。</p>
<p>文件的读写：</p>
<ol>
<li>为了打开一个可供输出的文件，我们定义一个 ofstream 对象，并将文件名传入：<code>ofstream outfile(&quot;a.txt&quot;);</code> 。便创建并构造函数初始化了一个 ofstream 对象 outfile。</li>
<li>为了打开一个可供输入的文件，我们定义一个 ifstream 对象，并将文件名传入：<code>ifstream infile(&quot;a.txt&quot;);</code> 。便创建并构造函数初始化了一个 ifstream 对象 infile。</li>
<li>如果想同时读写一个文件，我们得定义一个 fstream 对象，并将文件名和模式信息传入：<code>fstream iofile(&quot;a.txt&quot;, ios_base::app || ios_base::in);</code> 。其中 ios_base 定义了流打开模式信息。详细信息参考<a target="_blank" rel="noopener" href="https://www.apiref.com/cpp-zh/cpp/io/ios_base.html">官方文档</a></li>
</ol>
<h3 id="1-3-数据与运算符"><a href="#1-3-数据与运算符" class="headerlink" title="1.3 数据与运算符"></a>1.3 数据与运算符</h3><p>&lt;&lt; output 运算符</p>
<p>&lt;&lt; input 运算符</p>
<p>. dot 成员选择运算符</p>
<p>-&gt; arrow 成员选择运算符</p>
<p>字符常量分为两类：</p>
<ol>
<li>第一类是大打印字符。</li>
<li>第二类是不可打印字符，例如换行符(‘\n’)或制表符(‘\t’)。由于不可打印字符并无直接的表示法（这表示我们无法使用单一而可显示的字符来独立表示），所以必须以两个字符所组成的字符序列来表示。</li>
</ol>
<p>数据类型决定了对象所能持有的数值范围，同时也决定了对象应该占用多少内存空间。</p>
<p>相较于 C 语言只能采用 &#x3D;（assignment 运算符）来初始化，C ++ 为什么要额外增加构造函数语法来初始化对象呢？这主要是因为 C++ 增加了 class 的机制，例如 complex class，它的初始化需要两个值（一个实部一个虚部），而 assignment 运算符无法完成这个任务。于是增加构造函数来处理“多值初始化”</p>
<p>我们知道，windows下的路径表示使用 ‘\’，而 linux 下的路径表示使用 ‘&#x2F;’，由于 ‘\’ 是转义字符，所以说用字符串保存 windows 下的路径的时候，要使用两个 ‘\’。例如：</p>
<p><code>string path = F:\\essential\\prigram\\chapter1\\demo1.cpp;</code></p>
<p>数组的大小是一个<strong>常量表达式</strong>，它必须在编译时确定（常量可以在编译时确定），而普通变量只能在运行时确定。</p>
<h3 id="1-4-错误"><a href="#1-4-错误" class="headerlink" title="1.4 错误"></a>1.4 错误</h3><p>在 C++ 中，如果你没有在 main() 的末尾写下 return 语句，会自动加上，</p>
<p>off-by-one错误。</p>
<blockquote>
<p><strong>差一错误</strong>（英语：<strong>Off-by-one error</strong>，缩写<strong>OBOE</strong>）是在计数时由于边界条件判断失误导致结果多了一或少了一的错误，通常指<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B">计算机编程</a>中<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E5%BE%AA%E7%8E%AF">循环</a>多了一次或者少了一次的程序错误，属于<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E9%94%99%E8%AF%AF_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)">逻辑错误</a>的一种。比如，程序员在循环中进行比较的时候，本该使用“小于等于”，但却使用了“小于”，或者是程序员没有考虑到一个序列是从0而不是1开始（许多程序语言的数组下标都是这样）。在<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6">数学</a>领域，此错误也时有发生。</p>
</blockquote>
<h3 id="1-5-模版"><a href="#1-5-模版" class="headerlink" title="1.5 模版"></a>1.5 模版</h3><p>在模版中，数据类型作为一个参数存在，在对数据类型赋值时，要用尖括号（&lt;&gt;）包围。</p>
<h3 id="1-6-指针"><a href="#1-6-指针" class="headerlink" title="1.6 指针"></a>1.6 指针</h3><p>指针可以为程序提供一层间接性。从而为程序提供弹性（在第二章和第三章将深切体会）。</p>
<p><code>p-&gt;a</code> 等价于 <code>(*p).a</code> ，arrow 成员选择运算符主要是为了我们方便使用指针而提供的。</p>
<p>在 C++ 动态分配时也可以使用构造函数（将 a 初始化为 3）:<code>int *a = new int(3);</code></p>
<p>C++ 没有为没有提供任何语法让我们得以从 heap 分配数组的同时为其元素设定初值（C 语言可以使用 malloc）。</p>
<p><code>int *a = new int[3];</code></p>
<p>释放为数组分配的空间（[ ]必须放在变量名的前面，delete的后面）：<code>delete []a;</code></p>
<h3 id="1-7-命名空间"><a href="#1-7-命名空间" class="headerlink" title="1.7 命名空间"></a>1.7 命名空间</h3><p>把命名空间和操作系统的文件管理下不同文件夹下文件名的管理练习起来，就很容易理解了。</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-namespaces.html">菜鸟教程</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/namespaces-cpp?view=msvc-170">微软文档</a></p>
<p>练习：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> xjy &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;namespace xjy!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cs &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;namespace cs!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> xjy &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">refunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        xjy::<span class="built_in">func</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;rexjy&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> rexjy &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> xjy;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">refunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">        xjy::<span class="built_in">refunc</span>(); </span><br><span class="line">        <span class="comment">// 如果我们using引入的命名空间和当前命名空间存在相同的函数</span></span><br><span class="line">        <span class="comment">// 并且我们还没有使用namespace::加以区分的话</span></span><br><span class="line">        <span class="comment">// 默认使用自己命名空间下的函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;std&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//     func();</span></span><br><span class="line"><span class="comment">//     xjy::func();</span></span><br><span class="line"><span class="comment">//     xjy::refunc();</span></span><br><span class="line">    rexjy::<span class="built_in">refunc</span>();   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0x02-面向过程的编程风格"><a href="#0x02-面向过程的编程风格" class="headerlink" title="0x02 面向过程的编程风格"></a>0x02 面向过程的编程风格</h2><p>在原书中，通过一步步的优化，将一个简单的低级的函数优化为一个复杂的高级的函数。</p>
<h3 id="2-1-如何编写函数"><a href="#2-1-如何编写函数" class="headerlink" title="2.1 如何编写函数"></a>2.1 如何编写函数</h3><p>在规模较大的程序当中，将一部分的代码封装成函数独立出来又很多好处：</p>
<ol>
<li>用函数调用操作取代编写相同的程序代码，可以使代码更容易读懂。</li>
<li>可以在不同的程序中调用这些函数。</li>
<li>可以更容易地将工作分配给协作开发团队。</li>
</ol>
<p>函数参数扮演者占位符的角色。</p>
<p>函数必须先声明，然后才能被调用。函数的声明让编译器得以检查后续出现的使用方式是否正确 —- 是否有足够的参数，参数类型是否正确，等等。函数证明不必提供函数题，但必须指明返回类型，函数名以及参数列表。此即所谓的<strong>函数原型</strong>。</p>
<p>函数声明中可以忽略参数名，但是不推荐这样做。因为参数名可以为我们提供很多有用的信息。在编写文档的时候，为函数的声明提供参数名也是必要的（不然别人看了你的文档中的某个函数就会一头雾水）。</p>
<p>如果函数的最后一条语句不是 return，那么最后一条语句之后便是该函数的<strong>隐式退出点</strong>。当然，前提是函数的返回类型是 void 你才可以这么做。</p>
<h3 id="2-2-调用函数"><a href="#2-2-调用函数" class="headerlink" title="2.2 调用函数"></a>2.2 调用函数</h3><h4 id="2-2-1-传引用"><a href="#2-2-1-传引用" class="headerlink" title="2.2.1 传引用"></a>2.2.1 传引用</h4><p>by reference（传引用，传址）:所有的引用占用同一个地址（被引用元素的地址）。</p>
<p>C++ 不允许我们改变 reference 所代表的对象，它们必须<strong>从一而终</strong>。reference也必须只想一个对象。</p>
<p>面对 reference 的所有操作和面对 “reference所代表的对象” 所进行的操作一般无二。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> &amp;p1 = a;</span><br><span class="line">    <span class="type">int</span> &amp;p2 = a; </span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; &amp;p1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; &amp;p2 &lt;&lt; endl;</span><br><span class="line">    p1 = <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">    a = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// &amp;p1 = b; // 编译错误</span></span><br><span class="line">    <span class="comment">//int &amp;p3; //Error: &#x27;p3&#x27; declared as reference but not initialized</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 1 1</span><br><span class="line">0x7fffc7134da8 0x7fffc7134da8 0x7fffc7134da8</span><br><span class="line">2 2 2</span><br><span class="line">3 3 3</span><br></pre></td></tr></table></figure>



<p>当我们以 by reference 方式将对象作为函数参数传入时，对象本身并不会复制出另一份 —— 复制的是对象的地址。函数中对该对象进行的任何操作，都是相当于对传入的对象进行<strong>间接操作</strong>。</p>
<p>以 by reference 的方式传入对象有两个理由：</p>
<ol>
<li>得以直接对所传入的对象进行修改。</li>
<li>降低复制大型对象的额外负担以提高程序效率。在这种情况下，我们可能并不想修改对象，为了保证程序的安全性，我们需要将参数同时声明为 const 类型来必然修改对象的操作。</li>
</ol>
<p>在传递参数时，使用 reference 或 point 的区别大致是用法不同罢了，reference 更简单？但是这两种方式传入的参数区别就很大了！point 可能是个空指针，因此当我们 deference 的时候，一定要先确定其值不为空。至于 reference，则必定会代表某个对象，所以不需要做额外的检查。</p>
<p>如果我们想要在函数中返回一个 vector 对象，无论是 point 还是 reference 都是不正确的，因为函数中的 vector 对象是分配在程序堆栈（program stack）上的，在函数结束时就会被释放（实际上是从 stack 中 pop掉了）。但是我们可以在函数中以传值方式返回该 vector 对象，因此返回的乃时对象的副本，它在函数之外依然存在。如下 func1()：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">3</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : a)    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于数组我们没法以 by value 的方式返回，因为数组的本质就是一个指针（by point）。</p>
<p>大多数 C++ 编译器对于 “以 by value 方式返回的 class object” ，都会通过优化程序，加上额外的 reference 参数。</p>
</blockquote>
<h4 id="2-2-2-冒泡排序"><a href="#2-2-2-冒泡排序" class="headerlink" title="2.2.2 冒泡排序"></a>2.2.2 冒泡排序</h4><p>所谓冒泡排序，就是将大的数据或者小的数据冒泡到数据的顶部（我们假设下标为 0 的位置为顶部）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vec)</span> <span class="comment">// 升序排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span>(vec[i] &gt; vec[j])</span><br><span class="line">                <span class="built_in">swap</span>(vec[i], vec[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	再该函数中，每次for:i，就可以确定下标为i的位置经过排序后的值。它的思路是那未经排序时该位置的值和所有未确定位置([i+1,j])的值进行比较，如果比未确定位置的值大就交换，最后就可以找到一个最小值然后放在该位置。</span></span><br><span class="line"><span class="comment">	整个过程就好像把所有数值小的元素冒泡到数组顶部一样。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="2-2-3-作为开关的参数"><a href="#2-2-3-作为开关的参数" class="headerlink" title="2.2.3 作为开关的参数"></a>2.2.3 作为开关的参数</h4><p>​								<strong>——- 为参数提供默认值</strong></p>
<p>在 C++ 中，我们可以为参数提供默认值，所有提供了默认值的参数都必须放在参数列表的末尾。</p>
<p>我们可以利用这个语法，将函数的参数作为一个开关。</p>
<p>例如上面我们编写的冒泡排序。如果我们想要打印排序的流程，即在函数中插入一些 printf() 函数，我们总不能为了这个功能而额外添加一个函数吧，毕竟这个功能可能很少用到。我们也不能在原函数直接添加 printf() 函数吧，当元素很多时，大量的打印信息会造成极大的浪费。</p>
<p>一个方便的且拓展性好的方式是为函数增加一个 “开关” 参数，这个参数作为是否打印信息的 “开关”，默认情况下，这个开关是关闭（设定一个初始值）的，我们甚至可以 “忽略这个参数”，即视这个参数不存在。只有当我们需要打印信息时，传入一个我们设定好的开关参数，函数就会打印我们想要的信息。如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vec, <span class="type">bool</span> flag = <span class="literal">false</span>)</span> <span class="comment">// 升序排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">true</span>)	</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(vec[i] &gt; vec[j])</span><br><span class="line">                <span class="built_in">swap</span>(vec[i], vec[j]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们甚至可以将 bool 类型替换为 int 类型来为这个参数增加更多的功能。</p>
</blockquote>
<p>不过为函数参数提供默认值会给我们带来一个问题，那就是这个默认值是在函数声明时提供，<strong>但不能同时在声明和定义处提供</strong>，还是都提供呢？</p>
<blockquote>
<p><strong>为什么不能在声明和定义处都提供呢？</strong></p>
<p>声明是用户可以看到的部分，<strong>客户非常信任</strong>地使用这个特性，希望得到一定的结果，但是你在实现里使用了不同的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BC%BA%E7%9C%81%E5%80%BC&spm=1001.2101.3001.7020">缺省值</a>，那么将是灾难性的。因此编译器禁止声明和定义时同时定义缺省参数值。</p>
<p><strong>结论：在声明处提供默认值更好！</strong></p>
<p>若声明时没有定义缺省参数值，那么在定义成员函数时可以定义缺省参数值。但这种情况通常<strong>用户是看不见的</strong>，因此应避免。</p>
<p><strong>核心：用户就是上帝！</strong></p>
</blockquote>
<p>在我看来，为参数提供默认值更像是一种<strong>机制</strong>，而你是否使用这个对象（你可以不为这个对象提供参数值，看起来就是好像没有使用这个对象一样），或者是否使用这个默认值更像是一种<strong>策略</strong>。（结合上面冒泡排序的例子理解）</p>
<h3 id="2-3-使用局部静态对象"><a href="#2-3-使用局部静态对象" class="headerlink" title="2.3 使用局部静态对象"></a>2.3 使用局部静态对象</h3><p><strong>为了节省函数之间的通信而将对象定义于 file scope，永远都是一种冒险</strong>。通常，file scope 对象会打乱不同函数之间的<strong>独立性</strong>，使他们难以理解。</p>
<blockquote>
<p>能不定义全局对象，就不要定义全局对象。</p>
</blockquote>
<p>一种好的方式是声明静态对象。</p>
<h3 id="2-4-声明-inline-函数"><a href="#2-4-声明-inline-函数" class="headerlink" title="2.4 声明 inline 函数"></a>2.4 声明 inline 函数</h3><p>将函数声明为 inline，表示<strong>要求</strong>编译器在每个函数函数调用点上，将函数的内容展开。面对一个 inline 函数调用操作，编译器可将该函数的调用操作该为以一份该函数的副本代替。</p>
<p>将函数指定为 inline，只是对编译器提出的一种 <strong>“要求”</strong> 或者说 <strong>“建议”</strong>，也就是说 inline 并不是一种强制性操作。编译器是否执行这项请求，需视编译器而定。</p>
<p>inline 函数的定义，通常放在头文件中。由于编译器必须在它被调用的时候加以展开，所以这个时候其定义必须时有效的。（也就是声明和定义必须在同一个文件当中）</p>
<blockquote>
<p>实测 inline 函数不会再初始化后展开。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/my_life/articles/4089184.html">参考</a></p>
<h3 id="2-5-重载函数"><a href="#2-5-重载函数" class="headerlink" title="2.5 重载函数"></a>2.5 重载函数</h3><p>编译器无法根据类型来区分两个具有相同名称的函数，因为返回类型无法给我们一个足以区分不同重载函数的语境。（你 TM 知道我想返回什么类型？）</p>
<h3 id="2-6-模版函数"><a href="#2-6-模版函数" class="headerlink" title="2.6 模版函数"></a>2.6 模版函数</h3><p>函数模版是一种 <strong>“机制”</strong>，让我们得以将单一函数的内容与希望显示的各种类型绑定（bind）起来。</p>
<p>function template 将参数列表中指定的全部（或部分）参数的类型信息抽离了出来。</p>
<p>function template 以关键字 template 开场，其后紧接着成对尖括号（&lt; &gt;）包围起来的一个或多个标识符。这些标识符表示我们希望 <strong>“推迟决定”</strong> 的数据类型。这些标识符事实上扮演着占位符的角色，用来放置函数参数列表及函数题中的某些实际数据类型。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ta, <span class="keyword">typename</span> Tb&gt;</span><br><span class="line"><span class="function">Ta <span class="title">MAX</span><span class="params">(Ta a, Tb b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">double</span> c = <span class="number">2.43</span>, d = <span class="number">4.34</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MAX</span>(a, b) &lt;&lt; endl &lt;&lt; <span class="built_in">MAX</span>(c, d) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当我们以某种类型调用模版函数时，编译器会将类型与我们模版中的定义绑定（bind）起来，然后生成一份函数实例（参数类型确定）。</p>
<blockquote>
<p>同 inline 函数，这应该是在编译时做的操作。</p>
</blockquote>
<h3 id="2-7-函数指针数组"><a href="#2-7-函数指针数组" class="headerlink" title="2.7 函数指针数组"></a>2.7 函数指针数组</h3><p>直接举例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x;     &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef个一个type，type的实例是一个返回值类型为int</span></span><br><span class="line"><span class="comment">// 有一个int类型参数的函数值怎</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*handler)</span><span class="params">(<span class="type">int</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数指针数组</span></span><br><span class="line">handler cal[<span class="number">3</span>] = &#123;</span><br><span class="line">    &amp;func1, &amp;func2, &amp;func3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">        cout &lt;&lt; cal[i](val) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在定义函数指针数组的时候，最好将函数指针 typedef 成一个单独的类型，这样方便我们编写代码。否则，看看下面的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*cal[<span class="number">3</span>])(<span class="type">int</span>) = &#123;</span><br><span class="line">    &amp;func1, &amp;func2, &amp;func3</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还好理解吗？更复杂一点的呢？（例如返回值类型为指针 or 指向指针的指针。。。）</p>
<p>一定要区分<strong>函数指针</strong> 和 <strong>指针函数</strong></p>
<blockquote>
<p><code>int (*cal)(int, int);</code>	– 函数指针，是一个指针，指针指向一个函数</p>
<p><code>int *cal(int,int);</code>		– 指针函数，是一个函数，函数的返回值类型为一个指针</p>
<p>差异的根源在于同是单目运算符的优先级从右向左。</p>
</blockquote>
<h3 id="2-8-设定头文件"><a href="#2-8-设定头文件" class="headerlink" title="2.8 设定头文件"></a>2.8 设定头文件</h3><p>头文件的拓展名习惯上是 <code>.h</code> 。标准库例外，它没有拓展名。</p>
<p>程序的定义可以有多份，但是声明只能有一份。（机制只能有一个，但是基于机制的策略可以有很多种）。但是有个例外：inline 函数的定义。为了能够拓展 inline 函数的内容，在每个调用点上，编译器都取得其定义。这意味着我们必须将 inline 函数的定义放在头文件中，而不是把它放在各个不同的程序代码文件中。还有个例外就是 const object。和 inline 一样，const 也是 “一次定义” 规则下的例外。<strong>const object 的定义只要一出文件之外便不可见</strong>。这意味着我们可以在多个程序代码文件中加以定义，不会导致任何错误。</p>
<blockquote>
<p>关于 const object 的定义一出文件之外便不可见是 C ++ 独有的性质， C并不具备这个性质。</p>
<p><strong>原因：c++中 const 具有内部链接性，c 中 const默认外部链接性。</strong></p>
<p>我们可以测试一下，有两个文件：</p>
<p>1.c&#x2F;1.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> val = <span class="number">2038</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">func</span>();</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;1.c val = %d\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.c&#x2F;2.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> val = <span class="number">222</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;2.c val = %d\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们以 <code>.c</code> 的后缀编译这两个文件的时候，编译器会给出重定义错误，但如果我们以 <code>.cpp</code> 的后缀编译这两个文件，就可以正常执行。</p>
</blockquote>
<p>一个关于 C++ 中的 const 变量定义在源文件还是头文件的建议：</p>
<blockquote>
<p>作者：雨落惊风<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21622061/answer/2373761045">https://www.zhihu.com/question/21622061/answer/2373761045</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>以下仅适用于c++中（c中有区别，原因：c++中const具有内部链接性，c中const默认外部链接性）</p>
<p>const&#x2F;constexpr定义放在头文件中，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;优点：编译器在进行分离编译时，由于在每个文件中都可以看到<span class="type">const</span>的定义，</span><br><span class="line">从而可以进行编译优化</span><br><span class="line">&gt;缺点：如果编译优化并未发生，</span><br><span class="line">  <span class="number">1.</span> 由于<span class="type">const</span>的内部链接性，每个文件都保存了一份<span class="type">const</span>的副本，</span><br><span class="line">       编译后，内存占用可能过大。</span><br><span class="line">    <span class="number">2.</span> 当对<span class="type">const</span>有变更需求时，每个包含头文件的.cpp文件都需要重新编译，</span><br><span class="line">       编译时间可能很长。</span><br></pre></td></tr></table></figure>

<p>const定义放在源文件中，并在.h头文件中包含对其声明，使用const的.cpp文件包含头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;优点：<span class="number">1.</span> <span class="keyword">extern</span> <span class="type">const</span>作为共享变量，仅仅在定义的.cpp文件被实例化<span class="number">1</span>次，</span><br><span class="line">       使用<span class="type">const</span>的.cpp文件只是包含头文件，</span><br><span class="line">       链接器负责链接到<span class="type">const</span>定义。所以，内存空间占用相对变小。</span><br><span class="line">    <span class="number">2.</span> 由于分离编译，当有需求变更<span class="type">const</span>变量时，仅需要重新编译</span><br><span class="line">       定义<span class="type">const</span>的.cpp源文件即可，其他使用<span class="type">const</span>的.cpp文件，由链接器</span><br><span class="line">       代劳链接到重新编译好的<span class="type">const</span>上，无需对使用<span class="type">const</span>的文件重新编译(g++ -c)。</span><br><span class="line">       所以，编译时间相对变少。</span><br><span class="line">&gt;缺点：当头文件被预处理器展开后，由于其中只有<span class="type">const</span>变量的声明，编译器在</span><br><span class="line">    分离编译时无法获取<span class="type">const</span>的定义值，所以存在无法进行编译优化的问题，</span><br><span class="line">    比如替换<span class="type">const</span>为对应值（做不到啊，<span class="type">const</span>值是啥！）</span><br></pre></td></tr></table></figure>

<p>所以，</p>
<p>如果你在意你程序内存的大小以及出版本时的编译速度（不用加班，oho），你就将const定义放在源文件中，const声明放在头文件中；</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;xxx.cpp</span><br><span class="line">&gt;extern const int noWantJiaBan = ...</span><br><span class="line"></span><br><span class="line">&gt;xxx.h</span><br><span class="line">&gt;extern const int noWantJiaBan;</span><br><span class="line"></span><br><span class="line">&gt;xxx.cpp</span><br><span class="line">&gt;#include &quot;xxx.h&quot;</span><br></pre></td></tr></table></figure>

<p>如果你在意编译优化，那么const定义就放直接放在头文件中.</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;xxx.h</span><br><span class="line">&gt;const int optimizable = ...</span><br><span class="line"></span><br><span class="line">&gt;xxx.cpp</span><br><span class="line">&gt;#include &quot;xxx.h&quot; </span><br></pre></td></tr></table></figure>
</blockquote>
<p>在 file scope 定义的对象，如果可能被多个文件访问，就应该声明于头文件中。因为如果我们没有在程序中声明某个对象，便无法加以访问。</p>
<p>关于头文件由 &lt;&gt; 或者 “” 包围的说明</p>
<blockquote>
<p>更有技术含量的回答是：</p>
<p>如果此文件被认定为标准的成项目的或项目专属的头文件，我们便以尖括号将文件名括住；当编译器搜索此文件时，会先在某些默认的磁盘目录中寻找。</p>
<p>如果此头文件由成对的双引号括住，此文件便被认为是一个用户提供的头文件；搜索此文件时，会由要包含此文件的文件的所在磁盘目录开始找起。</p>
</blockquote>
<h2 id="0x03-范型编程风格"><a href="#0x03-范型编程风格" class="headerlink" title="0x03 范型编程风格"></a>0x03 范型编程风格</h2><h3 id="1-STL"><a href="#1-STL" class="headerlink" title="1. STL"></a>1. STL</h3><p>STL：standard template library</p>
<p>组成：</p>
<ol>
<li>container：<ol>
<li>顺序容器：vector, list, deque, ..</li>
<li>关联容器：map, set, ..</li>
<li>容器适配器：stack, queue, ..</li>
</ol>
</li>
<li>generic algorithm：</li>
</ol>
<p>顺序容器</p>
<blockquote>
<p>顺序容器内元素的地址并不一定连续，但是它的元素位置一定连续。</p>
<p>vector 和 deque 支持随机索引。</p>
<p>list 和 deque 支持双向插入。</p>
</blockquote>
<p>插入（insert）</p>
<blockquote>
<p>push_back 和 push_pop 是特殊的插入操作。</p>
<p>insert 的四种变形：</p>
<p>1. </p>
</blockquote>
<p>范型算法系通过 function template 技术，达到 “与操作对象的类型相互独立” 的目的。而<strong>实现 “与容器无关” 的诀窍，就是不要直接在容器身上进行操作。</strong> 而是借由一对 iterator（first 和 last），表示我们要进行迭代的元素范围。</p>
<blockquote>
<p>对于 iterator last，我们一般将其设置为容器的<strong>终点位置（最后一个元素的下一个位置）</strong>，而不是最后一个元素的位置。并称其为 “哨兵”。</p>
</blockquote>
<h3 id="2-编写你的模板函数-find"><a href="#2-编写你的模板函数-find" class="headerlink" title="2. 编写你的模板函数 - find"></a>2. 编写你的模板函数 - find</h3><p>通过模版来屏蔽元素类型</p>
<p>如何屏蔽容器类型：如果我们使用指针来查找元素的话，那么我们传入某个容器的指针。如果我们能够把指针抽象，无论是哪个容器的指针，我们都能把他们看作普通的 “指针”，这样我们就实现了屏蔽容器的类型。</p>
<blockquote>
<p>vector !&#x3D; array</p>
<p>虽然可以用 array 给 vector 初始化，但是 vector 和 array 仍然是两个概念。</p>
</blockquote>
<p><strong>&lt; — 暂停更新，实在是太费时间，接下来只记录一些书上没有明确说明的nearing – &gt;</strong></p>
<h3 id="3-根据-const-重载"><a href="#3-根据-const-重载" class="headerlink" title="3. 根据 const 重载"></a>3. 根据 const 重载</h3><p>可以根据一个函数是否是 const 的重载，这里的 const 修饰的是函数而不是返回类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">get</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">        </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// compile error</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// accept</span></span><br></pre></td></tr></table></figure>



<h3 id="4-static-in-C-x2F-Cpp"><a href="#4-static-in-C-x2F-Cpp" class="headerlink" title="4. static in C&#x2F;Cpp"></a>4. static in C&#x2F;Cpp</h3><p>static 在 C 中一般作为静态全局&#x2F;局部变量和静态函数存在。</p>
<p>静态函数：</p>
<ol>
<li><p>静态函数的作用域为当前的源文件（屏蔽功能），而局部函数的作用域为整个工程。</p>
</li>
<li><p>静态函数会被一直放在一个一直使用的存储区，直到退出应用程序实列，避免了调用函数时的压栈和出栈，速度快很多。</p>
</li>
</ol>
<p>在 C++ 的 class 中，static 拓展出了 static member function 和 static member variable</p>
<h3 id="5-cerr-amp-amp-cout"><a href="#5-cerr-amp-amp-cout" class="headerlink" title="5. cerr &amp;&amp; cout"></a>5. cerr &amp;&amp; cout</h3><p>std::cerr是标准错误输出流，不需要缓存，直接显示在显示器上，而且只能显示到显示器上，即std::cerr流不能转向。</p>
<p>std::cout需要缓冲区（目的是为了减少屏幕刷新次数，一次全部显示），std::cout流可以转向，例如可将cout流流向文件操作中去。</p>
<p>1.区别<br>cout对应于标准输出流，默认情况下是显示器。这是一个被缓冲的输出，可以被重定向。<br>cerr对应标准错误流，用于显示错误消息。默认情况下被关联到标准输出流，但它不被缓冲，也就说错误消息可以直接发送到显示器，而无需等到缓冲区或者新的换行符时，才被显示。一般情况下不被重定向。</p>
<p>2.为什么要用cerr<br>比如，你的程序遇到调用栈用完了的威胁（无限，没有出口的递归）。<br>你说，你到什么地方借内存，存放你的错误信息？<br>所以有了cerr。其目的，就是在你最需要它的紧急情况下，还能得到输出功能的支持。 缓冲区的目的，就是减少刷屏的次数——比如，你的程序输出圣经中的一篇文章。不带缓冲的话，就会每写一个字母，就输出一个字母，然后刷屏。有了缓冲，你将看到若干句子“同时”就出现在了屏幕上（由内存翻新到显存，然后刷新屏幕）。</p>
<blockquote>
<p>by xjy</p>
<p>因此说 cerr 更像是一种需要在紧急情况下做输出的东西，他并不会终止程序的运行。</p>
</blockquote>
<h3 id="6-enum-的作用域"><a href="#6-enum-的作用域" class="headerlink" title="6. enum 的作用域"></a>6. enum 的作用域</h3><p>enum 内元素的作用域是全局的，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">E1</span> &#123;</span><br><span class="line">    a, b</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">E2</span> &#123;</span><br><span class="line">    a, b</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* compile error</span></span><br><span class="line"><span class="comment">error: &#x27;a&#x27; conflicts with a previous declaration</span></span><br><span class="line"><span class="comment">error: &#x27;b&#x27; conflicts with a previous declaration</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如果我们确实需要在不同的 enum 内声明重名的枚举量，C++ 11 位我们提供了一种新的枚举类型（enum class），其枚举的作用域为类。</p>
<p>这样编译就不会出错，但是使用的时候要加上枚举名来限定枚举量。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">e1</span>&#123;</span><br><span class="line">    d,a,b,c</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">e2</span>&#123;</span><br><span class="line">    b,c,e,a</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e1 var1 = e1::a;</span><br><span class="line">    e2 var2 = e2::a;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 必须强制类型转换</span></span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span>)var1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span>)var2 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于更详细的 enum 和 enum class 的比较 和 enum class 的介绍：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42817477/article/details/109029172?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-109029172-blog-78535754.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-109029172-blog-78535754.pc_relevant_recovery_v2&utm_relevant_index=3">[reference]</a></p>
</blockquote>
<h3 id="7-将临时对象作为参数传给引用"><a href="#7-将临时对象作为参数传给引用" class="headerlink" title="7. 将临时对象作为参数传给引用"></a>7. 将临时对象作为参数传给引用</h3><p>试看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;getx: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;getx: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">g</span>(a+b);</span><br><span class="line">    <span class="comment">//f(a+b);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>上面的两个调用之前，a+b 的值会存在一个临时变量中，当把这个临时变量传给函数 g 时，由于 g 的声明中，参数是 int&amp;，不是常量引用，所以产生以下编译错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.cpp:8:7: error: cannot bind non-const lvalue reference of type &#x27;int&amp;&#x27; to an rvalue of type &#x27;int&#x27;</span><br><span class="line">    8 |     g(3);</span><br></pre></td></tr></table></figure>

<p>意思就是我们不能将一个作为左值 int 引用和一个 int 绑定。</p>
<p>而在 f(a+b) 中，由于 f 定义的参数是 const int&amp;，编译通过。  问题是为什么临时变量作为引用参数传递时，必须是常量引用呢？很多人对此的解释<strong>是临时变量是常量，不允许赋或者改动</strong>，所以当作为非常量引用传递时，编译器就会报错。这个解释在关于理解临时变量不能作为非 const 引用参数这个问题上是可以的，但不够准确。事实上，临时变量是可以被作为左值(LValue)并被赋值的，请看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> test <span class="keyword">operator</span>+(<span class="type">const</span> test &amp;p1, <span class="type">const</span> test &amp;p2);</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> test &amp;p);</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">test</span>() &#123;&#125;</span><br><span class="line">        <span class="built_in">test</span>(<span class="type">int</span> _x) : <span class="built_in">x</span>(_x) &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test <span class="keyword">operator</span>+(<span class="type">const</span> test &amp;p1, <span class="type">const</span> test &amp;p2)</span><br><span class="line">&#123;</span><br><span class="line">    test p3;</span><br><span class="line">    p3.x = p1.x + p2.x;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;you get here!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> p3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> test &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; p.x;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">test <span class="title">a</span><span class="params">(<span class="number">2</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">3</span>)</span>, <span class="title">c</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; ((a + b) = c) &lt;&lt; endl;  <span class="comment">// 临时对象作为左值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// int x = 1, y = 2, z = 3;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; ((x + y) = z) &lt;&lt; endl; // 编译不通过</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面的程序编译通过，而且运行结果是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">you get here!</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>



<p>临时变量确实被赋值，而且成功了。</p>
<blockquote>
<p>至于为什么能成功，作者并没有说，但是从我们在 operator+ 重载函数插入的 cout 语句以及输出可以看出，应该是在 a+b 时调用了该函数，然后生成了一个 “对象”，该对象可以作为左值。</p>
<p>而在 main 函数的最后两条语句，(x+y)&#x3D;z 编译就不通过，大概是因为 x+y 生成的不算是一个 “对象”，而只是一个单纯的值罢了。</p>
</blockquote>
<p>所以，临时变量不能作为非 const 引用参数，不是因为他是常量，而是因为 c++ 编译器的一个关于语义的限制。如果一个参数是以非 const 引用传入，c++ 编译器就有理由认为程序员会在函数中修改这个值，并且这个被修改的引用在函数返回后要发挥作用。</p>
<p>但如果你把一个临时变量当作非 const 引用参数传进来，由于临时变量的特殊性，程序员并不能操作临时变量，而且临时变量随时可能被释放掉，所以，一般说来，修改一个临时变量是毫无意义的，据此，c++ 编译器加入了临时变量不能作为非const 引用的这个语义限制，意在限制这个非常规用法的潜在错误。</p>
<p>还不明白？OK，我们说直白一点，如果你把临时变量作为非 const 引用参数传递，一方面，在函数申明中，使用非常量型的引用告诉编译器你需要得到函数对某个对象的修改结果，可是你自己又不给变量起名字，直接丢弃了函数的修改结果，编译器只能说：“大哥，你这是干啥呢，告诉我把结果给你，等我把结果给你了，你又直接给扔了，你这不是在玩我呢吗？”所以编译器一怒之下就不让过了。这下大家明白了吧？</p>
<blockquote>
<p>所以说，临时对象只能作为右值的理解是片面的。</p>
<p>一个对象必然有左值和右值，系统是否提供给用户使用则是另外一码事</p>
</blockquote>
<h2 id="0x04-基于对象的编程风格"><a href="#0x04-基于对象的编程风格" class="headerlink" title="0x04 基于对象的编程风格"></a>0x04 基于对象的编程风格</h2><h3 id="1-operand-gt-amp-amp"><a href="#1-operand-gt-amp-amp" class="headerlink" title="1. operand -&gt;*  &amp;&amp;  .*"></a>1. operand -&gt;*  &amp;&amp;  .*</h3><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/pointer-to-member-operators-dot-star-and-star?view=msvc-170">rerference - 微软</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/cpp-func-pointer.html">rerference - 菜鸟教程</a></p>
<p><code>-&gt;* 和 .*</code>：指向成员的指针运算符</p>
<blockquote>
<p>当我们的成员函数或者成员变量被记录为指针时，不能再通过 <code>. 或者 -&gt;</code> 直接调用该成员，需要使用指向成员的指针运算符。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;helloBase&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (BaseClass::*Bptr)() = &amp;BaseClass::func1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> BaseClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;HelloDerived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (Derived::*Dptr)() = &amp;Derived::func2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BaseClass b;</span><br><span class="line">    BaseClass *pb = <span class="keyword">new</span> BaseClass;</span><br><span class="line">    (b.*Bptr)();</span><br><span class="line">    (pb-&gt;*Bptr)();</span><br><span class="line">    </span><br><span class="line">    Derived d;</span><br><span class="line">    Derived *pd = <span class="keyword">new</span> Derived;</span><br><span class="line">    (d.*Dptr)();</span><br><span class="line">    (pd-&gt;*Dptr)();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// (pb-&gt;*Dptr)();</span></span><br><span class="line">    (pd-&gt;*Bptr)();</span><br><span class="line">    <span class="comment">// (b.*Dptr)();</span></span><br><span class="line">    (d.*Bptr)();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x05-面向对象的编程风格"><a href="#0x05-面向对象的编程风格" class="headerlink" title="0x05 面向对象的编程风格"></a>0x05 面向对象的编程风格</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yuanch2019/p/11625460.html">析构函数与虚函数</a></p>
<p>局部对象在生命周期结束之后会自动调用 dtor，但是分配在 heap 上的对象在函数结束之后也不会调用 dtor，必须 delete 才会调用。</p>
<p>子类包含父类继承的成员，但是子类不能直接初始化这些成员，需要调用父类的构造函数，让每个类自己控制自己成员的初始化过程。</p>
<p>只要调用基类的构造函数和析构函数，就一定会调用父类的构造函数和析构函数。</p>
<p>如果类 A 有个虚函数，那么类 B 继承类 A，类 C 继承类 B，那么 B 也可以重载这个虚函数。并且父类 A 的指针也可以指向子类 C。</p>
<p>子类可以不实现父类的纯虚函数。存在纯虚函数的类不能被实例化。</p>
<h1 id="侯捷-OOP"><a href="#侯捷-OOP" class="headerlink" title="侯捷 OOP"></a>侯捷 OOP</h1><h2 id="preface"><a href="#preface" class="headerlink" title="preface"></a>preface</h2><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a target="_blank" rel="noopener" href="https://github.com/coder0818/-C-">侯捷资源github</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/coder0818/-C-/tree/master/C++-newC++11&14-HouJie">资料</a></p>
<h3 id="prologue"><a href="#prologue" class="headerlink" title="prologue"></a>prologue</h3><p>一、二：object based</p>
<p>三：some addition</p>
<p>四、：object oritened</p>
<h3 id="English"><a href="#English" class="headerlink" title="English"></a>English</h3><p>oop：object oriented programming，面向对象编程</p>
<p>layout：布局</p>
<p>torment：折磨，煎熬</p>
<p>overload：重载</p>
<p>override：覆写，覆盖</p>
<p>scopre：作用域</p>
<p>interlude：插叙</p>
<p>inheritance：继承</p>
<p>composition：复合</p>
<p>delegation：委托</p>
<p>composite：复合</p>
<p>prototype：原型</p>
<p>explicit：明白的，明去的，清楚的</p>
<p>signatrue：签名</p>
<p>parenthses：小括号， ()</p>
<p>barces：大括号，{}</p>
<p>alias：别名，化名</p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>模版会造成代码的膨胀，但这是必要的，并不是缺点。</p>
<p>编译器会对 function template 进行 实参推导（argument dedution）。即选择类型。</p>
<h3 id="ref1"><a href="#ref1" class="headerlink" title="ref1"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42247231/article/details/105109709">ref1</a></h3><p>今天我们来谈一谈面试 C++ 工程师时经常被谈到的一个问题：为什么析构函数必须是虚函数？为什么默认的析构函数不是虚函数？</p>
<p>首先，我们看一下百度百科对虚函数是怎么定义的:</p>
<p>在某基类中声明为 virtual并在一个或多个派生类中被重新定义的成员函数，用法格式为：virtual 函数返回类型 函数名 ( 参数表 ) { 函数体 }；实现多态性，通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。</p>
<p>好了，现在我们大概知道什么是虚函数，虚函数就是类中使用关键 virtual修饰的成员函数，其目的是为了实现多态性。</p>
<p>那么什么是多态性呢？</p>
<p>所谓多态性，顾名思义就是“多个性态”。更具体一点的就是，用一个名字定义多个函数，这些函数执行不同但相似的工作。最简单的多态性的实现方式就是函数重载和模板，这两种属于静态多态性。还有一种是动态多态性，其实现方式就是我们今天要说的虚函数。</p>
<p>回归正题。</p>
<p>一、为什么析构函数必须是虚函数？</p>
<p>当然了，这么说其实是不太严谨的，因为我完全可以将析构函数定义成非虚函数。这个我们后面再说。</p>
<p>首先我们需要知道析构函数的作用是什么。析构函数是进行类的清理工作，具体来说就是释放构造函数开辟的内存空间和资源，当然我们完全可以在析构函数中进行任何我们想要的操作，比如下面我们给出的示例代码，就在析构函数中打印提示信息。</p>
<p>前面我们在介绍虚函数的时候就说到，为实现多态性，可以通过基类的指针或引用访问派生类的成员。也就是说，声明一个基类指针，这个基类指针可以指向派生类对象。</p>
<p>下面我们来看一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Father</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Father destroyed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Son</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Son destroyed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Father* p = <span class="keyword">new</span> Son;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">class Father destroyed</span><br></pre></td></tr></table></figure>


<p>上面的示例程序中，我们定义了两个类，一个基类，一个派生类，派生类公有继承父类。为了描述简单，这两个类只定义了析构函数，并在析构函数中输出提示信息。在主函数中，我们声明了一个基类的指针，并用一个派生类的实例去初始化这个基类指针，随后删除这个指针。我们看到程序运行的结果，只有基类的析构函数被调用。</p>
<p>为什么会这样呢？指针明明指向的是派生类对象，那删除这个指针，为何只有基类的析构函数被调用，而派生类的析构函数却没有调用呢？</p>
<p>我们先把问题留在这里，接下来我们看看，若析构函数被定义成虚函数会怎么样呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Father</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Father destroyed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Son</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Son destroyed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Father* p = <span class="keyword">new</span> Son;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Son destroyed</span><br><span class="line">class Father destroyed</span><br></pre></td></tr></table></figure>

<p>当基类的析构函数被定义成虚函数时，我们再来删除这个指针时，先调用派生类的析构函数，再调用基类的析构函数，很明显这才是我们想要的结果。因为指针指向的是一个派生类实例，我们销毁这个实例时，肯定是希望即清理派生类自己的资源，同时又清理从基类继承过来的资源。而当基类的析构函数为非虚函数时，删除一个基类指针指向的派生类实例时，只清理了派生类从基类继承过来的资源，而派生类自己独有的资源却没有被清理，这显然不是我们希望的。</p>
<p>所以说，如果一个类会被其他类继承，那么我们有必要将被继承的类（基类）的析构函数定义成虚函数。这样，释放基类指针指向的派生类实例时，清理工作才能全面进行，才不会发生内存泄漏。</p>
<p>二、为什么默认的析构函数不是虚函数？</p>
<p>那么既然基类的析构函数如此有必要被定义成虚函数，为何类的默认析构函数却是非虚函数呢？</p>
<p>首先一点，语言设计者如此设计，肯定是有道理的。</p>
<p>原来是因为，虚函数不同于普通成员函数，当类中有虚成员函数时，类会自动进行一些额外工作。这些额外的工作包括生成虚函数表和虚表指针，虚表指针指向虚函数表。每个类都有自己的虚函数表，虚函数表的作用就是保存本类中虚函数的地址，我们可以把虚函数表形象地看成一个数组，这个数组的每个元素存放的就是各个虚函数的地址。<br>这样一来，就会占用额外的内存，当们定义的类不被其他类继承时，这种内存开销无疑是浪费的。</p>
<p>这样一说，问题就不言而喻了。当我们创建一个类时，系统默认我们不会将该类作为基类，所以就将默认的析构函数定义成非虚函数，这样就不会占用额外的内存空间。同时，系统也相信程序开发者在定义一个基类时，会显示地将基类的析构函数定义成虚函数，此时该类才会维护虚函数表和虚表指针。</p>
<h2 id="lt-一出手就是大家之范-gt"><a href="#lt-一出手就是大家之范-gt" class="headerlink" title="&lt;一出手就是大家之范&gt;"></a>&lt;一出手就是大家之范&gt;</h2><h2 id="一、class-with-no-pointer"><a href="#一、class-with-no-pointer" class="headerlink" title="一、class with no pointer"></a>一、class with no pointer</h2><h4 id="0x01-Introduce"><a href="#0x01-Introduce" class="headerlink" title="0x01 Introduce"></a>0x01 Introduce</h4><h5 id="1-C-vs-C"><a href="#1-C-vs-C" class="headerlink" title="1. C vs C++"></a>1. C vs C++</h5><p>由于 C 语言没有提供足够的关键字，因此 C 语言中能够被函数处理的变量一定是全局变量（局部变量没有意义，它在函数结束之后就释放了）。但这就意味着所有的函数都可以使用这个全局变量。</p>
<h5 id="2-class-based-or-class-oriented"><a href="#2-class-based-or-class-oriented" class="headerlink" title="2. class based or class oriented"></a>2. class based or class oriented</h5><p>只要你写的 class 之间有关系，就可以称为<strong>面向对象</strong>。</p>
<p>Class based: 单一 class</p>
<p>class oriented：多个class，class之间有连续</p>
<h5 id="3-C-code-frame"><a href="#3-C-code-frame" class="headerlink" title="3. C++ code frame"></a>3. C++ code frame</h5><p>.h：classes declaration</p>
<p>.h：standard library </p>
<p>.cpp：one main and others</p>
<h5 id="4-guard-declaration-of-header"><a href="#4-guard-declaration-of-header" class="headerlink" title="4. guard declaration of header"></a>4. guard declaration of header</h5><p>头文件防卫式声明：</p>
<p>避免重复 include。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ifndef __XXX_GUARD__</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __XXX_GUARD__</span></span><br><span class="line">...;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">endif</span></span><br></pre></td></tr></table></figure>

<h5 id="5-layout-of-header"><a href="#5-layout-of-header" class="headerlink" title="5. layout of header"></a>5. layout of header</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;guard&gt;</span></span><br><span class="line"></span><br><span class="line">// 0. forward declarations</span><br><span class="line"></span><br><span class="line">// 1. class declarations</span><br><span class="line"></span><br><span class="line">// 2. class definition</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;/guard&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="6-about-a-x3D-b"><a href="#6-about-a-x3D-b" class="headerlink" title="6. about a &#x3D; b"></a>6. about a &#x3D; b</h5><p>对于类似 <code>a = b;</code> 类型的语句，你应该说： </p>
<p><code>b assigned to a </code>，而不是： </p>
<p><code>a 等于 b</code></p>
<h4 id="0x02-Construtor"><a href="#0x02-Construtor" class="headerlink" title="0x02 Construtor"></a>0x02 Construtor</h4><h5 id="1-access-level"><a href="#1-access-level" class="headerlink" title="1. access level"></a>1. access level</h5><p>class 中一般根据访问级别划分为两大段：public, private。（当然你也可以划分为多个public，private….）</p>
<p>数据部分一般划分为 private，因为我们的数据需要封装起来，不能随便为外界所看到。</p>
<p>函数根据是否需要开放给外界可以划分为 private，也可以划分为 public。</p>
<p>当然，还有另一种 access level：protected。</p>
<h5 id="2-constructor（ctor）"><a href="#2-constructor（ctor）" class="headerlink" title="2. constructor（ctor）"></a>2. constructor（ctor）</h5><p>initialization list（初值列，初始列），只有构造函数才有的语法。当我们使用构造函数时，能使用初值列，不要在大括号内初始化。</p>
<p>因为一个数据的设定有两个阶段：初始化（初值列）和赋值（大括号内）。你如果不在初值列不设定数值，而在大括号内设定数值，就会浪费初始化这一步骤。（这是效率的问题，你明明能一步搞定，为啥走两步呢？</p>
<p>当我们为一个构造函数的所有参数都提供默认值时，此时不能再提供默认的没有参数的构造函数。因为前面的构造函数已经实现了默认构造函数的功能。</p>
<h5 id="3-tmp-var"><a href="#3-tmp-var" class="headerlink" title="3. tmp var"></a>3. tmp var</h5><p>局部变量，没有名字。</p>
<p><a target="_blank" rel="noopener" href="https://blog.popkx.com/why-can-c-language-functions-be-return-local-variables-and-local-variables-are-not-released/">参考</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaomingZeng/article/details/89319861">参考</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lsfv/p/6016764.html">好文！</a></p>
<p><a target="_blank" rel="noopener" href="https://www.3dwindy.com/article/177572">临时变量的常量性</a></p>
<p> 临时变量应该在导致临时变量创建的”完整表达式”求值过程的最后一个步骤被析构</p>
<blockquote>
<p>如果函数返回值是一个对象，要考虑 return 语句的效率。例如<br>        return String(s1 + s2);<br>     	这是临时对象的语法，表示“创建一个临时对象并返回它” 。</p>
<p>不要以为它与“先创建一个局部对象 temp 并返回它的结果”是等价的，如<br>            String temp(s1 + s2);<br>            return temp;</p>
<p>实质不然，上述代码将发生三件事。首先，temp 对象被创建，同时完成初始化；然后拷贝构造函数把 temp 拷贝到保存返回值的外部存储单元中；最后，temp 在函数结束时被销毁（调用析构函数） 。</p>
<p>然而“创建一个临时对象并返回它”的过程是不同的，<strong>编译器直接把临时对象创建并初始化在外部存储单元中</strong>，省去了拷贝和析构的化费，提高了效率。</p>
<p>类似地，我们不要将<br>return int(x + y); &#x2F;&#x2F; 创建一个临时变量并返回它<br>写成<br>int temp &#x3D; x + y;<br>return temp;</p>
<p>由于内部数据类型如 int,float,double 的变量不存在构造函数与析构函数， 虽然该 “临时变量的语法”不会提高多少效率，但是程序更加简洁易读。</p>
</blockquote>
<p>当返回一个变量的时候，我们只想返回这个变量的值，而不是这个变量。</p>
<p>虽然局部变量和临时变量在函数结束后被销毁，但其值仍存放在寄存器 rax 中。</p>
<p>临时对象在表达式完成之后就会被销毁。但如果将一个临时变量返回给一个引用，它的生命周期会延长。</p>
<p><strong>编译器直接把临时对象创建并初始化在外部存储单元中</strong>。这句话我们可以这样理解：返回局部变量时，我们返回的是一个对象，而对象需要创建和销毁。返回临时变量时，我们直接返回了一个值，</p>
<p><code>typename(...)；</code></p>
<p>不可以对临时对象 returnby reference，因为，它们返回的必定是个 local object。</p>
<h4 id="0x03-Const"><a href="#0x03-Const" class="headerlink" title="0x03 Const"></a>0x03 Const</h4><h5 id="1-overload-by-const"><a href="#1-overload-by-const" class="headerlink" title="1. overload by const"></a>1. overload by const</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">imag</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> im; &#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">imag</span><span class="params">()</span> </span>&#123; im = <span class="number">-1</span>; <span class="keyword">return</span> im; &#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-by-value-vs-by-reference-to-const"><a href="#2-by-value-vs-by-reference-to-const" class="headerlink" title="2. by value vs. by reference(to const)"></a>2. by value vs. by reference(to const)</h5><p>上面的（to const）表示可选。</p>
<p>pass&#x2F;return by value or pass&#x2F;return by reference(to const)</p>
<p>引用（reference）为 C++ 特有。引用的底部就是一个指针。传引用就是传指针，但是它更漂亮。</p>
<p>注意并不是传指针一定比传引用快，例如我们只是传一个char，一个字节，而指针则需要四个字节。</p>
<p>当我们传指针（引用）只是为了效率，要加上 const。</p>
<h6 id="3-friend"><a href="#3-friend" class="headerlink" title="3. friend"></a>3. friend</h6><p>将一个函数设置为 friend 之后，该函数可以拿到该对象的 private 数据成员，虽然有时我们也可以通过开放的函数看到 private 成员。但这样做的一个好处是减少通过函数调用拿到成员的函数调用开销。</p>
<p><strong>同个 class 的各个 objects 互为 friends</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">test</span>(<span class="type">int</span> r) : <span class="built_in">val</span>(r) &#123;&#125;</span><br><span class="line">    	<span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(test &amp;x)</span> </span>&#123; <span class="keyword">return</span> x.val; &#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">    	<span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上面的例子中，我们在 func 中直接拿到了另一个对象 x 的私有成员。这是合法的。不需要将 func 声明为 friend。</p>
</blockquote>
<h4 id="0x04-Operator-overload"><a href="#0x04-Operator-overload" class="headerlink" title="0x04 Operator overload"></a>0x04 Operator overload</h4><h5 id="1-this"><a href="#1-this" class="headerlink" title="1. this *"></a>1. this *</h5><p>所有的成员函数都带有一个隐藏的成员参数 – *this，谁调用这个函数，谁就是 this，这个参数一般放在参数列表的最左侧。当成员调用成员函数的时候就会把它的地址放到 this 中。</p>
<h5 id="2-return-way"><a href="#2-return-way" class="headerlink" title="2. return way"></a>2. return way</h5><p>传送者无需知道接收者是否以 reference 形式接受。但是在 C 中，传送者必须知道接收者是否以 pointer 形式接受来决定返回数值还是地址。</p>
<h5 id="3-连串赋值的返回类型"><a href="#3-连串赋值的返回类型" class="headerlink" title="3. 连串赋值的返回类型"></a>3. 连串赋值的返回类型</h5><p>因为赋值运算符（&#x3D;，+&#x3D;，-+ …）的优先级顺序自右向左，因为它可能会出现这种形式：</p>
<p><code>a += b += c</code></p>
<p><code>b+=c</code> 的结果会作为左值交给 <code>a+=</code></p>
<p>此时如果我们重载的 <code>+=</code> 返回了一个 void，那事情就严重了。我们应该返回 <code>b+c</code> 的类型</p>
<p>对任意 a op b，都是 b 作用 op 于 a 身上，即右侧的对象作用到左侧，C++ 不存在左侧的对象作用在右侧的语法。</p>
<p>当我们重载 output(&lt;&lt;) 运算符的时候，不可以重载为成员函数。</p>
<blockquote>
<p>如果我们重载为成员函数，那么 class 对象会作为隐式的最左侧的 operand，而 ostream 对象会作为右 operand，此时如果我们调用该函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>;</span><br><span class="line"><span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">c &lt;&lt; cout;</span><br></pre></td></tr></table></figure>

<p>这显然是不合理的，cout 竟然在右侧！</p>
</blockquote>
<h2 id="二、class-with-pointer"><a href="#二、class-with-pointer" class="headerlink" title="二、class with pointer"></a>二、class with pointer</h2><h3 id="0x01-Big-Three"><a href="#0x01-Big-Three" class="headerlink" title="0x01 Big Three"></a>0x01 Big Three</h3><h4 id="1-what’s-three"><a href="#1-what’s-three" class="headerlink" title="1 what’s three?"></a>1 what’s three?</h4><p> copy structure function </p>
<p>copy assignment struction</p>
<p>destruction function</p>
<h4 id="2-how-copy"><a href="#2-how-copy" class="headerlink" title="2. how copy"></a>2. how copy</h4><p>copy struction</p>
<p><code>string s1(s2);</code></p>
<p><code>string s1 = s2</code>;</p>
<p>copy assignment</p>
<p><code>s1 = s2;</code></p>
<blockquote>
<p>当一个对象第一次出现并利用另一个对象赋值的时候，它会调用拷贝构造函数。</p>
<p>如果对象已经出现，此时再用另一个对象赋值，它会调用拷贝赋值。</p>
</blockquote>
<p>如果你没有在类中提供拷贝构造和拷贝赋值函数，编译器会默认使用自己的那一套函数，就是一个 bit 一个 bit 的copy 过去，也就是说，对于指针类型，它只会把指针 copy 过去，这显然是不合理的，但是对于<strong>非指针</strong>，这是可行的。</p>
<p>因此，对于指针，你必须有你自己的 copy structure function and copy assignment function</p>
<p>拷贝构造函数：构造函数的参数对象是它自己</p>
<p>拷贝赋值函数：重载赋值运算符，参数对象是它自己。当我们使用拷贝赋值时，一定要检查是否是自己赋值给自己。这不仅是效率的问题，还关乎程序的正确性。</p>
<p><code>delete [] ptr;</code> 的 [] 理解为<strong>“关门”</strong>很形象啊。</p>
<blockquote>
<p>总而言之，用同类对象为该对象初始化 or 赋值的操作就是拷贝初始化 or 赋值。</p>
<p>但是默认拷贝只是单纯拷贝 val，对于指针来说，它的 val 就是 只想对象的 address。</p>
<p>这可能（绝大数情况下）并非我们想要的，因此我们需要重载拷贝（初始化 and 赋值）。</p>
<p>就是这么简单。</p>
</blockquote>
<h4 id="3-ctor-and-dtor"><a href="#3-ctor-and-dtor" class="headerlink" title="3. ctor and dtor"></a>3. ctor and dtor</h4><p>构造和析构函数</p>
<p><code>complex();</code> 创建一个临时对象</p>
<p><code>complex c1;</code> 调用默认构造函数创建一个全局&#x2F;局部对象c1</p>
<h3 id="0x02-memory-management"><a href="#0x02-memory-management" class="headerlink" title="0x02  memory management"></a>0x02  memory management</h3><h4 id="1-Local-object"><a href="#1-Local-object" class="headerlink" title="1. Local object"></a>1. Local object</h4><p>also named <strong>auto object</strong>, because it’s memory will be cleaned up automatically by stack.</p>
<h4 id="2-new-and-delete"><a href="#2-new-and-delete" class="headerlink" title="2. new and delete"></a>2. new and delete</h4><blockquote>
<p>new：先分配空间，再调用构造函数</p>
</blockquote>
<p>当我们执行语句：<code>complex *p = new colplex(1,2);</code>的时候，编译器优化为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *mem = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(complex)); <span class="comment">// 分配内存</span></span><br><span class="line">pc = <span class="built_in">static_cast</span>&lt;complex*&gt;(mem); <span class="comment">// 类型转换</span></span><br><span class="line">pc-&gt;complex::<span class="built_in">complex</span>(<span class="number">1</span>,<span class="number">2</span>);	<span class="comment">// call dtor</span></span><br></pre></td></tr></table></figure>

<p>其中，operator new 在内部调用的是 C 的 malloc</p>
<p>complex(1,2) 转换为 complex(pc,1,2);</p>
<blockquote>
<p> delete：先调用 dtor，再释放内存</p>
</blockquote>
<p>当我们执行语句 <code>delete []pc;</code> 的时候，编译器会优化为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">complex::~<span class="built_in">colplex</span>(ps);	<span class="comment">// 析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ps)</span></span>;	<span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure>

<p>operator delete 内部调动 free();</p>
<blockquote>
<p>array new &amp;&amp; array delete</p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/20/3d23ec94b22a0b36.png" alt="IMG"></p>
<p>如果我们使用了 array new 而没有使用 array delete</p>
<p>那么编译器只会调用一次 dtor。</p>
<h2 id="三、Interlude"><a href="#三、Interlude" class="headerlink" title="三、Interlude"></a>三、Interlude</h2><h3 id="0x01-static"><a href="#0x01-static" class="headerlink" title="0x01 static"></a>0x01 static</h3><h4 id="1-静态成员变量"><a href="#1-静态成员变量" class="headerlink" title="1. 静态成员变量"></a>1. 静态成员变量</h4><h5 id="1-1-性质"><a href="#1-1-性质" class="headerlink" title="1.1 性质"></a>1.1 性质</h5><p>静态变量是 一个<strong>类的成员变量</strong>，而不是<strong>类的实例的成员变量</strong>。</p>
<p>静态变量调用的时候可以通过对象调用,也可以通过类直接调用。</p>
<blockquote>
<p> 不能在构造对象的构造函数中初始化静态变量。不然的话你就是把静态变量视为类的实例的一个成员变量，这就与它的定义矛盾了。</p>
</blockquote>
<blockquote>
<p>设计模式中的<strong>单例模式</strong>就是只有一个实例对象，这个实例对象是静态的，并且它的构造函数被放在 private 中。</p>
</blockquote>
<h5 id="1-2-内存分配"><a href="#1-2-内存分配" class="headerlink" title="1.2 内存分配"></a>1.2 内存分配</h5><p>静态就是在程序编译时就分配存储空间，而不是等到运行时才知道，也就是程序加载之后，它的存储空间就已经分配了。这是因为<strong>我们有时候希望即便类的实例销毁了，但我却希望保存它的某些数据</strong>，那么这个时候，静态成员变量就是一个很好的选择。对于被所有类共享的数据可声明成静态变量，它在程序运行前就已经存在了(所以一定要初始化)，它被放到静态存储区，按照出现次序被初始化。 它被所有该类的对象共享，静态变量可以被改变。</p>
<h5 id="1-3-静态成员变量一定要初始化吗"><a href="#1-3-静态成员变量一定要初始化吗" class="headerlink" title="1.3 静态成员变量一定要初始化吗"></a>1.3 静态成员变量一定要初始化吗</h5><p>先上答案：绝绝绝大多数情况下，需要初始化！暂时还不知道不不初始化的情况。</p>
<p>我们知道C++类的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%9D%99%E6%80%81%E6%88%90%E5%91%98&spm=1001.2101.3001.7020">静态成员</a>变量是需要初始化的，但为什么要初始化呢。</p>
<p>其实这句话“静态成员变量是需要初始化的”是有一定问题的，应该说“静态成员变量需要定义”才是准确的，而不是初始化。</p>
<p>两者的区别在于：<strong>初始化是赋一个初始值并且同时分配内存，而定义是只分配<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>。</strong></p>
<p>静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义，实际上是给静态成员变量分配内存。</p>
<p>如果我们没有在类的外部定义静态成员变量，那么我们此时就仅仅只是声明了它，如果我们尝试使用它就会导致编译错误。</p>
<p>当然你也可以不定义它，前提是你不会使用它，但既然你不使用它，你为何声明它，并且声明为静态的，这不是搞笑吗？因此，只要在类中声明了一个静态成员变量，你就有很大的必要在类外部定义它（可以不赋值，此时它应该会被默认初始化为0）。</p>
<h5 id="1-4-为什么-static-成员变量一定要在类外初始化"><a href="#1-4-为什么-static-成员变量一定要在类外初始化" class="headerlink" title="1.4 为什么 static 成员变量一定要在类外初始化"></a>1.4 为什么 static 成员变量一定要在类外初始化</h5><p>先上答案：<strong>不一定！</strong></p>
<p>前面提到，我们要在外部定义（注意不一定是初始化，我们可以不给它赋值）静态成员函数。那么我们可以不可以在类中初始化它呢？ </p>
<p>因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。</p>
<p>《c++primer》里面说在类外定义和初始化是保证<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020">static</a> 成员变量<strong>只被定义一次</strong>的好方法。 但为什么 static const int 就可以在类里面初始化呢？ </p>
<p>想起 C 中一个函数里定义一个 static 变量是为了保证只初始化（分配内存并赋值）一次。</p>
<p>那么，是否可以这样理解: static 数据成员在类外定义和初始化是为了<strong>保证只被定义和初始化一次</strong>,这样编译器就不必考虑类的函数里面第一个对 static 变量的 ’&#x3D;’ 操作是赋值还是初始化了。 static const int 可以在类里面初始化，是因为它既然是 const 的，那程序就不会再去试图初始化了。</p>
<p>什么东西能在类内初始化 ？<br>能在类中初始化的成员只有一种，那就是<strong>静态常量成员</strong>。</p>
<blockquote>
<p>因为静态常量成员是常量，不允许修改，这种情况下是否所有的对象共享同一份数据已经不重要了，因为都是同一常量数据，而且如果不允许直接赋值，那么这个常量就没有意义了，直接就是系统默认的值了。</p>
<p>另外常量在声明时必须同时初始化，否则编译器报错。</p>
</blockquote>
<blockquote>
<p>在我的测试中，发现即使在类中初始化静态成员变量，它也不会算到类的实例的空间当中。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="type">int</span> y;</span><br><span class="line">     <span class="type">const</span> <span class="type">int</span> z = <span class="number">0</span>;</span><br><span class="line">     <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> test a;</span><br><span class="line"> cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>Sizeof(a) 的大小是 4 而不是 8，这谁就说明 static 仍然属于类。</p>
</blockquote>
<blockquote>
<p>c++11现在支持在类内初始化 const 常量成员了。<code>const int count =0;</code>是可以的。</p>
</blockquote>
<h4 id="2-静态成员函数"><a href="#2-静态成员函数" class="headerlink" title="2. 静态成员函数"></a>2. 静态成员函数</h4><h5 id="2-1-性质"><a href="#2-1-性质" class="headerlink" title="2.1 性质"></a>2.1 性质</h5><ol>
<li><p>静态函数没有 this 指针。 （它不属于类的实例）</p>
</li>
<li><p>静态函数只能访问类中的静态成员变量。</p>
</li>
<li><p>静态函数不需要类的实例就可以调用。</p>
</li>
<li><p>静态成员函数不属于任何对象，而是属于类的。</p>
</li>
</ol>
<h5 id="2-2-访问权限"><a href="#2-2-访问权限" class="headerlink" title="2.2 访问权限"></a>2.2 访问权限</h5><p>调用<strong>静态函数</strong>效率要高，因为不需要找类实例的数据就可以执行（所以自然不需要标记类实例地址的 this 指针了，不需要穿参），同时由于没有隐含的this指针，自然无法访问类的其他变量，而<strong>只能访问静态变量</strong>了。</p>
<h5 id="2-3-static-amp-virtual-amp-const"><a href="#2-3-static-amp-virtual-amp-const" class="headerlink" title="2.3 static &amp; virtual &amp; const"></a>2.3 static &amp; virtual &amp; const</h5><p>(1) static 成员函数不能为 virtual：       </p>
<p><code> virtual static void fun() &#123; &#125;//错误</code></p>
<p>原因：</p>
<ol>
<li><p>static成员不属于任何类对象或类实例，故即使给此函数加上virutal也是没意义的。</p>
</li>
<li><p>静态成员函数没有this指针。</p>
</li>
</ol>
<p>(2) static成员函数不能为const函数：</p>
<p>  <code>static void fun() const &#123; &#125; //编译错误</code>  </p>
<p> <code>const static void fun() &#123;&#125;  //可以的</code> </p>
<p>原因：当声明一个非静态成员函数为 const 时，对 this 指针会有影响。对于一个 Test 类中的 const 修饰的成员函数，this 指针相当于 Test const , 而对于非 const 成员函数，this 指针相当于 Test . 而 static 成员函数没有 this 指针，所以使用const 来修饰 static 成员函数没有意义。 volatile 的道理也是如此。</p>
<h5 id="2-4-为啥要引入静态成员函数"><a href="#2-4-为啥要引入静态成员函数" class="headerlink" title="2.4 为啥要引入静态成员函数"></a>2.4 为啥要引入静态成员函数</h5><blockquote>
<p>假如我们需要将对静态成员变量的一系列操作封装起来作为一个成员函数（注意不是静态的），那么如果我们想要调用该函数，就必须实例化一个类的对象。而对象的实例化与销毁是需要开销的，更何况我们只是想操作静态成员变量，仅此而已，为此我们实例化一个对象，这太浪费了。</p>
</blockquote>
<p>我们知道在C++中调用类的成员函数，会传递一个this指针，将类的实例化对象的首地址传递给成员函数，函数操作会根据对象首地址计算其成员变量的地址，然后进行操作。然而静态成员变量并不保存在对象的内存布局中，而是保存在数据段中，因而没有必要用到 this 指针。所以需要一种独立于对象之外对对象静态成员变量的访问操作。在早期 C++ 引入静态成员函数之前，你会看到下面这样奇怪的写法：（假设有类 test，静态成员函数 <code>sfunc()</code>）</p>
<p><code>((test *)0)-&gt;sfunc();</code></p>
<p>编译器生成的代码是先将 ecx 清零，然后直接调用 <code>test::sfunc()</code> 函数。这种写法的优点就在于不用对进行对象实例化操作从而节省了时间和空间。这种写法最早由贝尔实验室的成员 Jonathan Shopiro 提出，他本人也是引入静态成员函数的主要倡导者。</p>
<p>另外，当我们不存在实例并且也不想额外实例化一个对象的时候，静态成员函数为我们提供了操作静态成员变量的方法，这种场景很多。</p>
<p>但注意，它不能操作非静态成员变量，否则当不存在类实例的时候，我们可以调用非静态成员变量，但此时非静态成员变量尚不存在，显然是不合法的。而静态成员变量存储在数据段中，所以它是存在的。</p>
<blockquote>
<p>还有如下好处：</p>
<ol>
<li><p>与类实例无关。</p>
</li>
<li><p>把类名当成namespace用。</p>
</li>
<li><p>控制该函数的访问权限。</p>
</li>
<li><p>控制类内的static变量。</p>
</li>
</ol>
</blockquote>
<h3 id="0x02-namespace"><a href="#0x02-namespace" class="headerlink" title="0x02 namespace"></a>0x02 namespace</h3><h4 id="1-reference"><a href="#1-reference" class="headerlink" title="1. reference"></a>1. reference</h4><p><a target="_blank" rel="noopener" href="https://codeantenna.com/a/gIRJK7VV7N">里面谈到了全局命名空间</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/aiyc/4998037">知乎的讨论</a></p>
<p><a target="_blank" rel="noopener" href="http://129.226.226.195/post/602.html">stack overflow 讨论中文翻译</a></p>
<h4 id="2-using-namespace-std"><a href="#2-using-namespace-std" class="headerlink" title="2. using namespace std"></a>2. using namespace std</h4><p>为什么不要在<strong>头文件</strong>中引入 <code>using namespace std;</code></p>
<blockquote>
<p> <strong>本来只需要一棵树，你缺砍了整个森林。</strong></p>
</blockquote>
<p>这句解释太形象了，有时候你只是想要 cout，cin，但你却把整个标准库 using 进来，太不合理了。</p>
<p>你引入的太多，发生冲突的概率也就越大。</p>
<p>另外，注意我们是不要在 头文件（.h）而不是源文件（.cpp）里面。因为头文件需要开放给他人使用，而 .cpp 文件并不需要开放给他人。</p>
<blockquote>
<p>只是千万不要在头文件里面using而已。</p>
<p>主要是命名冲突，而且冲突以后，编译器给的错误信息基本是妖魔，牛头不对马嘴，难以追查。有些根本编译就没错误和警告，但是就是运行错误。</p>
<p>跟萌心们解释这些很麻烦，而且效果也不是很好，所以一般直接硬性规定头文件不准出现任何一个using。</p>
</blockquote>
<p>比较好的做法应该是自己用一个命名空间封装std，然后using 自己的那个命名空间。</p>
<p><code>x=::a;</code>  a 是全局global作用域下的，不声明 namespace 就是默认处于全局作用域下。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> xjy &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;namespace:xjy&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">2020</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;namespce:global&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; ::a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; xjy::a &lt;&lt; endl;</span><br><span class="line">    ::<span class="built_in">f</span>();</span><br><span class="line">    xjy::<span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Examples"><a href="#3-Examples" class="headerlink" title="3. Examples"></a>3. Examples</h4><p>举个例子1：变量冲突</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> name1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> name2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> name1;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> name2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int a = 10; // (1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在命名空间 name1 和 name2 中我们都定义了一个 a，此时如果把他们全部引入到程序当中，此时再使用 a，就会出现编译错误–命名冲突，但如果我们加入 （1）处语句，程序会成功运行并输出 10，这是因为（1）处的 a 处于<strong>全局命名空间</strong>，他会取代 using 的 a，就像我们 using namespace std 之后，我们再写一个函数 max，它会覆盖标准库的 max 函数。</p>
<p>例子2：函数冲突</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> name1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> name2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> name1;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> name2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a.cpp: In function &#x27;int main()&#x27;:</span><br><span class="line">a.cpp:28:7: error: call of overloaded &#x27;f()&#x27; is ambiguous</span><br><span class="line">   28 |     f();</span><br><span class="line">      |       ^</span><br><span class="line">a.cpp:9:10: note: candidate: &#x27;void name1::f()&#x27;</span><br><span class="line">    9 |     void f()</span><br><span class="line">      |          ^</span><br><span class="line">a.cpp:17:10: note: candidate: &#x27;void name2::f()&#x27;</span><br><span class="line">   17 |     void f()</span><br><span class="line">      |          ^</span><br></pre></td></tr></table></figure>



<p>例子3：与 std 发生冲突</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> max = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; max &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们将 using namespace std 注释掉，程序正确运行并输出 1，但如果不注释掉，max 会命名冲突。</p>
<p>别问我为什么定义一个 max 变量，只要我不引用 std，不就是正确的吗？</p>
<p>但是我引用了你的头文件，而你的头文件中引用了 std，那我就绷不住了 T.T。</p>
<h3 id="0x03-Virtual-function-table"><a href="#0x03-Virtual-function-table" class="headerlink" title="0x03 Virtual function table"></a>0x03 <a target="_blank" rel="noopener" href="https://leehao.me/C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%89%96%E6%9E%90/">Virtual function table</a></h3><p>虚函数表就是一个 <strong>指针数组</strong>，数组的元素就是指向一个虚函数的指针。</p>
<p>虚函数表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了。</p>
<h3 id="0x04-typename"><a href="#0x04-typename" class="headerlink" title="0x04 typename"></a>0x04 typename</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/iotflh/article/details/114789270">Reference</a></p>
<h2 id="四、Oritened-Object"><a href="#四、Oritened-Object" class="headerlink" title="四、Oritened Object"></a>四、Oritened Object</h2><h3 id="0x01-Class-Relation"><a href="#0x01-Class-Relation" class="headerlink" title="0x01 Class Relation"></a>0x01 Class Relation</h3><blockquote>
<p>面向对象的思想就是 class 和 class 之间有各种各样的联系</p>
</blockquote>
<h4 id="1-Composition（has-a）"><a href="#1-Composition（has-a）" class="headerlink" title="1. Composition（has a）"></a>1. Composition（has a）</h4><p>复合表示一种 “has-a” 的关系。即，“我中有你”。</p>
<p>在人类的理解中，一个东西的构造肯定是由内而外的，只有里面构造好了，东西才扎实。同样，C++ 面向对象也要和人类的理解相似。</p>
<blockquote>
<p>复合关系下的构造和析构。</p>
<p>假设现在有一个 Container 类包含 Component 类。</p>
</blockquote>
<p><strong>构造由内而外：</strong></p>
<p>Container 的构造函数首先调用 Component 的 default 构造函数，然后才执行自己。</p>
<p><code>Container::Container(...) : Component() &#123; ... &#125;;</code></p>
<p><strong>析构由外而内：</strong></p>
<p>Container 的析构函数首先执行自己，然后才调用 Component 的析构函数。</p>
<p><code>Container::~Container(...) &#123; .. ~Component() &#125;;</code></p>
<p>如果包含了多个 class，执行的顺序编译器会帮我们实现。</p>
<blockquote>
<p>关于这里的执行顺序问题，在下面 [四 .0X02 .1] 中我们把 component 比作房子中的装饰品，把 container 比作房子。这其实对于这里的理解不太好，因为不都是先建好房子，再装饰房子吗？</p>
<p>我们可以换一种角度，只有把房子装饰好了，才能说这个房子是完整的，而我们要的是一个完整的房子，不是一个空壳。</p>
<p>因此说，我们先构造 compoent，再构造 container。</p>
</blockquote>
<h4 id="2-Inheritance（is-a）"><a href="#2-Inheritance（is-a）" class="headerlink" title="2. Inheritance（is a）"></a>2. Inheritance（is a）</h4><p>is a，表示 “是一种” 的关系。</p>
<p>C++ 给我们提供了三种继承方式（Java 只有 public 一种继承方式，因此在 Java 中，public 可以不写）。</p>
<blockquote>
<p>单纯的继承价值并不大，只有与 “虚函数” 搭配时，继承才能发挥它最大的价值。</p>
</blockquote>
<blockquote>
<p>继承关系下的构造与析构。</p>
<p>假设现在类 Derived 继承自基类（父类） Base。</p>
</blockquote>
<p><strong>构造由内而外：</strong></p>
<p>Derived 的构造函数首先调用 Base 的 default 构造函数，然后才执行自己。</p>
<p><code>Derived::Derived(...) : Base() &#123; ... &#125;;</code></p>
<p><strong>析构由外而内：</strong></p>
<p>Derived 的析构函数首先执行自己，然后才调用 Base 的析构函数。</p>
<p><code>Derived::~Derived( ... ) &#123; ...~Base() &#125;;</code></p>
<blockquote>
<p>Base class 的 dtor 必须是 virtual，否则会出现 undefined behavior。</p>
</blockquote>
<p>[参考本文 Appendix 中的 0x04]</p>
<p>文中提到了：</p>
<ol>
<li>静态多态性 和 动态多态性：函数重载与模版实现静态多态性。虚函数实现动态多态性。</li>
<li>为什么需要将析构函数设置为虚拟函数：避免内存泄漏。</li>
<li>为什么默认的构造函数不是虚函数：避免不必要的内存浪费。</li>
</ol>
<blockquote>
<p>为什么析构函数不设置为虚函数会导致内存泄漏？ —— 动态绑定</p>
<p><strong>virtual function is the basis for dynamic binding</strong> </p>
</blockquote>
<p> 直接的讲，C++中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。 <strong>“假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数”</strong>。 那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。</p>
<h4 id="3-Delegation"><a href="#3-Delegation" class="headerlink" title="3. Delegation"></a>3. Delegation</h4><p><strong>composition by reference</strong></p>
<blockquote>
<p>也有人把 delegation 和 composition 视为一类，这是术语上的差异，明白其<strong>“精神”</strong>即可，怎么称呼其实无关紧要。delegation 的 “精神” 就是 composition by reference。</p>
</blockquote>
<blockquote>
<p>by pointer</p>
<p>The way to pass value is divided into two ways: pass by value and pass by reference. </p>
<p>We find that there is no pass by pointer. why? Because that is what academia(学术界) calls it. <strong>Although we pass by pointer, we still call it pass by reference.</strong></p>
</blockquote>
<p>通过在 class 中引用其他 class 可以提高程序的弹性，我们的源 class 不需要变化（这意味着我们开放给用户的接口不变），而只需要修改引用的 class 即可。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/20/bcce1dd5388a77e9.png" alt="img"></p>
<p>Pimpl: pointer to implement </p>
<h3 id="0x02-virtual-function"><a href="#0x02-virtual-function" class="headerlink" title="0x02 virtual function"></a>0x02 virtual function</h3><blockquote>
<p><strong>virtual function is the basis for dynamic binding</strong></p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/20/56c751f20ee7e7c0.png" alt="img"></p>
<p>this template is not that key template</p>
<h4 id="1-Inheritance-and-composition"><a href="#1-Inheritance-and-composition" class="headerlink" title="1. Inheritance and composition"></a>1. Inheritance and composition</h4><p>当继承和复合都存在的时候，构造和析构的顺序：</p>
<p>这里有两种情况：</p>
<ol>
<li><strong>class</strong> inherit 继承<strong>class</strong> fa，<strong>class</strong> inherit 包含 <strong>class</strong> com</li>
<li><strong>class</strong> inhert 继承 <strong>class</strong> fa，<strong>class</strong> fa 包含 <strong>class</strong> com：这种情况比较明显，<strong>class</strong> inherit contain <strong>class</strong> fa, <strong>class</strong> fa contain <strong>class</strong> com</li>
</ol>
<p>所以我们考虑第一种情况：</p>
<p>构造函数执行顺序：fa -&gt; com -&gt; inherit</p>
<p>析构函数执行顺序：herit-&gt;com-&gt;fa</p>
<blockquote>
<p>为什么总是先调用父类的呢？</p>
</blockquote>
<p>我们可以这样理解：把子类比作一个房子。</p>
<p>子类继承自父类，父类就相当于 “地基”，而子类中的复合类就相当于 “房子中的装饰”，例如地板，墙壁，装饰品等，我们首先得把地基搭好了，然后才能开始建房子，所以说父类肯定在子类之前。</p>
<p>而我们只有把地基搭好，才能装饰我们的房子吧，所以说，复合类也应该在父类之前。</p>
<blockquote>
<p>不过无需太关心这个，而且这个一般和编译器相关。</p>
</blockquote>
<h4 id="2-Inheritance-and-delegation"><a href="#2-Inheritance-and-delegation" class="headerlink" title="2. Inheritance and delegation"></a>2. Inheritance and delegation</h4><p>候捷这里举了一个很经典的例子，来说明继承和委托的典型应用：画图。</p>
<p>在一些画图软件中，我们可能有这样的功能选项：系统给定了你一些图形（圆形，三角等），你可以自己设置这些图形的参数（长宽高，半径等）。</p>
<p>想要用类来表达这个功能，我们首先需要将所有的图形抽象出来，作为一个抽象的 <strong>class</strong> shape，那么 <strong>class</strong> 三角，<strong>class</strong> 圆形等都继承自 <strong>class</strong> shape。然后我们可以把我们的数据传送（委托）给具体的子类（<strong>class</strong> 圆形，<strong>class</strong> 三角形），让它替我们完成数据的处理并描绘出具体的图形。 </p>
<p>这就是通过委托和继承我们将一份数据（图形的参数信息）表达为多种不同的形态（三角形 or 圆形 .. ）。 </p>
<h4 id="3-composite"><a href="#3-composite" class="headerlink" title="3. composite"></a>3. composite</h4><p>设计模式之 complsite（复合）模式。</p>
<h4 id="4-prototype-模式"><a href="#4-prototype-模式" class="headerlink" title="4. prototype 模式"></a>4. prototype 模式</h4><p>设计模式之 prototype（原型） 模式</p>
<h2 id="lt-勿在浮沙筑高台-gt"><a href="#lt-勿在浮沙筑高台-gt" class="headerlink" title="&lt;勿在浮沙筑高台&gt;"></a>&lt;勿在浮沙筑高台&gt;</h2><h2 id="五、object-modle"><a href="#五、object-modle" class="headerlink" title="五、object modle"></a>五、object modle</h2><h3 id="0x01-conversion-function"><a href="#0x01-conversion-function" class="headerlink" title="0x01 conversion function"></a>0x01 conversion function</h3><p>格式：<code>operator TYPE() const &#123; return XX_TYPE; &#125;</code></p>
<p>其中 TYPE 就是我们想要转换成的类型，返回值的类型也是 TYPE，注意<strong>不能有参数和返回类型</strong>。</p>
<p>作为一个转换函数当然不需要参数。没有返回类型是因为返回值的类型和 TYPE 必然相同，C++ 编译器说：“你不用写返回类型，因为 TYPE 已经指出返回类型了，而你写还有可能写错”。</p>
<p>后面通常加上 const，你不加也没错，但是你该加就要加，因为类型转换一般不会改变成员变量。</p>
<p>转换函数和内置类型的转换函数一样，都可以隐式调用。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Fraction</span>(<span class="type">int</span> _num, <span class="type">int</span> _den = <span class="number">1</span>) : <span class="built_in">num</span>(_num), <span class="built_in">den</span>(_den) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是这个 ctor，直接产生解释2</span></span><br><span class="line">    <span class="comment">// explicit Fraction(int _num, int _den = 1) : num(_num), den(_den) &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)num / den;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(<span class="built_in">to_string</span>(num) + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">to_string</span>(den));</span><br><span class="line">    &#125;</span><br><span class="line">    Fraction <span class="keyword">operator</span> +(<span class="type">const</span> Fraction &amp;f) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Fraction</span>(num + f.num, den + f.den);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> den;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">4</span> + f;</span><br><span class="line">    <span class="comment">//double d = f + 4; // ambiguous overload for &#x27;operator+&#x27; (operand types are &#x27;Fraction&#x27; and &#x27;int&#x27;)</span></span><br><span class="line">    cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// extension</span></span><br><span class="line">    string s = f;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意转换函数可能会与我们重载的其它运算符发生冲突。在上面的例子中，如果我们以 <code>double d = f + 4;</code> 的形式调用就会产生二义性，这是因为 <code>f + 4</code> 可以有两种解释形式：</p>
<ol>
<li>调用 <code>operator+</code> 解释 <code>f+4</code> 为一个<code> fraction</code> 类型（因为在  <code>fraction</code> 的构造函数中，我们只需要传入一个参数 <code>num</code> 就可以调用构造函数，所以这里的 <code>4</code> 调用了构造函数），然后调用转换函数，将 <code>fraction(f+4)</code> 转换为 <code>double</code> 类型。</li>
<li>调用转换函数将 <code>f</code> 解释为 <code>double</code>。</li>
</ol>
<blockquote>
<p>我们可以通过如下方式调用构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fraction f = 4;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>不过如果我们不适用<code> f+4</code> 这种形式就不会出现这种错误（自己骗自己），但是要留意这种二义性错误。</p>
<blockquote>
<p>应用：</p>
<p><code>vector</code> 的 <code>[]</code> 就是通过构造函数实现的</p>
</blockquote>
<h3 id="0x02-non-explicit-one-argument-ctor"><a href="#0x02-non-explicit-one-argument-ctor" class="headerlink" title="0x02 non-explicit-one-argument ctor"></a>0x02 non-explicit-one-argument ctor</h3><p>one argument 表示该 ctor “至少” 需要一个实参，也就是说可以是多个实参，但是其他都有默认值，我们只需要一个参数就可以调用 ctor。</p>
<p>explicit 是一个 <strong>key word</strong>，它的意思是：明白的，明确的。用它修饰一个函数（例如构造函数），就是在告诉编译器，我就是一个构造函数，不要那我干其他事情，例如用我做类型转换等。</p>
<p>这个 key word 很少用到，并且百分之九十五的情况下看到这个关键字都是在 ctor 的前面，其它在模版里一个很小的地方也会用到。</p>
<p>其实主要就是为了解决 0x01 中的二义性错误，在上面的例子中，之所以产生二义性错误的主要原因是因为我们的语句：<code>double d = f + 4;</code> 的 <code>4</code> 会调用构造函数，这并不是我们所希望的，我们没有任何显式的表示要让这个 <code>4</code> 作为 <code>Fraction</code> 类型，而且我们的本意也是说 4 是一个 <code>double</code> ，毕竟我们的 <code>d</code> 声明的也是一个 <code>double</code> 类型。</p>
<p>但是编译器“默默”为我们做了这些事，那么有没有什么办法阻止编译器“替”我们调用构造函数吗？有。</p>
<p>通过为构造函数加上关键字 <code>explicit</code>，就可以让 ctor 做他该做的事情（初始化对象），而不是在这里将表达式中的一个变量作为对象并调用构造函数。</p>
<p>这也说明了为啥是 one-argument，因为我们的运算对象通常都是一个变量，你不会一下子 op 两个对象把？<code>a op (b,c)</code> 这不太符合直觉。</p>
<hr>
<h3 id="0x03-xxx-like-classes"><a href="#0x03-xxx-like-classes" class="headerlink" title="0x03 xxx-like classes"></a>0x03 xxx-like classes</h3><h4 id="1-pointer-like-classes"><a href="#1-pointer-like-classes" class="headerlink" title="1.  pointer-like classes"></a>1.  pointer-like classes</h4><p>一个像 pointer 的 class，所谓 <strong>smart pointer</strong>。</p>
<p>为什么把一个 class 设计的像 pointer？因为我们像让它比单纯的指针多做一些事情。</p>
<p>一个智能指针里面一定包含一个真的指针，也就是说智能指针就是对普通指针的封装，并提供了更多的功能，但是它应该实现真的指针的功能（解引用 <code>*</code> 和 <code>-&gt;</code>）。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;you call Foo::method.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>(T *obj) : <span class="built_in">px</span>(obj) &#123;&#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span> *() <span class="type">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *px;</span><br><span class="line">    &#125;</span><br><span class="line">    T* <span class="keyword">operator</span> -&gt;() <span class="type">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// otherway, call operator* but create new</span></span><br><span class="line">        <span class="comment">//return &amp;(operator *());   </span></span><br><span class="line">        <span class="keyword">return</span> px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* px;</span><br><span class="line">    <span class="type">long</span> *pn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Foo&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>; </span><br><span class="line">    <span class="comment">// 把指向shared_ptr类的指针p当做一个指向Foo对象的指针使用即可</span></span><br><span class="line">    (*p).data = <span class="number">1024</span>;</span><br><span class="line">    p-&gt;<span class="built_in">method</span>();</span><br><span class="line">    cout &lt;&lt; p-&gt;data &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    Foo *f = <span class="keyword">new</span> Foo;</span><br><span class="line">    f-&gt;<span class="built_in">method</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的对 std 中的 shared_ptr 简化模拟中，我们可以发现，shared_ptr 内部包含了一个成员变量 - 指针 px，这体现了智能指针其实就是对普通指针的封装。我们还可以在 shared_ptr 中添加一个额外的功能。（但是我并没有。。懒）</p>
<p>然后可以发现我们重载了 <code>*</code> 和 <code>-&gt;</code> 这两个指针必需的运算符</p>
<ol>
<li><code>*</code> 的返回类型是一个对象的引用（<code>&amp;</code>），这我们可以理解。在上面的例子中，我们的语句 <code>(*p).data = 1024;</code> 会被转换为 <code>(*px).data = 1024;</code>  很合理。</li>
<li><code>-&gt;</code> 的返回类型是一个指针（<code>*</code>）。在上面的例子中，我们的语句 <code>p-&gt;method();</code> 会被转换为 <code>pxmethod();</code> what？这非常不合理，我们想要的是：<code>px-&gt;method();</code>  但是我们的 <code>-&gt;</code> 不见了！那我们还怎么调用 <code>method</code>。别担心，<code>-&gt;</code> 有一个性质，就是当它被解释后，它会继续执行执行下去，什么意思呢？在这里的重载函数中，我们实际上是把 <code>-&gt;</code> 解释没了，但其实，它仍然存在。好像有点麻烦，不过你不需要纠结这些，你只要记住 <code>-&gt;</code> 被解释之后也会继续作用在它原本指向的对象就行了。</li>
</ol>
<p>小 tips：</p>
<blockquote>
<p>在重载 <code>-&gt;</code> 之后，我们返回 <code>T*</code>。不要傻乎乎的把 <code>T*</code> 直接在源表达式替换：<code>(*px)-&gt;method();</code></p>
<p>在返回的时候，我们要加上 <code>*</code>表示这是一个指针，但是在使用 “指针”（注意不是指针所指向的对象）的时候，我们不能加上 <code>*</code>，否则就会被解释为指向所指向的对象。</p>
<p>指针其实就是对象的地址的另一种表达方式，同理，地址也是表示指针指向对象的一种表达方式。不要刻意区分他们。</p>
</blockquote>
<p>应用：</p>
<blockquote>
<p>迭代器。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_node</span> &#123;</span><br><span class="line">    <span class="type">void</span> *prev;</span><br><span class="line">    <span class="type">void</span> *next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_iterator</span> &#123;</span><br><span class="line">  <span class="keyword">typedef</span> list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> list_node&lt;T&gt;* link;</span><br><span class="line">  link node;</span><br><span class="line">  </span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> self &amp;x) <span class="type">const</span> &#123; <span class="keyword">return</span> node == x.node; &#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> !=(<span class="type">const</span> self &amp;x) <span class="type">const</span> &#123; <span class="keyword">return</span> node != x.node; &#125;</span><br><span class="line">  </span><br><span class="line">  reference <span class="keyword">operator</span>  *() <span class="type">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line">  pointer   <span class="keyword">operator</span> -&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span> *()); &#125;</span><br><span class="line">  </span><br><span class="line">  self&amp; <span class="keyword">operator</span> ++() &#123; <span class="comment">// pre: ++ x</span></span><br><span class="line">    node = (link)((*node).next);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  self <span class="keyword">operator</span> ++(<span class="type">int</span>)  &#123; <span class="comment">// post: x ++ </span></span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++ (*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  self&amp; <span class="keyword">operator</span> --() &#123; <span class="comment">// pre: -- x</span></span><br><span class="line">    node = (link)((*node).prev);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  self <span class="keyword">operator</span> --(<span class="type">int</span>) &#123; <span class="comment">// post: x --</span></span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    -- (*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-function-like-classes"><a href="#2-function-like-classes" class="headerlink" title="2. function-like classes"></a>2. function-like classes</h4><p>一个像 function 的 class，所谓 <strong>仿函数</strong>，<strong>函数对象（function object）</strong>。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">indetity</span> &#123;</span><br><span class="line">    <span class="comment">// 重载运算符：()</span></span><br><span class="line">    <span class="comment">// 返回类型是：const T&amp;</span></span><br><span class="line">    <span class="comment">// 参数是：T &amp;x</span></span><br><span class="line">    <span class="comment">// 是一个常量成员函数</span></span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; </span></span><br><span class="line"><span class="function">    <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Pair</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">select1st</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="keyword">typename</span> Pair::first_type&amp; </span></span><br><span class="line"><span class="function">    <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> Pair&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Pair</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">select2st</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="keyword">typename</span> Pair::second_type&amp;</span></span><br><span class="line"><span class="function">    <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> Pair &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Pair域下的两个类型变量</span></span><br><span class="line"><span class="comment">    Pair::first_type</span></span><br><span class="line"><span class="comment">    Pair::second_type</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    select1st&lt;pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt;&gt; s1;</span><br><span class="line">    pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; p = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">s1</span>(p) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准库中的仿函数的模拟实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">minus</span> &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;x, <span class="type">const</span> T &amp;y)</span> </span>&#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">equal_to</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;x, <span class="type">const</span> T &amp;y)</span> </span>&#123; <span class="keyword">return</span> x == y; &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;x, <span class="type">const</span> T &amp;y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">plus</span> &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;x, <span class="type">const</span> T &amp;y)</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> eleType&gt;</span></span><br><span class="line"><span class="function">eleType <span class="title">test</span><span class="params">(eleType a, eleType b, T func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; plus&lt;int&gt;()(a,b) &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; minus&lt;int&gt;()(a,b) &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; equal_to&lt;int&gt;()(a,b) &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; less&lt;int&gt;()(a,b) &lt;&lt; std::endl;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">test</span>(a, b, <span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;()) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">test</span>(a, b, <span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;()) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">test</span>(a, b, <span class="built_in">equal_to</span>&lt;<span class="type">int</span>&gt;()) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">test</span>(a, b, <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;()) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-CLASS-NAME-obj"><a href="#3-CLASS-NAME-obj" class="headerlink" title="3. CLASS_NAME obj();"></a>3. CLASS_NAME obj();</h4><p>这个写法是一个经典的错误写法。</p>
<p>下面通过一个例子再深刻理解一下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">test</span>() &#123; cout &lt;&lt; <span class="string">&quot;I am ctor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I am func!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I am &quot;</span> &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们定义了一个函数 print 和一个类 test，main 函数内容为空，程序可以通过编译。</p>
<p>（1）现在，如果我们想定义一个类的对象 p：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">test <span class="title">p</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>程序依然可以通过编译。</p>
<p>（2）接下来，我们希望通过这个对象 p 调用类中的函数 func：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">test <span class="title">p</span><span class="params">()</span></span>; </span><br><span class="line">p.<span class="built_in">func</span>();</span><br></pre></td></tr></table></figure>

<p>发现程序报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: request for member &#x27;func&#x27; in &#x27;p&#x27;, which is of non-class type &#x27;test()&#x27;</span><br><span class="line">   26 |     p.func();</span><br></pre></td></tr></table></figure>

<p>大致意思就是说我们的 p 不是一个 class 类型，所以它不存在成员函数，咦，我们不是定义了一个 class 对象 p 并且编译通过了吗？怎么现在又报错呢？</p>
<p>这是因为 C++ 兼容 C 的缘故，编译器看到 p 后面跟着一个 () ，就会将 <code>test p();</code> 解释为声明一个函数，函数名是 p，返回值类型是 class test。这当然没问题。</p>
<p>但是我们现在通过函数名调用 class 的成员函数 func 就不合理了。</p>
<blockquote>
<p>小插曲：可以在函数的内部声明函数吗？</p>
<p>这关系到 <strong>C 语言的标准规范</strong>和<strong>具体编译器的实现</strong>问题。</p>
<p>　从标准规范来看：</p>
<ol>
<li>C语言<strong>允许函数里声明函数</strong>，但是不建议这么写，因为不利于多文档的组织。</li>
<li>C语言<strong>禁止函数里定义函数</strong>，但是个别编译器却没遵循标准。</li>
<li><strong>C语言的标准</strong>和<strong>编译器的实现</strong>并不是完全统一，为了可移植性，建议一切都按 C 语言标准中推荐的做法来写。</li>
</ol>
<p>综上所述，在函数内声明函数是合法的，并且在链接到另外一个文件中的函数时，也可以在函数内部声明。但是这种语法不应该被我们使用，因为它不利于代码的移植性和规范性。</p>
<p>例如下面两个文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* declare.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;I am &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* main.cpp */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MAIN: &quot;</span> &lt;&lt; <span class="built_in">print</span>(<span class="number">1024</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  g++ declare.cpp main.cpp -o app</span></span><br><span class="line"><span class="comment">//  输出：</span></span><br><span class="line"><span class="comment">//  MAIN: I am 1024</span></span><br><span class="line"><span class="comment">//  1024</span></span><br></pre></td></tr></table></figure>

<p>经过测试发现可以正常执行。</p>
</blockquote>
<p>（3）但是在上一节的例子中，我们的语句 <code>std::cout &lt;&lt; test(a, b, plus&lt;int&gt;()) &lt;&lt; std::endl;</code> 可以正确执行。</p>
<p> <code>plus&lt;int&gt;()</code> 的作用是创建一个 “没有名字的” 临时对象，它会调用默认构造函数并且不会解释为函数。</p>
<p>而且如果我们声明语句： <code>less&lt;int&gt; tmp();</code> 依然会解释为一个函数。</p>
<p>（4）如何声明一个类的临时对象？</p>
<p>在上面的说明中，之所以编译器会将<code> less&lt;int&gt; tmp();</code> 解释为一个函数，其实主要是因为我们指定了“这个东西的名字”！如果我们不指定“名字”，而是直接： <code>less&lt;int&gt; ();</code> 那么编译器就会将这句话看做是声明一个 class less 的临时对象。</p>
<p>综上，创建临时对象的语法：<code>CLASS[&lt;&gt;] ();</code></p>
<p>这就是通过 <code>()</code> 调用默认构造函数，注意不要与上面的东西混淆了，他们的区别仅仅在于是否有名字，但是解释后的结果却截然相反，一个是函数，一个是对象。</p>
<h3 id="0x04-template"><a href="#0x04-template" class="headerlink" title="0x04 template"></a>0x04 template</h3><h4 id="1-class-template"><a href="#1-class-template" class="headerlink" title="1. class template"></a>1. class template</h4><p>不多做介绍。</p>
<h4 id="2-function-template"><a href="#2-function-template" class="headerlink" title="2. function template"></a>2. function template</h4><p>函数模版在编译后得到的是一个 “半成品”，它不一定能保证使用。意思就是模版本身编译可以通过，当真正使用时会再编译一次（这次实参的类型已经确定了），这时能不能通过就不确定了（类型不合适之类，或者你得类没有重载相应的运算符）。</p>
<h4 id="4-member-template"><a href="#4-member-template" class="headerlink" title="4. member template"></a>4. member template</h4><p>成员模板。</p>
<p>向上转型（<strong>up-cast</strong>）：在将继承关系画成图的时候，我们通常将父类画在图的上方，子类画在图的下方，子类指向父类。因为子类到父类的转换我们形象的称其为 “向上转型”。</p>
<p>在成员模板中，子类的对象可以传给父类，因为子类从父类继承，它拥有父类的东西，但是父类不一定包含子类的东西，所以说父类的对象不可以传给父类。当我们把一个子类的对象传给父类的时候，我们说发生了 “<strong>up-case</strong>”。</p>
<p>如图：（我们通常用用△来表示继承关系，用◇箭头表示 point 关系，point 关系的 ◇ 在指针一方而不是指向的对象一方，继承关系的△在父类乙方）<img src="https://s3.bmp.ovh/imgs/2022/10/25/90eda9ffa0c8f118.png" alt="IMG"></p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line">    </span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Pair</span>() : <span class="built_in">first</span>(<span class="built_in">T1</span>()), <span class="built_in">second</span>(<span class="built_in">T2</span>()) &#123; cout &lt;&lt; <span class="string">&quot;ctor1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Pair</span>(<span class="type">const</span> T1 &amp;a, <span class="type">const</span> T2 &amp;b) : <span class="built_in">first</span>(a), <span class="built_in">second</span>(b) &#123; cout &lt;&lt; <span class="string">&quot;ctor2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U1, <span class="keyword">class</span> U2&gt;</span></span><br><span class="line"><span class="function">    <span class="title">Pair</span><span class="params">(<span class="type">const</span> Pair&lt;U1, U2&gt; &amp;p)</span> : first(p.first), second(p.second) &#123;</span> cout&lt;&lt; <span class="string">&quot;ctor3&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;print&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* test 1 */</span></span><br><span class="line">    Pair&lt;<span class="type">char</span>, <span class="type">double</span>&gt; p1 = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="number">23.32</span>&#125;;</span><br><span class="line">    cout &lt;&lt; p1.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p1.second&lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Pair&lt;int, int&gt; p2 = p1;</span></span><br><span class="line">    Pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p2 = <span class="built_in">Pair</span>&lt;<span class="type">char</span>, <span class="type">double</span>&gt;(<span class="string">&#x27;A&#x27;</span>, <span class="number">23.32</span>);</span><br><span class="line">    cout &lt;&lt; p2.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p2.second&lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/* test 2 */</span></span><br><span class="line">    <span class="comment">// 向上转型</span></span><br><span class="line">    Pair&lt;Base, Base&gt; p3;</span><br><span class="line">    Pair&lt;Derived, Derived&gt; p4;</span><br><span class="line"></span><br><span class="line">    Pair&lt;Base, Base&gt; p5 = <span class="built_in">Pair</span>&lt;Derived, Derived&gt;(); <span class="comment">// up-cast</span></span><br><span class="line">    Pair&lt;Base, Base&gt; p6 = p4;   <span class="comment">// up-cast</span></span><br><span class="line">    <span class="comment">// Pair&lt;Derived, Derived&gt; p7 = p3;  // cant up-cast</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* test3 */</span></span><br><span class="line">    <span class="comment">// 声明一个临时对象</span></span><br><span class="line">    <span class="built_in">Pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; ().<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会问，为什么可以把子类的传给父类，而父类不可以传给子类？</p>
<blockquote>
<p>s别钻牛角筋。你只需要牢记，面向对象的考虑都是从现实生活考虑的。</p>
<p>现在假设动物是父类，哺乳类和鸟类分别是子类。（<strong>up-cast</strong>）</p>
<p>哺乳动物和鸟类是动物，但是动物不一定是鸟类或者哺乳类。</p>
<p>就是这么简单。</p>
</blockquote>
<h4 id="5-specialization"><a href="#5-specialization" class="headerlink" title="5. specialization"></a>5. specialization</h4><h5 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h5><p>模板特化就是将模板中的一部分类型抽离出来，明确的规定好是什么类型。</p>
<p>模板特化的种类：</p>
<ol>
<li><p>(full) specialization：模版特化（全特化）</p>
</li>
<li><p>paritical specialization：模版偏特化（局部特化）</p>
<p>(1) 个数的偏特化</p>
<p>(2) 范围的偏特化</p>
</li>
<li><p>template template parameter：模版模版参数</p>
</li>
</ol>
<p>语法：就如同我们前面说的那样，模板特化就是在原模板的基础上，将一部分类型从模板中 “抽离” 出来，直接写在类名的后面，然后在模板中删去这个类型即可。但是在偏特化中，即使我们只是抽取了一部分类型，也要把所有类型写在类中。</p>
<h5 id="5-2-全特化和偏特化"><a href="#5-2-全特化和偏特化" class="headerlink" title="5. 2 全特化和偏特化"></a>5. 2 全特化和偏特化</h5><p>类模板全特化的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hash</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Hash</span>() &#123; cout &lt;&lt; <span class="string">&quot;T1 &amp;&amp; T2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板全特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="comment">// 抽离 class key</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hash</span>&lt;<span class="type">int</span>, <span class="type">char</span>&gt; &#123; <span class="comment">// 加上 &lt;int&gt;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Hash</span>() &#123; cout &lt;&lt; <span class="string">&quot;int &amp;&amp; char&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (个数)模板偏特化 1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hash</span>&lt;T2, <span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Hash</span>() &#123; cout &lt;&lt; <span class="string">&quot;T2 &amp;&amp; int&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (个数)模板偏特化 2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hash</span>&lt;<span class="type">int</span>, T2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Hash</span>() &#123; cout &lt;&lt; <span class="string">&quot;int &amp;&amp; T2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (范围)模板偏特化 1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hash</span>&lt;T1*, T2*&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Hash</span>() &#123; cout &lt;&lt; <span class="string">&quot;T1* &amp;&amp; T2*&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (范围)模板偏特化 2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hash</span>&lt;<span class="type">int</span>*, T2*&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Hash</span>() &#123; cout &lt;&lt; <span class="string">&quot;int* &amp;&amp; T2*&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Hash&lt;<span class="type">int</span>,  <span class="type">char</span>&gt;   h1;    <span class="comment">// int &amp;&amp; char</span></span><br><span class="line">    <span class="comment">// Hash&lt;int,  int&gt;  h2; // ambiguous</span></span><br><span class="line">    Hash&lt;<span class="type">char</span>, <span class="type">char</span>&gt;   h3;    <span class="comment">// T1 &amp;&amp; T2</span></span><br><span class="line">    Hash&lt;<span class="type">char</span>, <span class="type">int</span>&gt;    h4;    <span class="comment">// T2 &amp;&amp; int</span></span><br><span class="line">    Hash&lt;<span class="type">int</span>*, <span class="type">int</span>*&gt;   h5;    <span class="comment">// int* &amp;&amp; T2*</span></span><br><span class="line">    Hash&lt;<span class="type">char</span>*, <span class="type">char</span>*&gt; h6;    <span class="comment">// T1* &amp;&amp; T2*</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们将模板的类型固定为具体类型（指定类型的指针也是具体类型）的时候，我们称其为<strong>个数偏特化</strong>，如果固定为一个指针（没有指定类型），称为<strong>范围偏特化</strong>。</p>
<p>可以发现，模板特化与模板可以共存，并且当我们传入的类型可以从特化的模板中匹配时，会<strong>优先考虑特化的模板</strong>，如果有很多个特化的模板可供选择，选择<strong>特化程度最高的</strong>。</p>
<p>另外，当我们声明 h2 的时候会产生二义性，这是因为两个个数偏特化的模板都符合要求，并且优先级相同，编译器不知道调用那个了。同样 h7 也会产生二义性，因为个数偏特化2 和 范围偏特化1 发生了冲突。</p>
<p>由此，我们可以发现模板特化很容易产生冲突啊。</p>
<p>上面的例子都是特化类模板，如果我们特化的是函数模板呢？加入此时同时存在普通函数，特化模板，纯模板，函数调用的优先级是什么呢?</p>
<blockquote>
<p>普通函数的优先级 &gt; 特化 &gt; 非特化</p>
</blockquote>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template&lt;T1, T2&gt; func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template&lt;int,int&gt; func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, T2 b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template&lt;int,int&gt; func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;normal func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">3.14</span>;</span><br><span class="line">    <span class="built_in">func</span>(a, b); <span class="comment">// int,int</span></span><br><span class="line">    <span class="built_in">func</span>(a, d); <span class="comment">// int, double</span></span><br><span class="line">    <span class="built_in">func</span>(c, d); <span class="comment">// char, double</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*normal func</span></span><br><span class="line"><span class="comment">template&lt;int,int&gt; func</span></span><br><span class="line"><span class="comment">template&lt;T1, T2&gt; func*/</span></span><br></pre></td></tr></table></figure>

<p>使用普通函数重载和使用模板特化还是有不同之处，主要表现在如下三个方面：</p>
<ol>
<li><p>如果使用普通重载函数，那么不管是否发生实际的函数调用，都会在目标文件中生成该函数的二进制代码。而如果使用模板的特化版本，除非发生函数调用，否则不会在目标文件中包含特化模板函数的二进制代码。这符合函数模板的“<strong>惰性实例化</strong>”准则。</p>
</li>
<li><p>如果使用普通重载函数，那么在分离编译模式下，需要在各个源文件中包含重载函数的申明，否则在某些源文件中就会使用模板函数，而不是重载函数。</p>
</li>
<li><p>模板特化版本还是模板，必须放到头文件里面。普通函数重载得放在.c和.cpp里面。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e78d9d3bf535">为什么不该特化函数模板</a></p>
<h5 id="5-3-模板模板参数"><a href="#5-3-模板模板参数" class="headerlink" title="5.3 模板模板参数"></a>5.3 模板模板参数</h5><p>模板模板参数的含义就是模板的一个参数又是一个模板。</p>
<p>例如：<a target="_blank" rel="noopener" href="https://blog.csdn.net/men_wen/article/details/74033327">参考自</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板类 XCls 的一个参数是一个又是一个模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, </span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; </span><br><span class="line">        <span class="keyword">typename</span> Container</span><br><span class="line">        &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TT</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Container&lt;T&gt; c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2 = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Foo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T1 t1;</span><br><span class="line">        T2 t2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TT&lt;string, Bar&gt; mylst1;</span><br><span class="line">    TT&lt;string, Foo&gt; mylst2;</span><br><span class="line">    <span class="comment">// 很奇怪</span></span><br><span class="line">    <span class="comment">// TT&lt;string, list&gt;   mylst3;</span></span><br><span class="line">    <span class="comment">// TT&lt;string, map&gt;    mylst4;</span></span><br><span class="line">    TT&lt;string, set&gt;    mylst5;</span><br><span class="line">    TT&lt;string, vector&gt; mylst6;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="0x05-reference-VS-pointer"><a href="#0x05-reference-VS-pointer" class="headerlink" title="0x05 reference VS. pointer"></a>0x05 reference VS. pointer</h3><p>引用：代表</p>
<p>指针：指向</p>
<p>引用的底层实现就是指针</p>
<p>reference 就是一种漂亮的 pointer</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cnmilan/article/details/7464233?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-7464233-blog-78511858.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-7464233-blog-78511858.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=1">[1]</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/384591552">[3]</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33868027/article/details/86379309?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-86379309-blog-7464233.pc_relevant_layerdownloadsortv1&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-86379309-blog-7464233.pc_relevant_layerdownloadsortv1&utm_relevant_index=1">[2]</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/coutamg/article/details/61924902?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-61924902-blog-100904422.pc_relevant_layerdownloadsortv1&spm=1001.2101.3001.4242.1&utm_relevant_index=3">[4]</a></p>
<p>signature签名, const算函数签名，但是引用不算</p>
<p>string 内部是一个指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;sddsdasa&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="0x06-vptr-amp-amp-vtbl"><a href="#0x06-vptr-amp-amp-vtbl" class="headerlink" title="0x06 vptr &amp;&amp; vtbl"></a>0x06 vptr &amp;&amp; vtbl</h3><p><img src="https://s3.bmp.ovh/imgs/2022/10/25/e00b2a81977cdfb5.png" alt="img"></p>
<p>虚指针和虚表:放的都是函数指针</p>
<p>在继承中，成员变量直接把内存也继承了过来，而成员函数只是继承了使用权（它不会在生成一份），因此，如果父类有虚函数，子类也一定有（不管你有没有实现）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> data1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> data2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="type">int</span> data1;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> data3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    C c;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">sizeof</span>(c) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们可以发现 sizeof(a)=16，这是因为虚指针占用8字字节并且对其的原因</span></span><br></pre></td></tr></table></figure>

<p>打印虚函数的地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="type">int</span> base_data;</span><br><span class="line">    <span class="built_in">Base</span>() &#123; base_data = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;base_func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;base_func2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;base_func3&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="type">int</span> derive_data;</span><br><span class="line">    <span class="built_in">Derive</span>() &#123; derive_data = <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;derive_func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;derive_func2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*func)</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base base;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;base: &quot;</span> &lt;&lt; &amp;base &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;base.base_data: &quot;</span> &lt;&lt; &amp;base.base_data &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    Derive derive;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;derive: &quot;</span> &lt;&lt; &amp;derive &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;derive.base_data: &quot;</span> &lt;&lt; &amp;derive.base_data &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;derive.derive_data: &quot;</span> &lt;&lt; &amp;derive.derive_data &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 对象和第一个数据之间的地址差了8，这个8应该存放的时虚指针 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// &amp;base : base首地址</span></span><br><span class="line">        <span class="comment">// (unsigned long*)&amp;base : base的首地址，vptr的地址</span></span><br><span class="line">        <span class="comment">// (*(unsigned long*)&amp;base) : vptr的内容，即vtable的地址，指向第一个虚函数的slot的地址</span></span><br><span class="line">        <span class="comment">// (unsigned long*)(*(unsigned long*)&amp;base) : vtable的地址，指向第一个虚函数的slot的地址</span></span><br><span class="line">        <span class="comment">// vtbl : 指向虚函数slot的地址</span></span><br><span class="line">        <span class="comment">// *vtbl : 虚函数的地址</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>* vtbl = (<span class="type">unsigned</span> <span class="type">long</span>*)(*(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;base) + i;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;slot address: &quot;</span> &lt;&lt; vtbl &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func address: &quot;</span> &lt;&lt; *vtbl &lt;&lt; endl;</span><br><span class="line">        func pfunc = (func)*(vtbl);</span><br><span class="line">        <span class="built_in">pfunc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>* vtbl = (<span class="type">unsigned</span> <span class="type">long</span>*)(*(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;derive) + i;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;slot address: &quot;</span> &lt;&lt; vtbl &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func address: &quot;</span> &lt;&lt; *vtbl &lt;&lt; endl;</span><br><span class="line">        func pfunc = (func)*(vtbl);</span><br><span class="line">        <span class="built_in">pfunc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态绑定的三个条件：指针调用。向上转型。调用虚函数。</p>
<h3 id="0x07-class-VS-struct-in-C"><a href="#0x07-class-VS-struct-in-C" class="headerlink" title="0x07 class VS. struct in C++"></a>0x07 class VS. struct in C++</h3><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 中保留了C语言的 struct 关键字，并且加以扩充。在C语言中，struct 只能包含成员变量，不能包含成员函数。而在C++中，struct 类似于 class，既可以包含成员变量，又可以包含成员函数。</p>
<p>C++中的 struct 和 class 基本是通用的，唯有几个细节不同：</p>
<ul>
<li>使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。</li>
<li>class 继承默认是 private 继承，而 struct 继承默认是 public 继承。</li>
<li>class 可以使用模板，而 struct 不能（《<a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/biancheng/cpp/rumen_14/">模板、字符串和异常</a>》一章会讲解模板）。</li>
</ul>
<p>C++ 没有抛弃C语言中的 struct 关键字，其意义就在于给C语言程序开发人员有一个归属感，并且能让C++编译器兼容以前用C语言开发出来的项目。</p>
<p><strong>在编写C++代码时，我强烈建议使用 class 来定义类，而使用 struct 来定义单纯的结构体（无函数），这样做语义更加明确。</strong></p>
<p>在 C 语言中，结构体内无法声明函数，但是我们增加一层抽象（计算机的问题总是可以通过抽象解决），在结构内声明一个指针，让这个指针指向某个函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;func::f&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;self[x]&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="built_in">void</span> (*p1)();</span><br><span class="line">    <span class="built_in">int</span> (*p2)(<span class="type">int</span>);</span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   node s = &#123;</span><br><span class="line">      .data = <span class="number">1</span>,</span><br><span class="line">      .p1 = f,</span><br><span class="line">      .p2 = g</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data: %d\n&quot;</span>, s.data);</span><br><span class="line">    s.<span class="built_in">p1</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p2: %d\n&quot;</span>, s.<span class="built_in">p2</span>(<span class="number">1024</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="0x08-Using"><a href="#0x08-Using" class="headerlink" title="0x08 Using"></a>0x08 Using</h3><h4 id="1-management-namespace"><a href="#1-management-namespace" class="headerlink" title="1. management namespace"></a>1. management namespace</h4><p>配合命名空间，对命名空间权限进行管理**</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//释放整个命名空间到当前作用域</span></span><br><span class="line"><span class="keyword">using</span> std::cout;    <span class="comment">//释放某个变量到当前作用域</span></span><br></pre></td></tr></table></figure>

<h4 id="2-type-alias"><a href="#2-type-alias" class="headerlink" title="2. type alias"></a>2. type alias</h4><p>类型重命名。作用等同typedef，但是逻辑上更直观。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*tptr)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">using</span> uptr = <span class="built_in">void</span>(*)();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;you call f^ ^&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tptr tp = f;</span><br><span class="line">    uptr up = f;</span><br><span class="line">    <span class="built_in">tp</span>();</span><br><span class="line">    <span class="built_in">up</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-inherit-permission"><a href="#3-inherit-permission" class="headerlink" title="3. inherit permission"></a>3. inherit permission</h4><p>继承体系中，改变部分接口的继承权限。</p>
<p>有这样一种应用场景，比如我们需要私有继承一个基类，然后又想将基类中的某些 public 接口在子类对象实例化后对外开放直接使用。如下即可</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/376368003">附：私有继承</a></p>
<h4 id="4-TODO-VS-typedef-amp-define"><a href="#4-TODO-VS-typedef-amp-define" class="headerlink" title="4.TODO: VS. typedef &amp; define"></a>4.TODO: VS. typedef &amp; define</h4><h3 id="0x09-delete-amp-new"><a href="#0x09-delete-amp-new" class="headerlink" title="0x09 delete &amp; new"></a>0x09 delete &amp; new</h3><p>我们在前面已经提到过，调用 new 和 delete 时编译器会转化为调用 operator new 和 operator delete，而 operator new 和 operator delete 的底层调用是 malloc 和 free。也就是对 malloc 和 free 的封装。</p>
<p>我们可以重载 new 和 delete，通过重载 operator new 和 operator delete，实际上就是以我们自己的方式封装 malloc 和 free。</p>
<p><a target="_blank" rel="noopener" href="https://bbs.csdn.net/topics/390822574">重载的 delete 为什么不能执行</a></p>
<p>new ：operator new，array new，placement new</p>
<p>重载的 new 的第一个参数的类型必须是 <code>size_t</code> 。我们在调用 new 函数的时候，并不需要将 size_t 作为参数传入参数列表，而是在 new 后面紧跟着一个类型，例如： <code>new int;</code> 而不是 <code>new(4);</code> 或者 <code>new(int);</code></p>
<p>所以说，在我们 placement new 的时候，为 new 的参数列表中传入 n 个参数，那么实际上 new 的参数列表中有 n+1 个参数。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/27/1f9bf40a891a34f9.png" alt="img"></p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">my_Alloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;you call myAlloc&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_Free</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;you all myFree&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 new 和 delete，其实就是运算符重载</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;you call global new()\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">my_Alloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> extra)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;extra: &quot;</span> &lt;&lt; extra &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">my_Alloc</span>(size + extra);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;you call global delete delete()\n&quot;</span>;</span><br><span class="line">    <span class="built_in">my_Free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;you call global new[]()\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">my_Alloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;you call global delete[]\n&quot;</span>;</span><br><span class="line">    <span class="built_in">my_Free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;you call test&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Foo</span>() &#123; </span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Foo::Foo()&quot;</span> &lt;&lt; endl; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Foo</span>(<span class="type">int</span> x) &#123; </span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Foo::Foo(int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">throw</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        ~<span class="built_in">Foo</span>() &#123; <span class="comment">// 我们这里写析构函数只是为了测试，实际上Foo类并不需要析构函数</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Foo::~Foo()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            cout &lt;&lt;<span class="string">&quot;you call Foo new()\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">my_Alloc</span>(size);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;you call Foo delete delete()\n&quot;</span>;</span><br><span class="line">            <span class="built_in">my_Free</span>(ptr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">static</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;you call Foo new[]()\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">my_Alloc</span>(size);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;you call Foo delete[]\n&quot;</span>;</span><br><span class="line">            <span class="built_in">my_Free</span>(ptr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">// 虚函数表占 8 字节</span></span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*  测试 delete 和 new  */</span></span><br><span class="line">    <span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    <span class="type">double</span> *b = <span class="keyword">new</span> <span class="type">double</span>;</span><br><span class="line">    <span class="built_in">test</span>(a);</span><br><span class="line">    <span class="built_in">test</span>(b);</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 测试 delete array 和 new array */</span></span><br><span class="line">    <span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 测试在 class 上 new 和 delete */</span></span><br><span class="line">    Foo singleF;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(Foo) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(singleF) &lt;&lt; endl;</span><br><span class="line">    Foo *f = <span class="keyword">new</span> Foo[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] f;</span><br><span class="line">    Foo *f2 = ::<span class="keyword">new</span> Foo[<span class="number">5</span>];</span><br><span class="line">    ::<span class="keyword">delete</span>[] f;</span><br><span class="line">    <span class="comment">// Foo *wf = new Foo(1);   // throw exception: terminate called after throwing an instance of &#x27;int&#x27;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* placement new */</span></span><br><span class="line">    <span class="type">int</span> *pn = <span class="built_in">new</span>(<span class="number">1</span>) <span class="type">int</span>; <span class="comment">// new只传入一个参数</span></span><br><span class="line">    <span class="keyword">delete</span> pn;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、-C-2-0"><a href="#七、-C-2-0" class="headerlink" title="七、 C++ 2.0"></a>七、 C++ 2.0</h2><h3 id="0x01-Revolution-of-C"><a href="#0x01-Revolution-of-C" class="headerlink" title="0x01. Revolution of C++"></a>0x01. Revolution of C++</h3><h4 id="1-C-的标准演化"><a href="#1-C-的标准演化" class="headerlink" title="1. C++ 的标准演化"></a>1. C++ 的标准演化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C++98 (c++ 1.0)</span><br><span class="line">C++03</span><br><span class="line">C++11 (C++ 2.0)</span><br><span class="line">C++14</span><br></pre></td></tr></table></figure>

<h4 id="2-C-2-0之后更新的小主题"><a href="#2-C-2-0之后更新的小主题" class="headerlink" title="2. C++ 2.0之后更新的小主题"></a>2. C++ 2.0之后更新的小主题</h4><blockquote>
<p>其实就是我不想太详细的做笔记了 T.T</p>
</blockquote>
<ol>
<li><p><strong>header:</strong> 在引入 C头文件的时候不需要加 .c 后缀是在 C++11 引入的。</p>
</li>
<li><p><strong>space in template expression</strong>:  类似于：<code>vector&lt;vector&lt;int&gt;&gt; v;</code> 最后的两个 <code>&gt;</code> 之间不再需要空格。</p>
</li>
<li><p><strong>auto：</strong>不要滥用 auto，编译器的类型推导在 C++ 11 之前就已经存在了，只不过在 C++11 之后才把这个功能提供给我们。</p>
</li>
<li><p>全局函数 <code>begin()</code> 和 <code>end()</code>，取代 <code>obj.begin()</code> 为 <code>begin(obj)</code>。</p>
</li>
</ol>
<h3 id="0x02-Variadic-Templates"><a href="#0x02-Variadic-Templates" class="headerlink" title="0x02. Variadic Templates"></a>0x02. Variadic Templates</h3><p>7大例子</p>
<h3 id="0x03-nullptr-and-std-nullptr-t"><a href="#0x03-nullptr-and-std-nullptr-t" class="headerlink" title="0x03. nullptr and std::nullptr_t"></a>0x03. nullptr and std::nullptr_t</h3><p>C++11 lets you use nullptr instead of 0 or NULL to specify that a pointer refers to no value(with differs from habing an undefined value). </p>
<p>用法：<code>void *p = nullptr;</code></p>
<p>nullptr 的一个好处是它显示的指明：我是一个空指针。</p>
<p>而在次之前，我们使用 NULL 来表示空指针，但其实 NULL 只不过是一个值为 0 的宏罢了，它也可以被解释成其他类型，例如整形，浮点型等。</p>
<p>但是 nullptr 只能被解释为指针，这在下图的例子中深有体现：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/26/4b9ea5742d3f1eea.png" alt="IMG"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I am int&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I am pointer&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">0</span>);       <span class="comment">// &quot;I am int&quot;</span></span><br><span class="line">    <span class="comment">// f(NULL); // ambigious</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="literal">nullptr</span>); <span class="comment">// &quot;I am pointer&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="0x04-Uniform-Initializarion"><a href="#0x04-Uniform-Initializarion" class="headerlink" title="0x04 Uniform Initializarion"></a>0x04 Uniform Initializarion</h3><p>一致性初始化。</p>
<p>在 C++11 之前，对象的初始化可能发生在：</p>
<ol>
<li>大括号 {} 之后</li>
<li>小括号 () 之后</li>
<li>赋值运算符之后</li>
</ol>
<p>这让人很迷惑，到底什么时候用什么样的初始化方式呢？</p>
<p>基于这个原因，C++11 统一使用大括号 {} 来初始化。当然，之前的小括号和赋值也会向前兼容。</p>
<p><strong>原理：</strong>编译器会把大括号 {} 内的所有参数<strong>打包</strong>到一个数据结构 <code>initializer_list&lt;&gt;</code> 中，形成一个<strong>数据包</strong>，并关联到一个 <code>array&lt;T,n&gt;</code> 容器中，<code>T</code> 是类型，<code>n</code> 是参数。当我们调用函数的时候（例如 ctor），<code>array</code> 内的所有元素会被编译器逐一分解给函数。但若函数参数是个 <code>initializer&lt;_list&gt;</code>，不会自动分解，也就是说，传给函数参数的仍然是数据包 <code>initializer_list&lt;int&gt;</code>，而不是单一的一个个 <code>&lt;int&gt;</code> 数据。（很合理）</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/26/080a6ee4df06aa92.png" alt="img"></p>
<h3 id="0x05-Initializer-lists"><a href="#0x05-Initializer-lists" class="headerlink" title="0x05 Initializer lists"></a>0x05 Initializer lists</h3><p>用于初始化，并且可以默认初始化，在 gcc 平台上还可以做隐式类型转换。(注意在投影片中不可以做隐式类型转换，这应该是编译器平台的问题，不必深究)</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/26/b4766877737c31e2.png" alt="img"></p>
<h4 id="1-Initializaer-lists-的底层结构："><a href="#1-Initializaer-lists-的底层结构：" class="headerlink" title="1. Initializaer lists 的底层结构："></a>1. Initializaer lists 的底层结构：</h4><h4 id="initializer-list-lt-gt"><a href="#initializer-list-lt-gt" class="headerlink" title="initializer_list&lt;&gt;"></a><code>initializer_list&lt;&gt;</code></h4><p><img src="https://s3.bmp.ovh/imgs/2022/10/26/a00c529e01d71682.png" alt="IMG"></p>
<p>Initializer_list&lt;&gt; 和 Variadic Templates 的区别在于前者只能传入统一类型的参数，而后者可以传入不同类型的参数</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(initializer_list&lt;<span class="type">int</span>&gt; vals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p = vals.<span class="built_in">begin</span>(); p != vals.<span class="built_in">end</span>(); p ++ )</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">p</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">p</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;P(int,int), a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">p</span>(initializer_list&lt;<span class="type">int</span>&gt; list)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;P(Initializer_list&lt;int&gt;), val = &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(initializer_list&lt;<span class="type">int</span>&gt;::iterator it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); it ++ )</span><br><span class="line">                cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">p <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    p b&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    p c&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    p d = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">P(int,int), a = 1 b = 2</span></span><br><span class="line"><span class="comment">P(Initializer_list&lt;int&gt;), val = 1 2 </span></span><br><span class="line"><span class="comment">P(Initializer_list&lt;int&gt;), val = 1 2 3 </span></span><br><span class="line"><span class="comment">P(Initializer_list&lt;int&gt;), val = 1 2 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>下图中包含了 <code>initializer_list&lt;int&gt;</code> 的源码，编译器会调用它的私有的构造函数，将一个容器 <code>array</code> 的头和大小传给它（当然，在此之前，编译器已经构造好了一个 <code>array</code> 容器）。</p>
<blockquote>
<p>编译器拥有无上权限，它可以调用你的私有对象！</p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/26/5fba537fae2977b6.png" alt="IMG"></p>
<p>如上图，在 <code>class initializer_list&lt;&gt;</code> 源代码中，我们可以发现它内部并没有包含元素，所有的元素都在 <code>array</code> 中，而它只是包含一个指向 <code>array</code> 的指针。</p>
<p>所以说如果我们 copy <code>initializer_list&lt;int&gt;</code> ，实际上是一个浅拷贝。</p>
<p><code>initializer_list&lt;&gt;</code> 被广泛应用于容器和算法当中，也就是说这些容器和算法都可以接受任意数量的参数。</p>
<h4 id="2-关联的容器-array"><a href="#2-关联的容器-array" class="headerlink" title="2. 关联的容器 array"></a>2. 关联的容器 array</h4><p><code>array</code> 就是数组的另一种表现性质，只不过它现在是一个容器，可以利用容器的很多接口，例如迭代器 begin(), end(), 和算法等。</p>
<p>在 array 容器中，如果你传入的长度是 0，它内部会变为 1，毕竟长度为 0 的容器不太合理。。 <code>len ? len : 1;</code></p>
<p>如下图，红圈中的内容需要额外注意：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/26/0fd7a98ee82afd23.png" alt="img"></p>
<h3 id="0x06-explicit"><a href="#0x06-explicit" class="headerlink" title="0x06 explicit"></a>0x06 explicit</h3><blockquote>
<p> 构造函数的类型</p>
</blockquote>
<p><strong>构造函数</strong>分为无参构造函数，和有参构造函数。有参构造函数又分为单参数构造函数和多参数构造函数</p>
<p><strong>C++中存在隐式构造的现象：在某些情况下，会隐式调用单参数的构造函数</strong></p>
<p>总而言之，大概就是 <code>A a(10);</code> 就是显式调用构造函数。而 <code>A a = 10;</code> 就是显式的调用构造函数。</p>
<p>但是这种隐式调用有些不太好，因为我们的本意可能不是调用构造函数，所以我们有了 explicit 关键字</p>
<blockquote>
<p> explicit</p>
</blockquote>
<p>在C++中，<code>explicit</code>关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的<strong>隐式类型转换</strong>，只能以显示的方式进行类型转换。因为无参构造函数和多参构造函数本身就是显示调用的。再加上<code>explicit</code>关键字也没有什么意义。</p>
<p>在 C++2.0 之前，是  <strong>explicit for ctor one argument</strong>，这个我们前面已经介绍过了，不再多做介绍。</p>
<p>在 C++2.0 之后，有了<strong>explicit for ctors taking more than one argument</strong>，我们发现多了一个 more than，这是因为 C++2.0 提供了一种新的语法：<code>initializer_list&lt;&gt;</code> ，这个我们前面也提到过了。所以说，现在我们不仅传入一个单参数会隐式调用  ctor，传入一个数据包也会调用  ctor。</p>
<blockquote>
<p>参考</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cpp_learner/article/details/117883912?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-117883912-blog-84141043.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-117883912-blog-84141043.pc_relevant_recovery_v2&utm_relevant_index=2">implicit &amp; explicit</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45452278/article/details/126019006">隐式构造函数</a></p>
<blockquote>
<p>举几个例子：</p>
</blockquote>
<p>例1：下面的代码可以正确运行，但如果我们将 p 的构造函数用关键字 explicit 修饰的话，编译器就会报错。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">p</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:    </span><br><span class="line">        <span class="built_in">p</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;P(int,int,int), a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b </span><br><span class="line">                &lt;&lt; <span class="string">&quot;, c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">// 隐式类型转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例2；下面的代码可以正确运行，但如果我们将 C 的构造函数用关键字 explicit 修饰的话，编译器就会报错。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">C</span>(string _s) : <span class="built_in">s</span>(_s) &#123;&#125;;</span><br><span class="line">        string s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> C c) &#123;</span><br><span class="line">    <span class="keyword">return</span> cout &lt;&lt; c.s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; s = &#123;</span><br><span class="line">        <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;cpp&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> C &amp;ele : s)   <span class="comment">// 隐式类型转换</span></span><br><span class="line">        cout &lt;&lt; ele &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">world</span></span><br><span class="line"><span class="comment">cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>但如果我们以如下方式进行 for 循环，那么程序依然可以正确执行，这是因为我们使用的不再是隐式类型转换，而是显式类型转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ele : s) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">C</span>(ele) &lt;&lt; endl; <span class="comment">// 显式类型转换</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="0x07-range-based-for-statement"><a href="#0x07-range-based-for-statement" class="headerlink" title="0x07 range-based for statement"></a>0x07 range-based for statement</h3><p><strong>range-based for statement</strong>：即 for 函数</p>
<p>有以下需要注意的点：</p>
<ol>
<li>和 auto结合使用效果极佳。</li>
<li>关联式容器不可以用 auto 修改元素的值。</li>
<li>for 的实质就是迭代器遍历。如下图所示：</li>
</ol>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/26/8268f467b08cd0b7.png" alt="IMG"></p>
<h3 id="0x08-x3D-default-x3D-delete"><a href="#0x08-x3D-default-x3D-delete" class="headerlink" title="0x08 &#x3D;default, &#x3D;delete"></a>0x08 &#x3D;default, &#x3D;delete</h3><p>一言以蔽之：&#x3D;default 用来让编译器生成默认函数，&#x3D;delete 用来删除编译器生成默认函数</p>
<p>c++ 右值引用</p>
<p>参考：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tutuxs/article/details/54947395">big fice</a></p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7829.html">右值引用</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Braveliu/p/12247471.html">&#x3D;default, &#x3D;delete</a></p>
</blockquote>
<h3 id="0x09-Alias-Template"><a href="#0x09-Alias-Template" class="headerlink" title="0x09 Alias Template"></a>0x09 Alias Template</h3><h3 id="0x0a-decltype"><a href="#0x0a-decltype" class="headerlink" title="0x0a decltype"></a>0x0a decltype</h3><p>declareType</p>
<p>当我们用了：：的时候，加上 typename 让编译器直到我们要的是一个类型。</p>
<p>![img](file:&#x2F;&#x2F;&#x2F;C:\Users\24072\AppData\Roaming\Tencent\Users\2407217576\QQ\WinTemp\RichOle\1[</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">redis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-15 20:14:25 / Modified: 20:14:57" itemprop="dateCreated datePublished" datetime="2023-06-15T20:14:25+08:00">2023-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="0x00-conf"><a href="#0x00-conf" class="headerlink" title="0x00 conf"></a>0x00 conf</h2><h3 id="1-Introduce"><a href="#1-Introduce" class="headerlink" title="1. Introduce"></a>1. Introduce</h3><p><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-tutorial.html">菜鸟教程</a></p>
<h3 id="2-相关资源"><a href="#2-相关资源" class="headerlink" title="2. 相关资源"></a>2. 相关资源</h3><p><a target="_blank" rel="noopener" href="https://redis.io/">官网</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/redis/redis">SourceCode</a></p>
<p><a target="_blank" rel="noopener" href="http://doc.redisfans.com/">命令参考</a></p>
<p><a target="_blank" rel="noopener" href="https://try.redis.io/">在线命令测试</a></p>
<h3 id="3-在Docker中使用Redis"><a href="#3-在Docker中使用Redis" class="headerlink" title="3. 在Docker中使用Redis"></a>3. <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1678634">在Docker中使用Redis</a></h3><ol>
<li><p>连接容器</p>
</li>
<li><p>登陆 redis 用户界面：<code>redis-cli</code></p>
</li>
</ol>
<blockquote>
<p><strong>命令行界面</strong>（英语：<strong>C</strong>ommand-<strong>L</strong>ine <strong>I</strong>nterface，缩写：<strong>CLI</strong>）是在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2">图形用户界面</a>得到普及之前使用最为广泛的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2">用户界面</a>，它通常不支持<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%BC%A0%E6%A0%87">鼠标</a>，用户通过<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%94%AE%E7%9B%98">键盘</a>输入指令，计算机接收到指令后，予以执行。也有人称之为<strong>字符用户界面</strong>（character user interface, CUI）。</p>
</blockquote>
<h3 id="4-修改端口号"><a href="#4-修改端口号" class="headerlink" title="4. 修改端口号"></a>4. 修改端口号</h3><p>redis 默认端口号为 <code>6379</code>，而我已经有了一个 docker 容器占用了此端口号，因此我的 mac 本地和 ubuntu 都需要修改端口号。</p>
<ol>
<li>修改 conf 文件</li>
</ol>
<blockquote>
<p> <code>cd /etc/redis</code>，先备份 <code>redis.conf</code> 到 <code>redis_back.conf</code> 然后修改 <code>redis.conf</code> 中的 <code>port</code> 为没有被占用的端口号。</p>
</blockquote>
<ol start="2">
<li>重启 redis 使得 conf 文件生效</li>
</ol>
<blockquote>
<p><code>sudo ervice redis-server restart</code></p>
</blockquote>
<p>参考</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/banfushen007/article/details/99316845">ref here</a></p>
</blockquote>
<h3 id="5-修改密码"><a href="#5-修改密码" class="headerlink" title="5. 修改密码"></a>5. 修改密码</h3><ol>
<li>修改 conf 文件</li>
</ol>
<blockquote>
<p>找到 <code>#requirepass foobared</code> 这一行，将注释去掉，修改 <code>foobared</code> 为自己要设置的密码。</p>
<p>注意 vim 下 <code>:/</code> 搜索，查找下&#x2F;上一个匹配项是 <code>n/N</code>，不是回车。</p>
</blockquote>
<ol start="2">
<li>重启 redis 使 conf 生效</li>
</ol>
<blockquote>
<p><code>sudo service redis-server restart</code></p>
</blockquote>
<h3 id="6-redis-cli"><a href="#6-redis-cli" class="headerlink" title="6. redis-cli"></a>6. redis-cli</h3><p><code>-a</code> 参数指定密码</p>
<p><code>-p</code> 指定端口号</p>
<p><code>-h</code> 指定 IP 地址</p>
<p><code>–no-auth-warning</code> 忽略警告信息</p>
<p>如果你开启了密码，即使不指定密码也能登陆，但无法使用，有两种方式指定密码：</p>
<ol>
<li><code>redis-cli -a</code>，通过这种方式指定的密码会显示在 <code>command line</code>，不安全，因为通过 <code>history</code> 可以查看。</li>
<li>通过 <code>redis-cli</code> 登陆之后，使用 <code>auth</code> 命令输入密码，虽然也会显示，但是他不会记录在 <code>history</code> 中。</li>
</ol>
<blockquote>
<p>Do not use ‘-a’, instead, running <code>auth password</code> explicitly in <code>redis-cli</code> shell. <code>Auth</code> command does not save in Redis-cli’s command history.</p>
</blockquote>
<h3 id="7-Ubuntu-下-redis-数据目录"><a href="#7-Ubuntu-下-redis-数据目录" class="headerlink" title="7. Ubuntu 下 redis 数据目录"></a>7. Ubuntu 下 redis 数据目录</h3><p><code>/var/lib/redis</code> 下的 <code>dump.rdb</code> 文件</p>
<h3 id="8-下标"><a href="#8-下标" class="headerlink" title="8. 下标"></a>8. 下标</h3><p>在 <code>redis</code> 世界中，下标从 0 开始</p>
<h3 id="9-事务"><a href="#9-事务" class="headerlink" title="9. 事务"></a>9. 事务</h3><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p>
<p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p>
<h2 id="0x01-noun"><a href="#0x01-noun" class="headerlink" title="0x01 noun"></a>0x01 noun</h2><p>daemonize：守护进程</p>
<p>blpop: blocking left pop</p>
<p>brpop: blocking right pop</p>
<p>sard: set cardinality(势,基数)</p>
<h2 id="0x02-DataStruct"><a href="#0x02-DataStruct" class="headerlink" title="0x02 DataStruct"></a>0x02 DataStruct</h2><ol>
<li>string</li>
<li>hash</li>
<li>list</li>
<li>set</li>
<li>zset(sorted set)</li>
</ol>
<h2 id="0x03-command"><a href="#0x03-command" class="headerlink" title="0x03 command"></a>0x03 command</h2><h3 id="1-KEY"><a href="#1-KEY" class="headerlink" title="1. KEY"></a>1. KEY</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">keys pattrn</span><br><span class="line">type key</span><br><span class="line">rename key newname</span><br><span class="line">exist key</span><br><span class="line">del key</span><br><span class="line">dump key</span><br><span class="line">random key</span><br><span class="line">select idx</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jyyyx</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/qaqowoqaq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qaqowoqaq" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2407217576@qq.com" title="E-Mail → 2407217576@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jyyyx</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
