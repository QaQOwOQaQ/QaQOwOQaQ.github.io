<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qaqowoqaq.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="jyyyyyyyyyx">
<meta property="og:url" content="https://qaqowoqaq.github.io/index.html">
<meta property="og:site_name" content="jyyyyyyyyyx">
<meta property="og:locale">
<meta property="article:author" content="jyyyx">
<meta property="article:tag" content="cs">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://qaqowoqaq.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'cn'
  };
</script>

  <title>jyyyyyyyyyx</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">jyyyyyyyyyx</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">后来居上</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">C++ template</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-15 20:20:57" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-16 09:43:52" itemprop="dateModified" datetime="2023-06-16T09:43:52+08:00">2023-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-templates"><a href="#C-templates" class="headerlink" title="C++ templates"></a>C++ templates</h1><h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><h2 id="English"><a href="#English" class="headerlink" title="English"></a>English</h2><p>instantiation：实例化</p>
<p>paradigm：范例</p>
<h2 id="P1-基础"><a href="#P1-基础" class="headerlink" title="P1 基础"></a>P1 基础</h2><h3 id="1-函数模板"><a href="#1-函数模板" class="headerlink" title="1. 函数模板"></a>1. 函数模板</h3><p>当自定义的函数和 <code>std</code> 的函数名重复时，使用 <code>::</code> 调用我们定义的全局函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="type">const</span>&amp; <span class="title">max</span><span class="params">(T <span class="type">const</span>&amp; a, T <span class="type">const</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; ::<span class="built_in">max</span>(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板会被编译两次：</p>
<ol>
<li>实例化之前，先检查模板代码本身，查看语法是否正确。</li>
<li>实例化期间，检查模板代码，查看是否所有的调用都有效，例如某些类型可能无法调用某些函数，以及类型是否匹配，在上面的例子中，如果我们传入两个不同的类型，就会编译错误。</li>
</ol>
<p>模板类型可以显示制定，例如下面形式编译可以通过：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i= <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> d =<span class="number">3.13</span>;</span><br><span class="line">cout &lt;&lt; ::<span class="built_in">max</span>&lt;<span class="type">double</span>&gt;(i, d) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>为了解决参数必须相同的问题，我们可以指定两个模板参数，但是我们必须指定返回类型，指定返回类型比较麻烦：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">max</span><span class="params">(T2 <span class="type">const</span>&amp; a, T1 <span class="type">const</span>&amp; b)</span> -&gt; <span class="title">decltype</span><span class="params">(a + b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; ::<span class="built_in">max</span>(<span class="number">3</span>, <span class="number">3.13</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，你还可以重载模板函数，但要确保函数模板的所有重载版本的声明都位于它们被调用的位置之前。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">2023 C/C++语言考试试卷</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-15 20:20:57" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-16 09:44:02" itemprop="dateModified" datetime="2023-06-16T09:44:02+08:00">2023-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2023-C-x2F-C-语言考试试卷"><a href="#2023-C-x2F-C-语言考试试卷" class="headerlink" title="2023 C&#x2F;C++语言考试试卷"></a>2023 C&#x2F;C++语言考试试卷</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><p>所有的题目，除了答案，<strong>你应该给出合理的解释，解释非常重要，甚至比答案重要的多</strong>。</p>
<p>不但要知其然，还要知其所以然</p>
<p>并且，我们为了代码简洁，默认不加标头，你应该默认认为我们使用的库都有正确的标头,如#include<iostream>#include<vector>等等</p>
<p>如果是最近的标准，如C++11,14,17,20有的，我们一般不强调标准多少，除非的确有歧义，如constexpr，noexcept，复制消除，如果是老式的，C语言的，我们会强调。并且有些题目，不同编译器实际上也不见得都一样，不保证编译器厂商都按照标准实现。</p>
<p>所有题目不涉及任何框架和方言，标准C++，如果要提C，会强调是C语言</p>
<p>所有的题目，均在</p>
<p><a href="www.bilibili.com/video/BV1D84y1t76J/?spm_id_from=333.999.0.0&vd_source=1992ca910d6cd0582931f6f985dc7fa0">现代C++教程 2023_哔哩哔哩_bilibili</a></p>
<p>中有讲过，<strong>如果你看过视频还看不懂这些，最好思考一下自己学了啥</strong>，目前总计75题</p>
<hr>
<h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = +[] &#123;<span class="keyword">return</span> <span class="number">6</span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>p的类型是什么?</p>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> p = [=] &#123; ++a; &#125; ;</span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">sizeof</span> p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">p</span>();</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提问，打印p是多少？return a是多少？</p>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line">    <span class="type">float</span>&amp; r = x;</span><br><span class="line">    <span class="keyword">auto</span> p = [=] &#123;&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">sizeof</span> p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印多少?</p>
<h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">auto</span> p =[=] &#123;</span><br><span class="line">		<span class="type">int</span> arr[N]&#123;&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	std::cout &lt;&lt; <span class="keyword">sizeof</span> p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印多少？</p>
<h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">auto</span> p =[=] &#123;</span><br><span class="line">		<span class="type">int</span> p = N;</span><br><span class="line">	&#125;;</span><br><span class="line">	std::cout &lt;&lt; <span class="keyword">sizeof</span> p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印多少?</p>
<h3 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> a = <span class="number">6</span>;</span><br><span class="line">    [] &#123;</span><br><span class="line">        std::cout &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能否正常编译?打印多少?</p>
<h3 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line">    [] &#123;</span><br><span class="line">        std::cout &lt;&lt; &amp;a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能否正常编译?打印多少?</p>
<h3 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h3><p><strong>lambda表达式的类型是什么?请写一段代码表示(不要超脱语言层面)</strong></p>
<h3 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = +[]()<span class="keyword">noexcept</span> &#123; &#125;;</span><br></pre></td></tr></table></figure>

<p>在<code>C++17</code>p的类型是什么?</p>
<h3 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> a = [] &#123;<span class="keyword">return</span> <span class="number">6</span>; &#125;();</span><br></pre></td></tr></table></figure>

<p>上面代码在c++17是否合法?</p>
<h3 id="第十一题"><a href="#第十一题" class="headerlink" title="第十一题"></a>第十一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lm = [&amp;args...] &#123;  &#125;;</span><br><span class="line">    <span class="keyword">auto</span> lm2 = [&amp;] &#123;  &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">sizeof</span> lm &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">sizeof</span> lm2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>, <span class="number">1.0</span>, <span class="number">1.f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印多少?</p>
<h3 id="第十二题"><a href="#第十二题" class="headerlink" title="第十二题"></a>第十二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="built_in">X</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;X&quot;</span>); &#125;</span><br><span class="line">	~<span class="built_in">X</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;~X&quot;</span>); &#125;</span><br><span class="line">	<span class="built_in">X</span>(X&amp;&amp;)<span class="keyword">noexcept</span> &#123; <span class="built_in">puts</span>(<span class="string">&quot;X&amp;&amp;&quot;</span>); &#125;</span><br><span class="line">	<span class="built_in">X</span>(<span class="type">const</span> X&amp;) &#123; <span class="built_in">puts</span>(<span class="string">&quot;const X&amp;&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(Args&amp;&amp;...args)</span> </span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">	[args...] &#123; <span class="built_in">g</span>(args...); &#125;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f_</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">	[... args = std::forward&lt;Args&gt;(args)] &#123;<span class="built_in">g</span>(args...); &#125;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X x_;</span><br><span class="line">	<span class="built_in">f_</span>(std::<span class="built_in">move</span>(x_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码，打印多少?</p>
<h3 id="第十三题"><a href="#第十三题" class="headerlink" title="第十三题"></a>第十三题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> p = +[](...) &#123;&#125;;</span><br><span class="line">	<span class="keyword">auto</span> p2 = [](<span class="keyword">auto</span>...args) &#123;</span><br><span class="line">		((std::cout &lt;&lt; args &lt;&lt; <span class="string">&#x27; &#x27;</span>), ...);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">p</span>(<span class="number">1</span>, <span class="string">&quot;*&quot;</span>, <span class="number">5.6</span>);</span><br><span class="line">	<span class="built_in">p2</span>(<span class="number">1</span>, <span class="string">&quot;*&quot;</span>, <span class="number">5.6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能否通过编译?打印多少?</p>
<h3 id="第十四题"><a href="#第十四题" class="headerlink" title="第十四题"></a>第十四题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line">	<span class="function"><span class="keyword">auto</span> <span class="title">concat</span><span class="params">(F t, Ts ...ts)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(ts) &gt; <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> [=](<span class="keyword">auto</span> ...parameters) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">t</span>(<span class="built_in">concat</span>(ts...)(parameters...));</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> [=](<span class="keyword">auto</span> ...parameters) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">t</span>(parameters...);</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码，思考是否看的懂</p>
<hr>
<h2 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h2><h3 id="第一题-1"><a href="#第一题-1" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span> = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>=<span class="number">6</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> = <span class="number">4</span>,<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123; std::cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码，是否正确？打印多少?</p>
<h3 id="第二题-1"><a href="#第二题-1" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f_</span><span class="params">(<span class="type">int</span> n = <span class="number">6</span>, Args...args)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码，是否正确?</p>
<h3 id="第三题-1"><a href="#第三题-1" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i = <span class="number">3</span>)</span></span>;</span><br><span class="line">	<span class="built_in">C</span>(<span class="type">int</span> arg); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">C::f</span><span class="params">(<span class="type">int</span> i = <span class="number">3</span>)</span> </span>&#123;&#125;        </span><br><span class="line">C::<span class="built_in">C</span>(<span class="type">int</span> arg = <span class="number">1</span>) &#123;&#125;            </span><br></pre></td></tr></table></figure>

<p>给出以上代码，是否正确?</p>
<h3 id="第四题-1"><a href="#第四题-1" class="headerlink" title="第四题"></a>第四题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a = <span class="number">7</span>)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base &quot;</span> &lt;&lt; a &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived &quot;</span> &lt;&lt; a &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	std::unique_ptr&lt;Base&gt;ptr&#123; <span class="keyword">new</span> Derived &#125;;</span><br><span class="line">	ptr-&gt;<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印多少?</p>
<h3 id="第五题-1"><a href="#第五题-1" class="headerlink" title="第五题"></a>第五题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> n = <span class="keyword">sizeof</span> f)</span></span>;</span><br><span class="line">	<span class="built_in">f2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?打印多少?</p>
<hr>
<h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><h3 id="第一题-2"><a href="#第一题-2" class="headerlink" title="第一题"></a>第一题</h3><p>template<classT>void f(T);表达式f({1, 2, 3})良构吗?</p>
<p><code>decltype(&#123;1,2,3&#125;)</code>良构吗?</p>
<p><code>&#123;&#125;</code>是表达式吗?它有类型吗?</p>
<h3 id="第二题-2"><a href="#第二题-2" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">V</span><span class="params">(std::istream_iterator&lt;<span class="type">int</span>&gt;(std::cin), &#123;&#125;)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> i : V) &#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>那么这里的<code>std::vector</code>的构造器第二个参数传一个空<code>&#123;&#125;</code>是否正确?</p>
<h3 id="第三题-2"><a href="#第三题-2" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> S&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="built_in">Test</span>(S a ,S b)<span class="keyword">noexcept</span> &#123;</span><br><span class="line">		std::cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Test t&#123; <span class="number">1</span>,&#123;&#125; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码，是否正确?</p>
<h3 id="第四题-2"><a href="#第四题-2" class="headerlink" title="第四题"></a>第四题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>p使用的是什么初始化，它的类型是什么?</p>
<h3 id="第五题-2"><a href="#第五题-2" class="headerlink" title="第五题"></a>第五题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span>  <span class="title">X</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> :a(a), b(b) &#123;</span> std::cout &lt;&lt; <span class="string">&quot;X(int a,int b)\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a&#123;&#125;;</span><br><span class="line">	<span class="type">int</span> b&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X x&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">	<span class="function">X <span class="title">x2</span><span class="params">( <span class="number">1</span>,<span class="number">2</span> )</span></span>;</span><br><span class="line">	X x3 = &#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码,是否正确?</p>
<h3 id="第六题-1"><a href="#第六题-1" class="headerlink" title="第六题"></a>第六题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span>  <span class="title">X</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> :a(a), b(b) &#123;</span> std::cout &lt;&lt; <span class="string">&quot;X(int a,int b)\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a&#123;&#125;;</span><br><span class="line">	<span class="type">int</span> b&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X x&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">	<span class="function">X <span class="title">x2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> ret = <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码,是否正确?</p>
<h3 id="第七题-1"><a href="#第七题-1" class="headerlink" title="第七题"></a>第七题</h3><p><strong><code>std::array</code>的构造函数是用<code>std::initializer_list</code>定义的吗?</strong></p>
<hr>
<h2 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h2><h3 id="第一题-3"><a href="#第一题-3" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDEF(sname, ...) S sname __VA_OPT__(= &#123; __VA_ARGS__ &#125;)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SDEF</span>(bar, <span class="number">1</span>, <span class="number">2</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SDEF(bar, 1, 2); </code>替换成了什么?</p>
<hr>
<h2 id="用户定义字面量"><a href="#用户定义字面量" class="headerlink" title="用户定义字面量"></a>用户定义字面量</h2><h3 id="第一题-4"><a href="#第一题-4" class="headerlink" title="第一题"></a>第一题</h3><p>自定义一个字面量，做到如下功能:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;乐 :&#123;&#125; *\n&quot;</span>_f(<span class="number">5</span>);</span><br><span class="line"><span class="string">&quot;乐 :&#123;0&#125; &#123;0&#125; *\n&quot;</span>_f(<span class="number">5</span>);</span><br><span class="line"><span class="string">&quot;乐 :&#123;:b&#125; *\n&quot;</span>_f(<span class="number">0b01010101</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="名字查找"><a href="#名字查找" class="headerlink" title="名字查找"></a>名字查找</h2><p><strong>也牵扯待决名</strong></p>
<h3 id="第一题-5"><a href="#第一题-5" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> X &#123;</span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">namespace</span> std&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> X;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	::std::vector v&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">	std::vector v2&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码，是否正确?</p>
<h3 id="第二题-3"><a href="#第二题-3" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">std</span>&#123;&#125;;</span><br><span class="line">	::std::vector v&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">	std::vector v2&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码，是否正确?</p>
<h3 id="第三题-3"><a href="#第三题-3" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> X &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Y</span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Y)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(X::<span class="built_in">Y</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码，是否正确?</p>
<h3 id="第四题-3"><a href="#第四题-3" class="headerlink" title="第四题"></a>第四题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;基\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;派生\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;Base&gt;p&#123; <span class="keyword">new</span> Derived &#125;;</span><br><span class="line">    p-&gt;<span class="built_in">f</span>();</span><br><span class="line">    p-&gt;Base::<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问以上代码打印什么?</p>
<h3 id="第五题-3"><a href="#第五题-3" class="headerlink" title="第五题"></a>第五题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;X\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;全局\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span> : X&lt;T&gt; &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">t</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">t2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Y&lt;<span class="type">void</span>&gt;y;</span><br><span class="line">	y.<span class="built_in">t</span>();</span><br><span class="line">	y.<span class="built_in">t2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印什么?</p>
<h3 id="第六题-2"><a href="#第六题-2" class="headerlink" title="第六题"></a>第六题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">	<span class="keyword">using</span> type = <span class="type">const</span> T::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span> &#123;</span><br><span class="line">	<span class="keyword">using</span> type = <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X&lt;Y&gt;::type a&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码，请问是否正确?</p>
<hr>
<h2 id="重载决议"><a href="#重载决议" class="headerlink" title="重载决议"></a>重载决议</h2><p>我非常喜欢考<code>&#123;&#125;</code>，因为错误言论实在太多，那么这里就多写点</p>
<h3 id="第一题-6"><a href="#第一题-6" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>(&amp;)[])</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;const int(&amp;)[]&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>(&amp;)[<span class="number">2</span>])</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;const int(&amp;)[2]&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;);</span><br><span class="line">	<span class="built_in">f</span>(&#123; <span class="number">1</span>,<span class="number">2</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印多少?</p>
<h3 id="第二题-4"><a href="#第二题-4" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>(&amp;)[])</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;const int(&amp;)[]&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>(&amp;)[<span class="number">2</span>])</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;const int(&amp;)[2]&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>(&amp;&amp;)[])</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;const int(&amp;&amp;)[]&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;);</span><br><span class="line">	<span class="built_in">f</span>(&#123; <span class="number">1</span>,<span class="number">2</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印多少?</p>
<h3 id="第三题-4"><a href="#第三题-4" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123; <span class="type">int</span> x, y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span> &#123;</span><br><span class="line">	<span class="built_in">Y</span>(std::initializer_list&lt;<span class="type">int</span>&gt;)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>(&amp;)[])</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;const int(&amp;)[]&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>(&amp;)[<span class="number">2</span>])</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;const int(&amp;)[2]&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>(&amp;&amp;)[])</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;int(&amp;&amp;)[]&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(X)</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;X&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Y)</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;Y&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;);</span><br><span class="line">	<span class="built_in">f</span>(&#123; <span class="number">1</span>,<span class="number">2</span> &#125;);</span><br><span class="line">	<span class="built_in">f</span>(&#123; .x=<span class="number">1</span>,.y=<span class="number">2</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印多少?</p>
<hr>
<h2 id="值类别"><a href="#值类别" class="headerlink" title="值类别"></a>值类别</h2><h3 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h3><h4 id="第一题-7"><a href="#第一题-7" class="headerlink" title="第一题"></a>第一题</h4><p>字面量都是<strong>纯右值表达式</strong></p>
<h4 id="第二题-5"><a href="#第二题-5" class="headerlink" title="第二题"></a>第二题</h4><p>返回类型是非引用的函数调用或重载运算符表达式，例如 str.substr(1, 2)、str1 + str2 或 it++都是<strong>纯右值表达式</strong></p>
<h4 id="第三题-5"><a href="#第三题-5" class="headerlink" title="第三题"></a>第三题</h4><p><code>std::move(x)</code>是<strong>亡值表达式</strong></p>
<h4 id="第四题-4"><a href="#第四题-4" class="headerlink" title="第四题"></a>第四题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>&amp;&amp;)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">6</span>;</span><br><span class="line">	<span class="type">int</span>&amp;&amp; p = std::<span class="built_in">move</span>(n);</span><br><span class="line">	<span class="built_in">f</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码合法</p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="第一题-8"><a href="#第一题-8" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="built_in">X</span>()<span class="keyword">noexcept</span> &#123; <span class="built_in">puts</span>(<span class="string">&quot;默认构造&quot;</span>); &#125;</span><br><span class="line">	<span class="built_in">X</span>(<span class="type">const</span> X&amp;) &#123; <span class="built_in">puts</span>(<span class="string">&quot;复制构造\n&quot;</span>); &#125;</span><br><span class="line">	<span class="built_in">X</span>(X&amp;&amp;)<span class="keyword">noexcept</span> &#123; <span class="built_in">puts</span>(<span class="string">&quot;移动构造&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">X <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X x;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X x = <span class="built_in">X</span>();</span><br><span class="line">	X x2 = <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确保在<code>C++17</code>的环境下，请问打印什么?</p>
<h3 id="第二题-6"><a href="#第二题-6" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">using</span> T = <span class="keyword">decltype</span>((a + b));</span><br><span class="line">	<span class="keyword">using</span> T2 = <span class="keyword">decltype</span>(std::<span class="built_in">move</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T和T2的类型是什么?</p>
<hr>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="第一题-9"><a href="#第一题-9" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> array[<span class="number">10</span>]&#123;&#125;;</span><br><span class="line">	<span class="keyword">using</span> T = <span class="keyword">decltype</span>(array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T的类型是什么?</p>
<h3 id="第二题-7"><a href="#第二题-7" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">using</span> T = <span class="keyword">decltype</span>((<span class="string">&quot;***&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T的类型是什么?</p>
<h3 id="C语言C99数组"><a href="#C语言C99数组" class="headerlink" title="C语言C99数组"></a>C语言<code>C99</code>数组</h3><h4 id="第一题-10"><a href="#第一题-10" class="headerlink" title="第一题"></a>第一题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">double</span> b;</span><br><span class="line">	<span class="type">char</span> c[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> t = (test*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(test) + <span class="number">27</span> * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">	<span class="built_in">memset</span>(t-&gt;c, <span class="number">0</span>, <span class="number">27</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="keyword">sizeof</span> * t &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">		t-&gt;c[i] = <span class="string">&#x27;A&#x27;</span> + i;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; t-&gt;c &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">free</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印多少?</p>
<h4 id="第二题-8"><a href="#第二题-8" class="headerlink" title="第二题"></a>第二题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">size_t</span> x, <span class="type">int</span> a[*])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">size_t</span> x, <span class="type">int</span> a[x])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="built_in">sizeof</span>(a)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> n=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> array[n];</span><br><span class="line">    <span class="built_in">foo</span>(n,array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码是否正确?</p>
<h4 id="第三题-6"><a href="#第三题-6" class="headerlink" title="第三题"></a>第三题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> A[n];            </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">int</span> <span class="params">(*p2)</span>[n]</span>; </span><br><span class="line"><span class="type">int</span> B[<span class="number">100</span>];          </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fvla</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> C[m][m])</span></span>; </span><br></pre></td></tr></table></figure>

<p>下面声明的数组，哪些错误，哪些正确</p>
<p><strong>第四题</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">10</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> array[n];</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> array_[n];</span><br><span class="line">    <span class="type">int</span> array__[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面声明的数组，哪些错误，哪些正确</p>
<h4 id="第五题-4"><a href="#第五题-4" class="headerlink" title="第五题"></a>第五题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="type">int</span> array[<span class="number">6</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> array[];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">		std::cout &lt;&lt; array[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?</p>
<h4 id="第六题-3"><a href="#第六题-3" class="headerlink" title="第六题"></a>第六题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">0</span>]; </span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?</p>
<h4 id="第七题-2"><a href="#第七题-2" class="headerlink" title="第七题"></a>第七题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> array[<span class="number">6</span>]&#123;&#125;;</span><br><span class="line">	<span class="keyword">using</span> T = <span class="keyword">decltype</span>( + array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T的类型是什么?</p>
<h4 id="第八题-1"><a href="#第八题-1" class="headerlink" title="第八题"></a>第八题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">char</span> s[<span class="number">3</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">char</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">char</span>* s)</span></span>;</span><br></pre></td></tr></table></figure>

<p>以上代码声明了几个函数?</p>
<h4 id="第九题-1"><a href="#第九题-1" class="headerlink" title="第九题"></a>第九题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a[<span class="number">0</span>])</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确</p>
<hr>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="第一题-11"><a href="#第一题-11" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">int</span>(<span class="type">void</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">int</span>())</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">int</span>(*)())</span></span>;</span><br></pre></td></tr></table></figure>

<p>以上代码声明了几个函数</p>
<h3 id="第二题-9"><a href="#第二题-9" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(X())</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>t</code>是什么?</p>
<hr>
<h2 id="形参包展开"><a href="#形参包展开" class="headerlink" title="形参包展开"></a>形参包展开</h2><p>我们前面的题目已经使用了很多包展开了，所以我们这里只写两个例子</p>
<h3 id="第一题-12"><a href="#第一题-12" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F,<span class="keyword">class</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">(F func,Args...args)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> _[] = &#123; (<span class="built_in">func</span>(args),<span class="number">0</span>)... &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">f</span>([](<span class="keyword">auto</span> t) &#123;std::cout &lt;&lt; t &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;, <span class="number">1</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印多少?</p>
<h3 id="第二题-10"><a href="#第二题-10" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>...Args&gt;</span></span><br><span class="line"><span class="function">std::initializer_list&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(Args...args)</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="keyword">auto</span> list = &#123; args * args + args... &#125;;</span><br><span class="line">	<span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> ret = <span class="built_in">f</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>); <span class="type">const</span> <span class="keyword">auto</span> &amp; i : ret) &#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印多少?</p>
<h2 id="并发支持库"><a href="#并发支持库" class="headerlink" title="并发支持库"></a>并发支持库</h2><h3 id="第一题-13"><a href="#第一题-13" class="headerlink" title="第一题"></a>第一题</h3><p><strong>实现<code>std::lock_guard</code></strong></p>
<h3 id="第二题-11"><a href="#第二题-11" class="headerlink" title="第二题"></a>第二题</h3><p>实现<code>std::scoped_lock</code></p>
<h3 id="第三题-7"><a href="#第三题-7" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::promise&lt;<span class="type">void</span>&gt;read;</span><br><span class="line">	std::future&lt;<span class="type">void</span>&gt;fu = read.<span class="built_in">get_future</span>();</span><br><span class="line">	std::thread t&#123; [&amp;] &#123;</span><br><span class="line">		fu.<span class="built_in">wait</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;乐\n&quot;</span>;</span><br><span class="line">	&#125; &#125;;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;main\n&quot;</span>;</span><br><span class="line">	read.<span class="built_in">set_value</span>();</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码打印什么?</p>
<hr>
<h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><h2 id="成员函数-1"><a href="#成员函数-1" class="headerlink" title="成员函数"></a>成员函数</h2><h3 id="第一题-14"><a href="#第一题-14" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span><span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;const\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X x;</span><br><span class="line">	x.<span class="built_in">f</span>();</span><br><span class="line">	std::<span class="built_in">move</span>(x).<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上 是否正确，如果正确，打印什么?</p>
<h3 id="第二题-12"><a href="#第二题-12" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span><span class="type">const</span>&amp; </span>&#123; std::cout &lt;&lt; <span class="string">&quot;const\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X x;</span><br><span class="line">	x.<span class="built_in">f</span>();</span><br><span class="line">	std::<span class="built_in">move</span>(x).<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上 是否正确，如果正确，打印什么?</p>
<h3 id="第三题-8"><a href="#第三题-8" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>&#123;</span><br><span class="line">	<span class="type">int</span> n&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span><span class="type">const</span>&amp; </span>&#123; std::cout &lt;&lt; <span class="string">&quot;const&amp;\n&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span><span class="keyword">volatile</span>&amp; </span>&#123; std::cout &lt;&lt; <span class="string">&quot;volatile&amp;\n&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span><span class="type">const</span> <span class="keyword">volatile</span>&amp; </span>&#123; std::cout &lt;&lt; <span class="string">&quot;const volatile&amp;\n&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span>&amp; </span>&#123; std::cout &lt;&lt; <span class="string">&quot;&amp;\n&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span>&amp;&amp; </span>&#123; std::cout &lt;&lt; <span class="string">&quot;&amp;&amp;\n&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span><span class="type">const</span>&amp;&amp; </span>&#123; std::cout &lt;&lt; <span class="string">&quot;const &amp;&amp;\n&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span><span class="keyword">volatile</span>&amp;&amp; </span>&#123; std::cout &lt;&lt; <span class="string">&quot;volatile &amp;&amp;\n&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span><span class="type">const</span> <span class="keyword">volatile</span>&amp;&amp; </span>&#123; std::cout &lt;&lt; <span class="string">&quot;const volatile &amp;&amp;\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	S s;</span><br><span class="line">	s.<span class="built_in">f</span>();</span><br><span class="line">	std::<span class="built_in">move</span>(s).<span class="built_in">f</span>();</span><br><span class="line">	<span class="built_in">S</span>().<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?如果正确，打印什么?</p>
<h3 id="C-23显式对象形参"><a href="#C-23显式对象形参" class="headerlink" title="C++23显式对象形参"></a>C++<code>23</code>显式对象形参</h3><h3 id="第一题-15"><a href="#第一题-15" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="keyword">this</span> X x)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;f\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">this</span> X&amp; x)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;f2\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> X x;</span><br><span class="line">	x.<span class="built_in">f</span>();</span><br><span class="line">	x.<span class="built_in">f2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?如果正确，打印什么?</p>
<h3 id="第二题-13"><a href="#第二题-13" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Self&gt;</span></span><br><span class="line"><span class="function">	<span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">this</span> Self&amp;&amp; self)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;bar\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">this</span> foo&amp; self)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;bar &amp;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">this</span> <span class="type">const</span> foo&amp; self)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;const bar &amp;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">this</span> foo&amp;&amp; self)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;bar &amp;&amp;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">this</span> <span class="type">const</span> foo&amp;&amp; self)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;const bar &amp;&amp;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	foo a;</span><br><span class="line">	a.<span class="built_in">bar</span>();</span><br><span class="line">	std::<span class="built_in">move</span>(a).<span class="built_in">bar</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> foo b;</span><br><span class="line">	b.<span class="built_in">bar</span>();</span><br><span class="line">	std::<span class="built_in">move</span>(b).<span class="built_in">bar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?如果正确，打印什么?</p>
<h3 id="第三题-9"><a href="#第三题-9" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="type">int</span> n&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">plus</span><span class="params">(<span class="keyword">this</span> X x)</span> </span>&#123;</span><br><span class="line">		x.n++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X x;</span><br><span class="line">	x.<span class="built_in">plus</span>();</span><br><span class="line">	<span class="keyword">auto</span> p = &amp;X::plus;</span><br><span class="line">	<span class="built_in">p</span>(x);</span><br><span class="line">	std::cout &lt;&lt; x.n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?如果正确，打印什么?</p>
<h3 id="第四题-5"><a href="#第四题-5" class="headerlink" title="第四题"></a>第四题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> p = [n = <span class="number">0</span>](<span class="keyword">this</span> <span class="keyword">auto</span> self, <span class="keyword">auto</span> f, <span class="keyword">auto</span> x) &#123;</span><br><span class="line">		<span class="built_in">f</span>(x);</span><br><span class="line">		self.n++;</span><br><span class="line">		std::cout &lt;&lt; self.n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">p</span>([](<span class="keyword">auto</span> x) &#123;std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;, <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">p</span>([](<span class="keyword">auto</span> x) &#123;std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?如果正确，打印什么?</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="第一题-16"><a href="#第一题-16" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">f</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; ret = <span class="built_in">f</span>(<span class="string">&quot;哈哈&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?</p>
<h3 id="第二题-14"><a href="#第二题-14" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n=<span class="number">1</span>)</span><span class="keyword">try</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n&#123; <span class="number">6</span> &#125;;</span><br><span class="line">&#125;<span class="built_in">catch</span>(...)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?</p>
<h3 id="第三题-10"><a href="#第三题-10" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="type">size_t</span> size)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X* x = ::<span class="keyword">new</span> X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?</p>
<h3 id="第四题-6"><a href="#第四题-6" class="headerlink" title="第四题"></a>第四题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t</span><span class="params">(<span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">t</span><span class="params">(<span class="type">double</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">t</span>(<span class="number">1.</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?</p>
<h3 id="第五题-5"><a href="#第五题-5" class="headerlink" title="第五题"></a>第五题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::vector v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="function">std::function <span class="title">f</span><span class="params">([](<span class="type">int</span>&amp; i) &#123; i = i * i; &#125;)</span></span>;</span><br><span class="line">	<span class="function">std::function <span class="title">f2</span><span class="params">([](<span class="type">int</span>&amp; i) &#123;i = i + i; &#125;)</span></span>;</span><br><span class="line">	<span class="function">std::function <span class="title">f3</span><span class="params">([](<span class="type">int</span> i) &#123;std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;)</span></span>;</span><br><span class="line">	v | f | f2 | f3;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	v | [](<span class="type">int</span>&amp; i) &#123; i = i * i; &#125; | [](<span class="type">int</span> i) &#123;std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : v | [](<span class="type">int</span>&amp; i) &#123;i = i / <span class="number">10</span>; &#125;) &#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据以上使用代码，实现一个管道运算符</p>
<h3 id="第六题-4"><a href="#第六题-4" class="headerlink" title="第六题"></a>第六题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Ty</span>,<span class="type">size_t</span> size&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">array</span> &#123;</span><br><span class="line">	<span class="function">Ty* <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> arr; &#125;;</span><br><span class="line">	<span class="function">Ty* <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> arr + size; &#125;;</span><br><span class="line">	Ty arr[size];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	::array arr&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; i : arr) &#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码，请为模板类<code>array</code>添加推导指引，让main中代码合法</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然题目看着多，但是我依旧省略了很多,并发那块以后再详细出点题，基本上都只是视频讲过的罢了，这只是初稿，会有很多修改的，欢迎评论提建议。</p>
<p>对了，我们连UB都没详细介绍~~~</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">Hashtable</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-15 20:20:57 / Modified: 20:26:53" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="0-题目地址"><a href="#0-题目地址" class="headerlink" title="0. 题目地址"></a>0. 题目地址</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-hashmap/solution/she-ji-ha-xi-ying-she-by-leetcode-soluti-klu9/">设计哈希映射</a></p>
<h2 id="1-链地址法"><a href="#1-链地址法" class="headerlink" title="1. 链地址法"></a>1. 链地址法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashMap</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> key;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="type">int</span> key,<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Node&gt;[] map;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> capacity = <span class="number">857</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> LinkedList[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> myHashCode = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(map[myHashCode] == null)&#123;</span><br><span class="line">            List&lt;Node&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            list.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">Node</span>(key,value));</span><br><span class="line">            map[myHashCode] = list;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            List&lt;Node&gt; list = map[myHashCode];</span><br><span class="line">            <span class="keyword">for</span>(Node m : list)&#123;</span><br><span class="line">                <span class="keyword">if</span>(m.key == key)&#123;</span><br><span class="line">                    m.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">Node</span>(key,value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> myHashCode = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(map[myHashCode] == null)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Node&gt; list = map[myHashCode];</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node m : list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.key == key)&#123;</span><br><span class="line">                res = m.value;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> myHashCode = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(map[myHashCode] == null)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Node&gt; list = map[myHashCode];</span><br><span class="line">        <span class="keyword">for</span>(Node m : list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.key == key)&#123;</span><br><span class="line">                list.<span class="built_in">remove</span>(m);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-开放寻址法"><a href="#2-开放寻址法" class="headerlink" title="2. 开放寻址法"></a>2. 开放寻址法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHashMap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">HashEntry</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        boolean remove; <span class="comment">// 记录元素是否被删除。</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">HashEntry</span>(<span class="type">int</span> key, <span class="type">int</span> value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashEntry[] table = <span class="keyword">new</span> HashEntry[<span class="number">101</span>]; <span class="comment">// 保存哈希表中的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size = <span class="number">0</span>; <span class="comment">// 哈希表中元素的数量。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">index</span>(key, table);</span><br><span class="line">        <span class="keyword">if</span> (table[index] != null &amp;&amp; !table[index].remove) &#123;</span><br><span class="line">            table[index].value = value; <span class="comment">// 哈希表中已存在该元素。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        table[index] = <span class="keyword">new</span> <span class="built_in">HashEntry</span>(key, value); <span class="comment">// 哈希表中不存在该元素。</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt;= table.length &gt;&gt; <span class="number">1</span>) <span class="built_in">resize</span>(); <span class="comment">// 元素数量超过数组的一半则进行扩容。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        HashEntry entry = table[<span class="built_in">index</span>(key, table)];</span><br><span class="line">        <span class="keyword">return</span> entry == null || entry.remove ? <span class="number">-1</span> : entry.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">index</span>(key, table);</span><br><span class="line">        <span class="keyword">if</span> (table[index] == null || table[index].remove)</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 哈希表中不存在该元素或该元素已被删除则直接返回。</span></span><br><span class="line">        table[index].remove = <span class="literal">true</span>; <span class="comment">// 将元素标记为已删除。</span></span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">int</span> <span class="title">index</span><span class="params">(<span class="type">int</span> key, HashEntry[] table)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = (index = key % table.length) &lt; <span class="number">0</span> ? index + table.length : index;</span><br><span class="line">        <span class="keyword">while</span> (table[index] != null &amp;&amp; table[index].key != key)</span><br><span class="line">            <span class="keyword">if</span> (++index &gt;= table.length)</span><br><span class="line">                index -= table.length;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断一个数是否为一个质数。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> boolean <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span> || n == <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || (n &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对哈希表进行扩容。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashEntry[] oldTable = table; <span class="comment">// 原来的数据。</span></span><br><span class="line">        <span class="comment">// 新数组的容量为原来容量的两倍。</span></span><br><span class="line">        HashEntry[] newTable = <span class="keyword">new</span> HashEntry[<span class="built_in">tableSizeFor</span>(oldTable.length &lt;&lt; <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">for</span> (HashEntry entry : oldTable) <span class="comment">// 将原数组中的元素复制到新数组中。</span></span><br><span class="line">            <span class="keyword">if</span> (entry != null &amp;&amp; !entry.remove) <span class="comment">// 已删除的元素不搬移到新数组中。</span></span><br><span class="line">                newTable[<span class="built_in">index</span>(entry.key, newTable)] = entry;</span><br><span class="line">        table = newTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证哈希表的容量是一个质数。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="type">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((capacity &amp; <span class="number">1</span>) == <span class="number">0</span>) capacity++;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isPrime</span>(capacity)) capacity += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-AV二叉树"><a href="#3-AV二叉树" class="headerlink" title="3. AV二叉树"></a>3. AV二叉树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashMap</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> ***LTree ***lTree;</span><br><span class="line">	<span class="keyword">private</span> NewNode node = null;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		***lTree = <span class="keyword">new</span> ***<span class="built_in">LTree</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">		node = ***lTree.<span class="built_in">insert</span>(node, key, value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">		NewNode nn = ***lTree.get***<span class="built_in">LTree</span>(key,node);</span><br><span class="line">		<span class="keyword">if</span>(nn!=null)&#123;</span><br><span class="line">			<span class="keyword">return</span> nn.val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//不存在，返回-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">		node = ***lTree.<span class="built_in">deleteNode</span>(node, key);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	NewNode left;</span><br><span class="line">	NewNode right;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点高度,高度是指节点到一片树叶的最长路径的长</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewNode</span><span class="params">(<span class="type">int</span> key,<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        height = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ***LTree &#123;</span><br><span class="line">    <span class="keyword">public</span> NewNode root;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算***L节点的高度的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">int</span> <span class="title">height</span><span class="params">(NewNode NewNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果为空，返回height为0</span></span><br><span class="line">        <span class="keyword">return</span> NewNode == null ? <span class="number">0</span> : NewNode.height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算两个的最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右旋转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">NewNode <span class="title">rightRotate</span><span class="params">(NewNode y)</span> </span>&#123;</span><br><span class="line">        NewNode x = y.left;</span><br><span class="line">        NewNode T1 = x.right;</span><br><span class="line">        x.right = y;</span><br><span class="line">        y.left = T1;</span><br><span class="line">        <span class="comment">//更新高度</span></span><br><span class="line">        y.height = <span class="built_in">max</span>(<span class="built_in">height</span>(y.left), <span class="built_in">height</span>(y.right)) + <span class="number">1</span>;</span><br><span class="line">        x.height = <span class="built_in">max</span>(<span class="built_in">height</span>(x.left), <span class="built_in">height</span>(x.right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左旋转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">NewNode <span class="title">leftRotate</span><span class="params">(NewNode x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        NewNode y = x.right;</span><br><span class="line">        NewNode T2 = y.left;</span><br><span class="line">        y.left = x;</span><br><span class="line">        x.right = T2;</span><br><span class="line">        <span class="comment">//更新高度</span></span><br><span class="line">        x.height = <span class="built_in">max</span>(<span class="built_in">height</span>(x.left), <span class="built_in">height</span>(x.right)) + <span class="number">1</span>;</span><br><span class="line">        y.height = <span class="built_in">max</span>(<span class="built_in">height</span>(y.left), <span class="built_in">height</span>(y.right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  获取平衡因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getBalance</span><span class="params">(NewNode NewNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NewNode == null ? <span class="number">0</span> : (<span class="built_in">height</span>(NewNode.left) - <span class="built_in">height</span>(NewNode.right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">NewNode <span class="title">insert</span><span class="params">(NewNode NewNode,<span class="type">int</span> key, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (NewNode == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NewNode</span>(key,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; NewNode.key) &#123;</span><br><span class="line">            NewNode.left = <span class="built_in">insert</span>(NewNode.left, key,val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; NewNode.key) &#123;</span><br><span class="line">            NewNode.right = <span class="built_in">insert</span>(NewNode.right, key,val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	NewNode.val = val;</span><br><span class="line">            <span class="keyword">return</span> NewNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新节点高度</span></span><br><span class="line">        NewNode.height = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">height</span>(NewNode.left), <span class="built_in">height</span>(NewNode.right));</span><br><span class="line">        <span class="comment">//这是插入完毕后的</span></span><br><span class="line">        <span class="type">int</span> balance = <span class="built_in">getBalance</span>(NewNode);</span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &lt; NewNode.left.key) &#123;</span><br><span class="line">            <span class="comment">//右旋</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(NewNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &gt; NewNode.right.key) &#123;</span><br><span class="line">            <span class="comment">//左旋</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(NewNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &gt; NewNode.left.key) &#123;</span><br><span class="line">            <span class="comment">//先左旋，再右旋</span></span><br><span class="line">            NewNode.left = <span class="built_in">leftRotate</span>(NewNode.left);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(NewNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &lt; NewNode.right.key) &#123;</span><br><span class="line">            <span class="comment">//先右旋再左旋</span></span><br><span class="line">            NewNode.right = <span class="built_in">rightRotate</span>(NewNode.right);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(NewNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NewNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">NewNode get***<span class="title">LTree</span><span class="params">(<span class="type">int</span> key,NewNode node)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(node==null) <span class="keyword">return</span> null;</span><br><span class="line">		<span class="keyword">if</span>(key&gt;node.key)&#123;</span><br><span class="line">			node = get***<span class="built_in">LTree</span>(key,node.right);</span><br><span class="line">	    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key&lt;node.key)&#123;</span><br><span class="line">	    	node = get***<span class="built_in">LTree</span>(key,node.left);</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">if</span>(node!=null&amp;&amp;key==node.key) <span class="keyword">return</span> node;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> null;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">NewNode <span class="title">deleteNode</span><span class="params">(NewNode root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; root.key) &#123;</span><br><span class="line">            root.left = <span class="built_in">deleteNode</span>(root.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root.key) &#123;</span><br><span class="line">            root.right = <span class="built_in">deleteNode</span>(root.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//删除节点有两个孩子</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != null &amp;&amp; root.right != null) &#123;</span><br><span class="line">                root.val = <span class="built_in">findMin</span>(root.right).val;</span><br><span class="line">                root.key = <span class="built_in">findMin</span>(root.right).key;</span><br><span class="line">                root.right = <span class="built_in">deleteNode</span>(root.right, root.key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//删除节点只有一个孩子或者没有孩子</span></span><br><span class="line">                root = (root.left != null) ? root.left : root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以下操作是为了恢复***L树的平衡性</span></span><br><span class="line">        <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        root.height = <span class="built_in">max</span>(<span class="built_in">height</span>(root.left), <span class="built_in">height</span>(root.right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> balance = <span class="built_in">getBalance</span>(root);</span><br><span class="line">        <span class="comment">//左-左情况，这里使用&gt;=而不是&gt;就是为了保证这些情形下使用的是单旋转而不是双旋转</span></span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">getBalance</span>(root.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左-右情况</span></span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">getBalance</span>(root.left) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root.left = <span class="built_in">leftRotate</span>(root.left);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右-右情况</span></span><br><span class="line">        <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; <span class="built_in">getBalance</span>(root.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右-左情况</span></span><br><span class="line">        <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; <span class="built_in">getBalance</span>(root.right) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root.right = <span class="built_in">rightRotate</span>(root.right);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> NewNode <span class="title">findMin</span><span class="params">(NewNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findMin</span>(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="4-红黑树"><a href="#4-红黑树" class="headerlink" title="4. 红黑树"></a>4. 红黑树</h2><pre><code class="c++">class MyHashMap &#123;
    private static class TreeNode &#123;
        private int key;
        private int value;
        private boolean color;
        private TreeNode left;
        private TreeNode right;
        private TreeNode parent;

        private TreeNode(int key, int value) &#123;
            this.key = key;
            this.value = value;
        &#125;
    &#125;

    private static final boolean RED = false;
    private static final boolean BLACK = true;
    private TreeNode[] hashtable = new TreeNode[1024];
    private int currentSize;

    public void put(int key, int value) &#123;
        if (currentSize &gt;= hashtable.length) &#123;
            resize(); // 从结果来看，加载因子选 1.0 效率较高。
        &#125;
        int index = key &amp; (hashtable.length - 1);
        insert(index, new TreeNode(key, value));
    &#125;

    public int get(int key) &#123;
        int index = key &amp; (hashtable.length - 1);
        TreeNode node = getNode(index, key);
        return node == null ? -1 : node.value;
    &#125;

    public void remove(int key) &#123;
        int index = key &amp; (hashtable.length - 1);
        delete(index, key);
    &#125;

    // 对哈希表进行扩容。
    private void resize() &#123;
        TreeNode[] oldTable = hashtable;
        hashtable = new TreeNode[hashtable.length &lt;&lt; 1];
        for (TreeNode root : oldTable) &#123;
            postorderTraversal(root);
        &#125;
        currentSize &gt;&gt;= 1;
    &#125;

    // 获取指定位置上的指定结点。
    private TreeNode getNode(int index, int key) &#123;
        TreeNode current = hashtable[index];
        while (current != null) &#123;
            if (current.key == key) &#123;
                break;
            &#125;
            if (current.key &lt; key) &#123;
                current = current.right;
            &#125; else &#123;
                current = current.left;
            &#125;
        &#125;
        return current;
    &#125;

    // 在指定位置上插入结点。
    private void insert(int index, TreeNode insert) &#123;
        TreeNode current = hashtable[index], parent = null; // 分别保存当前结点及其父结点。
        while (current != null) &#123;
            parent = current;
            if (current.key == insert.key) &#123;
                current.value = insert.value;
                return;
            &#125;
            if (current.key &lt; insert.key) &#123;
                current = current.right;
            &#125; else &#123;
                current = current.left;
            &#125;
        &#125;
        insert.parent = parent;
        if (parent == null) &#123;
            hashtable[index] = insert;
        &#125; else if (parent.key &lt; insert.key) &#123;
            parent.right = insert;
        &#125; else &#123;
            parent.left = insert;
        &#125;
        currentSize++;
        fixAfterInsertion(index, insert);
    &#125;

    // 删除指定位置上的指定结点。
    private void delete(int index, int key) &#123;
        TreeNode delete = getNode(index, key);
        if (delete == null) &#123;
            return;
        &#125;
        if (delete.left != null &amp;&amp; delete.right != null) &#123;
            TreeNode successor = delete.right;
            while (successor.left != null) &#123;
                successor = successor.left;
            &#125;
            delete.key = successor.key;
            delete.value = successor.value;
            delete = successor;
        &#125;
        TreeNode replacement = delete.left == null ? delete.right : delete.left;
        if (replacement == null) &#123;
            fixAfterDeletion(index, delete);
            if (delete.parent == null) &#123;
                hashtable[index] = null;
            &#125; else if (delete.parent.left == delete) &#123;
                delete.parent.left = null;
            &#125; else &#123;
                delete.parent.right = null;
            &#125;
        &#125; else &#123; // 被删除的结点只有一个子结点，那它一定是黑色结点，且它的子结点为红色。
            replacement.parent = delete.parent;
            if (delete.parent == null) &#123;
                hashtable[index] = replacement;
            &#125; else if (delete.parent.left == delete) &#123;
                delete.parent.left = replacement;
            &#125; else &#123;
                delete.parent.right = replacement;
            &#125;
            replacement.color = BLACK;
        &#125;
        currentSize--;
    &#125;

    // 对插入后的结点进行调整。
    private void fixAfterInsertion(int index, TreeNode insert) &#123;
        while (colorOf(insert.parent) == RED) &#123; // 只有父结点是红色才进行处理。
            // 分别保存当前结点的父结点、叔父结点、祖父结点。
            TreeNode parent = insert.parent, uncle = sibling(parent), grand = parent.parent;
            grand.color = RED; // 不管是哪种情况，祖父结点都需要染成红色。
            if (colorOf(uncle) == BLACK) &#123; // 叔父结点为黑色。
                if (grand.left == parent) &#123;
                    if (parent.right == insert) &#123;
                        rotationLeft(index, parent); // LR 情况：先对父结点进行左旋转。
                        parent = insert;
                    &#125;
                    rotationRight(index, grand); // LL 情况：对祖父结点进行右旋转。
                &#125; else &#123;
                    if (parent.left == insert) &#123;
                        rotationRight(index, parent); // RL 情况：先对父结点进行右旋转。
                        parent = insert;
                    &#125;
                    rotationLeft(index, grand); // RR 情况：对祖父结点进行左旋转。
                &#125;
                parent.color = BLACK; // 将旋转后的中心结点染成黑色。
                insert = hashtable[index]; // 处理完直接退出循环。
            &#125; else &#123; // 叔父结点为红色，则将父结点与叔父结点都染成黑色，将祖父结点作为新插入的结点继续处理。
                uncle.color = BLACK;
                parent.color = BLACK;
                insert = grand;
            &#125;
        &#125;
        hashtable[index].color = BLACK; // 根结点必须是黑色。
    &#125;

    // 对删除后的结点进行调整。
    private void fixAfterDeletion(int index, TreeNode delete) &#123;
        while (delete.parent != null &amp;&amp; delete.color == BLACK) &#123; // 只有删除的是黑色结点才进行处理。
            // 分别保存当前结点的父结点、兄弟结点。
            TreeNode parent = delete.parent, sibling = sibling(delete);
            if (sibling.color == BLACK) &#123; // 兄弟结点是黑色。
                if (colorOf(sibling.left) == BLACK &amp;&amp; colorOf(sibling.right) == BLACK) &#123; // 兄弟结点没有红色子结点。
                    if (parent.color == BLACK) &#123;
                        delete = parent;
                    &#125;
                    parent.color = BLACK;
                    sibling.color = RED;
                &#125; else &#123; // 兄弟结点有红色子结点。
                    if (parent.left == sibling) &#123;
                        if (colorOf(sibling.left) == BLACK) &#123;
                            rotationLeft(index, sibling); // LR 情况：先对兄弟结点进行左旋转。
                            sibling = sibling.parent;
                        &#125;
                        rotationRight(index, parent); // LL 情况：对父结点进行右旋转。
                    &#125; else &#123;
                        if (colorOf(sibling.right) == BLACK) &#123;
                            rotationRight(index, sibling); // RL 情况：先对兄弟结点进行右旋转。
                            sibling = sibling.parent;
                        &#125;
                        rotationLeft(index, parent); // RR 情况：对父结点进行左旋转。
                    &#125;
                    sibling.color = parent.color; // 旋转后中心结点继承父结点的颜色。
                    sibling.left.color = BLACK;
                    sibling.right.color = BLACK;
                    delete = hashtable[index]; // 处理完直接退出循环。
                &#125;
            &#125; else &#123; // 兄弟结点是红色。
                if (parent.left == sibling) &#123;
                    rotationRight(index, parent);
                &#125; else &#123;
                    rotationLeft(index, parent);
                &#125;
                parent.color = RED;
                sibling.color = BLACK;
            &#125;
        &#125;
    &#125;

    // 获取指定结点的兄弟结点。
    private TreeNode sibling(TreeNode node) &#123;
        if (node.parent.left == node) &#123;
            return node.parent.right;
        &#125;
        return node.parent.left;
    &#125;

    // 对指定位置上的指定结点进行左旋转。
    private void rotationLeft(int index, TreeNode node) &#123;
        TreeNode newRoot = node.right; // 结点的右子结点会成为这颗子树的根结点。
        node.right = newRoot.left;
        if (newRoot.left != null) &#123;
            newRoot.left.parent = node;
        &#125;
        newRoot.left = node;
        newRoot.parent = node.parent;
        if (node.parent == null) &#123;
            hashtable[index] = newRoot;
        &#125; else if (node.parent.left == node) &#123;
            node.parent.left = newRoot;
        &#125; else &#123;
            node.parent.right = newRoot;
        &#125;
        node.parent = newRoot;
    &#125;

    // 对指定位置上的指定结点进行右旋转。
    private void rotationRight(int index, TreeNode node) &#123;
        TreeNode newRoot = node.left; // 结点的左子结点会成为这颗子树的根结点。
        node.left = newRoot.right;
        if (newRoot.right != null) &#123;
            newRoot.right.parent = node;
        &#125;
        newRoot.right = node;
        newRoot.parent = node.parent;
        if (node.parent == null) &#123;
            hashtable[index] = newRoot;
        &#125; else if (node.parent.left == node) &#123;
            node.parent.left = newRoot;
        &#125; else &#123;
            node.parent.right = newRoot;
        &#125;
        node.parent = newRoot;
    &#125;

    // 获取指定结点的颜色。
    private boolean colorOf(TreeNode node) &#123;
        return node == null || node.color;
    &#125;

    // 对结点进行后序遍历。
    private void postorderTraversal(TreeNode node) &#123;
        if (node == null) &#123;
            return;
        &#125;
        postorderTraversal(node.left);
        postorderTraversal(node.right);
        node.left = node.right = node.parent = null;
        node.color = RED;
        int index = node.key &amp; (hashtable.length - 1);
        insert(index, node);
    &#125;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">NP probelm</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-15 20:20:57 / Modified: 20:17:41" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NP/" itemprop="url" rel="index"><span itemprop="name">NP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="NP-completeness"><a href="#NP-completeness" class="headerlink" title="NP completeness"></a>NP completeness</h1><h2 id="proface"><a href="#proface" class="headerlink" title="proface"></a>proface</h2><p>P：Polynomial</p>
<p>NP：Non-determinstic Polynomial</p>
<p>NPC：Non-deterministic Polynomial complete</p>
<p>RP：人品</p>
<p>reducibility：归约，约化</p>
<h2 id="time-compleity"><a href="#time-compleity" class="headerlink" title="time compleity"></a>time compleity</h2><p>时间复杂度并不是表示一个程序解决问题需要花费的时间，而是当问题规模扩大后，程序需要的时间长度增长的多快</p>
<h2 id="whats-polynomial？"><a href="#whats-polynomial？" class="headerlink" title="whats polynomial？"></a>whats polynomial？</h2><p>假设有一个自变量 <code>n</code></p>
<p><code>n + n^2 + 3n^3</code> 这就是一个多项式</p>
<p><code>2^n</code> , <code>n!</code>  不是多项式，他们也有自己的名字：超多项式</p>
<blockquote>
<p>一般而言，当 <code>n</code> 作为底数时，就是多项式，当 <code>n</code> 作为指数时或者阶乘时，就是超多项式。</p>
</blockquote>
<h2 id="reducibility"><a href="#reducibility" class="headerlink" title="reducibility"></a>reducibility</h2><p>  简单地说，一个问题A可以约化为问题B的含义即是，可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个“规则”，按照这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能得到一样的结果。这个规则即是：两个方程的对应项系数不变，一元二次方程的二次项系数为0。按照这个规则把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton回路可以约化为TSP问题(Travelling Salesman Problem，旅行商问题)：在Hamilton回路问题中，两点相连即这两点距离为0，两点不直接相连则令其距离为1，于是问题转化为在TSP问题中，是否存在一条长为0的路径。Hamilton回路存在当且仅当TSP问题中存在长为0的回路。<br>  “问题A可约化为问题B”有一个重要的直观意义：B的时间复杂度高于或者等于A的时间复杂度。也就是说，问题A不比问题B难。这很容易理解。既然问题A能用问题B来解决，倘若B的时间复杂度比A的时间复杂度还低了，那A的算法就可以改进为B的算法，两者的时间复杂度还是相同。正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者。<br>  很显然，约化具有一项重要的性质：约化具有传递性。如果问题A可约化为问题B，问题B可约化为问题C，则问题A一定可约化为问题C。这个道理非常简单，就不必阐述了。<br>  现在再来说一下约化的标准概念就不难理解了：如果能找到这样一个变化法则，对任意一个程序A的输入，都能按这个法则变换成程序B的输入，使两程序的输出相同，那么我们说，问题A可约化为问题B。<br>  当然，我们所说的“可约化”是指的可“多项式地”约化(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的。约化的过程只有用多项式的时间完成才有意义。</p>
<h2 id="p-np-npc-np-hard"><a href="#p-np-npc-np-hard" class="headerlink" title="p,np,npc,np-hard"></a>p,np,npc,np-hard</h2><h3 id="1-P问题"><a href="#1-P问题" class="headerlink" title="1. P问题"></a>1. P问题</h3><p>在多项式时间内可解的问题</p>
<h3 id="2-NP问题"><a href="#2-NP问题" class="headerlink" title="2. NP问题"></a>2. NP问题</h3><p>首先，NP问题不是指： not P问题。</p>
<p>它指的是可以在多项式的时间里验证一个解的问题。</p>
<p>但这并不意味着Np问题可以在多项式时间内可解，在多项式时间内可验证和在多项式时间内可解没有任何关联。</p>
<p>换句话来说，NP问题指的是可以在多项式的时间里才出一个解的问题。</p>
<blockquote>
<p> 哈密顿回路就是一个NP问题</p>
<p>之所以要定义NP问题，是因为通常只有NP问题才可能找到多项式的算法。我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。</p>
</blockquote>
<p>因此，显然的，&lt;font color &#x3D; “blue”&gt;所有的 P 类问题都是 NP 问题。</font>也就是说，能在多项式时间内解决一个问题，必然能在多项式时间验证一个问题的解。</p>
<p>关键是，人们想知道，是否所有的 NP 问题都是 P 类问题？也即，是否有 P&#x3D;NP？</p>
<p>通常所谓的“NP问题”，其实就一句话：证明或推翻P&#x3D;NP。</p>
<p>NP问题很难解决，但现在有一个总的趋势，然们普遍倾向于认为：P!&#x3D;NP，因为人们在研究NP问题的时候找到了一类特殊的NP问题叫做NP-完全问题，也就是NPC问题。</p>
<h3 id="3-NPC问题"><a href="#3-NPC问题" class="headerlink" title="3. NPC问题"></a>3. NPC问题</h3><p>  好了，从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。再回想前面讲的P和NP问题，联想起约化的传递性，自然地，我们会想问，如果不断地约化上去，不断找到能“通吃”若干小NP问题的一个稍复杂的大NP问题，那么最后是否有可能找到一个时间复杂度最高，并且能“通吃”所有的 NP问题的这样一个超级NP问题？答案居然是肯定的。也就是说，存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是传说中的NPC 问题，也就是NP-完全问题。NPC问题的出现使整个NP问题的研究得到了飞跃式的发展。我们有理由相信，NPC问题是最复杂的问题。</p>
<p>  NPC问题的定义非常简单。同时满足下面两个条件的问题就是NPC问题。首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。证明一个问题是 NPC问题也很简单。先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它（由约化的传递性，则NPC问题定义的第二条也得以满足；至于第一个NPC问题是怎么来的，下文将介绍），这样就可以说它是NPC问题了。</p>
<p>  既然所有的NP问题都能约化成NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决了，NP也就等于P 了。因此，给NPC找一个多项式算法太不可思议了。因此，前文才说，“正是NPC问题的存在，使人们相信P≠NP”。我们可以就此直观地理解，NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。</p>
<h3 id="4-np-hard"><a href="#4-np-hard" class="headerlink" title="4. np-hard"></a>4. np-hard</h3><p>  顺便讲一下NP-Hard问题。NP-Hard问题是这样一种问题，它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广）。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。</p>
<h2 id="case-npc-problem"><a href="#case-npc-problem" class="headerlink" title="case: npc problem"></a>case: npc problem</h2><p>逻辑电路问题。这是第一个NPC问题。其它的NPC问题都是由这个问题约化而来的。因此，逻辑电路问题是NPC类问题的“鼻祖”。</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><a href="%5Bref%5D(https://www.zhihu.com/question/24653072)">知乎：什么是多项式？</a></p>
<p><a target="_blank" rel="noopener" href="http://www.matrix67.com/blog/archives/105">Matrix67: 什么是P问题、NP问题和NPC问题</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">OSTEP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-15 20:20:57 / Modified: 20:22:10" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="OSTEP-jyy"><a href="#OSTEP-jyy" class="headerlink" title="OSTEP jyy"></a>OSTEP jyy</h1><h2 id="0x-01-reference"><a href="#0x-01-reference" class="headerlink" title="0x 01 reference"></a>0x 01 reference</h2><p><a target="_blank" rel="noopener" href="http://jyywiki.cn/OS/2022/">官网</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12L4y1379V/?spm_id_from=333.788&vd_source=38033fe3a1f136728a1d6f8acf710b51">教学视频</a></p>
<hr>
<h3 id="1-why-learn-OS"><a href="#1-why-learn-OS" class="headerlink" title="1.why learn OS"></a>1.why learn OS</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>解决一个问题的步骤：why-what-how</span><br><span class="line">为什么要学习操作系统</span><br><span class="line">什么是操作系统</span><br><span class="line">怎样学习操作系统</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>三个根本问题</span><br><span class="line">（<span class="number">1</span>）操作系统服务谁</span><br><span class="line">程序=状态机</span><br><span class="line">课程涉及：多线程Linux应用程序</span><br><span class="line">（<span class="number">2</span>）（乘机/应用视角）操作系统为程序提供什么服务</span><br><span class="line">操作系统=对象+API（用来操纵对象)</span><br><span class="line">课程涉及：POSIX+部分Linux特性</span><br><span class="line">（<span class="number">3</span>）（实现/硬件角度）如何实现操作系统提供的服务</span><br><span class="line">操作系统=C程序</span><br><span class="line">课程涉及：xv6,自制迷你操作系统</span><br></pre></td></tr></table></figure>

<h3 id="2-code"><a href="#2-code" class="headerlink" title="2.code"></a>2.code</h3><table>
<thead>
<tr>
<th>说明</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>查看用户名</td>
<td>uname -a</td>
</tr>
<tr>
<td>传送ACWing配置</td>
<td>scp .bashrc .vimrc .tmux.conf：…</td>
</tr>
<tr>
<td>下载tldr(too long dont read)</td>
<td>sudo apt-get install tldr</td>
</tr>
</tbody></table>
<h3 id="3-wrong-when-install-tldr"><a href="#3-wrong-when-install-tldr" class="headerlink" title="3. wrong when install tldr"></a>3. wrong when install tldr</h3><p>报错，出现用户名 is not in the sudoers file.<br>是因为当前的用户没有加入到sudo的配置文件里<br>解决方案：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>切换到root用户</td>
<td>su - root</td>
</tr>
<tr>
<td>修改配置文件</td>
<td>vim &#x2F;etc&#x2F;sudoers</td>
</tr>
<tr>
<td>修改</td>
<td>增加配置, 在打开的配置文件中，找到ununtu&#x2F;root ALL&#x3D;(ALL) ALL, 在下面添加一行：your_user_name ALL&#x3D;(ALL) ALL，wq!退出，这个文件是只读的，所以需要加！在ubuntu下是最后一行</td>
</tr>
</tbody></table>
<h3 id="4-some-jyy-wonderful-operating"><a href="#4-some-jyy-wonderful-operating" class="headerlink" title="4. some jyy wonderful operating"></a>4. some jyy wonderful operating</h3><table>
<thead>
<tr>
<th>功能</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>在vim里面编译C&#x2F;C++</td>
<td>:!gcc&#x2F;g++  %  -o  main (% 获取当前文件名)</td>
</tr>
<tr>
<td>在vim里面编译并运行C++</td>
<td>:!g++ % -o main &amp;&amp; .&#x2F;main</td>
</tr>
<tr>
<td>wget用于从网络上下载资源，没有指定目录，下载资源回默认为当前目录。wget支持HTTP，HTTPS和FTP协议，可以使用HTTP代理</td>
<td>wget url</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="0x-02-what-is-Programs-and-Compilers"><a href="#0x-02-what-is-Programs-and-Compilers" class="headerlink" title="0x 02 what is Programs and Compilers"></a>0x 02 what is Programs and Compilers</h2><h3 id="1-notes"><a href="#1-notes" class="headerlink" title="1. notes"></a>1. notes</h3><blockquote>
<p>程序就是状态机</p>
<blockquote>
<p>数字系统是状态机，程序运行在数字系统上，因而程序也应该是状态机。</p>
<p>在 C 语言中，程序中所有的东西（堆，栈）就是程序的状态，每执行一条一句，程序的状态就会变一下。</p>
</blockquote>
<p>include的形式语义就是复制粘贴，它是在预编译阶段处理的，例如我们 <code>#include &lt;tets.c&gt;</code> , 在预处理阶段，会从一个目录找到 include 的 test.c 文件，然后将它的内容复制粘贴到源代码中。</p>
</blockquote>
<h3 id="2-more-instruction"><a href="#2-more-instruction" class="headerlink" title="2. more instruction"></a>2. more instruction</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb layout src</span><br><span class="line">asm volatile(“rdrand %rax”);</span><br><span class="line">info proc mappings :查看进程信息</span><br><span class="line">unist: unix standard library</span><br></pre></td></tr></table></figure>

<h3 id="3-bug"><a href="#3-bug" class="headerlink" title="3. bug"></a>3. bug</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FOE_EACH(_) _(X) _(Y);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE(X) int X, X1;</span></span><br><span class="line"></span><br><span class="line">FOE_EACH(DEFINE)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    我们的本意是执行:</span></span><br><span class="line"><span class="comment">    int X, X1; int Y, Y1;</span></span><br><span class="line"><span class="comment">    但是我们执行是：</span></span><br><span class="line"><span class="comment">    int X, X1; int Y, X1;</span></span><br><span class="line"><span class="comment">  	这里的X1重复定义了</span></span><br><span class="line"><span class="comment">  	这是因为X1的X并不能被识别，它会被认为是一个字符串</span></span><br><span class="line"><span class="comment">	正确的写法是:</span></span><br><span class="line"><span class="comment">	#define DEFINE(X) int X, X##1</span></span><br><span class="line"><span class="comment">	这样X##1的X就可以被识别</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="4-Unix’s-philosophy"><a href="#4-Unix’s-philosophy" class="headerlink" title="4. Unix’s philosophy"></a>4. Unix’s philosophy</h3><ul>
<li>Make each program do one thing well</li>
<li>Expect the output of every program to become the input to anothe</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">RBTree</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-15 20:20:57 / Modified: 20:18:29" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RBT"><a href="#RBT" class="headerlink" title="RBT"></a>RBT</h1><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/SwgIJV/">LC</a></p>
<p><a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/rbtree/">OI WiKi</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/julycoding/The-Art-Of-Programming-By-July-2nd/blob/master/ebook/code/c/4.4%EF%BC%9A%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88LCA%E9%97%AE%E9%A2%98.LCAProblem.c">github</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e136ec79235c">illustrate</a></p>
<h2 id="insight"><a href="#insight" class="headerlink" title="insight"></a>insight</h2><h2 id="completement"><a href="#completement" class="headerlink" title="completement"></a>completement</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">design parteen & STL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-15 20:20:57 / Modified: 20:28:16" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/common/" itemprop="url" rel="index"><span itemprop="name">common</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Design-Patterns-TODO"><a href="#Design-Patterns-TODO" class="headerlink" title="Design Patterns[TODO]"></a>Design Patterns[TODO]</h1><h2 id="0x01-依赖转置原则"><a href="#0x01-依赖转置原则" class="headerlink" title="0x01. 依赖转置原则"></a>0x01. 依赖转置原则</h2><h3 id="ref1"><a href="#ref1" class="headerlink" title="ref1"></a>ref1</h3><p>例如人吃巧克力：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface IChocolates&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Oreo</span> implements IChocolates &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dove</span> implements IChocolates &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> interface Person &#123; <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">( IChocolates chocolates )</span></span>; &#125;</span><br></pre></td></tr></table></figure>



<p>上面的例子中人对巧克力产生了依赖，那人吃的行为依赖其实跟巧克力没有关系，在巧克力出现之前就已经存在了，因此吃的动作依赖的接口应该是人本身内部的概念，这个接口的归属权应该属于人，概念应该为可食用的（edible）。因此人对巧克力的依赖关系应该倒置为巧克力对可食用接口的依赖。这样倒置之后对人来说具有了更好的扩展性，不仅可以吃各种不同的巧克力，还可以吃饼干，米饭，鱼肉等等其它任何可吃的东西。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface IChocolates extends IEdible&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Oreo</span> implements IChocolates &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dove</span> implements IChocolates &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> interface Person &#123; <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">( IEdible edible )</span></span>; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ref2"><a href="#ref2" class="headerlink" title="ref2"></a>ref2</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/li1358159/article/details/123306664">REF</a></p>
<h3 id="ref3"><a href="#ref3" class="headerlink" title="ref3"></a>ref3</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012346890/article/details/111034907?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-111034907-blog-123306664.pc_relevant_aa2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-111034907-blog-123306664.pc_relevant_aa2&utm_relevant_index=1">REF</a></p>
<p>在例子中，如果我们让上层 dirver 依赖于底层的细节 car，那么就完全错误了。</p>
<p>我们应该让 diver 依赖于抽象的 CAR，让具体的 car 继承自抽象的 CAR。 </p>
<h2 id="0x02-装饰模式"><a href="#0x02-装饰模式" class="headerlink" title="0x02 装饰模式"></a>0x02 装饰模式</h2><h3 id="ref1-1"><a href="#ref1-1" class="headerlink" title="ref1"></a>ref1</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40594696/article/details/107611074">原文链接</a></p>
<p>1.什么是装饰模式</p>
<p>装饰模式是一种用于替代继承的技术。它无需定义子类却可以给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。</p>
<p>举个栗子：一张照片，不改变照片本身，给它增加一个相框，使他增加防潮的功能，这就是装饰模式。</p>
<p>装饰模式是一种对象结构型模式，他以对客户透明的方式动态的给一个对象附加上更多的责任，可以在不需要创建更多子类的情况下让对象的功能得以扩展。</p>
<p>2.装饰模式的结构</p>
<p>（1）<strong>Component（抽象构件）：</strong>它是具体构件和抽象装饰类的共同父类，声明了在具体构建中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。</p>
<p>（2）<strong>ConcreteComponent（具体构件）：</strong>它是抽象构件的子类，用于定义具体的构建对象，实现了在抽象构建中声明的方法，装饰类可以给它增加额外的职责。</p>
<p>（3）<strong>Decorator（抽象装饰类）：</strong>他也是抽象构件的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。</p>
<p>（4）<strong>ConcreteDecorator（具体装饰类）：</strong>它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，他可以调用在抽象装饰类中定义的方法，并可以增加新的方法用于扩充对象的行为。</p>
<h3 id="ref2-1"><a href="#ref2-1" class="headerlink" title="ref2"></a>ref2</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhshulin/article/details/38665187">refreence</a></p>
<p>####### <a target="_blank" rel="noopener" href="https://blog.csdn.net/NEXUS666/article/details/115672452">更好的 ref – c++ 实例</a></p>
<h2 id="0x03-代理模式"><a href="#0x03-代理模式" class="headerlink" title="0x03 代理模式"></a>0x03 代理模式</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/starlee/article/details/1647412">引用计数</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012344185/article/details/114497309">引用计数</a></p>
<p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/169263">jk时间 – 好文</a></p>
<h2 id="0x04-工厂模式"><a href="#0x04-工厂模式" class="headerlink" title="0x04 工厂模式"></a>0x04 工厂模式</h2><p>现实生活中，工厂是负责生产产品的；同样在设计模式中，简单工厂模式我们可以理解为<strong>负责生产对象</strong>的一个类，称为“工厂类”。</p>
<h2 id="0X05-原型模式"><a href="#0X05-原型模式" class="headerlink" title="0X05 原型模式"></a>0X05 原型模式</h2><p>原型模式定义了一个 virtual 拷贝构造函数，C++ 有吗？ C++ 没有虚拷贝构造</p>
<p><a href="cloud.tencent.com/developer/article/1686487">ref1</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/365222623">ref2</a></p>
<p><a href="cnblogs.com/jylz/p/10648439.html">ref3</a></p>
<h1 id="STL-TODO"><a href="#STL-TODO" class="headerlink" title="STL[TODO]"></a>STL[TODO]</h1><h2 id="prelogue"><a href="#prelogue" class="headerlink" title="prelogue"></a>prelogue</h2><h3 id="0x01-导读"><a href="#0x01-导读" class="headerlink" title="0x01 导读"></a>0x01 导读</h3><p>候捷 STL 与 范型编程学习笔记。</p>
<h3 id="0x02-英语"><a href="#0x02-英语" class="headerlink" title="0x02 英语"></a>0x02 英语</h3><p>identity：同一，本身</p>
<h3 id="0x03-problem"><a href="#0x03-problem" class="headerlink" title="0x03 problem"></a>0x03 problem</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/nirendao/article/details/115815599?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-115815599-blog-110736211.pc_relevant_3mothn_strategy_and_data_recovery&spm=1001.2101.3001.4242.1&utm_relevant_index=3">1</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/luolaihua2018/article/details/110736211">2</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013317445/article/details/89680330">3</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6b526aa481b1">4</a></p>
<h2 id="一、container"><a href="#一、container" class="headerlink" title="一、container"></a>一、container</h2><p>大家风范：用前置++，–实现后置++，–</p>
<p>仿函数：函数对象</p>
<p>关联：有key和value</p>
<p>array就是把数组包装成一个class</p>
<p>deque：dai ke</p>
<p>set, map:红黑树.c++并未规定必须使用红黑树，只不过红黑树效率高，因此各大制定标准库的公司都使用红黑树。</p>
<p>set的key就是value，value就是key。</p>
<p>哈希表由一个个桶（bucket）组成，每个桶都是一个链表（link）。现在哈希表大多采用分离链表发（yxc：拉链法）实现。</p>
<p>头文件有保护机制，多次引入没问题</p>
<p>vector空间两倍增长(成长)</p>
<p>（2）vector 有一个机制是这样的，如果新加入一个元素，比如通过push_back()，但是size 大于了capacity，那么vector 就会重新找一块更大的地方再把数据放进去。重新分配的过程：<strong>申请一块新的内存 &gt; 拷贝数据 &gt; 释放原内存</strong>。</p>
<p> 2、vector扩容怎么拷贝？</p>
<p>经常问的一个问题，vector怎么扩容？最简单的回答就是先申请内存，再拷贝，最后销毁原来的内存，然后是1.5倍还是2倍，解释一下。</p>
<p>但是！我看到有人问，怎么拷贝？？？what？？？</p>
<p>没想到吧，看书还是看漏了。</p>
<p>拷贝用的是uninitialized_copy，如果拷贝的是POD（标量型别，也就是trivial）调用的是copy（自己去看STL 的copy实现），如果是non-POD使用for循环遍历，调用construct，一个一个的构造，针对char<em>和wchar_t</em>，uninitialized_copy直接用memmove来执行复制行为，更加快。</p>
<p>版权声明：本文为CSDN博主「m0_60126088」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_60126088/article/details/119616254">https://blog.csdn.net/m0_60126088/article/details/119616254</a></p>
<p>虽然标准库提供了sort函数，但是一些函数也提供了自己的sort，当容器存在自己的sort的时候，优先使用容器自己的，它自己的肯定更好，不然它提供这个函数干嘛。</p>
<p>forward_list 和 list 提供了自己的 sort</p>
<p>forward_list使用头插法。因此只能在链表头插入元素。</p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6908.html">deque容器底层实现</a></p>
<p>queue 和 stack 由于元素进出的顺序是死的（固定的），因此他们没有迭代器，如果有迭代器的话，我们就有可能通过迭代器改变元素进出的顺序，这是不合理的。</p>
<p>set，map底层是红黑树（自平衡二叉查找树）</p>
<p>multimap不可以用下标做 iterator</p>
<p>hashtable 的 bucket 比 元素个数还有要多是合理的，因为元素中间会空出很多 bucket。事实上，bucket的个数肯定比元素个数多，否则的话 bucket 就要重新扩充变为原来的（大约）两倍。（经验法则，避免 bucket 的长度太长）（以空间换时间）</p>
<p>map的底部就是一个 pair</p>
<p>map，set 会丢掉重复元素</p>
<p>从测试结果我们可以看出，使用insert()插入元素的方式并不能覆盖掉相同key的值；而使用[]方式则可以覆盖掉之前的值。为什么会出现这样的结果呢？</p>
<p>原因分析<br>我们可以通过源码来找原因，在map的源码中，insert方法是这样定义的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; __x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> _M_t.<span class="built_in">insert_unique</span>(__x); &#125;</span><br></pre></td></tr></table></figure>

<p>他调用_M_t.insert_unique(_x)方法，该方法会首先遍历整个集合，判断是否存在相同的key，如果存在则直接返回，放弃插入操作。如果不存在才进行插入。<br>而[]方式是通过重载[]操作符来实现的，它直接进行插入或覆盖</p>
<blockquote>
<p> 今天调试程序，弄得有点纠结。无意间，和一帮同事讨论起一个问题：进程结束操作系统会回收new的内存吗？在自己的印象中，一直固执地认为，在使用C++操作分配对象内存后，如果程序员自己不用相应的delete操作回收的话，这块从堆内存是一直存在。在讨论中，有同事提醒说，在进程结束后，new操作的内存会被回收。但也只是结论，也说不出具体理由。</p>
<pre><code>没关系，何不google一下，一查下去，答案已是清晰：

“内存泄漏不是系统无法回收那片内存，而是你自己的应用程序无法使用那片内存。当你程序结束时，你所有分配的内存自动都被系统回收，不存在泄漏问题。但是在你程序的生命期内，如果你分配的内存都不回收，你将很快没内存使用。”再用自己的一句话来概括的话就是：操作系统本身就有内存管理的职责，一般而言，用malloc、new操作分配的内存，在进程结束后，操作系统是会自己的回收的。但某些系统态的资源，用特殊的系统API申请的内存就不一定了，比如：linux中的shmget申请的共享内存，就与进程结束无关了。

 经过这一番查找，不禁自己为自己汗颜了一把，之前还以为自己对内存管理理解较深，现在才明白：在没有认真深入地钻研过操作系统内核原理之前，所有对内存管理的理解还是浮在表面上的。这次讨论也分外地提醒自己，自己知识的盲区还有许多，还要不断的踏踏实实地努力学习啊！
</code></pre>
<hr>
<p> 版权声明：本文为CSDN博主「stanjiang2010」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/stanjiang2010/article/details/5386647">https://blog.csdn.net/stanjiang2010/article/details/5386647</a></p>
</blockquote>
<p>不建议使用分配器。</p>
<p>oop企图将data和method关联在一起</p>
<p>gp企图将data和method分离开</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/y1196645376/article/details/52938474">容器内存分配</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line">        PII p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">complex</span>(T _val) : <span class="built_in">val</span>(_val) &#123;&#125;</span><br><span class="line">        T val;</span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">        <span class="keyword">friend</span> complex&lt;U&gt; <span class="title">cal</span><span class="params">(complex&lt;U&gt; a, complex&lt;U&gt; b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">complex&lt;T&gt; <span class="title">cal</span><span class="params">(complex&lt;T&gt; a, complex &lt;T&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">complex&lt;T&gt; <span class="title">c</span><span class="params">(a.val + b.val)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">    <span class="comment">// return complex(a.val + b.val);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test3</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*====================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test::PII p = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    cout &lt;&lt; p.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">    <span class="function">complex&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">complex&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.val &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b.val &lt;&lt; endl;</span><br><span class="line">    complex&lt;<span class="type">int</span>&gt; c = <span class="built_in">cal</span>(a, b);</span><br><span class="line">    cout &lt;&lt; c.val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;vec &lt;&lt; endl;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);   <span class="comment">// add -&gt; cap:1</span></span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;vec &lt;&lt; endl;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);   <span class="comment">// add -&gt; cap:2</span></span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;(vec[<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);   <span class="comment">// add -&gt; cap:4</span></span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;(vec[<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);   <span class="comment">// add -&gt; cap:8</span></span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;(vec[<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i ++ )   vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; &amp;vec &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    cout &lt;&lt; m[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line">    cout &lt;&lt; m[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    m[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    m[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; m[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、alloactor"><a href="#二、alloactor" class="headerlink" title="二、alloactor"></a>二、alloactor</h2><p>容器的幕后英雄。</p>
<p>所有的分配和释放动作最后都会跑到 malloc 和 free 去。</p>
<p>分配器的 allocate 和 deallocate 最终都是使用 malloc 和 free</p>
<p>直接使用分配器在释放内存的时候，还需要指出需要释放的内存大小。</p>
<p>因此并不建议直接使用分配器分配内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *x = <span class="built_in">new</span>(<span class="string">&quot;hello&quot;</span>) <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;();   </span><br><span class="line">    <span class="type">int</span> *p = a.<span class="built_in">allocate</span>(<span class="number">512</span>, <span class="number">0</span>);</span><br><span class="line">    a.<span class="built_in">deallocate</span>(p, <span class="number">512</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="三、list"><a href="#三、list" class="headerlink" title="三、list"></a>三、list</h2><p>不允许 x++ ++</p>
<p>允许 ++ ++ x</p>
<p>所有的容器区间都是前闭后开</p>
<p>在链表中为了保证这个要求，必须要设置一个虚节点（为空）</p>
<h2 id="四、vector"><a href="#四、vector" class="headerlink" title="四、vector"></a>四、vector</h2><p>内存的扩充一般不会是原地扩充，它会在另一个地方找内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(vec) &lt;&lt; endl; <span class="comment">// 24 = 3 * 8(point)</span></span><br></pre></td></tr></table></figure>

<p>public 继承表示一种 is-a 的关系</p>
<h2 id="五、array"><a href="#五、array" class="headerlink" title="五、array"></a>五、array</h2><p>array 内部的数据就是一个真的数组，它没有tors</p>
<h2 id="六、deque"><a href="#六、deque" class="headerlink" title="六、deque"></a>六、deque</h2><p>号称自己拥有连续空间^^</p>
<p>连续是假象，分段是事实。</p>
<p>deque（dei ke）其实是分段连续的。deque的数据由许多个段组成，段与段之间不连续，每个段内连续。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i ++ )    q.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span> - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *x = &amp;q[i + <span class="number">1</span>], *y = &amp;q[i];</span><br><span class="line">        <span class="keyword">if</span>(y - x != <span class="number">-1</span>)  </span><br><span class="line">            cout &lt;&lt; y - x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; &amp;q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; &amp;q[i + <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试结果</span></span><br><span class="line"><span class="number">-5</span> <span class="number">0x19d4e6c</span> <span class="number">0x19d4e80</span></span><br><span class="line"><span class="number">-5</span> <span class="number">0x19d507c</span> <span class="number">0x19d5090</span></span><br><span class="line"><span class="number">-5</span> <span class="number">0x19d528c</span> <span class="number">0x19d52a0</span></span><br><span class="line"><span class="number">-5</span> <span class="number">0x19d549c</span> <span class="number">0x19d54b0</span></span><br><span class="line"><span class="number">-45</span> <span class="number">0x19d56ac</span> <span class="number">0x19d5760</span></span><br></pre></td></tr></table></figure>

<p>deque 的底部实现是一个 vector（称为 map ？？ ），vector 的每个元素是一个指针，每个指针指向一个缓冲区 buffer。</p>
<p>其迭代器是一个类</p>
<ol>
<li>first：当前所在 buffer 的起点</li>
<li>last：当前所在 buffer 的重点</li>
<li>node：处于（deque控制中心） 的那个段</li>
<li>cur：处于当前 buffer 的位置</li>
</ol>
<p>first 和 last 相当于两个哨兵[first，last) 前闭后开</p>
<p>迭代器在移动的过程中，每次移动都需要判断是否移动到了当前段的末尾，来决定是否需要调到下一个段。（效率低！每次都需要判断一下）</p>
<p>和 vector 一样，deque 也是 2 倍增长的，因此它也有 capacity，事实上标准库并未规定容器的增长细节，但是大多数实现都使用了 2 倍增长。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="type">clock_t</span> start;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )    q.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">clock</span>() - start) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )    vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">clock</span>() - start) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )    sum = q[i];</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">clock</span>() - start) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )    sum = vec[i];</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">clock</span>() - start) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15584</span></span><br><span class="line"><span class="number">16521</span></span><br><span class="line"><span class="number">79156</span></span><br><span class="line"><span class="number">3326</span></span><br></pre></td></tr></table></figure>

<p>deque 在拓展的时候 copy 方式是 copy 到新空间的中间位置，以方便前面和后面的扩充。</p>
<h2 id="八、queue"><a href="#八、queue" class="headerlink" title="八、queue"></a>八、queue</h2><p><code>queue&lt;int,  vector&lt;int&gt;&gt; q;</code> 可以通过编译</p>
<p>但是当我们使用 <code>q.pop();</code> 编译器报错</p>
<p>这说明编译器对模板不会进行一个全面的、完整的检测</p>
<p>只有当你用到时才会进行检测</p>
<h2 id="九、stack"><a href="#九、stack" class="headerlink" title="九、stack"></a>九、stack</h2><h2 id="十、Red-Black-tree"><a href="#十、Red-Black-tree" class="headerlink" title="十、Red-Black tree"></a>十、Red-Black tree</h2><p>关联式容器甚至可以看做一个小型数据库</p>
<p>关联式容器的两个重要的底层数据结构：红黑树和哈希表</p>
<p>红黑树就是一颗高度平衡的二叉搜索树</p>
<p>红黑树提供遍历操作和迭代器</p>
<p>编译器会将 size &#x3D; 0 的class 的size 设为 1</p>
<p>同 link，rb_tree 也设置了一个空节点实现前闭后开区间。</p>
<p>红黑树有【元素自动排序】特性</p>
<p>value[key,date]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; s; </span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : s)    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::value_type x = <span class="number">23.2332</span>;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::key_type y = <span class="number">2.3232</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::value_type p = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::value_type::first_type px = <span class="number">1</span>;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::value_type::second_type py = <span class="number">2</span>;</span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">char</span>&gt;::key_type c1 = <span class="number">65</span>;</span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">char</span>&gt;::mapped_type c2 = <span class="number">97</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; p.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; px &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; py &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c2 &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">test1</span>();</span><br><span class="line">    <span class="built_in">test2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="十一、hashtable"><a href="#十一、hashtable" class="headerlink" title="十一、hashtable"></a>十一、hashtable</h2><p>hashtable 中有很多经验值</p>
<p>经验法则：如果某个 bucket 的元素个数比 bucket 的个数还要多，就要两倍扩充 bucket 并重新放入元素（rehashing）。</p>
<h2 id="十二、-STL-六大部件"><a href="#十二、-STL-六大部件" class="headerlink" title="十二、 STL 六大部件"></a>十二、 STL 六大部件</h2><p>容器替我们处理了内存分配上的问题，我们只管往容器里面添加删除元素，至于数据在内存上是怎样分配的，容器替我们解决了。</p>
<p>容器本身并不能处理内存，它是通过分配器来实现内存的分配与回收的。</p>
<p>算法通过迭代器操作容器。</p>
<ol>
<li>容器</li>
<li>分配器</li>
<li>算法</li>
<li>迭代器</li>
<li>仿函数</li>
<li>适配器</li>
</ol>
<h2 id="十三、新添加待处理"><a href="#十三、新添加待处理" class="headerlink" title="十三、新添加待处理"></a>十三、新添加待处理</h2><p>ctor 有必要添加</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Base() &#123;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> val) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> val) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;   <span class="comment">// wrong</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>Explicitly specializer:全特化</p>
<hr>
<p>模版别名。</p>
<p>typedef 不可以使用参数</p>
<p>define 虽然可以指定参数，但是必须用（）包围起来，而我们希望使用 &lt;&gt; 包围起来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> v(T) vector<span class="string">&lt;T&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> vec = vector&lt;pair&lt;T,T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">v</span>(<span class="type">int</span>) a; <span class="comment">// 很奇怪</span></span><br><span class="line">    vec&lt;pair&lt;<span class="type">double</span>,<span class="type">double</span>&gt;&gt; v;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(Container c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从容器中取出迭代器</span></span><br><span class="line">    <span class="comment">// 每个迭代器都有一个 value_type</span></span><br><span class="line">    <span class="comment">// 通过 value_type 就可以得到容器元素的类型</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;<span class="keyword">typename</span> Container::iterator&gt;::value_type Valtype;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">        c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(), i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : c)    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">            <span class="keyword">typename</span> Container</span><br><span class="line">        &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container&lt;T&gt; c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">        c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(), i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : c)    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    C&lt;<span class="type">int</span>, vector&gt; c;</span><br><span class="line">    <span class="comment">// C&lt;int, list&gt; c;</span></span><br><span class="line">    <span class="comment">// C&lt;int, queue&gt; c;</span></span><br><span class="line">    <span class="comment">// C&lt;int, map&gt; c;</span></span><br><span class="line">    <span class="comment">// C&lt;int, set&gt; c;</span></span><br><span class="line">    <span class="comment">// C&lt;int, stack&gt; c;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/409436201">模板模板参数</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T a, b;</span><br><span class="line">    <span class="built_in">Foo</span>() &#123;</span><br><span class="line">        a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Ctor for Foo::&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dtor for Foo::&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">            <span class="keyword">class</span> <span class="title class_">Container</span></span><br><span class="line">        &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Foo&lt;T&gt; c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Ctor for C&quot;</span> &lt;&lt; endl;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;begin\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; c.a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c.b &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;end\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">            <span class="keyword">class</span> <span class="title class_">Container</span></span><br><span class="line">        &gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Container&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// f(Foo&lt;int&gt;());</span></span><br><span class="line">    C&lt;<span class="type">int</span>, Foo&gt; c;</span><br><span class="line">    c.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<p>stl</p>
<p>traits：特征，特性</p>
<p>萃取机。</p>
<p>你丢给他某个东西，它可以萃取出这个东西的某些特征。</p>
<p>associated type:</p>
<blockquote>
<p>category</p>
<p>Value_type</p>
<p>Difference_type</p>
<p>pointer</p>
<p>reference</p>
</blockquote>
<p>中间件 for：</p>
<blockquote>
<p>class iterator</p>
<p>Native pointer</p>
<p>const native pointer</p>
</blockquote>
<p>算法所需要的信息：主要是迭代器的是怎么移动的（方向，大小）</p>
<p>虽然虽然可以直接向迭代器询问，迭代器也可以直接回答，但是如果迭代器不是一个 class，即迭代器如果是一个 native point 的话，他就没有 associate type（5个type），也就无法回答。这时候我们需要一个中间层（trait）来回答算法的询问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator_traits&lt;iterator&gt;::type;</span><br></pre></td></tr></table></figure>

<p>Bidirectional:双向</p>
<hr>
<p>typeid</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line">typeid(type).name();</span><br></pre></td></tr></table></figure>

<p>给 typeid 传入一个 type（typeid(type)），他就会生成一个对象，这个对象有 name() 方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out_tag</span><span class="params">(random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;random_access_iterator&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out_tag</span><span class="params">(bidirectional_iterator_tag)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;bidrectional_iterator_tag&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out_tag</span><span class="params">(forward_iterator_tag)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;forward_iterator_tag&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Itr&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out</span><span class="params">(Itr iter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;Itr&gt;::iterator_category category_obj;</span><br><span class="line">    <span class="built_in">out_tag</span>(category_obj);</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Itr&gt;::iterator_category category_type;</span><br><span class="line">    <span class="built_in">out_tag</span>(<span class="built_in">category_type</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;typeid: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(category_obj).<span class="built_in">name</span>() &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;typeid: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(<span class="built_in">category_type</span>()).<span class="built_in">name</span>() &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">out</span>(vector&lt;<span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    <span class="built_in">out</span>(set&lt;<span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    <span class="built_in">out</span>(multiset&lt;<span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    <span class="built_in">out</span>(unordered_set&lt;<span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Base b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;you call f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(Base *b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;you call g(*)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    <span class="built_in">f</span>(d);</span><br><span class="line">    Base *b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="built_in">g</span>(b);</span><br><span class="line">    Derived *pd = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="built_in">g</span>(pd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 继承表示 is-a 关系</span></span><br><span class="line"><span class="comment">因此可以把子类放到父类里面(子类 is-a 父类)*/</span></span><br></pre></td></tr></table></figure>



<hr>
<p>11 个算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">Myclass</span>() &#123; cout &lt;&lt; <span class="string">&quot;Myclass&quot;</span> &lt;&lt; endl; val = <span class="number">0</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Myclass</span>() &#123; cout &lt;&lt; <span class="string">&quot;Dtor for Myclass&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mystruct</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;Mstruct;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">Myclass</span>()); <span class="comment">// 生成一个临时对象，在 main 函数结束之前便结束</span></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), Mstruct);</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main-end&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. accumulate 累计(不是累加，因为还可以指定其他运算方式)</span></span><br><span class="line"><span class="comment">** 指定运算操作时，如果我们传入的是一个函数，那么直接传递函数名即可，</span></span><br><span class="line"><span class="comment">    因为此时相当于我们传入了一个函数指针，函数指针可以类似于函数直接调用。</span></span><br><span class="line"><span class="comment">    例如：void (*ptr)() = &amp;func;</span></span><br><span class="line"><span class="comment">          ptr(); // &lt;==&gt; func();</span></span><br><span class="line"><span class="comment">    但如果我们传入的是一个重载了 () 的函数对象</span></span><br><span class="line"><span class="comment">    我们就必须穿入一个对象，因为只有 class 被实例化为一个 object，</span></span><br><span class="line"><span class="comment">    才能调用它自己的成员函数。</span></span><br><span class="line"><span class="comment">    例如： struct Myclass &#123;</span></span><br><span class="line"><span class="comment">                int operator(int x, int y) &#123; return x + y; &#125;</span></span><br><span class="line"><span class="comment">            &#125;myobj;</span></span><br><span class="line"><span class="comment">            class Myclass &#123; </span></span><br><span class="line"><span class="comment">                int operator(int x, int y) &#123; return x + y; &#125;</span></span><br><span class="line"><span class="comment">            &#125;;</span></span><br><span class="line"><span class="comment">            直接传入 myobj 或者 myclass() 即可，</span></span><br><span class="line"><span class="comment">    如果成员函数是一个模版，还需要指定 &lt;type&gt;</span></span><br><span class="line"><span class="comment">    例如：标准库的 minus</span></span><br><span class="line"><span class="comment">            此时我们传入 minus&lt;int&gt;(); // 传入一个临时对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  2. for_each()</span></span><br><span class="line"><span class="comment">**  例如：</span></span><br><span class="line"><span class="comment">        void func(int x)&#123; cout &lt;&lt; x &lt;&lt; &#x27; &#x27;; &#125;</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt; a&#123;1, 2, 3&#125;;   </span></span><br><span class="line"><span class="comment">        for_each(a.begin(), a.end(), func); // 1 2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  3. replace, replace_if, replace_copy</span></span><br><span class="line"><span class="comment">        count, count_if</span></span><br><span class="line"><span class="comment">    ``` c++</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; a&#123;1, 4, 3, 4, 5&#125;;</span></span><br><span class="line"><span class="comment">    replace(a.begin(), a.end(), 4, 10);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : a)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 1 10 3 10 5 </span></span><br><span class="line"><span class="comment">    replace_if(a.begin(), a.end(), bind2nd(less&lt;int&gt;(), 10), 0);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : a)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 0 10 0 10 0 </span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; b(a.size()); // 必须为 b 分配空间，copy 不会分配空间</span></span><br><span class="line"><span class="comment">    replace_copy(a.begin(), a.end(), b.begin(), 0, 1);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : b)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 1 10 1 10 1 </span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; c; // 或者使用 back_inserter</span></span><br><span class="line"><span class="comment">    replace_copy(a.begin(), a.end(), back_inserter(c), 0, 1);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : c)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 1 10 1 10 1 </span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include &lt;iterator&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">using namespace std;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/* 1. accumulate 累计(不是累加，因为还可以指定其他运算方式)</span></span><br><span class="line"><span class="comment">** 指定运算操作时，如果我们传入的是一个函数，那么直接传递函数名即可，</span></span><br><span class="line"><span class="comment">    因为此时相当于我们传入了一个函数指针，函数指针可以类似于函数直接调用。</span></span><br><span class="line"><span class="comment">    例如：void (*ptr)() = &amp;func;</span></span><br><span class="line"><span class="comment">          ptr(); // &lt;==&gt; func();</span></span><br><span class="line"><span class="comment">    但如果我们传入的是一个重载了 () 的函数对象</span></span><br><span class="line"><span class="comment">    我们就必须穿入一个对象，因为只有 class 被实例化为一个 object，</span></span><br><span class="line"><span class="comment">    才能调用它自己的成员函数。</span></span><br><span class="line"><span class="comment">    例如： struct Myclass &#123;</span></span><br><span class="line"><span class="comment">                int operator(int x, int y) &#123; return x + y; &#125;</span></span><br><span class="line"><span class="comment">            &#125;myobj;</span></span><br><span class="line"><span class="comment">            class Myclass &#123; </span></span><br><span class="line"><span class="comment">                int operator(int x, int y) &#123; return x + y; &#125;</span></span><br><span class="line"><span class="comment">            &#125;;</span></span><br><span class="line"><span class="comment">            直接传入 myobj 或者 myclass() 即可，</span></span><br><span class="line"><span class="comment">    如果成员函数是一个模版，还需要指定 &lt;type&gt;</span></span><br><span class="line"><span class="comment">    例如：标准库的 minus</span></span><br><span class="line"><span class="comment">            此时我们传入 minus&lt;int&gt;(); // 传入一个临时对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  2. for_each()</span></span><br><span class="line"><span class="comment">**  例如：</span></span><br><span class="line"><span class="comment">        void func(int x)&#123; cout &lt;&lt; x &lt;&lt; &#x27; &#x27;; &#125;</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt; a&#123;1, 2, 3&#125;;   </span></span><br><span class="line"><span class="comment">        for_each(a.begin(), a.end(), func); // 1 2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  3. replace, replace_if, replace_copy</span></span><br><span class="line"><span class="comment">        count, count_if</span></span><br><span class="line"><span class="comment">     c++</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; a&#123;1, 4, 3, 4, 5&#125;;</span></span><br><span class="line"><span class="comment">    replace(a.begin(), a.end(), 4, 10);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : a)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 1 10 3 10 5 </span></span><br><span class="line"><span class="comment">    replace_if(a.begin(), a.end(), bind2nd(less&lt;int&gt;(), 10), 0);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : a)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 0 10 0 10 0 </span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; b(a.size()); // 必须为 b 分配空间，copy 不会分配空间</span></span><br><span class="line"><span class="comment">    replace_copy(a.begin(), a.end(), b.begin(), 0, 1);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : b)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 1 10 1 10 1 </span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; c; // 或者使用 back_inserter</span></span><br><span class="line"><span class="comment">    replace_copy(a.begin(), a.end(), back_inserter(c), 0, 1);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : c)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 1 10 1 10 1 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    如果函数名后面跟着 _if 表示你要传入一个“条件”</span></span><br><span class="line"><span class="comment">    如果函数名后面跟着 _copy 表示你要传入一个 iterator 用来放置 copy 的元素</span></span><br><span class="line"><span class="comment">        并且作用结果不会作用到原迭代器身上，只是 copy 到新迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  4. find &amp; find_if -- 线性时间复杂度 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  5. sort</span></span><br><span class="line"><span class="comment">**   不要拿我们写的 cmp 用于 sort list 和 forward_list</span></span><br><span class="line"><span class="comment">      因为他们的地址不是连续的。而我们写的 cmp 是连续的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  6. binary_search</span></span><br><span class="line"><span class="comment">**   二分查找的前提是有序</span></span><br><span class="line"><span class="comment">     binary_search() 调用了 lower_bound()</span></span><br><span class="line"><span class="comment">     然后对 lower_bound 找到的位置进行比较</span></span><br><span class="line"><span class="comment">        first = lower_bound(first, val);</span></span><br><span class="line"><span class="comment">        return (first != last) &amp;&amp; (val &gt;= *first);</span></span><br><span class="line"><span class="comment">        // 我感觉后面的 val&gt;=*first 不太必要的，因为如果你 first != last 的话</span></span><br><span class="line"><span class="comment">            // 就说明你肯定找到了，既然找到了，那就应该是合理的！</span></span><br><span class="line"><span class="comment">                // 很奇怪，不知道为啥</span></span><br><span class="line"><span class="comment">     关于 lower/upper_bound</span></span><br><span class="line"><span class="comment">     候捷的解释：</span></span><br><span class="line"><span class="comment">        lower_bound 查找的是 在不改变原数据顺序的前提下</span></span><br><span class="line"><span class="comment">            插入元素可以放入的 最低点</span></span><br><span class="line"><span class="comment">        upper_bound 查找的是 在不改变原数据顺序的前提下</span></span><br><span class="line"><span class="comment">            插入元素可以放入的 最高点</span></span><br><span class="line"><span class="comment">     网络上一般的解释为：</span></span><br><span class="line"><span class="comment">        lower 查找 &lt;=</span></span><br><span class="line"><span class="comment">        upper 查找 &gt;</span></span><br><span class="line"><span class="comment">     其实一样，只不过说法不同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> begin = <span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(),<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> end = <span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(),<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; *begin &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; *end &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>adapter</p>
<ol>
<li>容器适配器</li>
<li>迭代器适配器</li>
<li>仿函数适配器</li>
</ol>
<p>一个对象 A 想拥有对象 B  的功能，有两种方式：</p>
<ol>
<li>inherit，继承</li>
<li>composition，复合</li>
</ol>
<p>adapter 是复合</p>
<p>typedef:</p>
<p>binary_function</p>
<ol>
<li>first_arguement_type</li>
<li>second_arguement_type</li>
<li>result_type</li>
</ol>
<p>unary_function</p>
<ol>
<li>Argument_type</li>
<li>Result_type</li>
</ol>
<p><code>typename + ()</code> 产生临时对象</p>
<p>借用函数模版的实参推导来完成类模板的实参。</p>
<blockquote>
<p>如果我们直接写类模板的实参 <code>&lt;&gt;</code>，我们可能不太好写出类型，我们可以添加一层中间层（函数模板），让函数模板来完成实参类型的推导，然后将类型传给类模板。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">typename</span> less&lt;<span class="type">int</span>&gt;::second_argument_type x = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">typename</span> less&lt;<span class="type">int</span>&gt;::first_argument_type y = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">typename</span> less&lt;<span class="type">int</span>&gt;::result_type z = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>);</span><br><span class="line">    binder2nd&lt;less&lt;<span class="type">int</span>&gt;&gt; b2;  <span class="comment">// wrong，已经弃用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Argument 并无参数的意思，之所以被拿来做(参数、变量)的意思是历史原因。</p>
<hr>
<p>bind</p>
<p>取代了 bind2nd, binder2nd, bind1st, binder1st</p>
<p>没写构造函数也可以用 <code>&#123;&#125;</code> 初始化</p>
<p>placeholoders</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">typename</span> less&lt;<span class="type">int</span>&gt;::second_argument_type x = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">typename</span> less&lt;<span class="type">int</span>&gt;::first_argument_type y = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">typename</span> less&lt;<span class="type">int</span>&gt;::result_type z = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// binder2nd&lt;less&lt;int&gt;&gt; b2;  // wrong，已经弃用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">my_divide</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// _1, _2。。 在 std::placeholders 里面</span></span><br><span class="line">    <span class="comment">// auto f1 = bind(my_divide, std::placeholders::_1, std::placeholders::_2);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; f1(10, 2) &lt;&lt; endl;   // 5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// auto f2 = bind(my_divide, std::placeholders::_2, std::placeholders::_1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; f2(10, 2) &lt;&lt; endl;   // 0.5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// auto f3 = bind(my_divide, 10, std::placeholders::_1);   // 这里 10 被绑定到第一个参数</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; f3(200) &lt;&lt; endl;  // 10 / 200</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// auto f5 = bind(my_divide, std::placeholders::_1, 10);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; f5(100) &lt;&lt; endl;    // 10</span></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    <span class="comment">/*  --  */</span></span><br><span class="line">    <span class="comment">/* 占位符_n会选择 [我们传入的] 第n个参数 */</span></span><br><span class="line">    <span class="keyword">auto</span> f4 = <span class="built_in">bind</span>(my_divide, <span class="number">10</span>, std::placeholders::_2);   <span class="comment">// 这里 10 被绑定到第一个参数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f4</span>(<span class="number">3</span>,<span class="number">2</span>) &lt;&lt; endl;   <span class="comment">// 3.33，选择我们传入的第二个参数2</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">auto</span> f6 = <span class="built_in">bind</span>(my_divide, std::placeholders::_2, <span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f6</span>(<span class="number">3</span>,<span class="number">5</span>) &lt;&lt; endl;    <span class="comment">// 5 / 10，选择我们传入的第二个参数5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test3</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">C note</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-15 20:20:57" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-16 09:46:39" itemprop="dateModified" datetime="2023-06-16T09:46:39+08:00">2023-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C和指针"><a href="#C和指针" class="headerlink" title="C和指针"></a>C和指针</h1><h2 id="1-宏函数与自定义函数"><a href="#1-宏函数与自定义函数" class="headerlink" title="1. 宏函数与自定义函数"></a>1. 宏函数与自定义函数</h2><p>宏函数与自定义函数是对立的，宏函数的优点就是自定义函数的缺点，自定义函数的缺点就是宏函数的优点。<br>宏函数的优点：1·执行效率高  2·节省空间<br>宏函数的缺点：1编译时间长   2·不安全，没有语法检查</p>
<p>因为宏函数在编译时直接展开，所以不像自定义函数一样需要进行函数调用，因此宏函数运行时没有通过函数名找到函数的入口地址，保存返回地址，为形参分配空间，实参分配给形参，形参入栈等操作。因此步骤少，并且不需要在栈上分配额外空间。但因此宏函数需要在编译时替换，因此编译时间长。另外，宏函数也没有语法检查，不安全。</p>
<h2 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2. 关键字"></a>2. 关键字</h2><h3 id="2-1-extern，static"><a href="#2-1-extern，static" class="headerlink" title="2.1 extern，static"></a>2.1 extern，static</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//static int num = 100; // 1.static修饰全局变量，改变变量的作用域，只能在本文件中被调用，采用这种声明，编译1.c和2.c就会报错。</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">100</span>;  <span class="comment">// 声明并初始化一个变量，会分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span>;       <span class="comment">// 声明一个函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅声明变量num，但不初始化，否则就会为其分配内存</span></span><br><span class="line"><span class="comment">// extern表示该变量在别处定义并初始化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static void f()    // 2.static修饰函数，改变函数的作用域，只能在本文件中被调用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc 1.c 2.c -o main</span><br><span class="line">./main</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译多个文件时，要保证只有一个main函数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = <span class="number">0</span>; <span class="comment">// 3.static修饰局部变量，叫静态变量（存放在静态数据区），改变变量的生命周期，直到程序结束释放</span></span><br><span class="line">    <span class="comment">//int x = 0;</span></span><br><span class="line">    x ++ ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">    	Add();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-const"><a href="#2-2-const" class="headerlink" title="2.2 const"></a>2.2 const</h3><p>1.const 修饰普通变量即const修饰只读变量，不能通过变量本身修改变量的值，但可以通过其他方式(指针)修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)&amp;a;</span><br><span class="line">    *p ++ ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行上面的程序之后可以发现a的值仍然被修改了，所以说这也就说明了一个常见的误解，认为const修饰的就是常量，实际上并不是</p>
</blockquote>
<p>2.const修饰指针 （<strong>就近原则</strong>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向常量的指针</span></span><br><span class="line"><span class="comment">// 由于const和int的位置可以互换，所以可以忽略int，原式就成了 const *q，const距离*最近，因此const修饰的是*q</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *q = &amp;a;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *q = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针常量</span></span><br><span class="line"><span class="comment">// const距离q最近，因此const修饰的是q</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> q = &amp;a;</span><br></pre></td></tr></table></figure>

<p>3.const修饰函数形参</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">new_strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>((*dest ++ = *src++) != <span class="string">&#x27;\0&#x27;</span>)  ;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> d[<span class="number">20</span>] = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">20</span>] = <span class="string">&quot;newstr&quot;</span>;</span><br><span class="line">    new_strcpy(d, s);</span><br><span class="line">    <span class="built_in">puts</span>(d);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.const修饰函数的返回值</p>
<p>若函数的返回值是指针，且用const修饰，则函数返回值指向的内容是常数，不可被修改，此返回值仅能赋值给const修饰的相同类型的指针。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="title function_">f1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> * p;</span><br><span class="line">	p = new <span class="type">int</span>;</span><br><span class="line">	*p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *p; <span class="comment">// 改为int *p1;则编译时报错：“[8] error: invalid conversion from &#x27;const int*&#x27; to &#x27;int*&#x27;” (编译器code::block);</span></span><br><span class="line">    p = f1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若主函数改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> * p1;</span><br><span class="line">	p1 = f1();</span><br><span class="line">	*p1 = <span class="number">2</span>; <span class="comment">//则编译时报错：&quot;[10] error: assignment of read-only location &#x27;* p1&#x27;&quot;  (编译器code::block);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数返回值是数值（by value），因C++中，返回值会被复制到外部临时的存储单元中，故const 修饰是没有任何价值的。例：不要把函数int fun1() 写成const int func1()。<br>同理不要把函数A GetA(void) 写成const A GetA(void)，其中A 为用户自定义的数据类型。</p>
<p>如果返回值是对象，将函数A fun2() 改写为const A &amp; fun2()的确能提高效率。但此要注意，要确定函数究竟是想返回一个对象的“copy”,还是仅返回对象的“别名”即可，否则程序会出错。</p>
<h2 id="3-危险的指针"><a href="#3-危险的指针" class="headerlink" title="3. 危险的指针"></a>3. 危险的指针</h2><p><strong>警告⚠️：没有将一个free掉的指针置NULL</strong></p>
<p>一个指针被free之后，它仍然指向原来指向的内存区域。但是该空间的内容已经不再是之前的值了，已经释放掉了。</p>
<p>这时候的指针我们称为野指针。将它<strong>置为NULL</strong>后，可以防止被误用，同时也可以后续作为判断该指针是否已经释放的标记</p>
<h3 id="3-1-悬挂-悬空-指针"><a href="#3-1-悬挂-悬空-指针" class="headerlink" title="3.1 悬挂(悬空)指针"></a>3.1 悬挂(悬空)指针</h3><p>悬挂指针：当指针所指向的对象被释放，但是该指针没有任何改变，以至于其仍然指向已经被回收的内存地址，这种情况下该指针被称为悬挂指针；</p>
<h3 id="3-2-野指针"><a href="#3-2-野指针" class="headerlink" title="3.2 野指针"></a>3.2 野指针</h3><p>野指针：未初始化的指针被称为野指针。</p>
<h2 id="4-gcc编译器"><a href="#4-gcc编译器" class="headerlink" title="4. gcc编译器"></a>4. gcc编译器</h2><h3 id="4-1-编译过程"><a href="#4-1-编译过程" class="headerlink" title="4.1 编译过程"></a>4.1 编译过程</h3><h4 id="4-1-1-预处理"><a href="#4-1-1-预处理" class="headerlink" title="4.1.1 预处理"></a>4.1.1 预处理</h4><p>命令 <code>gcc -E x.c -o x.i</code> ，生成一个 <code>.i</code> 文件（预处理文件）</p>
<p>预处理就是处理所有<code>#</code> 开头的行，即展开头文件和宏定义和条件编译。</p>
<p>其中 <code>#include &lt;stdio.h&gt;</code> 中的 <code>&lt;&gt;</code> 表示在系统里面找 <code>stdio.h</code> 文件。在 <code>/usr/include</code> 目录下有很多头文件。</p>
<h4 id="4-1-2-编译"><a href="#4-1-2-编译" class="headerlink" title="4.1.2 编译"></a>4.1.2 编译</h4><p>命令 <code>gcc -S x.i -o x.s</code> ，生成一个<code>.s</code> 文件（汇编文件）</p>
<h4 id="4-1-3-汇编"><a href="#4-1-3-汇编" class="headerlink" title="4.1.3 汇编"></a>4.1.3 汇编</h4><p>命令 <code>gcc -c x.s -o x.o</code> ，生成一个<code>.o</code> 文件（二进制文件）</p>
<h4 id="4-1-4-链接"><a href="#4-1-4-链接" class="headerlink" title="4.1.4 链接"></a>4.1.4 链接</h4><p>生成一个可执行二进制文件。默认链接方式是动态链接。</p>
<p>对于一条语句 <code>printf(&quot;xxx&quot;)</code> ，动态链接会链接 printf 的位置信息，静态链接会链接 printf  的具体实现。因此，静态链接的文件大小比静态链接的文件大得多。但是静态链接对环境的依赖比动态链接要小，加入系统中不存在 printf 的实现，那么动态链接就无法执行。</p>
<h3 id="4-2-其它常用参数"><a href="#4-2-其它常用参数" class="headerlink" title="4.2 其它常用参数"></a>4.2 其它常用参数</h3><ul>
<li>-g：在可执行程序中包含标准调试信息。</li>
<li>-v：打印出编译器内部个过程的命令行信息和编译器的版本</li>
<li>-I dir：在头文件的搜索路径列表中添加 dir 目录</li>
<li>-L dir：在库文件的搜索路径列表中添加 dir 目录</li>
<li>-static：链接静态库</li>
<li>-l library：链接名为 library 的库文件</li>
</ul>
<h3 id="4-3-静态库"><a href="#4-3-静态库" class="headerlink" title="4.3 静态库"></a>4.3 静态库</h3><p>静态库文件格式：<code>.a</code>  结尾，<code>lib</code>  开头。</p>
<p>创建静态库文件步骤：</p>
<ol>
<li>写源文件，通过 <code>gcc -c xxx.c</code> 生成目标文件。</li>
<li>用 <code>ar</code> 归档目标文件，生成静态库。具体位为：<code>ar -crv libname.a lib1.o lib2.o</code>，执行该命令即可创建名为 <code>name</code> 的静态库。</li>
</ol>
<p>上述命令中 crv 是 ar的命令选项：</p>
<ul>
<li>c 如果需要生成新的库文件，不要警告</li>
<li>r 代替库中现有的文件或者插入新的文件</li>
<li>v 输出详细信息</li>
</ul>
<p>创建静态库举例：</p>
<p>f1.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;this is f1...\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>f2.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;this is f1...\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f1</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	f1();</span><br><span class="line">	f2();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 <code>f1.c</code>, <code> f2.c</code>为源文件创建静态库:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c f1.c f2.c  #生成目标文件f1.o f2.o</span><br><span class="line">ar -crv libmylib.a f1.o f2.o</span><br></pre></td></tr></table></figure>

<p>链接静态库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main -staic -l mylib -L .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虽然静态库文件为：libmylib.a，但是该静态库的名字是 mylib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-l mylib 表示链接名为 mylib 的静态库</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-L . 表示将当前目录添加到搜索静态库文件的目录</span></span><br></pre></td></tr></table></figure>



<h3 id="4-4-动态库"><a href="#4-4-动态库" class="headerlink" title="4.4 动态库"></a>4.4 动态库</h3><p>动态库文件格式：<code>.so</code> 结尾</p>
<p>创建并链接动态库：</p>
<ol>
<li><code>gcc -fPIC -shared -o libxxx.so xx1.c xx2.c</code></li>
<li><code>gcc main.c -o main -L . -l xxx</code></li>
</ol>
<blockquote>
<p>fPIC 作用于编译阶段，告诉编译器产生与位置无关代码(Position-Independent Code)，<strong>则产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意位置，都可以正确的执行。</strong>这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。</p>
<p>PIC就是position independent code</p>
<p>PIC使.so文件的代码段变为真正意义上的共享</p>
<p><strong>如果不加 -fPIC,则加载 .so文件的代码段时,代码段引用的数据对象需要重定位, 重定位会修改代码段的内容,这就造成每个使用这个 .so文件代码段的进程在内核里都会生成这个 .so文件代码段的copy.每个 copy都不一样,取决于这个 .so文件代码段和数据段内存映射的位置.</strong></p>
<p><strong>不加 fPIC编译出来的 so,是要再加载时根据加载到的位置再次重定位的.(因为它里面的代码并不是位置无关代码)</strong></p>
<p>如果被多个应用程序共同使用,那么它们必须每个程序维护一份so的代码副本了.(因为so被每个程序加载的位置都不同,显然这些重定位后的代码也不同,当然不能共享)<br>我们总是用fPIC来生成so,也从来不用fPIC来生成a.<br>fPIC与动态链接可以说基本没有关系,libc.so一样可以不用fPIC编译,只是这样的so必须要在加载到用户程序的地址空间时重定向所有表目.</p>
<p>因此,不用fPIC编译so并不总是不好.<br>如果你满足以下4个需求&#x2F;条件:<br>1.该库可能需要经常更新<br>2.该库需要非常高的效率(尤其是有很多全局量的使用时)<br>3.该库并不很大.<br>4.该库基本不需要被多个应用程序共享</p>
<p>如果用没有加这个参数的编译后的共享库，也可以使用的话，可能是两个原因：<br>1：gcc默认开启-fPIC选项<br>2：loader使你的代码位置无关</p>
<p>从GCC来看，shared应该是包含fPIC选项的，但似乎不是所以系统都支持，所以最好显式加上fPIC选项。</p>
</blockquote>
<p>还是上面的三个文件。执行完上述两个操作之后，执行 <code>./main</code> ，报错：<code>./main: error while loading shared libraries: libmylib.so: cannot open shared object file: No such file or directory</code></p>
<p>这是因为链接动态库虽然是在当前目录下链接的，但是在程序执行的时候并不在当前目录下找，我们可以用命令 <code>ldd main</code> 查看 <code>main</code> 程序在哪里寻找动态库。</p>
<blockquote>
<p>ldd命令用于查看二进制文件所有用到的动态库在哪</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">linux-vdso.so.1 (0x00007ffc4edf3000)</span><br><span class="line">libmylib.so =&gt; not found</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f23af86c000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f23afa6e000)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  可以看到，我们的动态库 <code>libmylib.so</code> 显示 <code>not found</code>，而系统自带的动态库 <code>libc.so.6</code> 在目录 <code>/lib/x86_64-linux-gnu/</code> 下。</p>
<p>因此我们只需要把 <code>libmylib.so</code> 复制到该目录下即可：<code>sudo cp libmylib.so /lib/x86_64-linux-gnu/</code>，然后 <code>main</code> 程序就可以正常执行了。</p>
<h2 id="5-sizeof-产生的问题"><a href="#5-sizeof-产生的问题" class="headerlink" title="5. sizeof 产生的问题"></a>5. sizeof 产生的问题</h2><h3 id="5-1-仍然需要加括号的情况"><a href="#5-1-仍然需要加括号的情况" class="headerlink" title="5.1 仍然需要加括号的情况"></a>5.1 仍然需要加括号的情况</h3><p>首先，sizeof是一个<strong>关键字</strong>而不是一个函数。其次，当我们用sizeof求字节长度时，最好加上括号，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>；</span></span><br><span class="line"><span class="class">// 上面的代码编译起就会报错，因为他被解释为:</span><span class="keyword">sizeof</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class"><span class="title">sizeof</span> <span class="title">a</span> + 1</span></span><br><span class="line"><span class="class">// 会被解释为:</span> <span class="keyword">sizeof</span>(a) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 而不是 sizeof(a + 1)</span></span><br></pre></td></tr></table></figure>

<p>所以说为了避免由于优先级问题导致的二义性，还是加上括号吧！</p>
<p>另外，看下面的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="number">0</span> == <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="keyword">sizeof</span>(a = <span class="number">4</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-sizeof到底是什么"><a href="#5-2-sizeof到底是什么" class="headerlink" title="5.2 sizeof到底是什么"></a>5.2 sizeof到底是什么</h3><p>网上有人说sizeof是一个操作符，但我觉得它更像一个<strong>特殊的宏</strong>，因为它是在编译阶段求值的。</p>
<p>在上面的例子中，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="number">0</span> == <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="keyword">sizeof</span>(a = <span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<p>在编译阶段会被翻译为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="number">4</span>;   </span><br></pre></td></tr></table></figure>

<p>因为C语言中没有bool类型，而是以int类型表示，所以</p>
<p><code>sizeof(0 == 1)</code> 就相当于 <code>sizeof(int)</code></p>
<p>并且我们在第二条语句中令a&#x3D;4，但输出的仍然是1，这说明a的值没有被改变，并且<code>sizeof(a=4)</code>被解释为<code>sizeof(int)</code></p>
<p>其原因就在于sizeof在编译阶段处理的特性。由于sizeof不能被编译成机器码，所以sizeof作用范围内，也就是()里面的内容也不能被编译，而是被替换成类型。&#x3D;操作符返回左操作数的类型，所以a&#x3D;3相当于int.</p>
<h3 id="5-3-总结"><a href="#5-3-总结" class="headerlink" title="5.3 总结"></a>5.3 总结</h3><p>所以，sizeof是不可能支持链式表达式的，这也是和一元操作符不一样的地方。</p>
<p><strong>结论：不要把sizeof当成函数，也不要看作一元操作符，把他当成一个特殊的编译预处理。</strong></p>
<h2 id="6-内存管理"><a href="#6-内存管理" class="headerlink" title="6. 内存管理"></a>6. 内存管理</h2><h3 id="6-1-内存结构"><a href="#6-1-内存结构" class="headerlink" title="6.1 内存结构"></a>6.1 内存结构</h3><p>在实际的程序当中，我们操作的都是虚拟内存，而不是实际的物理内存（因为操作者不一定能正确操纵内存，如果直接操作物理内存，可能会导致操作系统死掉等问题）。</p>
<p>虚拟内存与物理内存之间是映射关系，虚拟内存映射一小部分物理内存。在linux中，虚拟内存一般是4g，默认按照1:3分配（可以调整）。1个g是内核态、另外3个g是用户态。</p>
<p>其中3个g一般又分为5块。</p>
<p><img src="https://pic1.zhimg.com/v2-db1beae537441e72682b5932b97770b0_1440w.jpg?source=172ae18b" alt="再谈应用程序分段： 数据段、代码段、BSS段以及堆和栈"></p>
<p>相关段总结如下。</p>
<table>
<thead>
<tr>
<th>段名</th>
<th>存储属性</th>
<th>内存分配</th>
</tr>
</thead>
<tbody><tr>
<td>代码段 .text</td>
<td>存放可执行程序的指令，存储态和运行态都有</td>
<td>静态</td>
</tr>
<tr>
<td>数据段 .data</td>
<td>存放已初始化（非零初始化的全局变量和静态局部变量）的数据，存储态和运行态都有</td>
<td>静态</td>
</tr>
<tr>
<td>bss段 .bss</td>
<td>存放未初始化（未初始化或者0初始化的全局变量和静态局部变量）的数据，存储态和运行态都有</td>
<td>静态</td>
</tr>
<tr>
<td>堆 heap</td>
<td>动态分配内存，需要通过malloc手动申请，free手动释放，适合大块内存。容易造成内存泄漏和内存碎片。运行态才有。由程序员手动申请。</td>
<td>动态</td>
</tr>
<tr>
<td>栈 stack</td>
<td>存放函数局部变量和参数以及返回值，函数返回后，由操作系统立即回收。栈空间不大，使用不当容易栈溢出。运行态才有。系统自动分配。</td>
<td>静态</td>
</tr>
</tbody></table>
<p>看下面的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s1[size] = <span class="string">&quot;hello,world!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *s2 = <span class="string">&quot;hello,world!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *s3 = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码中，s1，s2，s3都是局部变量，s1是一个数组，s2，s3是一个指针，其本身被分配在栈中。</p>
<p>但是s2中的“hello，world！”是一个字符串常量，其也占用内存，并且分配在数据段，s2指向这个字符串常量的地址。</p>
<p>s3中malloc分配的大小为128字节的内存在堆中，s3指向堆中分配的这块内存。</p>
<p>可以看出，同样是局部变量，s1只占用了一块内存，而s2，s3占用了两块内存。</p>
</blockquote>
<h3 id="6-2-堆和栈的区别"><a href="#6-2-堆和栈的区别" class="headerlink" title="6.2 堆和栈的区别"></a>6.2 堆和栈的区别</h3><ol>
<li>管理方式不同：堆由程序员管理，栈由系统管理。</li>
<li>空间大小不同：栈的空间比较小，堆的空间比较大。</li>
<li>是否产生碎片：堆由于malloc&#x2F;new，从而产生大量的碎片，使程序效率降低（虽然程序结束后操作系统会对内存进行回收管理），对于栈来讲，内存连续分配，则不存在这个问题。</li>
<li>增长方向不同：栈向下（低地址）增长，堆向上（高地址）增长。</li>
<li>分配效率不同：栈是极其系统提供的数据结构，计算机会在底层对栈提供支持，分配专门的寄存器存放栈的地址，压栈出zhan都有专门的指令执行。堆则是C函数库提供的，它的机制很复杂，例如为了分配一块内存，库函数会按照一定的算法，在堆内存中搜索可用的，足够大的空间，如果没有（可能是由于内存碎片太多），就有需要操作系统来重新整理内存空间，这样就有机会分到足够大的内存，然后返回。显然，堆的效率比栈要低得多。</li>
<li>分配方式不同：堆都是程序中由malloc()函数动态申请分配并由free()函数释放的，栈的分配和释放是由编译器完成的，栈的动态分配由alloca()函数完成，但是栈的动态分配是和堆不同的，它的动态分配是由编译器完成申请和释放的，无需手工实现。</li>
</ol>
<h3 id="6-3-常见内存错误及对策"><a href="#6-3-常见内存错误及对策" class="headerlink" title="6. 3 常见内存错误及对策"></a>6. 3 常见内存错误及对策</h3><ol>
<li>指针没有指向一块合法的内存（野指针）：例如声明了一个指针但没有初始化就使用这个指针。</li>
<li>为指针分配的内存太小：例如为字符串str，malloc内存时，大小为strlen(str)+1，如果没有+1，malloc的大小就不够。</li>
<li>内存分配成功但未初始化：对于未初始化的指针，其值是未定义的。可以使用memset初始化。</li>
<li>内存越界：段错误。</li>
<li>内存泄露：没有释放掉分配的内存。</li>
<li>内存释放之后：虽然内存释放了，但是指针仍然指向该内存，所以要将指针置为空吗，否则就会变为野指针。free(p)释放的是p指向的内存，而不是p本身。</li>
<li>内存已经释放，但是继续通过指针来使用：分为堆释放（使用已经free掉内存的指针），栈释放（返回一个局部变量的地址）。</li>
</ol>
<h2 id="7-可变参数"><a href="#7-可变参数" class="headerlink" title="7. 可变参数"></a>7. 可变参数</h2><h3 id="7-1-带可变参数的函数由来"><a href="#7-1-带可变参数的函数由来" class="headerlink" title="7.1 带可变参数的函数由来"></a>7.1 带可变参数的函数由来</h3><p>当<strong>函数中的参数个数不确定</strong>时，这时候就需要带可变参数的函数！<br>如我们经常使用的C库函数printf()实际就是一个可变参数的函数，<br><strong>其原型为：</strong></p>
<p>int printf( const char* format, …);</p>
<p>它除了有一个参数format固定以外,后面跟的参数的个数和类型是可变的。例如我们可以有以下不同的调用方法：</p>
<p>printf( “%d “,i); printf( “%s “,s); printf( “the number is %d ,string is:%s “, i, s);</p>
<h3 id="7-2-带可变参数函数的实现"><a href="#7-2-带可变参数函数的实现" class="headerlink" title="7.2 带可变参数函数的实现"></a>7.2 带可变参数函数的实现</h3><h4 id="7-2-1-原理"><a href="#7-2-1-原理" class="headerlink" title="7.2.1 原理"></a>7.2.1 原理</h4><ul>
<li>使用了<strong>指针参数</strong>来解决参数的可变问题，指针参数随着其移动指向不同的参数；</li>
<li>C语言的函数形参是从右向左压入堆栈的，以保证栈顶是第一个参数。</li>
</ul>
<p>C语言标准库中头文件stdarg.h索引的接口包含了一组能够遍历变长参数列表的宏。<br>头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br></pre></td></tr></table></figure>



<h4 id="7-2-2-几个宏"><a href="#7-2-2-几个宏" class="headerlink" title="7.2.2 几个宏"></a>7.2.2 几个宏</h4><p>(1). <strong>va_list</strong> 定义一个指针<br>用来<strong>定义</strong>一个<strong>表示参数表中各个参数</strong>的<strong>变量</strong>，即定义了一个指向参数的指针， 用于指示可选的参数.<br>如：<strong>va_list ap</strong>;<br>(2). <strong>va_start(ap,v)</strong> 初始化指针<br>使参数列表指针<strong>ap</strong>指向函数参数列表中的第一个<strong>可选参数</strong>，<strong>v</strong>是位于第一个可选参数之前的<strong>固定参数</strong>, 或者说最后一个固定参数.通常用于指定可变参数列表中参数的个数！<br>如有一va函数的声明是void va_test(char a, char b, char c, …), 则它的固定参数依次是a,b,c, 最后一个固定参数v为c, 因此就是va_start(<strong>ap</strong>, c).</p>
<p>(3). va_arg(<strong>ap</strong>, type) 返回参数列表中指针<strong>ap</strong>所指的参数, 返回类型为type. <strong>并使指针ap指向参数列表中下一个参数</strong>.返回的是可选参数, 不包括固定参数.</p>
<p>(4). va_end(<strong>ap</strong>) 清空参数列表, 并置参数指针arg_ptr无效.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simple_va_fun</span><span class="params">(<span class="type">int</span> i,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	va_list arg_ptr; <span class="comment">//定义可变参数指针</span></span><br><span class="line">	<span class="built_in">va_start</span>(arg_ptr,i); <span class="comment">// i为最后一个固定参数</span></span><br><span class="line">	<span class="type">int</span> j = <span class="built_in">va_arg</span>(arg_ptr,<span class="type">int</span>); <span class="comment">//返回第一个可变参数，类型为int</span></span><br><span class="line">	<span class="type">char</span> c = <span class="built_in">va_arg</span>(arg_ptr,<span class="type">char</span>); <span class="comment">//返回第二个可变参数，类型为char</span></span><br><span class="line">	<span class="built_in">va_end</span>(arg_ptr); <span class="comment">// 清空参数指针</span></span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">&quot;%d %d %c\n&quot;</span>,i,j,c);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">simple_va_fun</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">simple_va_fun</span>(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">simple_va_fun</span>(<span class="number">100</span>,<span class="number">200</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出为</span></span><br><span class="line"><span class="comment">100 4193388 ?100 200 ?100 200 a</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>




<h4 id="7-2-3-思路"><a href="#7-2-3-思路" class="headerlink" title="7.2.3 思路"></a>7.2.3 思路</h4><p>（1）首先在函数里定义一个va_list型的变量,这里是arg_ptr,这个变量是指向参数的指针.</p>
<p>（2）然后用va_start宏初始化变量arg_ptr,这个宏的第二个参数是第一个可变参数的前一个参数,是一个固定的参数.<br>（3）然后用va_arg返回第一个可变的参数,并赋值给整数j。va_arg的第二个参数是你要返回的参数的类型,这里是int型. 返回第一个可变参数后arg_ptr指向第二个可变参数，用同样的方法返回并赋值给c，类型为char类型。<br>（4）最后用va_end宏结束可变参数的获取。<br><strong>小结：</strong><br>可变参数的函数原理其实很简单,而va系列是以宏定义来定义的,实现跟堆栈相关.我们写一个可变函数的C函数时,有利也有弊,所以在不必要的场合,我们无需用到可变参数.如果在C++里,我们应该利用C++的多态性来实现可变参数的功能,尽量避免用C语言的方式来实现。</p>
<h1 id="指针专题"><a href="#指针专题" class="headerlink" title="指针专题"></a>指针专题</h1><h2 id="1-指针简介"><a href="#1-指针简介" class="headerlink" title="1. 指针简介"></a>1. 指针简介</h2><h3 id="1-1-指针的声明"><a href="#1-1-指针的声明" class="headerlink" title="1.1 指针的声明"></a>1.1 指针的声明</h3><p>指针的标准写法：<code>type* p;</code>	<br>常见的不标准的写法：<code>type *p = &amp;a;</code></p>
<blockquote>
<p>在不标准的写法中，我们常常会把 解引用符号（*）与变量名联系在一起，这就导致了一些直观上的不舒服？。</p>
<p>例如代码：<code>int *p = &amp;a;</code> 我们会自觉的把等号左边分成两个部分，类型和变量名，如果把 <code>*</code> 和变量名连在一起，那么看上去就好像是把 <code>a</code> 的地址放到了<code>*p</code> 里面，而类型也变成了 <code>int</code> 而不是 <code>int*</code>。</p>
<p>但如果我们写成：<code>int* p = &amp;a;</code> 这样看起来就很舒服了，<code>a</code> 的地址存放在了指针变量 <code>p</code> 中，<code>p</code> 它就是一个变量，它存储的是 <code>a</code> 的地址，而 <code>*p</code> 表示解引用指针变量 <code>p</code> 里面的地址，得到该地址存放的值。</p>
</blockquote>
<p>所以说，推荐写成标准的形式，看起来更舒服！</p>
<h3 id="1-2-指针的常识"><a href="#1-2-指针的常识" class="headerlink" title="1.2 指针的常识"></a>1.2 指针的常识</h3><ol>
<li><strong>指针是不占用内存空间的</strong>，其本身是地址，地址怎么会占内存空间。<strong>指针变量才占用内存空间。</strong></li>
<li>当我们仅使用数组名时，返回的是<strong>数组首元素的地址</strong>。</li>
<li>函数用来指向或引用内存中的数据（变量或常量）。</li>
<li>指针是由地址的，指针的地址不等同于指针变量的地址。</li>
</ol>
<h3 id="1-3-指针的算术运算"><a href="#1-3-指针的算术运算" class="headerlink" title="1.3 指针的算术运算"></a>1.3 指针的算术运算</h3><p>指针变量+&#x2F;-1：这里的1是指针类型的长度，而不是数字 1  </p>
<p>Code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl; 	   <span class="comment">// -&gt; x</span></span><br><span class="line">cout &lt;&lt; (p + <span class="number">1</span>) &lt;&lt; endl;  <span class="comment">// -&gt; x + sizeof(int)</span></span><br></pre></td></tr></table></figure>



<h2 id="2-输出char类型的地址"><a href="#2-输出char类型的地址" class="headerlink" title="2. 输出char类型的地址"></a>2. 输出char类型的地址</h2><p>在C++中，如果cout一个字符数组的话，那么它会沿着这个地址，一直输出这个字符串，直到遇到’\0’,例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>*c = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">输出的结果是：hello</span><br></pre></td></tr></table></figure>

<p>如果我们自作聪明的想输出第一个字符的地址，例如这样输出：</p>
<p><code> cout &lt;&lt; &amp;c[0] &lt;&lt; endl;</code></p>
<p>不幸的是，这样输出的结果依旧不是我们需要的地址。实际上输出结果仍然是整个字符串。</p>
<p>但是，如果我们回归到C语言的话，例如用printf的话，如下：</p>
<p> <code>printf(&quot;%x\n&quot;, &amp;c[0]);</code></p>
<p>幸福的事情发生了，输出的结果是：</p>
<p><code> 46f020</code></p>
<p>的确是字符串的首地址，但是，如果我们要输出字符串的地址，难道就这一种方法吗？难道我们就不可以用我们C++上的cout达到我们的效果吗？</p>
<p><strong>原因：</strong><strong><em>c是靠%s, %x, %p来区分指针表达式&amp;a[0]的输出形式的；c++没有这个格式控制，只能按一种形式输出，对char</em>类型的指针值就理解为串输出，所以必须对这个指针表达式做类型转换处理。</strong></p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;c:&quot;</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">输出的仍然不是字符变量c的地址，而是乱码。</span><br></pre></td></tr></table></figure>



<p>在C++中，字符串是以空终止符（’&#x2F;0’）结尾的字符数组，通过字符串中第一个字符的指针访问字符串。也就是说，字符串的值是字符串中第一个字符的（常量）地址。如下的面3种形式表示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str1  = <span class="string">&quot;string1&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;string2&quot;</span>;</span><br><span class="line"><span class="type">char</span> str3[] = &#123;<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;line 1:str1=&quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;line 2:str2=&quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;line 3:str3=&quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">line <span class="number">1</span>:str  = string1</span><br><span class="line">line <span class="number">2</span>:str2 = string2</span><br><span class="line">line <span class="number">3</span>:str3 = string3</span><br></pre></td></tr></table></figure>

<p>运行可知，这3行的输出就是保存的字符串的值，而并非我们认为的地址。那么，我们可以联系到前面&amp;c，其实这就是一个char *的变量，所以，输出的自然就应该是字符串的值。可是，&amp;c保存的字符串是没有终止符的，因此输出的也就是乱码了。</p>
<p>最近，在读到《C++程序设计教程》（第4版）第12章的时候，我才解决了这个疑惑。实际上，**C++标准库中I&#x2F;O类对输出操作符&lt;&lt;重载，在遇到字符型指针时会将其当做字符串名来处理，输出指针所指的字符串。既然这样，我们就别让他知道那是字符型指针，所以得进行类型转换，即：希望任何字符型的指针变量输出为地址的话，都要作一个转换，即强制char *转换成void *，**如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">&quot;static_cast&lt;void *&gt;(&amp;c)=&quot;</span>&lt;&lt;<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;c)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;static_cast&lt;void *&gt;(str)=&quot;</span>&lt;&lt;<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(str)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>此时，可以看到输出的结果就是char类型变量和字符串变量的地址了。</p>
<h2 id="3-为什么指针要使用强类型"><a href="#3-为什么指针要使用强类型" class="headerlink" title="3. 为什么指针要使用强类型"></a>3. 为什么指针要使用强类型</h2><h3 id="3-1-强类型语言和弱类型语言"><a href="#3-1-强类型语言和弱类型语言" class="headerlink" title="3.1 强类型语言和弱类型语言"></a>3.1 强类型语言和弱类型语言</h3><p><strong>强类型语言是一种强制类型定义的语言，即一旦某一个变量被定义类型，如果不经强制转换，那么它永远就是该数据类型。而弱类型语言是一种弱类型定义的语言，某一个变量被定义类型，该变量可以根据环境变化自动进行转换，不需要经过现行强制转换。</strong></p>
<p>其中</p>
<p>强类型语言包括：Java、.net、Python、C++等语言。其中Python是动态语言，是强类型定义语言，是类型安全的语言，Java是静态语言，是强类型定义语言，也是；类型安全的语言；</p>
<p>弱类型语言包括：VB，PHP，JavaScript等语言。其中VBScript是动态语言，是一种类型不安全的原因。</p>
<p><strong>举个栗子吧：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var A=5;</span><br><span class="line">var B=&quot;5&quot;</span><br><span class="line">sumA=A+B;</span><br><span class="line">sumB=A-B;</span><br></pre></td></tr></table></figure>

<p><strong>sumA&#x3D;55,系统默认+字符连接符，将A转化为字符串类型；而sumB&#x3D;0；系统认为-是算数运算符，从而将B转化为int类型，所以sum为5-5&#x3D;0；</strong></p>
<p><em>上面就是一个弱类型语言的例子；</em></p>
<hr>
<p><em>那么强类型语言与弱类型语言有什么优缺点呢？</em></p>
<p><strong>强类型语言和弱类型原因其判断的根本是是否会隐形进行语言类型转变。强类型原因在速度上可能略逊于弱类型语言，但是强类型定义语带来的严谨性又避免了不必要的错误。</strong></p>
<p>上面提到了动态语言与静态语言，那就讲讲动态语言静态语言的区别：</p>
<p><strong>动态类型语言：动态性语言是指在运行期间才去做数据类型检查的语言，也就是说动态类型语言编程时，永远不用给任何变量指定数据类型，该语言会在第一次赋值给变量时，在内部将数据类型记录下来。Python和Ruby就是一种典型的动态类型语言，其他的各种脚本语言如VBScript也多少属于动态类型语言。</strong></p>
<p><strong>静态类型语言：静态类型语言与动态类则刚好相反，它的数据类型在编译期间检查，也就是说在写程序时要声明所有变量的数据类型，C&#x2F;C++是静态类型语言的典型代表，其他静态语言还有C#、Java等。</strong></p>
<p>对于动态语言与静态语言的区分，其根本在<strong>于判断是在运行期间去做数据类型还是在编译期间检查。</strong></p>
<h3 id="3-2-指针为什么要使用强类型"><a href="#3-2-指针为什么要使用强类型" class="headerlink" title="3.2 指针为什么要使用强类型"></a>3.2 指针为什么要使用强类型</h3><p>Q：指针保存的地址的类型都是一样的，为什么还要为指针指定类型呢？</p>
<p>A：我们使用指针不仅仅只是用到地址，还需要经常解引用(*)来获得指针所指向地址的值或者写数据，因此我们就需要知道两个信息：①我们需要获得多少字节的内容；②采用何种方式解析数据。例如：char占用1字节，int占用4字节，他们占用字节大小是不一样的，float也占用 4字节，但是float和int的解析方式是不一样的。</p>
<p>Eg：<strong>指针变量保存的地址是首地址</strong></p>
<h2 id="4-通用指针类型（void-）"><a href="#4-通用指针类型（void-）" class="headerlink" title="4. 通用指针类型（void *）"></a>4. 通用指针类型（void *）</h2><h2 id="5-指向指针的指针"><a href="#5-指向指针的指针" class="headerlink" title="5. 指向指针的指针"></a>5. 指向指针的指针</h2><p>理解多重指针的最好方法是<strong>画图</strong>。</p>
<p>如果我们让一个指针指向一片内存，那么就在指针和内存之间加上一个箭头，表示指针指向内存。假设有指针p指向内存s，那么*p就可以在图中表示为由p沿着指向s的指针到s，这样多重指针不过就是多走几次罢了。</p>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p= &amp;x;</span><br><span class="line"><span class="type">int</span>** q = &amp;p;</span><br><span class="line"><span class="type">int</span>*** r = &amp;q;</span><br></pre></td></tr></table></figure>

<p>对面上面的代码，表现在图形中就是：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/07/14/ec141bc6c035f827.png" alt="IMAGE"></p>
<h2 id="6-传值调用"><a href="#6-传值调用" class="headerlink" title="6. 传值调用"></a>6. 传值调用</h2><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increamet</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">Increment</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，main中的a是实参，Increment中的x是形参，传值调用的过程就是实参映射到实参，也就是将实参的值拷贝到形参中。</p>
<h2 id="7-数组与指针"><a href="#7-数组与指针" class="headerlink" title="7. 数组与指针"></a>7. 数组与指针</h2><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">cout &lt;&lt; &amp;a[i] &lt;&lt; endl; 	<span class="comment">// &lt;==&gt; cout &lt;&lt; (a + i) &lt;&lt; endl;</span></span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; endl;	<span class="comment">// &lt;==&gt; cout &lt;&lt; *(a + i) &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = a;</span><br><span class="line">*p ++ ; <span class="comment">// valid</span></span><br><span class="line">a ++ ;	<span class="comment">// invalid</span></span><br></pre></td></tr></table></figure>

<p><strong>指针就是数组，数组就是指针</strong></p>
<p>数组的基地址就是数组首元素的地址，直接使用数组名就可以得到数组的基地址</p>
<h2 id="8-数组作为函数参数"><a href="#8-数组作为函数参数" class="headerlink" title="8. 数组作为函数参数"></a>8. 数组作为函数参数</h2><h3 id="8-1-例1"><a href="#8-1-例1" class="headerlink" title="8.1 例1"></a>8.1 例1</h3><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> t[])</span> <span class="comment">// &lt;==&gt; int getSum(int *t)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> Size = <span class="built_in">sizeof</span>(t) / <span class="built_in">sizeof</span>(t[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size-t : &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(t) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;getSum-size: &quot;</span> &lt;&lt; Size &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; Size; i ++ ) sum += t[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> Size = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size-a: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main-size: &quot;</span> &lt;&lt; Size &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">getSum</span>(a);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sum: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size-a: <span class="number">20</span></span><br><span class="line">main-size: <span class="number">5</span></span><br><span class="line">size-t : <span class="number">8</span></span><br><span class="line">getSum-size: <span class="number">2</span></span><br><span class="line">sum: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>Explaion：</p>
<blockquote>
<p>在上面的程序中，我们希望将数组 a 传递给函数 getSum 来求得数组 a 中所有元素的和（15）。</p>
<p>我们通过一个巧妙的方法得到数组 a 中元素的个数：sizeof(a) &#x2F; sizeof(a[0]);</p>
<p>sizeof(a) 是数组 a 所占用的字节数，同理如果有一个 int 类型变量 i，那么 sizeof(i) &#x3D; 4；sizeof(a[0]) 是数组 a 中一个元素占用的字节数。</p>
<p>在 main 函数中我们正确求得了 数组 a 的元素个数（5），数组 a 占用的字节数（20），然而当我们把数组 a 传递给函数 getSum 时，我们在函数内求得数组 a 的元素个数为 2，并且数组 a 占用的字节大小为 8，而不是 20 (5*sizeof(int))。</p>
<p>这是为什么呢？</p>
</blockquote>
<h3 id="8-2-例2"><a href="#8-2-例2" class="headerlink" title="8.2 例2"></a>8.2 例2</h3><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> t[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        t[i] = t[i] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before change: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">change</span>(a, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after change: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before change: 1 2 3 4 5 </span><br><span class="line">after change: 2 4 6 8 10 </span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>我们发现，将数组 a 传递给函数 change 之后，在 change 中执行的操作返回到了实参中。</p>
<p>这说明数组的传递是传引用而不是传值。</p>
</blockquote>
<h3 id="8-3-例3"><a href="#8-3-例3" class="headerlink" title="8.3 例3"></a>8.3 例3</h3><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out</span><span class="params">(<span class="type">int</span> t[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;t: &quot;</span> &lt;&lt; &amp;t &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*t: &quot;</span> &lt;&lt; *t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;a: &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*a: &quot;</span> &lt;&lt; *a &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">out</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;a: 0x7fff33a6e2d0</span><br><span class="line">a: 0x7fff33a6e2d0</span><br><span class="line">*a: 1</span><br><span class="line">&amp;t: 0x7fff33a6e2b8</span><br><span class="line">t: 0x7fff33a6e2d0</span><br><span class="line">*t: 1</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>我们发现，将数组 a 传递给函数 out 之后，数组 t 的首地址和数组 a 的首地址是一样的，但是在数组中，理应来说 &amp;t 和 t 的结果应该是一样的，例如在 main中 &amp;a 和 a 的结果就是一致的，但实际上打印出来的结果是不同的，这又是为什么呢？</p>
</blockquote>
<h3 id="8-4-例4"><a href="#8-4-例4" class="headerlink" title="8.4 例4"></a>8.4 例4</h3><p>Code：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void out(int *t)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;&amp;t: &quot; &lt;&lt; &amp;t &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;t: &quot; &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*t: &quot; &lt;&lt; *t &lt;&lt; endl;</span><br><span class="line">    for(int i = 0; i &lt; 5; i ++ )</span><br><span class="line">        printf(&quot;&amp;(t + %d)[%p] = %d\n&quot;, i, t + i, *(t + i));</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[5] = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">    cout &lt;&lt; &quot;&amp;a: &quot; &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*a: &quot; &lt;&lt; *a &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    out(a);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&amp;a: 0x7fff9a681e00</span><br><span class="line">a: 0x7fff9a681e00</span><br><span class="line">*a: 1</span><br><span class="line">&amp;t: 0x7fff9a681dd8</span><br><span class="line">t: 0x7fff9a681e00</span><br><span class="line">*t: 1</span><br><span class="line">&amp;(t + 0)[0x7fff9a681e00] = 1</span><br><span class="line">&amp;(t + 1)[0x7fff9a681e04] = 2</span><br><span class="line">&amp;(t + 2)[0x7fff9a681e08] = 3</span><br><span class="line">&amp;(t + 3)[0x7fff9a681e0c] = 4</span><br><span class="line">&amp;(t + 4)[0x7fff9a681e10] = 5</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>我们发现，将数组 a 传递给函数 out，out 的形参是一个 int 型指针，依然可以遍历数组。</p>
</blockquote>
<h3 id="8-5-总结"><a href="#8-5-总结" class="headerlink" title="8.5 总结"></a>8.5 总结</h3><ol>
<li>由例4和例2可得出： **type function(int a[]) &lt;&#x3D;&#x3D;&gt; type function(int *a)<strong>，当我们把一个数组作为参数传递给函数时，并不会传递整个数组的内容，而是仅仅传递数组的首地址。同时这也印证了那句话：</strong>数组就是指针，指针就是数组**</li>
<li>由结论1，对于数组来说，不使用传值方式，总是<strong>传引用</strong>。因为有时候数组可能很大，拷贝整个数组没有太大意义，它会耗费大量内存。</li>
<li>由结论2，我们便可以知道为什么例3中，在函数 out 中打印 &amp;t 和 t是不一样结果了，因为编译器把 int t[] 转换成了 int *t，因此 t 本质上不是一个数组，而是一个指向数组的指针。所以在栈中，只会申请 8 字节（64位机器一个指针占用的内存空间）空间，用来存放这个指针 t，所以说&amp;t 实际上打印的是在栈中 t 的地址，而 t 则打印的是指针变量 t 的内容，也就是它指向的地址（即数组 a 的地址）。</li>
<li>由2和3，也就解释了例1 中为什么在函数 getSum中，sizeof(t) &#x3D; 8，因为我们传递过去的不是一个完整的数组，而是指向这个数组的指针。</li>
</ol>
<h2 id="9-指针和字符数组"><a href="#9-指针和字符数组" class="headerlink" title="9. 指针和字符数组"></a>9. 指针和字符数组</h2><p>——当我们在 C 语言中谈论字符数组时，基本上就是在讨论字符串</p>
<h3 id="9-1如何把字符串存入字符数组"><a href="#9-1如何把字符串存入字符数组" class="headerlink" title="9.1如何把字符串存入字符数组"></a>9.1如何把字符串存入字符数组</h3><p>——首要的需求就是字符数组必须足够大，大到能够容纳字符串</p>
<p>一个足够大的字符数组是指它的大小&gt;&#x3D;字符的数量 +1，因为在字符串中必须指明结束标志（\0），但整型和浮点型数组没有结束符， 完全要自己严格控制元素的数量。</p>
<h3 id="9-2-字符数组的声明"><a href="#9-2-字符数组的声明" class="headerlink" title="9.2 字符数组的声明"></a>9.2 字符数组的声明</h3><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;john&quot;</span>; <span class="comment">// 用双引号给字符数组复制，编译器会自动给字符串添加结束标志&#x27;\0&#x27;，因为字符数组的长度就是字符串长度+1（\0）</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl; <span class="comment">// 5，  包含&#x27;\0&#x27;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(s) &lt;&lt; endl; <span class="comment">// 4，不包含 &#x27;\0&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> a[] = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>&#125;; <span class="comment">// 需要手动添加结束标志，这里因为没有添加 &#x27;\0&#x27;，strlen(a)出错</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; 	<span class="comment">// 4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(a) &lt;&lt; endl;  <span class="comment">// 8，出错</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> b[] = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; 	<span class="comment">// 手动添加&#x27;\0&#x27;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; endl;  <span class="comment">// 3</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(b) &lt;&lt; endl;	<span class="comment">// 2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tips：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;john&quot;</span>;</span><br><span class="line"><span class="comment">// 不可以写为下面的形式：</span></span><br><span class="line"><span class="type">char</span> s[<span class="number">107</span>];</span><br><span class="line">s = <span class="string">&quot;john&quot;</span>;</span><br><span class="line"><span class="comment">// 用双引号初始化必须在同一行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其次，下面的声明方式是不严谨的，因为我们不知道字符串的结束在那</span></span><br><span class="line"><span class="comment">// 因此，可能发生奇怪的问题</span></span><br><span class="line"><span class="type">char</span> a[] = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如下面：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a[] = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *s = a;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="number">1234</span>t��M�</span><br><span class="line"><span class="number">1234</span>t��M�</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 可以发现出现了乱码    </span></span><br></pre></td></tr></table></figure>



<h3 id="9-3-char"><a href="#9-3-char" class="headerlink" title="9.3  char *"></a>9.3  char *</h3><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>上面的代码会报错，因此把  “Hello” 的值—-也就是<strong>字符串常量字面值</strong>，也就是 “Hello” 的地址，准确来说是起始地址—-赋给字符指针 str，Linux下 “Hello”字符串常量是存放于<strong>只读数据区</strong>（常量区）的，不可以修改。</p>
<p>因此如果我们要把 char* 传递到函数中，那么形参的类型最好是 const char*</p>
<p>对于 <code>char s[] = &quot;Hello&quot;; </code></p>
<p>s[] 是一个字符数组，编译器首先在栈中分配一定的连续空间用于存放 “Hello” 中的字符以及结尾符，然后把字符串常量的内容，也就是<br>“Hello” 中的各个字符和结尾符复制到这个<strong>栈</strong>中的连续空间中。str是数组名，用来表示这个连续栈空间的起始地址，所以str中存放的是栈地址，这个地址的数据是可写的。</p>
<p><strong>在 Linux 中，堆，全局数据，常量等都是存放于从 0x8048000 开始的内存地址，向上增长。一般来说，32位机器上，在Linux中，栈地址空间从3G（0xbfffffff）开始向下增长。</strong></p>
</blockquote>
<p>Tips：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *s = ch;</span><br><span class="line">    s ++ ;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;	<span class="comment">//ello</span></span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;	<span class="comment">// Xllo</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>char*s = ch;</code>中的 ch 不是字符串常量，因此 s 可以修改。</p>
<h2 id="10-指针和二维数组"><a href="#10-指针和二维数组" class="headerlink" title="10. 指针和二维数组"></a>10. 指针和二维数组</h2><p>多维数组本质上是<strong>数组的数组</strong>，由于一个指针可以表示一个数组，因此可以把二维数组看做一维指针数组。</p>
<p><strong>数组</strong>可以看做是同类事物的集合，<strong>多维数组</strong>基本上可以理解为数组的集合。</p>
<p>例如二维数组<code>A[3][2]</code>，如下图所示：</p>
<p><img src="https://s1.328888.xyz/2022/07/14/LtB4I.png"></p>
<blockquote>
<p>对 A 解引用就可以得到 A[0], A[1], A[2]</p>
<p>对 A[i] 解引用就可以得到 A[i][0], A[i][1]</p>
<p>对 A[i][j] 解引用就可以得到具体的值</p>
<p><strong>注意别把指针数组和二维指针搞混了，根本不是一回事！</strong></p>
</blockquote>
<h3 id="10-1-二维数组在内存中的存放方式"><a href="#10-1-二维数组在内存中的存放方式" class="headerlink" title="10.1 二维数组在内存中的存放方式"></a>10.1 二维数组在内存中的存放方式</h3><p>假设我们生成了一个数组 <code>A[3][2]</code></p>
<p><img src="https://i.bmp.ovh/imgs/2022/07/14/2e64b6aa12631e70.png" alt="IMAGE"></p>
<p>此时如果我们定义一个指针 <code>int *p = &amp;A;</code> 会编译错误，因为这里的 int 类型指针 p 指向了一个一维数组，这与指针的类型不匹配。</p>
<h3 id="10-2-二维数组的运算"><a href="#10-2-二维数组的运算" class="headerlink" title="10.2 二维数组的运算"></a>10.2 二维数组的运算</h3><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;二维数组b的首地址: &quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> (*p)[<span class="number">3</span>] = b; <span class="comment">// 一维指针数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// b是二维数组b[][]的数组名,它的地址就是首地址b[0]</span></span><br><span class="line">    cout &lt;&lt; b     &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b[<span class="number">0</span>] &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; b + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// b &lt;==&gt; &amp;b，b[i] &lt;==&gt; &amp;b[i]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对b直接解引用得到的是b[0]，b[0]是一维数组b[0]的数组名，因此b[0]的地址就是首地址b[0][0]</span></span><br><span class="line">    cout &lt;&lt; *b       &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; &amp;b[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; endl; <span class="comment">// *b = *(b + 0)</span></span><br><span class="line">    cout &lt;&lt; *(b + <span class="number">1</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; &amp;b[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    cout &lt;&lt; *(b + <span class="number">1</span>) + <span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b[<span class="number">1</span>] + <span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; &amp;b[<span class="number">1</span>][<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    cout &lt;&lt; *(*b + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">二维数组b的首地址: 0x7fff0e673980</span><br><span class="line">0x7fff0e673980 0x7fff0e673980</span><br><span class="line">0x7fff0e67398c 0x7fff0e67398c</span><br><span class="line">0x7fff0e673980 0x7fff0e673980 0x7fff0e673980</span><br><span class="line">0x7fff0e67398c 0x7fff0e67398c 0x7fff0e67398c</span><br><span class="line">0x7fff0e673994 0x7fff0e673994 0x7fff0e673994</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>Tips：</p>
<blockquote>
<p>在二维数组中，有以下两条等式</p>
<p><strong>取地址：</strong><code>&amp;b[i][j] &lt;=&gt; b[i] + j &lt;=&gt; *(b + i) + j</code></p>
<p><strong>取值：</strong>    <code>b[i][j] &lt;==&gt; *(b[i] + j ) &lt;==&gt; *(*(b + i) + j)</code></p>
</blockquote>
<h2 id="11-指针和多维数组"><a href="#11-指针和多维数组" class="headerlink" title="11. 指针和多维数组"></a>11. 指针和多维数组</h2><h3 id="11-1-指针和三维数组"><a href="#11-1-指针和三维数组" class="headerlink" title="11.1 指针和三维数组"></a>11.1 指针和三维数组</h3><p>Code：</p>
<p>要注意解引用运算符(*)的优先级</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">int</span> (*p)[<span class="number">2</span>][<span class="number">2</span>] = c;</span><br><span class="line">    <span class="comment">//int *p[2][2] = c; // Wrong!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tips：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c[i][j][k] </span><br><span class="line">	= *(c[i][j] + k) </span><br><span class="line">	= *(*(c[i] + j) + k) </span><br><span class="line">	= *(*(*(c + i) + j) + k)</span><br></pre></td></tr></table></figure>

<p>对于上面的转换，只需要牢记指针和数组之间的转换就可以了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c[i] = *(c + i);</span><br><span class="line">&amp;c[i] = c + i;</span><br></pre></td></tr></table></figure>



<h3 id="11-2-多维数组作为参数传递给函数"><a href="#11-2-多维数组作为参数传递给函数" class="headerlink" title="11.2 多维数组作为参数传递给函数"></a>11.2 多维数组作为参数传递给函数</h3><p>我们在第 8 章中已经知道，将数组作为参数传递给函数时，实际上不会拷贝整个数组，只会以指针的形式传它的引用。例如：</p>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a[])</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fundc</span><span class="params">(<span class="type">int</span> *a)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子是一维数组的情况，那么如果传递的是多维数组呢？</p>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> d[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> a[][])</span>  </span>&#123; 	<span class="comment">// test 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> *a)</span>     </span>&#123; 	<span class="comment">// test 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> a[][<span class="number">3</span>])</span> </span>&#123; 	<span class="comment">// test 3  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">(<span class="type">int</span> *a[<span class="number">3</span>])</span>  </span>&#123; 	<span class="comment">// test 4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func5</span><span class="params">(<span class="type">int</span> **a)</span>    </span>&#123;	<span class="comment">// test 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>在第一种形式中，编译器会报错，因为我们执行了一个二维数组作为形参，形式上虽然是 <code>a[][]</code>，但编译器会将其转化为  <code>(*a)[]</code>, 也就是说，我们指定了一个指针数组作为参数，但我们没有指定这个指针数组的大小，因此编译器报错。 </p>
<p>在第二种形式中，编译时不会报错，但如果我们将数组 <code>c</code> 作为参数执行 <code>func()</code> 函数，编译器会报错，因为 <code>c[][]</code> 的类型为 <code>(int *)[]</code>，而参数的类型为 <code>int *</code>，显然类型不匹配。</p>
<p>第三种形式和第四种形式都是正确的，因为我们指定了指针数组的大小。</p>
<p>将数组 <code>c</code> 传递给 <code>func3()</code> 和 <code>func4()</code> 是正确的，但如果传入数组 <code>d</code>  就会报错，因为数组的第二维不匹配。</p>
</blockquote>
<p>Tips：</p>
<blockquote>
<p>也就是说，在我们将数组作为参数传递给函数时，数组的第一维是可以省略的，但是剩下的维必须指定大小。</p>
<p>另外，一个常见的误区是：对于二维数组，我们传入一个指针的指针，对于三维数组，传递一个指针的指针的指针，这是不对的。</p>
</blockquote>
<h2 id="12-指针和内存管理"><a href="#12-指针和内存管理" class="headerlink" title="12. 指针和内存管理"></a>12. 指针和内存管理</h2><h3 id="12-1-内存架构"><a href="#12-1-内存架构" class="headerlink" title="12.1 内存架构"></a>12.1 内存架构</h3><p>在一个典型的架构中，分配给应用程序的内存可以分为四个区段：</p>
<ol>
<li>Test(Code)：用来存放需要执行的<strong>指令</strong></li>
<li>Static&#x2F;Global：用来存放<strong>静态变量</strong>或<strong>全局变量</strong>，也就是不在函数中声明的变量，它们的声明周期贯穿整个程序周期</li>
<li>Stack：用来存放<strong>函数调用的所有信息</strong>和<strong>所有局部变量</strong>，局部变量在函数内部声明</li>
<li>Heap：用来存放<strong>动态分配</strong>的变量</li>
</ol>
<p>Tips:</p>
<ol>
<li><strong>代码段，静态&#x2F;全局数据段，栈区在运行期间的大小是不会增长的。</strong></li>
<li>一个函数的帧栈大小，是在编译期间就决定了的。</li>
<li>程序在任何时间，都是栈顶的函数在执行。</li>
</ol>
<h3 id="12-2-堆的引入"><a href="#12-2-堆的引入" class="headerlink" title="12.2 堆的引入"></a>12.2 堆的引入</h3><p>内存在栈上的分配和销毁有一定的规则，当一个函数被调用的时候，它被压入堆栈，结束时，弹出堆栈。如果变量是在栈上分配的，那你就不能操纵变量的范围。</p>
<p>另外一个限制，如果我们需要声明一个很大的数据类型，或者一个很大的数组作为局部变量，我们需要在编译期间知道数组的大小。如果我们有这样一个场景：需要在运行期间根据参数决定数组的大小，那么使用栈就会有问题了。</p>
<p>针对这些问题，比如分配很大的内存，或者把变量预留在内存中直到我们想用的时候为止，我们就有了堆。</p>
<h3 id="12-3-堆简介和引应用"><a href="#12-3-堆简介和引应用" class="headerlink" title="12.3 堆简介和引应用"></a>12.3 堆简介和引应用</h3><p>不像栈，应用程序的堆的大小是<strong>不固定</strong>的，它的大小在应用程序的整个声明周期是可变的，也没有特定的规则来分配和销毁特定的内存，程序员可以完全控制在堆上分配多少存在，数据保留到什么时候，你几乎可以任意使用堆上的内存，只要不超出系统自身的内存限制，但有时候随意使用堆也是危险的（内存泄露）</p>
<p>有时候我们把堆称为<strong>内存的空闲池</strong>，或者内存空闲存取区，我们可以在堆中获得我们想要的内存，尽管不同的操作系统对分配堆的方式不同，但可以把堆抽象看做一块很大的自由使用的内存空间</p>
<p>注意不要把这里的堆和数据结构中的堆混淆了，它们是完全不同的概念，这里的堆表示的只是空闲的内存池。另外栈区是栈的一种实现，而堆不是的。</p>
<p>使用堆内存意味着<strong>动态内存分配</strong>，在 C 或者 C++ 中使用堆的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C：</span><br><span class="line">    malloc();</span><br><span class="line">    calloc();</span><br><span class="line">    realloc();</span><br><span class="line">    free();</span><br><span class="line">C ++ :</span><br><span class="line">	new;</span><br><span class="line">    delete();</span><br><span class="line">    C ++ 也可以使用 C 的四个函数，因为 C ++ 向后兼容 C</span><br></pre></td></tr></table></figure>

<p>malloc会返回一个指向这块内存起始地址的**(void *)指针<strong>，因此需要做类型转换，但是在 C ++ 里面则不需要，因此new 和 delete 操作符是</strong>类型安全**的，这意味着，他们是带着类型的，返回指向特定类型的指针。</p>
<p>事实上<strong>使用堆的唯一方式就是通过引用。</strong>malloc函数所做的事情仅仅是，从堆上找到空闲的内存，为你预留空间然后通过指针返回给你，你去访问这块内存的方式就是自己维护一个指针。</p>
<p>分配在堆上的内存在函数调用结束之后并不会像栈上那样自动释放，因此，对于分配的内存，要注意回收（free） ，否则可能导致内存泄露</p>
<p>Code：C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a; <span class="comment">// goes on stack</span></span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">20</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Code：C++</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;              <span class="comment">// 分配在栈上</span></span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *p = <span class="number">10</span>;            </span><br><span class="line">    <span class="keyword">delete</span> p;           <span class="comment">// 释放空间</span></span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>];    <span class="comment">// 分配一个数组</span></span><br><span class="line">    <span class="keyword">delete</span>[] p;         <span class="comment">// 释放空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-4-库函数"><a href="#12-4-库函数" class="headerlink" title="12.4 库函数"></a>12.4 库函数</h3><p>介绍 C 语言支持中支持动态内存分配的各种库函数。</p>
<h4 id="12-4-1-malloc"><a href="#12-4-1-malloc" class="headerlink" title="12.4.1 malloc()"></a>12.4.1 malloc()</h4><p>malloc 的全称是 <strong>memory allocation</strong>，中文叫<strong>动态内存分配</strong>，用于申请一块连续的指定大小的内存块区域以 void* 类型返回分配的内存区域地址，当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态的分配内存，且分配的大小就是程序要求的大小。 </p>
<p>如果分配成功则返回指向被分配内存的指针**(此空间中的初始值不确定)**，否则返回空指针 NULL。当内存不再使用时，应使用 free() 函数将内存块释放。</p>
<p>原型为：<em><em>void</em> malloc(size_t size);</em>*</p>
<blockquote>
<p>可以把 size_t看做 unsigned_int（&gt;&#x3D;0），显然我们不能指定一个负数。</p>
<p>malloc 返回一个 void* 指针，这个指针指向分配给我们的内存块的第一个地址。</p>
<p>size &#x3D; 单元的数量 * 每个单元的字节数</p>
</blockquote>
<p>例如：如果我们希望分配一个单元的 int 类型的空间</p>
<blockquote>
<figure class="highlight plaintext"><figcaption><span>*p </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们最好写成这样的形式：```void *p = malloc(sizeof(int));```</span><br><span class="line"></span><br><span class="line">我们不可以解引用一个 void 指针，因此为了能够使用这块内存，我们需要把 malloc 返回的指针转成一个特定类型的指针。</span><br><span class="line"></span><br><span class="line">malloc 之所以返回一个 void 指针是因为可以确保它的通用性，它做的仅仅只是分配内存，而不关心这块内存你是拿来存整形还是字符还是浮点数。</span><br><span class="line"></span><br><span class="line">Code：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int *p = (int *)malloc(3 * sizeof(int));</span><br><span class="line">   // 通过指针操纵</span><br><span class="line">   *p = 1;</span><br><span class="line">   *(p + 1) = 2;</span><br><span class="line">   *(p + 2) = 3;</span><br><span class="line">   </span><br><span class="line">   // 因为我们分配的是一个int数组，因此我们可以直接通过数组的方式操纵</span><br><span class="line">   p[0] = 4;</span><br><span class="line">   p[1] = 5;</span><br><span class="line">   p[2] = 6;</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="12-4-2-calloc"><a href="#12-4-2-calloc" class="headerlink" title="12.4.2 calloc()"></a>12.4.2 calloc()</h4><p>使用 malloc 初始化时不会进行初始化，因此如果没有填入值得话，会得到一些随机值。但是使用 calloc 的话，会对其进行初始化为 0，如果分配成功则返回指向被分配内存的指针(**此空间中的初始值为 0 **)，否则返回空指针 NULL，</p>
<p>calloc 的全称是 <strong>clear allocation</strong>，中文名为<strong>动态内存分配并清零</strong></p>
<p>函数原型为：*<em>void <em>calloc(unsigned int num，unsigned int size);</em></em></p>
<blockquote>
<p>num 表示分配的单元数量，size表示单元大小</p>
</blockquote>
<h4 id="12-4-3-realloc"><a href="#12-4-3-realloc" class="headerlink" title="12.4.3 realloc()"></a>12.4.3 realloc()</h4><p>如果你有一块内存，动态分配的内存，然后你想修改内存块的大小，就可以使用 realloc，realloc 的全称是 <strong>reset allocation</strong>，中文名为<strong>动态内存调整</strong>。</p>
<p>函数原型为：<em><em>extern void * realloc(void</em> mem_address, unsigned int newsize);</em>*</p>
<blockquote>
<p>mem_address 指向已分配内存的起始地址的指针，如果 mem_address &#x3D; NULL , 那么此时就相当于 malloc</p>
<p>newsize 为新内存块的大小</p>
<p>先判断当前的指针是否有足够的连续空间，如果有，扩大 mem_address 指向的地址，并且将 mem_address 返回，如果空间不够，先按照 newsize 指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来 mem_address 所指内存区域(<strong>原来的指针会自动释放，不需要再使用 free</strong>)，同时返回新分配的内存区域的首地址。重新分配成功返回指向被分配内存的指针，否则返回空指针 NULL。</p>
<p>注意：调整后的大小可大可小(如果新的大小大于原内存大小，新分配部分不会被初始化；如果新的大小小于原内存大小，可能会导致数据丢失）。</p>
</blockquote>
<h4 id="12-4-4-free"><a href="#12-4-4-free" class="headerlink" title="12.4.4 free()"></a>12.4.4 free()</h4><p>函数原型为：*<em>void free(void <em>ptr);</em></em></p>
<p>一般使用 malloc, calloc, realloc 函数进行内存分配后要使用 free(<strong>起始地址的指针</strong>) 对内存进行释放，不然内存申请过多会影响计算机的性能，以至于重启电脑。但是若使用动态内存分配函数后未使用 free 函数进行释放，还可以使用指针对该块内存进行访问，如果释放则不能再访问。</p>
<p><strong>注意：使用后该指针变量一定要重新指向 NULL，防止野指针出现，有效规避错误操作。</strong></p>
<h4 id="12-4-5-示例"><a href="#12-4-5-示例" class="headerlink" title="12.4.5 示例"></a>12.4.5 示例</h4><p>上面函数的使用需要引入头文件 <code>#include &lt;stdlib.h&gt;</code></p>
<p>Code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入数组的大小: &quot;</span> &lt;&lt; endl;   </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编译错误,不能在运行时定义数组</span></span><br><span class="line">    <span class="comment">//int A[n]; </span></span><br><span class="line">    <span class="comment">//正确方法</span></span><br><span class="line">    <span class="type">int</span>* A = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mallo分配的数组: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    cout &lt;&lt; A[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> *B = (<span class="type">int</span>*)<span class="built_in">calloc</span>(n, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;callo分配的数组: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    cout &lt;&lt; B[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Input &amp;&amp; Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请输入数组的大小: </span><br><span class="line">25</span><br><span class="line">mallo分配的数组: </span><br><span class="line">39855248 0 7365248 0 0 0 0 0 0 0 -1694498661 43847 39855248 0 7340368 0 0 -1 -1728053095 43846 39855248 0 7340368 0 0</span><br><span class="line">callo分配的数组:</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>在上面的代码中，我们实现了在程序运行过程当中分配一个数组，并且可以验证，malloc 不会进行初始化，因此我们得到一堆随机数，而 calloc 会进行0初始化，因此数组元素全为 0</p>
</blockquote>
<hr>
<p>Code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入数组的大小: &quot;</span> &lt;&lt; endl;   </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span>* A = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    A[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    cout &lt;&lt; A[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(A);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    cout &lt;&lt; A[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// free之后再次修改内存中的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    A[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    cout &lt;&lt; A[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Input &amp;&amp; Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请输入数组的大小: </span><br><span class="line">5</span><br><span class="line">1 2 3 4 5 </span><br><span class="line">16279024 0 16253264 0 5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>



<p>Expalin：</p>
<blockquote>
<p>可以发现，在释放掉动态分配的内存之后，仍然可以访问该内存，并打印出一些随机值(完全取决于编译器和机器)，甚至可以再次修改内存中的值并正常执行，但在其他的机器上这个程序可能会崩溃（可能另一个指针指向这块内存，而你修改了它）。</p>
<p>所以说 free 并不是真的 “销毁” 了一块内存，它只是说实现这个内存不属于你这个指针了。</p>
<p>这是使用指针的时候一个危险的地方。</p>
</blockquote>
<hr>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入数组的大小: &quot;</span> &lt;&lt; endl;   </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span>* A = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入数组改编后的大小:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> *B = (<span class="type">int</span> *)<span class="built_in">realloc</span>(A, n * <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 包含 free(A)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) B[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    cout &lt;&lt; B[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Input &amp;&amp; Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请输入数组的大小: </span><br><span class="line">5</span><br><span class="line">请输入数组改编后的大小:</span><br><span class="line">10</span><br><span class="line">1 2 3 4 5 6 7 8 9 10 </span><br></pre></td></tr></table></figure>



<h3 id="12-5-内存泄露"><a href="#12-5-内存泄露" class="headerlink" title="12.5 内存泄露"></a>12.5 内存泄露</h3><p>**所谓内存泄露，是指不当地使用动态内存或者内存的堆区，也就是在堆长增加”垃圾”**。其他语言诸如 Java 和 C# ，堆上的垃圾会被自动回收（垃圾回收机制）。</p>
<p>内存泄漏总是因为堆中未使用和未引用的内存块才发生的。</p>
<p>栈上的内存是自动回收的，栈的大小是固定的，会多就是会发生栈溢出。</p>
<p>常见的错误：在函数内部 malloc 一块内存，但是在函数结束时没有释放，如果这个函数执行非常多次，就造成内存泄漏。不要误以为在函数中 malloc 的内存会在函数结束时自动释放，函数结束时只会自动释放栈中的内存，而 malloc 是在堆上分配的内存，所以函数结束时不会释放。</p>
<h2 id="13-函数返回指针"><a href="#13-函数返回指针" class="headerlink" title="13. 函数返回指针"></a>13. 函数返回指针</h2><p><strong>重点：什么时候可以从函数返回一个指针</strong></p>
<blockquote>
<p>如果我们在堆上有一个内存地址或者在全局区有一个变量，那么我们就可以安全的返回他们的地址</p>
</blockquote>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int* Add1(int *a, int *b)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     int c = (*a) + (*b);</span></span><br><span class="line"><span class="comment">//     return &amp;c;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">Add</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *c = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *c = *a + *b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span>* c = <span class="built_in">Add</span>(&amp;a, &amp;b);</span><br><span class="line">    <span class="comment">//int *c = Add1(&amp;a, &amp;b); 报错</span></span><br><span class="line">    cout &lt;&lt; (*c) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>在上面的代码中，Add1函数并不是一个正确的函数返回指针的例子，因为它返回的是一个 《被调用的函数的中的局部变量的地址》，我们知道，一个函数的栈帧会随着函数的结束而被释放，所以当 Add1 函数结束的时候，局部变量 c 的地址就被释放了，所以说返回 c 的地址是错误的。</p>
<p>因此，<strong>从函数返回地址时，我们需要小心它们的作用范围</strong><br>从栈底向上传一个局部变量或者局部变量的地址是可以的。<br>但是，从栈顶想下传一个局部变量或者局部变量的地址是不可以的。</p>
<p>因为被调函数的地址在主调函数的上面，当被调函数执行时，主调函数一定还没结束，而主调函数在执行时，被调函数分配的内存空间也一定被释放掉了。</p>
<p>正确的做法是返回全局变量取的地址或者堆区的地址，因为那里的地址不会被自动释放。</p>
</blockquote>
<h2 id="14-函数指针"><a href="#14-函数指针" class="headerlink" title="14. 函数指针"></a>14. 函数指针</h2><h3 id="14-1-简介"><a href="#14-1-简介" class="headerlink" title="14.1 简介"></a>14.1 简介</h3><p>根据定义可以知道，函数指针是用来保存函数的地址的指针。</p>
<p>那么问题来了，<strong>函数的地址是什么？</strong></p>
<blockquote>
<p>在内存中，一个函数就是一块连续的内存（里面是指令）</p>
<p><strong>函数的地址，我们也把它称为函数的入口点，它是函数的第一条指令的地址（最低地址）</strong></p>
<p>通过直接使用函数名或者取地址可以得到函数的地址。</p>
<p><code>function = &amp;function</code></p>
</blockquote>
<h3 id="14-2-函数指针的使用"><a href="#14-2-函数指针的使用" class="headerlink" title="14.2 函数指针的使用"></a>14.2 函数指针的使用</h3><p>对于下面这个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>函数指针的声明和初始化：</p>
<blockquote>
<p>声明一个函数指针的步骤：</p>
<ol>
<li>首先输入的是，指向这个函数的返回类型，add 函数的返回类型是 int；</li>
<li>然后跟一个括号，括号里面是 *name，name就是函数指针的名字；</li>
<li>然后再跟一个括号，括号里面是所指向这个函数的所有参数的类型，要和所指向的这个函数的类型是一致的。</li>
</ol>
<p>即：function_type (*pointer_name)(arguments_type);</p>
<p>声明一个指向 add 函数的指针 p：</p>
<p>**–&gt; int (<em>p)(int, int);	 &#x2F;&#x2F; 声明了一个函数指针</em>*<br><strong>–&gt; p &#x3D; &amp;add;				&#x2F;&#x2F; 将函数指针 p 指向函数 add</strong></p>
<p>通过上面两条语句我们就实现了声明一个函数指针并让其指向一个函数，当然也可以写为一条语句。</p>
<p>调用函数指针：</p>
<p>**–&gt; int c &#x3D; (<em>p)(2, 3); &#x2F;&#x2F; 调用函数add</em>*</p>
<p>(*p)表示解引用，来获得这个函数，然后把两个参数传递给这个函数。</p>
<p>作为代替，我们也可以直接使用函数指针名（就像在使用函数名一样）：</p>
<p><strong>–&gt;int c &#x3D; p(2, 3); 	 &#x2F;&#x2F;  等价于上面的语句</strong></p>
</blockquote>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello,World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="built_in">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>) = &amp;add;</span><br><span class="line">    c = (*p)(<span class="number">2</span>, <span class="number">3</span>);     </span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;  <span class="comment">// 5</span></span><br><span class="line">    c = <span class="built_in">p</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;  <span class="comment">// 9</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">void</span> (*p1)();</span><br><span class="line">    p1 = printStr;</span><br><span class="line">    <span class="built_in">p1</span>();				<span class="comment">// Hello,World!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14-3-使用案例（回调函数）"><a href="#14-3-使用案例（回调函数）" class="headerlink" title="14.3 使用案例（回调函数）"></a>14.3 使用案例（回调函数）</h3><p><strong>回调函数：</strong>一个函数引用传递给另一个函数时，那个函数被称作回调函数。</p>
<p>函数指针可以被用来做函数参数，接受函数指针的那个函数可以回调函数指针所指向的那个函数，举个例子：</p>
<p>Code：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">B</span><span class="params">(<span class="type">void</span> (*ptr)())</span> &#123;</span><br><span class="line">    (*ptr)();    <span class="comment">// &lt;==&gt; ptr();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> (*ptr)() = A;</span><br><span class="line">    B(ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// &lt;==&gt;</span></span><br><span class="line">    B(A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>在上面的函数中，我们声明了两个函数 <code>A</code> 和 <code>B</code></p>
<figure class="highlight plaintext"><figcaption><span>没有参数，返回值类型为 ```void```；</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">```B ```有一个参数，参数类型为一个返回值类型为 ```void```，没有参数的函数指针，返回值类型为 ```void```；</span><br><span class="line"></span><br><span class="line">在 ```main```中，我们声明了一个返回值类型为 ```void```，没有参数的指针 ```ptr```，并让其指向函数 ```A```（类型匹配），返回将这个指针作为参数传递给函数 ```B```，函数 ```B``` 又通过函数指针 ```ptr``` 调用函数 ```A```。</span><br><span class="line"></span><br><span class="line">函数 ```B``` 可以通过函数指针回调函数 ```A```</span><br><span class="line"></span><br><span class="line">**另外也可以写成 ```B(A)```的形式，因为函数的名字返回的就是指针。**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">****</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">更清晰的例子：</span><br><span class="line"></span><br><span class="line">Code：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">void bubbleSort(int *a, int n) &#123;</span><br><span class="line">for(int i = 0; i &lt; n - 1; i ++ ) &#123;</span><br><span class="line">	for(int j = 0; j &lt; n - 1 - i; j ++ ) &#123;</span><br><span class="line">           if(a[i] &gt; a[i + 1]) &#123;</span><br><span class="line">               swap(a[i], a[i + 1])</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Explain：</p>
<blockquote>
<p>通过上面的冒泡排序，我们可以实现对一个数组升序排序。现在有这样一种情况，我们有时候需要升序排序，有时候又需要降序排序。</p>
<p>最简单的方式就是写两份冒泡排序，然后修改判断条件，但是这样代码的冗余度太高。</p>
<p>另一种冗余度低且比较简单的方法是在函数中额外传递一个参数 <code>flag</code> ，用来标记这是升序排序还是降序排序。但这样的话如果 <code>flag</code> 很大的话，那么函数内部的 <code>if</code> 比较函数就会很多（我们需要判断依据何种判断条件）。</p>
<p>还有一种方式就是在函数中额外传递一个比较函数，这样就不要额外添加判断语句。</p>
</blockquote>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> (*compare)(<span class="type">int</span>, <span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ ) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">compare</span>(a[j], a[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = a[j];</span><br><span class="line">                a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                a[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">74</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = (<span class="type">int</span>)<span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">bubbleSort</span>(arr, n, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>在 <code>bubbleSort</code> 函数中回调 <code>cmp</code> 函数实现自定义的排序方案。</p>
</blockquote>
<h2 id="15-第15章-C文件操作"><a href="#15-第15章-C文件操作" class="headerlink" title="15. 第15章 C文件操作"></a>15. 第15章 C文件操作</h2><h3 id="15-0-简介和参考"><a href="#15-0-简介和参考" class="headerlink" title="15.0 简介和参考"></a>15.0 简介和参考</h3><p><a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_6778368b0100vidz.html">c&amp;c++文件流参考</a></p>
<p>在ANSI C中，对文件的操作分为两种方式，即：</p>
<ul>
<li><p><strong>流式文件操作</strong></p>
</li>
<li><p><strong>I&#x2F;O文件操作</strong></p>
</li>
</ul>
<h3 id="15-1-英文名词"><a href="#15-1-英文名词" class="headerlink" title="15.1 英文名词"></a>15.1 英文名词</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">perror：错误</span><br><span class="line">flow：流</span><br><span class="line">reind：倒带,back to the begining</span><br></pre></td></tr></table></figure>



<h3 id="15-2-流式文件操作"><a href="#15-2-流式文件操作" class="headerlink" title="15.2 流式文件操作"></a>15.2 流式文件操作</h3><h4 id="15-2-0-FIle结构"><a href="#15-2-0-FIle结构" class="headerlink" title="15.2.0 FIle结构"></a>15.2.0 FIle结构</h4><p>这种方式的文件操作有一个重要的结构FILE，FILE在stdio.h中定义如下：　　</p>
<p><strong>以下是引用片段：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">　　<span class="type">int</span> level; </span><br><span class="line">　　<span class="type">unsigned</span> flags; </span><br><span class="line">　　<span class="type">char</span> fd; </span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">char</span> hold; </span><br><span class="line">　　<span class="type">int</span> bsize; </span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">char</span> _FAR *buffer; </span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">char</span> _FAR *curp; </span><br><span class="line">　　<span class="type">unsigned</span> istemp; </span><br><span class="line">　　<span class="type">short</span> token; </span><br><span class="line">　&#125; FILE;</span><br></pre></td></tr></table></figure>

<p> 　　FILE这个结构包含了文件操作的基本属性，对文件的操作都要通过这个结构的指针来进行，此种文件操作常用的函数如下，下面是这些函数的功能使用说明：</p>
<h4 id="15-2-1-perror"><a href="#15-2-1-perror" class="headerlink" title="15.2.1 perror()"></a>15.2.1 perror()</h4><p><code>void perror(const char *message);</code></p>
<p>在发生错误时，该函数会简化向用户报告这些指定错误的过程。</p>
<p>打印格式为  message: [“wrong message”]，message后面跟一个冒号和空格，然后就是错误信息。</p>
<h4 id="15-2-2-fopen"><a href="#15-2-2-fopen" class="headerlink" title="15.2.2 fopen()"></a>15.2.2 fopen()</h4><p><code>FILE *fopen(path, mode); // 打开一个流</code></p>
<p><code>FILE *freopen(path, mode); //重新打开一个流</code></p>
<p>Mode:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r 打开只读文件，该文件必须存在。 </span><br><span class="line"></span><br><span class="line">r+ 打开可读写的文件，该文件必须存在。 </span><br><span class="line">w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。 </span><br><span class="line">w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。 </span><br><span class="line">a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。 </span><br><span class="line">a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 </span><br><span class="line">上述的形态字符串都可以再加一个b字符，如rb、w+b或ab+等组合，加入b 字符用来告诉函数库打开的文件为二进制文件，而非纯文字文件。不过在POSIX系统，包含Linux都会忽略该字符。</span><br></pre></td></tr></table></figure>

<h4 id="15-2-3-fclose"><a href="#15-2-3-fclose" class="headerlink" title="15.2.3 fclose()"></a>15.2.3 fclose()</h4><p><code>int fclose (FILE *f*);</code></p>
<p>关闭fopen()打开的文件。</p>
<p>对于输出流，fclose函数在文件关闭之前刷新缓冲区。如果它执行成功，返回零值，否则返回EOEF(-1)</p>
<p>在程序结束时一定要记得关闭打开的文件，不然可能会造成数据的丢失。</p>
<h4 id="15-2-4-fputc-fgetc"><a href="#15-2-4-fputc-fgetc" class="headerlink" title="15.2.4 fputc(), fgetc()"></a>15.2.4 fputc(), fgetc()</h4><p><code>int fputc(int c, FILE *Stream);</code></p>
<p><code>int fgetc(FILE *Stream);</code></p>
<p>成功时都返回put&#x2F;get的字符，失败时都返回EOF</p>
<h4 id="15-2-5-fgets-fputs"><a href="#15-2-5-fgets-fputs" class="headerlink" title="15.2.5 fgets(), fputs()"></a>15.2.5 fgets(), fputs()</h4><p><code>int fputs(const char *s, FILE *Stream);</code></p>
<p>写入一个字符串到流中</p>
<p><code>char *fgets(char *s, int n, FILE *Strem)</code></p>
<p>从流中读取一行或指定个字符，注意是读取n-1个字符(还有一个默认的‘\0’)，除非读完一行。参数s是用来接收字符串，如果成功则返回s的指针，否则返回NULL。</p>
<p>注意fgets会读取回车, fputs不换行。</p>
<h4 id="15-2-6-fseek"><a href="#15-2-6-fseek" class="headerlink" title="15.2.6 fseek()"></a>15.2.6 fseek()</h4><p>fseek() 在流中定位到指定的字符</p>
<p>此函数一般用于二进制模式打开的文件中，功能是定位到流中指定的位置，原型是:</p>
<p><code>int fseek(FILE *stream, long offset, int whence);</code></p>
<p>如果成功返回0，参数offset是移动的字符数，whence是移动的基准，取值是：</p>
<p>符号常量 值 基准位置</p>
<ul>
<li><p><strong>SEEK_SET 0</strong> <strong>文件开头</strong></p>
</li>
<li><p><strong>SEEK_CUR 1</strong> <strong>当前读写的位置</strong></p>
</li>
<li><p><strong>SEEK_END 2</strong> <strong>文件尾部</strong></p>
</li>
</ul>
<p>例：fseek(fp,1234L,SEEK_CUR);&#x2F;&#x2F;把读写位置从当前位置向后移动1234字节(L后缀表示长整数)</p>
<p>fseek(fp,0L,2);&#x2F;&#x2F;把读写位置移动到文件尾</p>
<h4 id="15-2-7-fprintf-fscanf"><a href="#15-2-7-fprintf-fscanf" class="headerlink" title="15.2.7 fprintf(), fscanf()"></a>15.2.7 fprintf(), fscanf()</h4><p>fprintf按格式输入到流，其原型是:</p>
<p>&#96;&#96;&#96;int fprintf(FILE *stream, const char *format[, argument, …]);&#96;&#96;</p>
<p>其用法和printf()相同，不过不是写到控制台，而是写到流罢了。</p>
<p>例：fprintf(fp,”%d-%s”,4,”Hahaha”);</p>
<hr>
<p>fscanf从流中按格式读取，其原型是</p>
<p><code>int fscanf(FILE *stream, const char *format[, address, …]);</code></p>
<p>其用法和scanf()相同，不过不是从控制台读取，而是从流读取罢了。</p>
<p>例：fscanf(fp,”%d%d” ,&amp;x,&amp;y);</p>
<hr>
<p>如果想用scanf实现逐行读取，需要在fscanf中读取一个换行，否则第一次fscanf是正常读如，但第二次会读入一个换行，之后就全错了。</p>
<h4 id="15-2-8-rewind"><a href="#15-2-8-rewind" class="headerlink" title="15.2.8 rewind()"></a>15.2.8 rewind()</h4><p>把当前的读写位置回到文件开始，原型是:</p>
<p><code>void rewind(FILE *stream);</code></p>
<p>其实本函数相当于<code>fseek(fp,0L,SEEK_SET);</code></p>
<h4 id="15-2-9-remove"><a href="#15-2-9-remove" class="headerlink" title="15.2.9 remove()"></a>15.2.9 remove()</h4><p>删除文件，原型是</p>
<p><code>int remove(const char *filename);</code></p>
<p> 参数就是要删除的文件名，成功返回0。</p>
<h4 id="15-2-10-ferror"><a href="#15-2-10-ferror" class="headerlink" title="15.2.10 ferror()"></a>15.2.10 ferror()</h4><p><code>int ferror(FILE *stream);</code></p>
<p>返回流最近的<a target="_blank" rel="noopener" href="http://www.pcdog.com/special/1077/index.html">错误代码</a>，可用clearerr()来清除它，clearerr()的原型是:</p>
<p><code>void clearerr(FILE *stream);</code></p>
<h4 id="15-2-11-tmpname"><a href="#15-2-11-tmpname" class="headerlink" title="15.2.11 tmpname()"></a>15.2.11 tmpname()</h4><p><code>char *tmpname(char *s);</code></p>
<p> 生成一个唯一的文件名，其实tmpfile()就调用了此函数，参数s用来保存得到的文件名，并返回这个指针，如果失败，返回NULL。</p>
<h4 id="15-2-12-tmpfile"><a href="#15-2-12-tmpfile" class="headerlink" title="15.2.12 tmpfile()"></a>15.2.12 tmpfile()</h4><p><code>FILE *tmpfile(void);</code></p>
<p> 生成一个临时文件，以”w+b”的模式打开，并返回这个临时流的指针，如果失败返回NULL。在程序结束时，这个文件会被自动删除。</p>
<h4 id="15-2-13-fread-fwrite"><a href="#15-2-13-fread-fwrite" class="headerlink" title="15.2.13 fread(), fwrite()"></a>15.2.13 fread(), fwrite()</h4><p>fread()从流中读指定个数的字符，原型是</p>
<p><code>size_t fread(void *ptr, size_t size, size_t n, FILE *stream);</code></p>
<p>参数ptr是保存读取的数据，void*的指针可用任何类型的指针来替换，如char*、int *等等来替换;size是每块的字节数;n是读取的块数，如果成功，返回实际读取的块数(不是字节数)，本函数一般用于二进制模式打开的文件中。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以下是引用片段： </span><br><span class="line">char x[4230]; </span><br><span class="line">FILE *file1=fopen(&quot;file&quot;,&quot;r&quot;);  </span><br><span class="line">fread(x, 200, 12, file1);</span><br><span class="line">//共读取200*12=2400个字节 </span><br></pre></td></tr></table></figure>

<p>与fread对应，fwrite()向流中写指定的数据，原型是:</p>
<p><code>size_t fwrite(const void *ptr, size_t size, size_t n, FILE *stream);</code></p>
<p>参数ptr是要写入的数据指针，void<em>的指针可用任何类型的指针来替换，如char</em>、int *等等来替换;size是每块的字节数;n是要写的块数，如果成功，返回实际写入的块数(不是字节数)，本函数一般用于二进制模式打开的文件中。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">以下是引用片段： 　　</span><br><span class="line">char x[]=&quot;I Love You&quot;;  　　</span><br><span class="line">fwire(x, 6, 12, fp);//写入6*12=72字节  　　</span><br><span class="line">// 将把&quot;I Love&quot;写到流fp中12次，共72字节</span><br></pre></td></tr></table></figure>





<h3 id="15-2-I-x2F-O-文件操作"><a href="#15-2-I-x2F-O-文件操作" class="headerlink" title="15.2 I&#x2F;O 文件操作"></a>15.2 I&#x2F;O 文件操作</h3><p>参考博客吧！</p>
<p>暂时用不到！</p>
<hr>
<hr>
<h1 id="C陷阱与缺陷"><a href="#C陷阱与缺陷" class="headerlink" title="C陷阱与缺陷"></a>C陷阱与缺陷</h1><h2 id="第一章-词法陷阱"><a href="#第一章-词法陷阱" class="headerlink" title="第一章 词法陷阱"></a>第一章 词法陷阱</h2><h3 id="1-0-引子"><a href="#1-0-引子" class="headerlink" title="1.0 引子"></a>1.0 引子</h3><p>&#x3D;&#x3D;符号&#x3D;&#x3D; 指的是程序的一个基本组成单元，其作用相当于一个句子中的单词，但是同一个单词在不同的句子中意思是基本一样的，而符号可能完全不同。</p>
<p>编译器中负责将程序分解为一个一个符号的部分，一般称为&#x3D;&#x3D;“词法分析器”&#x3D;&#x3D;。</p>
<p>例如 <code>if （x &gt; big）big = x；</code>经过词法分析之后，可以写为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span></span><br><span class="line">(</span><br><span class="line">&gt;</span><br><span class="line">big</span><br><span class="line">)</span><br><span class="line">big</span><br><span class="line">=</span><br><span class="line">x</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-x3D-不同于-x3D-x3D"><a href="#1-1-x3D-不同于-x3D-x3D" class="headerlink" title="1.1 &#x3D;不同于&#x3D;&#x3D;"></a>1.1 &#x3D;不同于&#x3D;&#x3D;</h3><p>在C语言中，之所以使用&#x3D;作为赋值运算符，&#x3D;&#x3D;作为比较运算符，主要是因为赋值运算出现的更为频繁，因而字符较少的&#x3D;就被赋予了更常用的含义—赋值运算。</p>
<p>某些编译器在发现条件判断的条件判断表达式中出现类似于<code>e1 = e2</code> 的赋值语句时会给出警告。但当我们确实需要使用赋值语句时，不应该关闭警告选项，而是显示的进行比较。</p>
<p>例如表达式<code>if (x = y)</code></p>
<p>可以写为：<code>if ((x = y) != 0)</code></p>
<h3 id="1-2-amp-和-不同于-amp-amp-和"><a href="#1-2-amp-和-不同于-amp-amp-和" class="headerlink" title="1.2 &amp;和 | 不同于 &amp;&amp;和 ||"></a>1.2 &amp;和 | 不同于 &amp;&amp;和 ||</h3><h3 id="1-3-词法分析中的贪心法"><a href="#1-3-词法分析中的贪心法" class="headerlink" title="1.3 词法分析中的贪心法"></a>1.3 词法分析中的贪心法</h3><p>C语言划分符号的规则：每一个符号应该包含尽可能多的字符。</p>
<p>例如 <code>a---b;</code></p>
<p>将会被划分为<code>(a--) - b;</code>，而不是<code>a - (--b);</code></p>
<h3 id="1-4-整形常量"><a href="#1-4-整形常量" class="headerlink" title="1.4 整形常量"></a>1.4 整形常量</h3><p>&#x3D;&#x3D;八进制（octonary system）&#x3D;&#x3D;</p>
<p>如果一个整形常量第一个字符是数字0，或者以字符Q结尾，那么该常量将被视作八进制。</p>
<p>所以有时用O结尾，有时用Q结尾，原因：为避免把字母O误认作零，改由Q代替</p>
<p>&#x3D;&#x3D;十六进制（hexadecimal system）&#x3D;&#x3D;</p>
<p>0x开头，或者以字符H结尾。</p>
<p>&#x3D;&#x3D;二进制（binary system）&#x3D;&#x3D;</p>
<p>以字符B结尾。</p>
<p>&#x3D;&#x3D;十进制（decimal system）&#x3D;&#x3D;</p>
<p>开头不能是0，以 字符D结尾。</p>
<h3 id="1-5-字符和字符串"><a href="#1-5-字符和字符串" class="headerlink" title="1.5 字符和字符串"></a>1.5 字符和字符串</h3><p>C语言中的单引号和双引号的含义迥异。</p>
<p>用单引号引起的一个字符实际上代表一个<strong>整数</strong>，整数值对应于该字符在编译器采用的字符集中的序列值。因此，对于采用 ASCLL 字符集的编译器而言，’a’ 的含义与 97（十进制）严格一致。</p>
<p>用双引号引起的字符串，代表的却是一个指向无名数组起始字符的<strong>指针</strong>，该指针被双引号之间的字符以及一个额外的二进制为零的字符 ‘\0’ 初始化。</p>
<p>例如，下面的语句是等价的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等价于 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[] = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span> (str);</span><br></pre></td></tr></table></figure>



<h2 id="第二章-语法陷阱"><a href="#第二章-语法陷阱" class="headerlink" title="第二章 语法陷阱"></a>第二章 语法陷阱</h2><h3 id="2-1-理解函数声明"><a href="#2-1-理解函数声明" class="headerlink" title="2.1 理解函数声明"></a>2.1 理解函数声明</h3><p>任何 C 变量的声明都由两部分组成：类型以及一组类似表达式的声明符。</p>
<p><strong>一旦我们知道了如何声明一个给定类型的变量，那么该类型的类型转换符就很容易得到了：只需要把声明中的变量名和声明末尾的分号去掉，再将剩余的部分用一个括号整个“封装”起来即可。</strong></p>
<h3 id="2-2-优先级问题"><a href="#2-2-优先级问题" class="headerlink" title="2.2 优先级问题"></a>2.2 优先级问题</h3><p>C 语言运算符优先级表</p>
<p><img src="https://images2015.cnblogs.com/blog/550032/201609/550032-20160927115252031-1960111031.png" alt="img"></p>
<blockquote>
<p>单目运算符，赋值运算符，三目运算符自右向左结合。</p>
<p>任何一个逻辑运算符的优先级比任何一个关系运算符的优先级要低。</p>
<p>移位运算符的优先级比算术运算符要低，但是比关系运算符要高。</p>
<p>六个关系运算符的优先级并不相同。因此，如果我们要比较 a 和 b 的大小顺序是否和 c 和 d 的大小顺序一样，可以这样写：<code>a &lt; b == c &lt; d</code></p>
<p>任意两个逻辑运算符的具有不同的优先级，所有的按位运算符优先级（&amp; , | , ^）要比顺序运算符（&amp;&amp;， ||）的优先级高；每个与运算的优先级比或运算的优先级高，异或运算的优先级介于两者之间。</p>
<p>三目运算符的优先级最低，这样我们就可以在三目运算符的条件表达式中包含关系运算符的逻辑组合。例如：<code>tax_rate = income &gt; 4000 &amp;&amp; residency &lt; 5 ? 3.5 : 2.0;</code> 本例其实还说明赋值运算符的优先级低于条件运算符的优先级是有意义的。</p>
</blockquote>
<p>C++ 运算符优先级和结合性</p>
<table>
<thead>
<tr>
<th align="left">优先级</th>
<th>运算符</th>
<th>说明</th>
<th>结合性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td>::</td>
<td>范围解析</td>
<td>自左向右</td>
</tr>
<tr>
<td align="left">2</td>
<td>++  –</td>
<td>后缀自增&#x2F;后缀自减</td>
<td></td>
</tr>
<tr>
<td align="left">()</td>
<td>括号</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">[]</td>
<td>数组下标</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">.</td>
<td>成员选择（对象）</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">−&gt;</td>
<td>成员选择（指针）</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">3</td>
<td>++  –</td>
<td>前缀自增&#x2F;前缀自减</td>
<td>自右向左</td>
</tr>
<tr>
<td align="left">+  −</td>
<td>正&#x2F;负号</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">!  ~</td>
<td>逻辑非&#x2F;按位取反</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">(type)</td>
<td>强制类型转换</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">*</td>
<td>取指针指向的值</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">&amp;</td>
<td>某某的地址</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">sizeof</td>
<td>某某的大小</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">new, new[]</td>
<td>动态内存分配&#x2F;动态数组内存分配</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">delete, delete[]</td>
<td>动态内存释放&#x2F;动态数组内存释放</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">4</td>
<td>.*  -&gt;*</td>
<td>成员对象选择&#x2F;成员指针选择</td>
<td>自左向右</td>
</tr>
<tr>
<td align="left">5</td>
<td>*  &#x2F;  %</td>
<td>乘法&#x2F;除法&#x2F;取余</td>
<td></td>
</tr>
<tr>
<td align="left">6</td>
<td>+  −</td>
<td>加号&#x2F;减号</td>
<td></td>
</tr>
<tr>
<td align="left">7</td>
<td>&lt;&lt;  &gt;&gt;</td>
<td>位左移&#x2F;位右移</td>
<td></td>
</tr>
<tr>
<td align="left">8</td>
<td>&lt;  &lt;&#x3D;</td>
<td>小于&#x2F;小于等于</td>
<td></td>
</tr>
<tr>
<td align="left">&gt;  &gt;&#x3D;</td>
<td>大于&#x2F;大于等于</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">9</td>
<td>&#x3D;&#x3D;  !&#x3D;</td>
<td>等于&#x2F;不等于</td>
<td></td>
</tr>
<tr>
<td align="left">10</td>
<td>&amp;</td>
<td>按位与</td>
<td></td>
</tr>
<tr>
<td align="left">11</td>
<td>^</td>
<td>按位异或</td>
<td></td>
</tr>
<tr>
<td align="left">12</td>
<td>|</td>
<td>按位或</td>
<td></td>
</tr>
<tr>
<td align="left">13</td>
<td>&amp;&amp;</td>
<td>与运算</td>
<td></td>
</tr>
<tr>
<td align="left">14</td>
<td>||</td>
<td>或运算</td>
<td></td>
</tr>
<tr>
<td align="left">15</td>
<td>?:</td>
<td>三目运算符</td>
<td>自右向左</td>
</tr>
<tr>
<td align="left">16</td>
<td>&#x3D;</td>
<td>赋值</td>
<td></td>
</tr>
<tr>
<td align="left">+&#x3D;  −&#x3D;</td>
<td>相加后赋值&#x2F;相减后赋值</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">*&#x3D;  &#x2F;&#x3D;  %&#x3D;</td>
<td>相乘后赋值&#x2F;相除后赋值&#x2F;取余后赋值</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">&lt;&lt;&#x3D;  &gt;&gt;&#x3D;</td>
<td>位左移赋值&#x2F;位右移赋值</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">&amp;&#x3D;  ^&#x3D;  |&#x3D;</td>
<td>位与运算后赋值&#x2F;位异或运算后赋值&#x2F;位或运算后赋值</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">17</td>
<td>throw</td>
<td>抛出异常</td>
<td></td>
</tr>
<tr>
<td align="left">18</td>
<td>,</td>
<td>逗号</td>
<td>自左向右</td>
</tr>
</tbody></table>
<h3 id="2-3-注意作为语句结束标志的分号"><a href="#2-3-注意作为语句结束标志的分号" class="headerlink" title="2.3 注意作为语句结束标志的分号"></a>2.3 注意作为语句结束标志的分号</h3><p>例子1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">10</span>);</span><br><span class="line">    x = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>在 if 的后面，我们多加了一个分号，上述语句就相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>例子2：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">c = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>在 return 的后面，我们遗漏了分号，但是不会报错，上述语句就相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">return</span> a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-switch-语句"><a href="#2-4-switch-语句" class="headerlink" title="2.4 switch 语句"></a>2.4 switch 语句</h3><p><strong>由 switch 控制的流程在执行第一个 case 之后，会自然而然的顺序执行下去</strong>，C 语言的这种特性，既是它的优势所在，也是它的劣势。</p>
<p>因为程序员可能会遗漏 break 语句，而有时候，我们或许需要故意省略 break 语句来实现某种效果。</p>
<h3 id="2-5-函数调用"><a href="#2-5-函数调用" class="headerlink" title="2.5 函数调用"></a>2.5 函数调用</h3><p>与其他程序设计语言不同，C 语言要求：<strong>在函数调用时，即使函数不带参数，也应该包括参数列表。</strong></p>
<p>因此，如果 f 是一个函数，那么<code>f();</code>是一个函数调用语句，而<code>f</code>却是一个什么也不做的语句。更准确的说，它计算函数 f 的地址，却并不调用这个函数。</p>
<h3 id="2-6-悬挂-else-引发的额问题"><a href="#2-6-悬挂-else-引发的额问题" class="headerlink" title="2.6 悬挂 else 引发的额问题"></a>2.6 悬挂 else 引发的额问题</h3><p>C 语言有这样的规则：<strong>else 始终与同一括号内最近的未匹配的 if 结合。</strong></p>
<p>例如下面的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> (y == <span class="number">0</span>)	error();</span><br><span class="line"><span class="keyword">else</span> z = x + y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码，看起来像是：</span></span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">0</span>)	error();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    z = x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际上是：</span></span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">0</span>)	error();</span><br><span class="line">    <span class="keyword">else</span>		z = x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第三章-语义陷阱"><a href="#第三章-语义陷阱" class="headerlink" title="第三章 语义陷阱"></a>第三章 语义陷阱</h2><h3 id="3-1-指针与数组"><a href="#3-1-指针与数组" class="headerlink" title="3.1 指针与数组"></a>3.1 指针与数组</h3><p>C 语言中的数组值得注意的地方有以下两点：</p>
<ol>
<li>C 语言中只有一维数组，并且数组的大小必须在编译器就作为一个常数确定下来。所谓多维数组其实就是数组的元素可以是任意类型的对象，包括数组。</li>
<li>对于一个数组，我们能做的只有两件事：确定该数组的大小以及获得指向该数组下标为 0 的指针。有关数组的其他操作，哪怕他们乍看上去是以数组下标进行运算的，实际上都是通过指针进行的。换言之，任何一个数组下标运算都等同于一个对应的指针运算，因此我们完全可以根据指针行为定义数组下标的行为。</li>
</ol>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure>

<p>这种写法在 ANSI C 中是非法的，以为 <code>&amp;a</code> 是一个指向数组的指针，而 <code>p</code> 是一个指向整型变量的对象，它们的类型不匹配。</p>
<p>正确的写法应该是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = a;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>a</code> 就是 <code>a[0]</code> 的地址。</p>
<p><strong>除了 <code>a</code> 被用作运算符 <code>sizeof</code> 的参数这一情形，在其他所有情形中使用数组名 <code>a</code> 都代表指向数组 <code>a</code> 中下标为 <code>0</code>  的元素的指针</strong>。</p>
<p>另外，在上文中我们说过“有关数组的其他操作，哪怕他们乍看上去是以数组下标进行运算的，实际上都是通过指针进行的。”</p>
<p>例如 <code>a[i]</code> 表示取数组 <code>a</code> 下标为 <code>i</code> 的元素的值，它实际表示的是： <code>*(a + i)</code>，只不过这种写法非常常用，因此被简记为 <code>a[i]</code>。实际上，由于 <code>a + i</code> 和 <code>i + a</code> 一样，因此 <code>a[i]</code> 和 <code>i[a]</code> 具有相同的含义。(也许某些汇编程序员会觉得很熟悉–偏移量)</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">      &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> (*p)[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(p = a; p &lt; &amp;a[<span class="number">3</span>]; p ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> *j;</span><br><span class="line">        <span class="keyword">for</span>(j = *p; j &lt; &amp;(*p)[<span class="number">3</span>]; j ++ ) </span><br><span class="line">            cout &lt;&lt; *j &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*<em>对指针的 <em>(解引用) 可以理解为让指针指向某个地方。</em></em> </p>
<h3 id="3-2-非数组的指针"><a href="#3-2-非数组的指针" class="headerlink" title="3.2 非数组的指针"></a>3.2 非数组的指针</h3><p>在 C 语言中，<strong>字符串常量</strong>代表了一块包括字符串中所有字符以及一个空字符 <code>&#39;\0&#39;</code> 的内存区域的地址。</p>
<p>如果我们想要拼接两个字符串 s 和 t，正确的写法为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;Hello,&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *t = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *r;</span><br><span class="line">    r = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s) + <span class="built_in">strlen</span>(t) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!r) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;分配失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(r, s);</span><br><span class="line">    <span class="built_in">puts</span>(r);</span><br><span class="line">    <span class="built_in">strcat</span>(r, t);</span><br><span class="line">    <span class="built_in">puts</span>(r);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-作为参数的数组声明"><a href="#3-3-作为参数的数组声明" class="headerlink" title="3.3 作为参数的数组声明"></a>3.3 作为参数的数组声明</h3><p>在 C 语言中，我们无法将一个数组作为函数参数直接传递。如果我们将数组名作为参数，那么数组会立即被转换为指向该数组第一个元素的指针。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">    <span class="built_in">puts</span>(s);</span><br><span class="line">    <span class="built_in">puts</span>(&amp;s[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 传递一个数组名和传递数组第一个元素的地址是等价的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，将数组作为函数参数毫无意义。所以，C 语言会自动将作为参数的数组声明转换为对应的指针声明。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strlen</span><span class="params">(<span class="type">char</span> s[])</span> &#123;</span><br><span class="line">	<span class="comment">/* do something */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与下面的写法完全相同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strlen</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">	<span class="comment">/* do something */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-避免“举隅法”"><a href="#3-4-避免“举隅法”" class="headerlink" title="3.4 避免“举隅法”"></a>3.4 避免“举隅法”</h3><p><strong>举隅(yu2)法</strong>：举一端为例。意在使人由此一端而推知其他。意在以更宽泛的词语来代替含义相对较窄的词语，或者相反：例如，以整体代表部分，或者以部分代表整体。</p>
<p>C 语言中一个常见的陷阱：混淆指针与指针所指向的数据。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p, *q;</span><br><span class="line">p = <span class="string">&quot;xyz&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>尽管有时候我们不妨认为，上面的赋值语句使得 <code>p</code> 的值就是字符串 <code>&quot;xyz&quot;</code> ，然而实际情况并不是这样。实际上， <code>p</code> 的值是一个指向由 <code>&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;\0&#39;</code> 四个字符组成的数组的起始元素的指针。</p>
<p>因此，如果我们执行下面语句：</p>
<p><code>p = q;</code></p>
<figure class="highlight plaintext"><figcaption><span>和 ```q``` 现在是指向内存中同一个地址的指针。这个赋值语句并没有复制内存中的字符。需要记住的是，复制指针并不同时复制指针所指向的数据。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3.5 空指针并非空字符串</span><br><span class="line"></span><br><span class="line">在 C 语言中，编译器保证由 0 转换而来的指针并不等同与任何有效的指针。出于代码文档化的考虑，常数 0 这一个值常用一个符号来代替：</span><br><span class="line"></span><br><span class="line">```#define NULL 0```</span><br><span class="line"></span><br><span class="line">当常数 0 被转换为指针使用时，这个指针绝对不能被解除引用。换句话说，我们绝对不能企图用该指针所指向的内存中存储的内容。</span><br><span class="line"></span><br><span class="line">### 3.6 边界计算与不对称边界</span><br><span class="line"></span><br><span class="line">在所有常见的程序设计错误中，最难于察觉的一类是**“栏杆错误”**，也常被称为“差一错误”。典型的例子是：100 米长的围栏每隔 10 米 需要提跟支撑用的围栏，则总共需要多少根围栏？如果不假思索，最“显而易见”的答案是将 100 除以 10，得到的答案是 10，即需要 10 根栏杆。当然这个答案是错误的，正确答案是 11。</span><br><span class="line"></span><br><span class="line">也即，得出正确答案的最容易方式是这样考虑：要支撑 10 米长的围栏实际需要两根栏杆，两段各一根。这个问题的另一种考虑方式是：除了最右侧的一段围栏，其他每一段 10 米长的围栏都只在左侧有一根围栏；而例外的最右侧不仅左侧有一根围栏，右侧也有一根围栏。</span><br><span class="line"></span><br><span class="line">前面一段讨论了解决问题的两种方法，实际上提示了我们**避免“栏杆错误”的两个通用原则：**</span><br><span class="line"></span><br><span class="line">1.  首先考虑最简单情况下的特例，然后将得到的结果外推，这是原则一。</span><br><span class="line">2.  仔细计算边界，绝不掉以轻心，这是原则二。</span><br><span class="line"></span><br><span class="line">将上面总结的两个原则牢记于心之后，来看一个典型的例子：计算整数范围的边界。例如，假设整数 x 的边界条件为 x&gt;=16 且 x&lt;=27，那么此范围内 x 的可能取值个数有多少？</span><br><span class="line"></span><br><span class="line">根据原则一，我们考虑最简单情况下的特例：x&gt;=16 且 x&lt;=16，此时显然只有一个元素，也即上边界和下边界重合时，此范围内满足条件的整数只有一个。因此答案就是 27-16+1=12。</span><br><span class="line"></span><br><span class="line">然而有时稍不留意，我们会想当然的认为答案为：27-16=11个整数 ，那么是否存在一些编程技巧，可以降低这类错误发生的可能性呢？</span><br><span class="line"></span><br><span class="line">这个编程技巧不但存在，而且可以一言以蔽之：**用第一个入界点和第一个出界点来表示一个数值范围**。具体而言，对于上面的例子我们不应该说整数 x 的边界条件为 x&gt;=16 且 x&lt;=27，而应该说整数 x 的边界条件为 x&gt;=16 且 x&lt;28。注意，这里下界 16 是“入界点”，包含在取值范围之中；而上界是“出界点”，即不包含在取值范围之中，这种不对称或许从数学上而言并不优美，但是它对于程序设计的简化效果却令人吃惊。</span><br><span class="line"></span><br><span class="line">1. 取值范围的大小就是上界与下界之差。28-16的值恰好是12。</span><br><span class="line">2. 如果取值范围为空，那么上界等于下界。</span><br><span class="line">3. 即是取值范围为空，上界也永远不可能小于下界。</span><br><span class="line"></span><br><span class="line">对于像 C 语言这样数组下标从 0 开始的语言，不对称的边界给程序设计带来的便利要更加明显：这种数组的上界（即第一个“出界点”）恰好是数组元素的个数。</span><br><span class="line"></span><br><span class="line">另一种考虑不对称边界的方式是，把上界视作某序列中第一个被占用的元素，而把下界视作序列中第一个被释放的元素。当处理各种不同类型的缓冲区时，这种看待问题的方式特别有用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3.7 求值顺序</span><br><span class="line"></span><br><span class="line">C 语言中只有 4 个运算符（&amp;&amp;、||、 ?: 和 ,）存在规定的求值顺序。运算符 &amp;&amp; 和 || 先对左侧操作数求值，只在需要的时候才对右侧操作数求值。运算符 ?: 有三个操作数：在 a?b:c 中，操作数 a 首先被求值，根据 a 的值再去求操作数 b 或 c 的值。逗号运算符首先对左侧操作数求值，然后“丢弃”该值，再对右侧操作数求值。</span><br><span class="line"></span><br><span class="line">&gt; 注：分隔函数参数的逗号并非逗号运算符，例如，x 和 y 在函数 f(x, y) 中的求值顺序是未定义的，而在函数 g((x, y)) 中却是确定的先 x 后 y的顺序。  </span><br><span class="line">&gt;</span><br><span class="line">&gt; 在后一个例子中，函数 g 只有一个参数。这个参数的值是这样求得的：先对 x 求值，然后“丢弃” x 的值，接下来求 y 的值。因此最后的值永远是 y。</span><br><span class="line"></span><br><span class="line">C 语言中其它所有运算符对齐操作数求值的顺序是未定义的，特别是，赋值运算符并不保证任何求值顺序。另外，运算符 &amp;&amp; 和 || 对于保证检查操作按照正确的顺序执行至关重要，在语句``if(y != 0 &amp;&amp; x / y &gt; tolerate)`` 中，就必须保证 y 非 0 时才能执行 x/y 的操作。</span><br><span class="line"></span><br><span class="line">下面这种从数组 x 中复制前 n 个元素到数组 y 中的做法是不正确的，它对求值顺序做了太多假设：</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">i = 0;</span><br><span class="line">while(i &lt; n) &#123;</span><br><span class="line">    y[i] = x[i ++ ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们假设 <code>y[i] = x[i ++ ];</code> 执行的是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y[i] = x[i];</span><br><span class="line">i ++ ;</span><br></pre></td></tr></table></figure>

<p>但也有可能是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y[i + <span class="number">1</span>] = x[i];</span><br><span class="line">i ++ ;</span><br></pre></td></tr></table></figure>

<p>之所以会出现后面的情况是因为 <code>y[i]</code> 的地址将有可能在 <code>i</code> 自增之后被求值。而我们假设 <code>y[i]</code> 的地址在 <code>i</code> 自增之前被求值。</p>
<h3 id="3-8-操作符-amp-amp-、-和-！"><a href="#3-8-操作符-amp-amp-、-和-！" class="headerlink" title="3.8 操作符 &amp;&amp;、|| 和 ！"></a>3.8 操作符 &amp;&amp;、|| 和 ！</h3><p>不要把 &amp;&amp; 和 &amp; 混淆，以及 || 和 | 混淆。它们一类是逻辑运算符，一类是按位运算符。尽管有时候用错了可能也会得到理想的结果。</p>
<h3 id="3-9-整数溢出"><a href="#3-9-整数溢出" class="headerlink" title="3.9 整数溢出"></a>3.9 整数溢出</h3><p>C 语言中有两倍整数算术运算：有符号运算和无符号运算。在无符号算术运算中，没有所谓“溢出”一说：所有无符号数运算都以 2 的 n 次方为模，这里 n 是结果中的位数。</p>
<p>溢出的结果是未定义的，有时候会简单的利用符号来判断是否溢出，例如两个正数相加结果如果是负数那么肯定溢出，但是溢出不一定就是负数。</p>
<h3 id="3-10-为-main-函数提供返回值"><a href="#3-10-为-main-函数提供返回值" class="headerlink" title="3.10 为 main 函数提供返回值"></a>3.10 为 main 函数提供返回值</h3><p>对于一个函数而言，如果没有显式声明返回类型，那么函数返回类型就默认为整形。但是这个程序并没有给出任何返回值。</p>
<h2 id="第四章-链接"><a href="#第四章-链接" class="headerlink" title="第四章 链接"></a>第四章 链接</h2><h3 id="4-1-什么是链接器"><a href="#4-1-什么是链接器" class="headerlink" title="4.1 什么是链接器"></a>4.1 什么是链接器</h3><p>C 语言的一个重要思想就是分别编译，即若干个源程序可以在不同的时候单独进行编译，然后在恰当的时候整合到一起。</p>
<h2 id="第五章-库函数"><a href="#第五章-库函数" class="headerlink" title="第五章 库函数"></a>第五章 库函数</h2><h3 id="5-1-返回整数的-getchar-函数"><a href="#5-1-返回整数的-getchar-函数" class="headerlink" title="5.1 返回整数的 getchar 函数"></a>5.1 返回整数的 getchar 函数</h3><h2 id="第六章-预处理器"><a href="#第六章-预处理器" class="headerlink" title="第六章 预处理器"></a>第六章 预处理器</h2><h2 id="第七章-可移植性缺陷"><a href="#第七章-可移植性缺陷" class="headerlink" title="第七章 可移植性缺陷"></a>第七章 可移植性缺陷</h2><ul>
<li></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">Memory Management</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-15 20:20:57 / Modified: 20:22:41" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-Memory-Management"><a href="#C-Memory-Management" class="headerlink" title="C++ Memory Management"></a>C++ Memory Management</h1><h2 id="0x00-prelogue"><a href="#0x00-prelogue" class="headerlink" title="0x00 prelogue"></a>0x00 prelogue</h2><h3 id="1-source"><a href="#1-source" class="headerlink" title="1. source"></a>1. source</h3><p>候捷 C++ 内存管理课程 笔记</p>
<p><a target="_blank" rel="noopener" href="https://gee.cs.oswego.edu/">DL Malloc</a></p>
<p><a target="_blank" rel="noopener" href="https://gee.cs.oswego.edu/dl/html/malloc.html">A Memory Allocator</a></p>
<h3 id="2-english"><a href="#2-english" class="headerlink" title="2. english"></a>2. english</h3><p>macro：宏</p>
<h3 id="3-quote"><a href="#3-quote" class="headerlink" title="3. quote"></a>3. quote</h3><p>0x01 万丈高楼平地起</p>
<p>0x02 西北有高楼，上与浮云齐（为什么孔雀东南飞，因为西北有高楼）</p>
<h2 id="0x01-primitives"><a href="#0x01-primitives" class="headerlink" title="0x01 primitives"></a>0x01 primitives</h2><h3 id="1-分配内存的层级"><a href="#1-分配内存的层级" class="headerlink" title="1. 分配内存的层级"></a>1. 分配内存的层级</h3><p><img src="https://s3.bmp.ovh/imgs/2023/03/08/401ce1768fecfa41.png" alt="img"></p>
<p>malloc 并不是 c++ 的一部分，它属于更低阶的 c 中的 c-runtime-library 的一部分。</p>
<p>调用层次太低阶会导致移植性变差，所以最好不要在程序中使用底层调用函数。</p>
<h3 id="2-c-primitivies"><a href="#2-c-primitivies" class="headerlink" title="2.c++ primitivies"></a>2.c++ primitivies</h3><p><img src="https://s3.bmp.ovh/imgs/2023/03/08/b8ef04e0d7761b29.png" alt="c++"></p>
<p>测试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ::operator new</span></span><br><span class="line"><span class="type">void</span> *pp = ::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">// int *p = new(pp) int(4);</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; *p &lt;&lt; endl;</span></span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pp)</span></span>;  <span class="comment">// 必须加括号，因为是个函数</span></span><br><span class="line"><span class="comment">// allocator</span></span><br><span class="line"><span class="type">int</span> *pa = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )</span><br><span class="line">    *(pa + i) = i + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )</span><br><span class="line">    cout &lt;&lt; pa[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(pa, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-new-expression"><a href="#3-new-expression" class="headerlink" title="3. new expression"></a>3. new expression</h3><p>不能直接调用构造函数，非要调用的话，可以通过 <code>placement new</code> 来调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span>   <span class="comment">// not limits.h !! </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node_t</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">node_t</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">node_t</span>(<span class="type">int</span> _val, <span class="type">int</span> _len) : <span class="built_in">val</span>(_val), <span class="built_in">len</span>(_len) &#123;&#125;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// now, we want Node *pn = new Node(1,2);</span></span><br><span class="line">    <span class="comment">// compiler will conver this sentense in followings </span></span><br><span class="line"></span><br><span class="line">    Node *pn = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// like this way 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> V1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">void</span> *mem = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">        pn = <span class="built_in">static_cast</span>&lt;Node*&gt;(mem);</span><br><span class="line">        <span class="comment">// pn-&gt;Node::Node(1,2);    // 注意只有编译器能调用构造函数，因此本行编译不通过</span></span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(mem)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(std::bad_alloc &amp;c) &#123;  <span class="comment">// pass by ref</span></span><br><span class="line">        cout &lt;&lt; c.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">    <span class="comment">// like this way 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> V2</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cnt = numeric_limits&lt;<span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">        <span class="type">void</span> *mem = <span class="keyword">operator</span> <span class="built_in">new</span>(cnt * <span class="built_in">sizeof</span>(Node));</span><br><span class="line">        pn = <span class="built_in">new</span>(mem) <span class="built_in">Node</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        cout &lt;&lt; pn-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; pn-&gt;len &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(std::bad_alloc &amp;c) &#123;  <span class="comment">// pass by ref</span></span><br><span class="line">        cout &lt;&lt; c.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-delete-expression"><a href="#4-delete-expression" class="headerlink" title="4. delete expression"></a>4. delete expression</h3><p>可以直接调用析构函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node_t</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">node_t</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">node_t</span>(<span class="type">int</span> _val, <span class="type">int</span> _len) : <span class="built_in">val</span>(_val), <span class="built_in">len</span>(_len) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">node_t</span>() &#123; cout &lt;&lt; <span class="string">&quot;dtor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testMyType</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; newNode-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; newNode-&gt;len &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// now we want to delete newNode</span></span><br><span class="line">    <span class="comment">// delete newNode;</span></span><br><span class="line">    <span class="comment">// like this way in compile:</span></span><br><span class="line">    newNode-&gt;~<span class="built_in">Node</span>();     <span class="comment">// after dtor, newNode convert to a no-type pointer</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(newNode)</span></span>;   <span class="comment">// free memory</span></span><br><span class="line">    <span class="comment">// operator delete call free()</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// And you can found, we can call dtor directly</span></span><br><span class="line">    <span class="comment">// but we cant call ctor directly</span></span><br><span class="line">    <span class="comment">// And we not use newNode-&gt;Node::~Node(); to delete</span></span><br><span class="line">    <span class="comment">// but if we want to ctor(if we can do)</span></span><br><span class="line">    <span class="comment">// we must use like ptr-&gt;Node::Node(x,y); </span></span><br><span class="line">    <span class="comment">// because ptr is not a Node type object current</span></span><br><span class="line">    <span class="comment">// so Node() it not the member function for ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testBuiltInString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string *sptr = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello,world!&quot;</span>);</span><br><span class="line">    cout &lt;&lt; *sptr &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// sptr-&gt;~basic_string&lt;char&gt;();    </span></span><br><span class="line">    <span class="comment">// [Warning]</span></span><br><span class="line">    <span class="comment">// In old version, you cant write like followings</span></span><br><span class="line">    <span class="comment">// becuase string is a typedef of basic_string&lt;char&gt;</span></span><br><span class="line">    <span class="comment">// but now, it is valid....</span></span><br><span class="line">    sptr-&gt;~<span class="built_in">string</span>();</span><br><span class="line">    <span class="keyword">delete</span> sptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testMyType</span>();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">    <span class="built_in">testBuiltInString</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-array-new-x2F-delete"><a href="#5-array-new-x2F-delete" class="headerlink" title="5. array new&#x2F;delete"></a>5. array new&#x2F;delete</h3><p><code>array new</code> 在设计时，都会在分配的空间中添加一个 <code>cookie</code>用来保存一些额外信息，最重要的信息之一就是数组的长度。</p>
<p><code>array new</code> 和 <code>operator new</code> 需要配套使用的一个底层原因是，operator new 和 array new 分配出来的内存结构可能是不同的，例如，<code>array new</code> 分配出来的一块内存可能包含一个长度信息，而 <code>operator new</code> 则不需要。</p>
<p>另外，在析构函数没有意义（对象内没有动态分配的资源…）的情况下，可能可以使用 <code>operator delete</code> 来释放 <code>array new</code>，注意，是可能。因为 <code>operator delete</code> 会释放 <code>array new</code> 分配在堆上的所有内存，内存不会少释放，但是只会调用一次析构函数，因为析构函数没有意义（没有实际作用），所以说，调用一次与调用多次的效果都是一样的。当然，只是有可能，正如上面说的，他们的内存结构可能是不同的。</p>
<p>所以说，千万不要尝试通过 delete 释放 new[]，千万不要！</p>
<h3 id="6-placement-new"><a href="#6-placement-new" class="headerlink" title="6. placement new"></a>6. placement new</h3><p>Placement new 允许我们将 objects 构建与 allocated memory 中。</p>
<p>没有所谓的 placement delete，因为 placement new 根本就没有分配 memory。</p>
<p>当然，你可以称呼 placement new 对应的 operator delete 为 placement delete。因为我们需要为 placement new 重载一个对应的 operator delete。</p>
<p>同 operator new 一样，编译期在内部也会对 placement new 进行转换：</p>
<p>测试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node_t</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">node_t</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">node_t</span>(<span class="type">int</span> _val, <span class="type">int</span> _len) : <span class="built_in">val</span>(_val), <span class="built_in">len</span>(_len) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">node_t</span>() &#123; cout &lt;&lt; <span class="string">&quot;dtor:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testPlacementNew</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;hello,world!&quot;</span>;</span><br><span class="line">    <span class="type">void</span> *buf = ::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">strlen</span>(s) + <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span> *str = <span class="built_in">new</span>(buf) <span class="type">char</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buf)</span></span>; <span class="comment">// match operator new</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testPlacementNew2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">sizeof</span>(Node) * <span class="number">3</span>];</span><br><span class="line">    <span class="type">void</span> *nullp;</span><br><span class="line">    Node *p = <span class="built_in">new</span>(nullp) <span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">2</span>);    <span class="comment">// wrong!</span></span><br><span class="line">    cout &lt;&lt; p-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p-&gt;len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span>[] buf;   <span class="comment">// match array new</span></span><br><span class="line">    <span class="comment">/* --------  */</span></span><br><span class="line">    <span class="comment">/* placement new 语句就想当下面的四条语句，发现其实和operator new是一样的</span></span><br><span class="line"><span class="comment">       这是因为 placement new 其实就是调用的 operator new，是不是是其一个重载版本</span></span><br><span class="line"><span class="comment">       这个重载版本第二个参数接受一个指针，在这个指针分配的内存上构造对象</span></span><br><span class="line"><span class="comment">       因此说，我们要保证这个指针不为空或者未定义。。</span></span><br><span class="line"><span class="comment">    Node *p;</span></span><br><span class="line"><span class="comment">    void *mem = operator new(sizeof(Node), buf);</span></span><br><span class="line"><span class="comment">    p = static_cast&lt;Node*&gt;(mem);</span></span><br><span class="line"><span class="comment">    p-&gt;Node::Node(1, 2);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testPlacementNew</span>();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">    <span class="built_in">testPlacementNew2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-分配内存的途径（流程）"><a href="#7-分配内存的途径（流程）" class="headerlink" title="7. 分配内存的途径（流程）"></a>7. 分配内存的途径（流程）</h3><p><img src="https://s3.bmp.ovh/imgs/2023/03/08/e0d5986e17ce2219.png" alt="memory"></p>
<h3 id="8-重载"><a href="#8-重载" class="headerlink" title="8. 重载"></a>8. 重载</h3><p>我们可以重载 class member operator new()，并且重载多个版本，前提是每一个版本都有独特的参数列。重载 new() 必须其第一参数是 <strong>size_t</strong>，其余参数以 new 所指定的 <strong>placement arguments</strong> 作为初值。出现于 new(..) 小括号内的便是 <strong>placement arguements</strong>。此类形式都可以称为<strong>“placement new”</strong>。</p>
<p>例如：<code>Type *p = new(arg1, arg2, ... argn) Type;</code></p>
<p>其中的 <code>arg1, arg2, ... argn</code> 就是 placement arguments。</p>
<hr>
<p>我们可以重载 class member operator delete()，写出多个版本，但他们绝不会被 delete 调用。<strong>只有当 new 所调用的 ctor 抛出 exception 才会调用这些重载版的 oeprator delete()。</strong>它只可能这样被调用，主要用于清理未能称完全创建成功的 object 所占用的 memory。</p>
<p>即使 operator delete 未能一一对应与 operator new，也不会出现报错，你的意思是，放弃 ctor 抛出的任何异常，</p>
<h4 id="8-1-重载全局函数"><a href="#8-1-重载全局函数" class="headerlink" title="8.1 重载全局函数"></a>8.1 重载全局函数</h4><p>重载全局 operator new 和 全局 operator delete，注意重载全局 new 和 delete 是很危险的！</p>
<p>下面是某一版本的 operator new 和 operator delete 的实现：</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/03/08/a5000dbfa22f85f9.png" alt="deleteAndnew"></p>
<p>测试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node_t</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">node_t</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">node_t</span>(<span class="type">int</span> _val, <span class="type">int</span> _len) : <span class="built_in">val</span>(_val), <span class="built_in">len</span>(_len) &#123;&#125;</span><br><span class="line">    <span class="comment">// ~node_t() &#123; cout &lt;&lt; &quot;dtor:&quot; &lt;&lt; this &lt;&lt; endl; &#125;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">myAlloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFree</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator new&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">myAlloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator new[]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">myAlloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator delete with size&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">myFree</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator delete&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">myFree</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator delete[]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">myFree</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *ptr, <span class="type">size_t</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator delete[] with size&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">myFree</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 调用operator delete(void*, size_t)</span></span><br><span class="line">    <span class="comment">// 而不是 operator delete(void*)</span></span><br><span class="line">    <span class="comment">// 很疑惑。。</span></span><br><span class="line">    <span class="keyword">delete</span> p; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> *q = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]&#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">delete</span>[] q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 也是调用 operator delete with size_t</span></span><br><span class="line">    Node *fp = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span> fp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *fparr = <span class="keyword">new</span> Node[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] fparr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">    <span class="built_in">test2</span>();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">    <span class="built_in">test3</span>();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">    <span class="built_in">test4</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过测试之后发现，operator new 调用的是带有 size_t 参数的那个 operator delete，这是为什么呢？⚠️[TODO]</p>
<h4 id="8-2-重载-class-中的函数"><a href="#8-2-重载-class-中的函数" class="headerlink" title="8.2 重载 class 中的函数"></a>8.2 重载 class 中的函数</h4><p>这是更推荐的重载行为。注意在重载 class 中的 new 和 delete时，要将他们设置为 static，因为一般在调用 new 和 delete 时，对象还没有产生。</p>
<p>测试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">char</span> ch, <span class="type">size_t</span> extra)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;global operator new&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;char: &quot;</span> &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;extra: &quot;</span> &lt;&lt; extra &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size + extra);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _val = <span class="number">0</span>) : <span class="built_in">val</span>(_val) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Node</span>() &#123; cout &lt;&lt; <span class="string">&quot;dtor: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator new(size_t): &quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator new(size_t, char): &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;char: &quot;</span> &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator new[]: &quot;</span> &lt;&lt; size &lt;&lt; endl;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此 operator new 没有对应的 operator delete</span></span><br><span class="line">    <span class="comment">// 并且它回调了全局的 operator new</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">size_t</span> extra)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size, <span class="string">&#x27;A&#x27;</span>, extra);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator delete&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator delee with size_t: &quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator delete with char&quot;</span> &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;char: &quot;</span> &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator delete[]&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p = <span class="keyword">new</span> Node;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Node的大小是4，但是array new分配出来是12</span></span><br><span class="line">    <span class="comment">// 也就是说，多分配了8个字节</span></span><br><span class="line">    <span class="comment">// 因此，sizeof(p) = 8 + 4 * sizeof(Node)</span></span><br><span class="line">    Node *p = <span class="keyword">new</span> Node[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p = <span class="built_in">new</span>(<span class="string">&#x27;A&#x27;</span>) Node;</span><br><span class="line">    <span class="keyword">delete</span> p;   <span class="comment">// 不会调用带 char 的operator delete</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> extra = <span class="number">2</span>;</span><br><span class="line">    Node *p = <span class="built_in">new</span>(<span class="number">2</span> * <span class="built_in">sizeof</span>(Node)) Node;</span><br><span class="line">    <span class="comment">// p一共分配了3个Node的空间，但即使我们使用了多余三个，可能结果也是正确的</span></span><br><span class="line">    <span class="comment">// 注意！内存越界问题是未定义行为，什么叫未定义行为？</span></span><br><span class="line">    <span class="comment">// 你测试起来是正确的，别人测试起来是正确的，但在最重要的客户手中却失败了！</span></span><br><span class="line">    </span><br><span class="line">    extra = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; extra; i ++ ) (*(p + i)).val = i + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; extra; i ++ ) cout &lt;&lt; p[i].val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// test1();</span></span><br><span class="line">    <span class="comment">// puts(&quot;------------------------------&quot;);</span></span><br><span class="line">    <span class="comment">// test2();</span></span><br><span class="line">    <span class="comment">// puts(&quot;------------------------------&quot;);</span></span><br><span class="line">    <span class="comment">// test3();</span></span><br><span class="line">    <span class="comment">// puts(&quot;------------------------------&quot;);</span></span><br><span class="line">    <span class="built_in">test4</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-allocator"><a href="#9-allocator" class="headerlink" title="9. allocator"></a>9. allocator</h3><h4 id="9-1-allocator-1-0"><a href="#9-1-allocator-1-0" class="headerlink" title="9.1 allocator 1.0"></a>9.1 allocator 1.0</h4><p><strong>shortcoming:</strong></p>
<ol>
<li><p>复用性差：operator new&#x2F;delete 的重载放在了 class 实现中，如果我们想在另一个类中添加分配器，就需要再写一次</p>
</li>
<li><p>额外空间大：原本我们希望通过内存池设计，减少cookie的内存，但是我们却在class中添加了一个指针，原本只有一个 int 占 4 字节。现在添加了一个指针变成了 16 字节，足足扩大了 4 倍，当然，在我们的 class 原本体积就很大时，例如 100 字节，那么 8 字节的指针大小其实是可以忽略的。但是我们应该有更好的办法解决 next 指针的问题。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> _val = <span class="number">1024</span>) : <span class="built_in">val</span>(_val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> _val, Foo *_next) : <span class="built_in">val</span>(_val), <span class="built_in">next</span>(_next) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">grabage_collection</span><span class="params">()</span></span>;    <span class="comment">// 清理空闲链表</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> Foo* freeStore;               <span class="comment">// 空闲链表</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> FooChunk = <span class="number">24</span>;      <span class="comment">// 每次分配多少个Foo</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">allocate_new_memory</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TEST</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Foo *next;  <span class="comment">// 串连空闲链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义static成员时，不需要再加上static</span></span><br><span class="line">Foo* Foo::freeStore = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Foo::allocate_new_memory</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(freeStore)   <span class="keyword">return</span> ;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TEST</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Call allocate_new_memory!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">    <span class="type">size_t</span> chunk = FooChunk * size; </span><br><span class="line">    Foo *p = <span class="literal">nullptr</span>;</span><br><span class="line">    p = freeStore = (Foo*)<span class="built_in">malloc</span>(chunk);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TEST</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span>(p = freeStore; p != &amp;freeStore[FooChunk - <span class="number">1</span>]; ++ p)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TEST</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; ++ count &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="string">&quot; p: &quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;; p + 1: &quot;</span> &lt;&lt; p + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">        p-&gt;next = p + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Foo::grabage_collection</span><span class="params">()</span> <span class="comment">// cant run！</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(freeStore == <span class="literal">nullptr</span>)    <span class="keyword">return</span> ;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;can free&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">void</span> *ptr = (<span class="type">void</span>*)freeStore;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span>* Foo::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo *p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(freeStore == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="built_in">allocate_new_memory</span>(size);</span><br><span class="line">    p = freeStore;</span><br><span class="line">    freeStore = freeStore-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> Foo::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;Foo*&gt;(p)-&gt;next = freeStore;</span><br><span class="line">    freeStore = <span class="built_in">static_cast</span>&lt;Foo*&gt;(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Foo) &lt;&lt; endl;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> n = <span class="number">1024</span>;</span><br><span class="line">    Foo *p[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = <span class="keyword">new</span> <span class="built_in">Foo</span>(i + <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] now addr: &quot;</span> &lt;&lt; p[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> p[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Foo *tra = Foo::freeStore;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tra != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; ++count &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; tra-&gt;val &lt;&lt; endl;</span><br><span class="line">        tra = tra-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo *p[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = ::<span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">        cout &lt;&lt; p[i] &lt;&lt; endl;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test1</span>();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Test end ...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-allocator-2-0"><a href="#9-2-allocator-2-0" class="headerlink" title="9.2 allocator 2.0"></a>9.2 allocator 2.0</h4><p>在上一个版本中，我们提到了，我们在 class 当中，我们添加了一个成员变量 <code>*next*</code>，这是必要的，因为我们需要将那些放在空闲链表中的内存块串成一个链表。但是，当我们使用某个内存块之后，它的 <code>next</code> 指针就没有用了，因为此时它已经不存在与空闲链表中，所以说，我们可以通过 <code>union</code>，将我们的数据 <code>val</code> 和 <code>*next*</code> 放到同一个地址空间，这样就可以解决 <code>*next*</code> 带来的额外内存消耗。</p>
<p>一般的，我们称这种设计中的 <code>*next*</code> 指针为： <strong>embeded pointer（嵌入式指针）</strong></p>
<p>Code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span>)</span></span>;</span><br><span class="line">    <span class="type">static</span> Foo* freeStore;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> chunkSize = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> _val = <span class="number">0</span>) : <span class="built_in">val</span>(_val) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">allocateNewMemory</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TEST</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 节省内存</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        Foo *next;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo *Foo::freeStore = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Foo::allocateNewMemory</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> chunk = chunkSize * size;</span><br><span class="line">    <span class="comment">// 不要直接在函数中 new/malloc</span></span><br><span class="line">    <span class="type">void</span> *mem = <span class="built_in">malloc</span>(chunk);</span><br><span class="line">    <span class="built_in">assert</span>(mem);</span><br><span class="line">    Foo *p = <span class="literal">nullptr</span>;</span><br><span class="line">    p = freeStore = <span class="built_in">static_cast</span>&lt;Foo*&gt;(mem);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; chunkSize - <span class="number">1</span>; i ++ )</span><br><span class="line">        p[i].next = p + (i + <span class="number">1</span>);</span><br><span class="line">    p[chunkSize - <span class="number">1</span>].next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> *Foo::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 内存分配有误，交给全局 operator new 处理</span></span><br><span class="line">    <span class="keyword">if</span>(size != <span class="built_in">sizeof</span>(Foo))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;size[&quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;] not match&quot;</span> &lt;&lt; endl; </span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    Foo *p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(freeStore == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="built_in">allocateNewMemory</span>(size);</span><br><span class="line">    <span class="built_in">assert</span>(freeStore);</span><br><span class="line">    p = freeStore;</span><br><span class="line">    freeStore = freeStore-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> Foo::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 可以删除nullptr</span></span><br><span class="line">    <span class="keyword">if</span>(ptr == <span class="literal">nullptr</span>)  <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(size != <span class="built_in">sizeof</span>(Foo))</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">delete</span>(ptr);</span><br><span class="line">    <span class="comment">// 删除只是重新添加到空闲链表</span></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;Foo*&gt;(ptr)-&gt;next = freeStore;</span><br><span class="line">    freeStore = <span class="built_in">static_cast</span>&lt;Foo*&gt;(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo::~<span class="built_in">Foo</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> dtorCount = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; dtorCount &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; <span class="string">&quot;dtor: &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> n = <span class="number">32</span>;</span><br><span class="line">    Foo* f[n];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="keyword">new</span> <span class="built_in">Foo</span>(i + <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 间隔只有8，而不是16了！</span></span><br><span class="line">        <span class="comment">// 另外，不同的内存大块之间是不连续的</span></span><br><span class="line">        <span class="comment">// 我们每次只分配24个内存小块</span></span><br><span class="line">        <span class="comment">// 所以说每24个小块之间可能不连续</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Ctor[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; f[i] &lt;&lt; <span class="string">&quot;, val= &quot;</span> &lt;&lt; f[i]-&gt;<span class="built_in">get</span>() &lt;&lt;  endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="built_in">delete</span>(f[i]);</span><br><span class="line">    <span class="type">int</span> freeCount = <span class="number">0</span>;</span><br><span class="line">    Foo *p = Foo::freeStore;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Del[&quot;</span> &lt;&lt; ++freeCount &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;, val= &quot;</span> &lt;&lt; p-&gt;<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(freeCount &gt;= <span class="number">32</span>)  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Test end....&quot;</span>);</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-3-allocator-3-0"><a href="#9-3-allocator-3-0" class="headerlink" title="9.3 allocator 3.0"></a>9.3 allocator 3.0</h4><p>在 2.0 版本中，我们解决了 <code>*next*</code> 指针的额外内存消耗问题，但是还有一个问题我们还没有解决，那就是复用性差的问题，对于每一个 class，如果想要使用我们的分配器，就要重载一遍 operator new&#x2F;delete，这不仅会导致代码的大量重复，导致代码膨胀，维护难等问题，还完全不符合面向对象的设计思想，我们是在 OOP 中写程序！</p>
<p>解决方案也很简单，就是将 operator new&#x2F;delete 的重载部分拿出来，单独放在一个 class allocator 当中，然后让需要使用的 class 包含 allocator，然后调用接口即可！</p>
<p>taik is cheap，show me your code：</p>
<blockquote>
<p>在 <code>void* MyAllocator::allocate(size_t size)</code> 中我应该是写出了一个比较经典的 bug 了。😅😅😅😅</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAllocator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">obj</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">obj</span> *next; <span class="comment">// embeded pointer(嵌入式指针)</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TEST</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">    obj* freeStore = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> CHUNK = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Foo() = default;</span></span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> _cnt = <span class="number">1024</span>, <span class="type">double</span> _price = <span class="number">10.25</span>) </span><br><span class="line">    : <span class="built_in">count</span>(_cnt), <span class="built_in">price</span>(_price) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123; cout &lt;&lt; <span class="string">&quot;[Dtor] &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getPrice</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> price; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> MyAllocator myAlloc;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">if</span>(size != <span class="built_in">sizeof</span>(Foo))</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;alloc error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myAlloc.<span class="built_in">allocate</span>(size);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size != <span class="built_in">sizeof</span>(Foo))</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;delete error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">delete</span>(ptr, size);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myAlloc.<span class="built_in">deallocate</span>(ptr, size); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TEST</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyAllocator Foo::myAlloc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">MyAllocator::allocate</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj *p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(freeStore == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;call new memory!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">size_t</span> chunk = CHUNK * size;</span><br><span class="line">        <span class="type">void</span> *mem = <span class="built_in">malloc</span>(chunk);</span><br><span class="line">        <span class="built_in">assert</span>(mem);</span><br><span class="line">        p = freeStore = <span class="built_in">static_cast</span>&lt;obj*&gt;(mem);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; CHUNK - <span class="number">1</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// [WARNNING] [BUG]</span></span><br><span class="line">            <span class="comment">// 注意不可能写为下面的形式</span></span><br><span class="line">            <span class="comment">// p[i].next = &amp;p[i + 1];</span></span><br><span class="line">            <span class="comment">// 因为p虽然是一个obj对象，但是我们要把它当做一个Foo对象</span></span><br><span class="line">            <span class="comment">// 所以我们要移动的距离是sizeof(Foo)</span></span><br><span class="line">            <span class="comment">// 但是在上面的形式中，我们移动的距离是sizeof(obj)</span></span><br><span class="line">            p-&gt;next = (obj*)((<span class="type">char</span>*)p + size);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p = freeStore;</span><br><span class="line">    freeStore = freeStore-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyAllocator::deallocate</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;obj*&gt;(ptr)-&gt;next = freeStore;</span><br><span class="line">    freeStore = <span class="built_in">static_cast</span>&lt;obj*&gt;(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;SIZE: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Foo) &lt;&lt; endl;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> N = <span class="number">16</span>;</span><br><span class="line">    Foo *f[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// f[i] = new Foo(Foo(i, i * 1.1)); </span></span><br><span class="line">        f[i] = <span class="keyword">new</span> Foo;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Ctor[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; f[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]-&gt;count = (i + <span class="number">1</span>);</span><br><span class="line">        f[i]-&gt;price = (i + <span class="number">1</span>) * <span class="number">1.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; f[i]-&gt;<span class="built_in">getCount</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; f[i]-&gt;<span class="built_in">getPrice</span>() &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">        <span class="keyword">delete</span> f[i];</span><br><span class="line">    <span class="keyword">auto</span> p = Foo::myAlloc.freeStore;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; counter &lt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;cur: &quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        counter ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Foo *f = new Foo(i, i + 10);</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;addr: &quot; &lt;&lt; f &lt;&lt; &#x27; &#x27; &lt;&lt; f-&gt;getCount() &lt;&lt; &#x27; &#x27; &lt;&lt; f-&gt;getPrice() &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// delete f;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Foo *f = new Foo(1, 1024);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;addr: &quot; &lt;&lt; f &lt;&lt; &#x27; &#x27; &lt;&lt; f-&gt;getCount() &lt;&lt; &#x27; &#x27; &lt;&lt; f-&gt;getPrice() &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">test2</span>();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Test end......&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-4-allocator-4-0"><a href="#9-4-allocator-4-0" class="headerlink" title="9.4 allocator 4.0"></a>9.4 allocator 4.0</h4><p>虽然是 4.0，但是它并没有什么更高级的设计，只不过是将 3.0 中的 class 封装设计改为 macro(宏) 设计。</p>
<p>不建议使用 macro，代码不给出了。</p>
<h3 id="10-new-handler"><a href="#10-new-handler" class="headerlink" title="10. new handler"></a>10. new handler</h3><p>new handler 提供给你一个机会阻止可能发生的异常(bad_alloc)，因为如果异常产生，程序可能会直接terminate，new handler 就是 c++平台给你提供的补救措施。</p>
<p>在 《Effective C++》提到过，new_handler 做5件事，但真正有用的可能就两件：</p>
<ol>
<li>分配更多的内存</li>
<li>调用 exit() 和 abort()</li>
</ol>
<p><img src="https://s3.bmp.ovh/imgs/2023/03/09/6542ab298879ce75.png" alt="IMG"></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/03/09/6673d1b83363c6dc.png" alt="IMG"></p>
<h3 id="11-x3D-default-x3D-delete"><a href="#11-x3D-default-x3D-delete" class="headerlink" title="11. &#x3D;default,&#x3D;delete"></a>11. &#x3D;default,&#x3D;delete</h3><blockquote>
<p> It is not only for constructors and assignments,  but also applies to operator new&#x2F;new[], operator delete&#x2F;delete[] and their overloads(for &#x3D;delete)</p>
</blockquote>
<h2 id="0x02-std-allocator"><a href="#0x02-std-allocator" class="headerlink" title="0x02 std::allocator"></a>0x02 std::allocator</h2><p>chunk：大块</p>
<p>block：小块</p>
<p><code>G2.9</code> 的 std::alloc 并没有“释放”内存，他只是把分配的内存重心放入内存池，严格来说，这不算是内存泄漏，因为内存仍然在自己手上，只不过没有释放罢了。之所以不真正 free，是因为难度较大。这也是 alloc 的一个争议点，因为在多用户，多任务系统中，你独占如此大的memory却不释放，肯定不好。</p>
<p>战备池 Pool：</p>
<ol>
<li>如果战备池为空，分配新内存</li>
<li>能分配几个就分配几个<ul>
<li>一个都不能分配，处理碎片，分配新内存</li>
<li>分配战备池</li>
</ul>
</li>
</ol>
<p>判断指针 p 是否为 null，看以下两种写法：</p>
<ol>
<li><code>if(0 == p) &#123;&#125;</code></li>
<li><code>if(p == 0) &#123;&#125;</code></li>
</ol>
<p>我们通常都是第二种写法，但是第一种写法更好，因为如果我们不小心将 <code>==</code> 写成了 <code>=</code>，编译器会报错，而在第二种写法中，编译会顺利通过，并带来灾难性的后果且不以排查。</p>
<p>但是在现代 c++ 中，我们有 nullptr，不需要担心了。😊</p>
<p>侯捷老师说在第四章会有解决方案，这个“内存泄漏”问题终于解决了！</p>
<hr>
<p>operator delete(ptr)</p>
<p>operator delete(ptr, size_t)</p>
<p>在 class 中可不可以并存吗？并存会报错？</p>
<hr>
<p>round(x,n) &#x3D; (x+(n-1)) &amp; ~(n-1)</p>
<hr>
<p>malloc 把 VA 分为 32 个 group，每个 group 又分为 8 个page</p>
<p>所以最多有 32*8&#x3D;256 个 page</p>
<p>而在 tagRegion 中，有 32 个 tagGroup</p>
<p>每个 TagGroup 有 64 个双向链表，总共 2048 个双向链表</p>
<hr>
<p>4080 &#x3D; 4096 - 8(黄色的两个0xffffffff) - 8(保留&#x2F;浪费，因为需要16对齐)</p>
<p>4096 - 8 &#x3D; 4088 not 16 的倍数，因此需要对齐减去 8</p>
<p>16，32，48, 。。。。&gt;&#x3D;1024 (16 aligned)</p>
<p>Cookie 保存长度信息，这个长度信息包含cookie本身</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; ls;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> c;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node_t</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> va;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum += size;</span><br><span class="line">    c ++ ;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt; 3; i ++ )  ls.push_back(1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; sum &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; pow(2,18) &lt;&lt; endl;</span></span><br><span class="line">    Node *newNode = <span class="keyword">new</span> Node;   <span class="comment">// 16</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="number">68</span> + <span class="number">256</span> + <span class="number">32</span> * <span class="number">516</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="number">16</span> * <span class="number">1024</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="number">32</span> * <span class="number">64</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="number">0x130</span> + <span class="number">8</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">void</span> *test = <span class="built_in">sbrk</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;start heap brk: &quot;</span> &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">    test = <span class="built_in">sbrk</span>(<span class="number">0x20ff8000</span>);    <span class="comment">// 0x9a0000</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after sbrk() brk: &quot;</span> &lt;&lt; test &lt;&lt; endl;   <span class="comment">// 0x9a0000</span></span><br><span class="line">    <span class="type">void</span> *p = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="number">0x20ff8000</span>));</span><br><span class="line">    test = <span class="built_in">sbrk</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after use, brk: &quot;</span> &lt;&lt; test &lt;&lt; endl;<span class="comment">// 0x21998000</span></span><br><span class="line">    cout &lt;&lt; hex &lt;&lt;  <span class="number">0x20ff8000</span> + <span class="number">0x9a0000</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    即使移动了brk位置，在实际使用之前，Linux也不会给进程分配内存的。</span></span><br><span class="line"><span class="comment">    必须要等到实际写内存的时候，产生了缺页中断后，Linux系统才会申请一个物理内存页给进程。内核申请物理内存页的函数是get_free_pages()。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>通过 header -&gt; group -&gt; free-list  来切分，使得每一块内存都比较小，因此全部回收的可能性就更大</p>
<p>如果每一块内存都是 1MB，那么它的回收就很困难</p>
<p>例如即使 1MB 中有 1023KB 没有使用，我们也不能回收它。</p>
<hr>
<p>group头部的size就可以很方便的告诉我们，是否可以全回收。</p>
<p>每个page内的内存块的合并是积极的。</p>
<p>page全回收之后不会立即释放，当等到再有一个page全回收时，才会释放。</p>
<h2 id="0x03-malloc-x2F-free"><a href="#0x03-malloc-x2F-free" class="headerlink" title="0x03 malloc&#x2F;free"></a>0x03 malloc&#x2F;free</h2><h2 id="0x04-loki-allocator"><a href="#0x04-loki-allocator" class="headerlink" title="0x04 loki::allocator"></a>0x04 loki::allocator</h2><h3 id="1-Loki-SourceCode"><a href="#1-Loki-SourceCode" class="headerlink" title="1. Loki SourceCode"></a>1. Loki SourceCode</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://loki-lib.sourceforge.net/html/a00671.html">New Version Source Code</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/UnGeek/p/4537114.html">别人做的分析</a></p>
</blockquote>
<h3 id="2-旧版本的两个-bug"><a href="#2-旧版本的两个-bug" class="headerlink" title="2. 旧版本的两个 bug"></a>2. 旧版本的两个 bug</h3><h4 id="（1）-无限循环"><a href="#（1）-无限循环" class="headerlink" title="（1） 无限循环"></a>（1） 无限循环</h4><p>在旧版本的 <code>VicinityFind</code> 函数中，如果我们传入的 <code>p</code> 不是经由 <code>chunk</code> 分配的话，那么在 <code>for</code> 中会无限循环。这是因为当 <code>lo</code> 和 <code>hi</code> 都为 <code>false</code> 时，没有判断条件来使得 <code>for</code> 退出。</p>
<p>这是更正版的代码，在我们标识出的 <code>(1)</code> 和 <code>(2)</code> 处，添加了判断，这样当 <code>lo</code> 和 <code>hi</code> 都为 <code>false</code> 时，循环就会退出并返回 <code>NULL</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Chunk * <span class="title">FixedAllocator::VicinityFind</span><span class="params">( <span class="type">void</span> * p )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( chunks_.<span class="built_in">empty</span>() ) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">const</span> std::<span class="type">size_t</span> chunkLength = numBlocks_ * blockSize_;</span><br><span class="line">    Chunk * lo = deallocChunk_;</span><br><span class="line">    Chunk * hi = deallocChunk_ + <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> Chunk * loBound = &amp;chunks_.<span class="built_in">front</span>();</span><br><span class="line">    <span class="type">const</span> Chunk * hiBound = &amp;chunks_.<span class="built_in">back</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Special case: deallocChunk_ is the last in the array</span></span><br><span class="line">    <span class="keyword">if</span> (hi == hiBound) hi = <span class="literal">NULL</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( lo-&gt;<span class="built_in">HasBlock</span>( p, chunkLength ) ) <span class="keyword">return</span> lo;</span><br><span class="line">            <span class="keyword">if</span> ( lo == loBound )</span><br><span class="line">            &#123;</span><br><span class="line">                lo = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">if</span> ( <span class="literal">NULL</span> == hi ) <span class="keyword">break</span>;	<span class="comment">// （1）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> --lo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( hi-&gt;<span class="built_in">HasBlock</span>( p, chunkLength ) ) <span class="keyword">return</span> hi;</span><br><span class="line">            <span class="keyword">if</span> ( ++hi == hiBound )</span><br><span class="line">            &#123;</span><br><span class="line">                hi = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">if</span> ( <span class="literal">NULL</span> == lo ) <span class="keyword">break</span>;	<span class="comment">// （2）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（2）-chunk-不会回收-TODO"><a href="#（2）-chunk-不会回收-TODO" class="headerlink" title="（2） chunk 不会回收 [TODO]"></a>（2） chunk 不会回收 [TODO]</h4><p>看下面回收操作的代码：</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/03/21/dbe229b367a5733b.png" alt="img"></p>
<p>其中，绿色框框出的代码块就是处错的代码，而红色框框出的代码块是导致绿色代码块处错的根源。</p>
<p>先看红色的代码块：意思是，我们释放了一块内存之后发现它所在 <code>chunk</code> 为空，并且这个 <code>chunk</code> 不是最后一个 <code>chunk</code>，如果此时最后一个 <code>chunk</code> 非空的话，说明有两个空 <code>chunk</code>，所以我们需要删除一个，由于 <code>vector</code> 从中间删除效率很低，所以我们肯定删除最后一个 <code>chunk</code> 了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| A | F1 | A | A1 | F2 |</span><br><span class="line">    --&gt;</span><br><span class="line">| A | F1 | A | A1 |，释放 A1</span><br><span class="line">    --&gt;</span><br><span class="line">| A | F1 | A | F |，A1 变为 F</span><br></pre></td></tr></table></figure>

<p>如上图所示，我们当前的空 <code>chunk</code> 为 <code>F1</code>（F 表示 Free，A 表示Allocate），之前的空 <code>chunk</code> 是 <code>F2</code>，然后我们删除了 <code>F2</code>。</p>
<p>好，假设我们现在不停的释放 <code>chunk A1</code>，直到它为空。</p>
<p>此时，<code>vector&lt;chunk&gt;</code> 中显然有两个 <code>Free chunk</code>（F 和 F1），但是我们的 <code>DoDeallocate</code> 函数无法清除其中一个 <code>Chunk</code>。</p>
<p>因为此时，&#96;&#96;F1<code>虽然</code>Free<code>，但它没有位于 </code>vector&#96; 的尾部。</p>
<p>而我们的回收操作，是基于一个假设的：</p>
<blockquote>
<p>Free Chunk 一定在 vector 的尾部。</p>
</blockquote>
<p>此时，假设不成立！</p>
<p>所以说，我们不能依赖于该假设，而是要显示的用一个变量来指示，之前 Free 但没有回收的 Chunk在哪里，这就是改正 BUG 之后的新版本的做法。</p>
<h2 id="0x05-other-allocator"><a href="#0x05-other-allocator" class="headerlink" title="0x05 other::allocator"></a>0x05 other::allocator</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">DataBase kernel learn</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-15 20:20:57 / Modified: 20:23:14" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DB/" itemprop="url" rel="index"><span itemprop="name">DB</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="必备"><a href="#必备" class="headerlink" title="必备"></a>必备</h2><ul>
<li>C&#x2F;C++&#x2F;Java&#x2F;Go&#x2F;Rust</li>
<li>数据库原理</li>
<li>操作系统</li>
<li>算法与数据结构</li>
<li>分布式原理</li>
<li>编译原理</li>
<li>网络编程</li>
<li>数据库架构原理</li>
<li>工程化能力</li>
</ul>
<h2 id="OLAP"><a href="#OLAP" class="headerlink" title="OLAP"></a>OLAP</h2><ul>
<li>ClickHouse</li>
<li>Doris</li>
</ul>
<h2 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h2><ul>
<li>TiDB</li>
<li>OceanBase</li>
<li>CockRoachDB</li>
</ul>
<h2 id="云原生数据库"><a href="#云原生数据库" class="headerlink" title="云原生数据库"></a>云原生数据库</h2><ul>
<li>Aurora</li>
<li>Snowflake</li>
<li>PolarDB</li>
</ul>
<h3 id="云原生的特点"><a href="#云原生的特点" class="headerlink" title="云原生的特点"></a>云原生的特点</h3><blockquote>
<p>本质：池化和弹性</p>
</blockquote>
<ul>
<li>计算存储弹性伸缩</li>
<li>存算分离</li>
<li>计算节点无状态</li>
<li>资源调用K8s operator</li>
</ul>
<h2 id="国外课程"><a href="#国外课程" class="headerlink" title="国外课程"></a>国外课程</h2><ul>
<li>MIT6.824 分布式系统</li>
<li>CMU15-445 数据库系统概论</li>
<li>CMU15-721 高级数据库设计</li>
<li>MIT6.S081 操作系统概论</li>
<li>MIT6.828 高级操作系统设计</li>
</ul>
<h2 id="三大顶会"><a href="#三大顶会" class="headerlink" title="三大顶会"></a>三大顶会</h2><ul>
<li>SIGMOD</li>
<li>VLDB</li>
<li>ICDE</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li>存储</li>
<li>索引</li>
<li>查询</li>
<li>优化</li>
<li>并发控制</li>
<li>日志和恢复</li>
<li>分布式</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li>Oracle（#0）</li>
<li>MySQL（#1）</li>
<li>PostgreSQL（#2）</li>
<li>PolarDB（#3）</li>
<li>TiDB（#3）</li>
<li>openGauss</li>
<li>Redis</li>
<li>ElasticSearch</li>
<li>MongoDB</li>
<li>Aurora</li>
<li>CockRoachDB</li>
<li>InfluxDB</li>
</ul>
<h2 id="优质开源项目"><a href="#优质开源项目" class="headerlink" title="优质开源项目"></a>优质开源项目</h2><ul>
<li>TiDB</li>
<li>Doris</li>
<li>Arrow</li>
<li>RocksDB</li>
</ul>
<h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ul>
<li>《Database System Concepts》简称DBC</li>
<li>《Designing Data-Intensive Application》简称DDIA</li>
<li>《深入理解计算机系统》简称CSAPP</li>
<li>《Unix网络编程》简称APUE</li>
</ul>
<h2 id="学术大佬"><a href="#学术大佬" class="headerlink" title="学术大佬"></a>学术大佬</h2><ul>
<li>清华姚班AP<a target="_blank" rel="noopener" href="http://people.iiis.tsinghua.edu.cn/~huanchen/index.html">张焕晨</a></li>
<li>卡耐基梅隆CMU<a target="_blank" rel="noopener" href="http://www.cs.cmu.edu/~pavlo/">Andy Pavlo</a></li>
<li>慕尼黑工业<a target="_blank" rel="noopener" href="https://scholar.google.com/citations?hl=zh-CN&user=xSDfDpsAAAAJ&view_op=list_works&sortby=pubdate">Thomas Neumann</a></li>
</ul>
<h2 id="工程技能"><a href="#工程技能" class="headerlink" title="工程技能"></a>工程技能</h2><ul>
<li>git 版本管理</li>
<li>Linux&#x2F;shell 命令</li>
<li>Flame Graph 火焰图</li>
<li>gdb 调试</li>
</ul>
<h2 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h2><ul>
<li>大厂（阿里，腾讯，华为）</li>
<li>四朵金花（达梦，人大金仓，南大通用，神舟通用）</li>
<li>开源界扛把子：PingCAP</li>
<li>大牛初创公司<ul>
<li>Singularity data </li>
<li>天谋科技</li>
<li>偶数科技</li>
<li>四维纵横</li>
<li>Hashdata</li>
<li>Starrocks</li>
<li>selectDB</li>
<li>zilliz</li>
<li>OpenPie</li>
</ul>
</li>
</ul>
<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.inlighting.org/archives/how-to-find-a-database-job">沧海月明</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jyyyx</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/qaqowoqaq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qaqowoqaq" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2407217576@qq.com" title="E-Mail → 2407217576@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jyyyx</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
