<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qaqowoqaq.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="jyyyyyyyyyx">
<meta property="og:url" content="https://qaqowoqaq.github.io/index.html">
<meta property="og:site_name" content="jyyyyyyyyyx">
<meta property="og:locale">
<meta property="article:author" content="jyyyx">
<meta property="article:tag" content="cs">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://qaqowoqaq.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'cn'
  };
</script>

  <title>jyyyyyyyyyx</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">jyyyyyyyyyx</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">后来居上</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">C++ template</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-15 20:20:57 / Modified: 20:20:51" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-templates"><a href="#C-templates" class="headerlink" title="C++ templates"></a>C++ templates</h1><h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><h2 id="English"><a href="#English" class="headerlink" title="English"></a>English</h2><p>instantiation：实例化</p>
<p>paradigm：范例</p>
<h2 id="P1-基础"><a href="#P1-基础" class="headerlink" title="P1 基础"></a>P1 基础</h2><h3 id="1-函数模板"><a href="#1-函数模板" class="headerlink" title="1. 函数模板"></a>1. 函数模板</h3><p>当自定义的函数和 <code>std</code> 的函数名重复时，使用 <code>::</code> 调用我们定义的全局函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="type">const</span>&amp; <span class="title">max</span><span class="params">(T <span class="type">const</span>&amp; a, T <span class="type">const</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; ::<span class="built_in">max</span>(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板会被编译两次：</p>
<ol>
<li>实例化之前，先检查模板代码本身，查看语法是否正确。</li>
<li>实例化期间，检查模板代码，查看是否所有的调用都有效，例如某些类型可能无法调用某些函数，以及类型是否匹配，在上面的例子中，如果我们传入两个不同的类型，就会编译错误。</li>
</ol>
<p>模板类型可以显示制定，例如下面形式编译可以通过：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i= <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> d =<span class="number">3.13</span>;</span><br><span class="line">cout &lt;&lt; ::<span class="built_in">max</span>&lt;<span class="type">double</span>&gt;(i, d) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>为了解决参数必须相同的问题，我们可以指定两个模板参数，但是我们必须指定返回类型，指定返回类型比较麻烦：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">max</span><span class="params">(T2 <span class="type">const</span>&amp; a, T1 <span class="type">const</span>&amp; b)</span> -&gt; <span class="title">decltype</span><span class="params">(a + b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; ::<span class="built_in">max</span>(<span class="number">3</span>, <span class="number">3.13</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，你还可以重载模板函数，但要确保函数模板的所有重载版本的声明都位于它们被调用的位置之前。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">2023 C/C++语言考试试卷</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-15 20:20:57 / Modified: 20:31:59" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2023-C-x2F-C-语言考试试卷"><a href="#2023-C-x2F-C-语言考试试卷" class="headerlink" title="2023 C&#x2F;C++语言考试试卷"></a>2023 C&#x2F;C++语言考试试卷</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><p>所有的题目，除了答案，<strong>你应该给出合理的解释，解释非常重要，甚至比答案重要的多</strong>。</p>
<p>不但要知其然，还要知其所以然</p>
<p>并且，我们为了代码简洁，默认不加标头，你应该默认认为我们使用的库都有正确的标头,如#include<iostream>#include<vector>等等</p>
<p>如果是最近的标准，如C++11,14,17,20有的，我们一般不强调标准多少，除非的确有歧义，如constexpr，noexcept，复制消除，如果是老式的，C语言的，我们会强调。并且有些题目，不同编译器实际上也不见得都一样，不保证编译器厂商都按照标准实现。</p>
<p>所有题目不涉及任何框架和方言，标准C++，如果要提C，会强调是C语言</p>
<p>所有的题目，均在</p>
<p><a href="www.bilibili.com/video/BV1D84y1t76J/?spm_id_from=333.999.0.0&vd_source=1992ca910d6cd0582931f6f985dc7fa0">现代C++教程 2023_哔哩哔哩_bilibili</a></p>
<p>中有讲过，<strong>如果你看过视频还看不懂这些，最好思考一下自己学了啥</strong>，目前总计75题</p>
<hr>
<h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = +[] &#123;<span class="keyword">return</span> <span class="number">6</span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>p的类型是什么?</p>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> p = [=] &#123; ++a; &#125; ;</span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">sizeof</span> p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">p</span>();</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提问，打印p是多少？return a是多少？</p>
<h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line">    <span class="type">float</span>&amp; r = x;</span><br><span class="line">    <span class="keyword">auto</span> p = [=] &#123;&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">sizeof</span> p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印多少?</p>
<h3 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">auto</span> p =[=] &#123;</span><br><span class="line">		<span class="type">int</span> arr[N]&#123;&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	std::cout &lt;&lt; <span class="keyword">sizeof</span> p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印多少？</p>
<h3 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">auto</span> p =[=] &#123;</span><br><span class="line">		<span class="type">int</span> p = N;</span><br><span class="line">	&#125;;</span><br><span class="line">	std::cout &lt;&lt; <span class="keyword">sizeof</span> p &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印多少?</p>
<h3 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> a = <span class="number">6</span>;</span><br><span class="line">    [] &#123;</span><br><span class="line">        std::cout &lt;&lt; a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能否正常编译?打印多少?</p>
<h3 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line">    [] &#123;</span><br><span class="line">        std::cout &lt;&lt; &amp;a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能否正常编译?打印多少?</p>
<h3 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h3><p><strong>lambda表达式的类型是什么?请写一段代码表示(不要超脱语言层面)</strong></p>
<h3 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = +[]()<span class="keyword">noexcept</span> &#123; &#125;;</span><br></pre></td></tr></table></figure>

<p>在<code>C++17</code>p的类型是什么?</p>
<h3 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> a = [] &#123;<span class="keyword">return</span> <span class="number">6</span>; &#125;();</span><br></pre></td></tr></table></figure>

<p>上面代码在c++17是否合法?</p>
<h3 id="第十一题"><a href="#第十一题" class="headerlink" title="第十一题"></a>第十一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lm = [&amp;args...] &#123;  &#125;;</span><br><span class="line">    <span class="keyword">auto</span> lm2 = [&amp;] &#123;  &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">sizeof</span> lm &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">sizeof</span> lm2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>, <span class="number">1.0</span>, <span class="number">1.f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印多少?</p>
<h3 id="第十二题"><a href="#第十二题" class="headerlink" title="第十二题"></a>第十二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="built_in">X</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;X&quot;</span>); &#125;</span><br><span class="line">	~<span class="built_in">X</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;~X&quot;</span>); &#125;</span><br><span class="line">	<span class="built_in">X</span>(X&amp;&amp;)<span class="keyword">noexcept</span> &#123; <span class="built_in">puts</span>(<span class="string">&quot;X&amp;&amp;&quot;</span>); &#125;</span><br><span class="line">	<span class="built_in">X</span>(<span class="type">const</span> X&amp;) &#123; <span class="built_in">puts</span>(<span class="string">&quot;const X&amp;&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(Args&amp;&amp;...args)</span> </span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">	[args...] &#123; <span class="built_in">g</span>(args...); &#125;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f_</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">	[... args = std::forward&lt;Args&gt;(args)] &#123;<span class="built_in">g</span>(args...); &#125;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X x_;</span><br><span class="line">	<span class="built_in">f_</span>(std::<span class="built_in">move</span>(x_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码，打印多少?</p>
<h3 id="第十三题"><a href="#第十三题" class="headerlink" title="第十三题"></a>第十三题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> p = +[](...) &#123;&#125;;</span><br><span class="line">	<span class="keyword">auto</span> p2 = [](<span class="keyword">auto</span>...args) &#123;</span><br><span class="line">		((std::cout &lt;&lt; args &lt;&lt; <span class="string">&#x27; &#x27;</span>), ...);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">p</span>(<span class="number">1</span>, <span class="string">&quot;*&quot;</span>, <span class="number">5.6</span>);</span><br><span class="line">	<span class="built_in">p2</span>(<span class="number">1</span>, <span class="string">&quot;*&quot;</span>, <span class="number">5.6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能否通过编译?打印多少?</p>
<h3 id="第十四题"><a href="#第十四题" class="headerlink" title="第十四题"></a>第十四题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line">	<span class="function"><span class="keyword">auto</span> <span class="title">concat</span><span class="params">(F t, Ts ...ts)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(ts) &gt; <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> [=](<span class="keyword">auto</span> ...parameters) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">t</span>(<span class="built_in">concat</span>(ts...)(parameters...));</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> [=](<span class="keyword">auto</span> ...parameters) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">t</span>(parameters...);</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码，思考是否看的懂</p>
<hr>
<h2 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h2><h3 id="第一题-1"><a href="#第一题-1" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span> = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>=<span class="number">6</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> = <span class="number">4</span>,<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123; std::cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码，是否正确？打印多少?</p>
<h3 id="第二题-1"><a href="#第二题-1" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f_</span><span class="params">(<span class="type">int</span> n = <span class="number">6</span>, Args...args)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码，是否正确?</p>
<h3 id="第三题-1"><a href="#第三题-1" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i = <span class="number">3</span>)</span></span>;</span><br><span class="line">	<span class="built_in">C</span>(<span class="type">int</span> arg); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">C::f</span><span class="params">(<span class="type">int</span> i = <span class="number">3</span>)</span> </span>&#123;&#125;        </span><br><span class="line">C::<span class="built_in">C</span>(<span class="type">int</span> arg = <span class="number">1</span>) &#123;&#125;            </span><br></pre></td></tr></table></figure>

<p>给出以上代码，是否正确?</p>
<h3 id="第四题-1"><a href="#第四题-1" class="headerlink" title="第四题"></a>第四题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a = <span class="number">7</span>)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base &quot;</span> &lt;&lt; a &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Derived &quot;</span> &lt;&lt; a &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	std::unique_ptr&lt;Base&gt;ptr&#123; <span class="keyword">new</span> Derived &#125;;</span><br><span class="line">	ptr-&gt;<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印多少?</p>
<h3 id="第五题-1"><a href="#第五题-1" class="headerlink" title="第五题"></a>第五题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> n = <span class="keyword">sizeof</span> f)</span></span>;</span><br><span class="line">	<span class="built_in">f2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?打印多少?</p>
<hr>
<h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><h3 id="第一题-2"><a href="#第一题-2" class="headerlink" title="第一题"></a>第一题</h3><p>template<classT>void f(T);表达式f({1, 2, 3})良构吗?</p>
<p><code>decltype(&#123;1,2,3&#125;)</code>良构吗?</p>
<p><code>&#123;&#125;</code>是表达式吗?它有类型吗?</p>
<h3 id="第二题-2"><a href="#第二题-2" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">V</span><span class="params">(std::istream_iterator&lt;<span class="type">int</span>&gt;(std::cin), &#123;&#125;)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> i : V) &#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>那么这里的<code>std::vector</code>的构造器第二个参数传一个空<code>&#123;&#125;</code>是否正确?</p>
<h3 id="第三题-2"><a href="#第三题-2" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> S&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="built_in">Test</span>(S a ,S b)<span class="keyword">noexcept</span> &#123;</span><br><span class="line">		std::cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Test t&#123; <span class="number">1</span>,&#123;&#125; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码，是否正确?</p>
<h3 id="第四题-2"><a href="#第四题-2" class="headerlink" title="第四题"></a>第四题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>p使用的是什么初始化，它的类型是什么?</p>
<h3 id="第五题-2"><a href="#第五题-2" class="headerlink" title="第五题"></a>第五题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span>  <span class="title">X</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> :a(a), b(b) &#123;</span> std::cout &lt;&lt; <span class="string">&quot;X(int a,int b)\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a&#123;&#125;;</span><br><span class="line">	<span class="type">int</span> b&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X x&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">	<span class="function">X <span class="title">x2</span><span class="params">( <span class="number">1</span>,<span class="number">2</span> )</span></span>;</span><br><span class="line">	X x3 = &#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码,是否正确?</p>
<h3 id="第六题-1"><a href="#第六题-1" class="headerlink" title="第六题"></a>第六题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span>  <span class="title">X</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> :a(a), b(b) &#123;</span> std::cout &lt;&lt; <span class="string">&quot;X(int a,int b)\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a&#123;&#125;;</span><br><span class="line">	<span class="type">int</span> b&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X x&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">	<span class="function">X <span class="title">x2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> ret = <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码,是否正确?</p>
<h3 id="第七题-1"><a href="#第七题-1" class="headerlink" title="第七题"></a>第七题</h3><p><strong><code>std::array</code>的构造函数是用<code>std::initializer_list</code>定义的吗?</strong></p>
<hr>
<h2 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h2><h3 id="第一题-3"><a href="#第一题-3" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDEF(sname, ...) S sname __VA_OPT__(= &#123; __VA_ARGS__ &#125;)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SDEF</span>(bar, <span class="number">1</span>, <span class="number">2</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SDEF(bar, 1, 2); </code>替换成了什么?</p>
<hr>
<h2 id="用户定义字面量"><a href="#用户定义字面量" class="headerlink" title="用户定义字面量"></a>用户定义字面量</h2><h3 id="第一题-4"><a href="#第一题-4" class="headerlink" title="第一题"></a>第一题</h3><p>自定义一个字面量，做到如下功能:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;乐 :&#123;&#125; *\n&quot;</span>_f(<span class="number">5</span>);</span><br><span class="line"><span class="string">&quot;乐 :&#123;0&#125; &#123;0&#125; *\n&quot;</span>_f(<span class="number">5</span>);</span><br><span class="line"><span class="string">&quot;乐 :&#123;:b&#125; *\n&quot;</span>_f(<span class="number">0b01010101</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="名字查找"><a href="#名字查找" class="headerlink" title="名字查找"></a>名字查找</h2><p><strong>也牵扯待决名</strong></p>
<h3 id="第一题-5"><a href="#第一题-5" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> X &#123;</span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">namespace</span> std&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> X;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	::std::vector v&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">	std::vector v2&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码，是否正确?</p>
<h3 id="第二题-3"><a href="#第二题-3" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">std</span>&#123;&#125;;</span><br><span class="line">	::std::vector v&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">	std::vector v2&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码，是否正确?</p>
<h3 id="第三题-3"><a href="#第三题-3" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> X &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Y</span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Y)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(X::<span class="built_in">Y</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码，是否正确?</p>
<h3 id="第四题-3"><a href="#第四题-3" class="headerlink" title="第四题"></a>第四题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;基\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;派生\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;Base&gt;p&#123; <span class="keyword">new</span> Derived &#125;;</span><br><span class="line">    p-&gt;<span class="built_in">f</span>();</span><br><span class="line">    p-&gt;Base::<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问以上代码打印什么?</p>
<h3 id="第五题-3"><a href="#第五题-3" class="headerlink" title="第五题"></a>第五题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;X\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;全局\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span> : X&lt;T&gt; &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">t</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">t2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Y&lt;<span class="type">void</span>&gt;y;</span><br><span class="line">	y.<span class="built_in">t</span>();</span><br><span class="line">	y.<span class="built_in">t2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印什么?</p>
<h3 id="第六题-2"><a href="#第六题-2" class="headerlink" title="第六题"></a>第六题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">	<span class="keyword">using</span> type = <span class="type">const</span> T::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span> &#123;</span><br><span class="line">	<span class="keyword">using</span> type = <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X&lt;Y&gt;::type a&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码，请问是否正确?</p>
<hr>
<h2 id="重载决议"><a href="#重载决议" class="headerlink" title="重载决议"></a>重载决议</h2><p>我非常喜欢考<code>&#123;&#125;</code>，因为错误言论实在太多，那么这里就多写点</p>
<h3 id="第一题-6"><a href="#第一题-6" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>(&amp;)[])</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;const int(&amp;)[]&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>(&amp;)[<span class="number">2</span>])</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;const int(&amp;)[2]&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;);</span><br><span class="line">	<span class="built_in">f</span>(&#123; <span class="number">1</span>,<span class="number">2</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印多少?</p>
<h3 id="第二题-4"><a href="#第二题-4" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>(&amp;)[])</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;const int(&amp;)[]&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>(&amp;)[<span class="number">2</span>])</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;const int(&amp;)[2]&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>(&amp;&amp;)[])</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;const int(&amp;&amp;)[]&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;);</span><br><span class="line">	<span class="built_in">f</span>(&#123; <span class="number">1</span>,<span class="number">2</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印多少?</p>
<h3 id="第三题-4"><a href="#第三题-4" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123; <span class="type">int</span> x, y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span> &#123;</span><br><span class="line">	<span class="built_in">Y</span>(std::initializer_list&lt;<span class="type">int</span>&gt;)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>(&amp;)[])</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;const int(&amp;)[]&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>(&amp;)[<span class="number">2</span>])</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;const int(&amp;)[2]&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>(&amp;&amp;)[])</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;int(&amp;&amp;)[]&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(X)</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;X&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Y)</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;Y&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;);</span><br><span class="line">	<span class="built_in">f</span>(&#123; <span class="number">1</span>,<span class="number">2</span> &#125;);</span><br><span class="line">	<span class="built_in">f</span>(&#123; .x=<span class="number">1</span>,.y=<span class="number">2</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印多少?</p>
<hr>
<h2 id="值类别"><a href="#值类别" class="headerlink" title="值类别"></a>值类别</h2><h3 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h3><h4 id="第一题-7"><a href="#第一题-7" class="headerlink" title="第一题"></a>第一题</h4><p>字面量都是<strong>纯右值表达式</strong></p>
<h4 id="第二题-5"><a href="#第二题-5" class="headerlink" title="第二题"></a>第二题</h4><p>返回类型是非引用的函数调用或重载运算符表达式，例如 str.substr(1, 2)、str1 + str2 或 it++都是<strong>纯右值表达式</strong></p>
<h4 id="第三题-5"><a href="#第三题-5" class="headerlink" title="第三题"></a>第三题</h4><p><code>std::move(x)</code>是<strong>亡值表达式</strong></p>
<h4 id="第四题-4"><a href="#第四题-4" class="headerlink" title="第四题"></a>第四题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>&amp;&amp;)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">6</span>;</span><br><span class="line">	<span class="type">int</span>&amp;&amp; p = std::<span class="built_in">move</span>(n);</span><br><span class="line">	<span class="built_in">f</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码合法</p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="第一题-8"><a href="#第一题-8" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="built_in">X</span>()<span class="keyword">noexcept</span> &#123; <span class="built_in">puts</span>(<span class="string">&quot;默认构造&quot;</span>); &#125;</span><br><span class="line">	<span class="built_in">X</span>(<span class="type">const</span> X&amp;) &#123; <span class="built_in">puts</span>(<span class="string">&quot;复制构造\n&quot;</span>); &#125;</span><br><span class="line">	<span class="built_in">X</span>(X&amp;&amp;)<span class="keyword">noexcept</span> &#123; <span class="built_in">puts</span>(<span class="string">&quot;移动构造&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">X <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X x;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X x = <span class="built_in">X</span>();</span><br><span class="line">	X x2 = <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确保在<code>C++17</code>的环境下，请问打印什么?</p>
<h3 id="第二题-6"><a href="#第二题-6" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">using</span> T = <span class="keyword">decltype</span>((a + b));</span><br><span class="line">	<span class="keyword">using</span> T2 = <span class="keyword">decltype</span>(std::<span class="built_in">move</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T和T2的类型是什么?</p>
<hr>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="第一题-9"><a href="#第一题-9" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> array[<span class="number">10</span>]&#123;&#125;;</span><br><span class="line">	<span class="keyword">using</span> T = <span class="keyword">decltype</span>(array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T的类型是什么?</p>
<h3 id="第二题-7"><a href="#第二题-7" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">using</span> T = <span class="keyword">decltype</span>((<span class="string">&quot;***&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T的类型是什么?</p>
<h3 id="C语言C99数组"><a href="#C语言C99数组" class="headerlink" title="C语言C99数组"></a>C语言<code>C99</code>数组</h3><h4 id="第一题-10"><a href="#第一题-10" class="headerlink" title="第一题"></a>第一题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">double</span> b;</span><br><span class="line">	<span class="type">char</span> c[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> t = (test*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(test) + <span class="number">27</span> * <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">	<span class="built_in">memset</span>(t-&gt;c, <span class="number">0</span>, <span class="number">27</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="keyword">sizeof</span> * t &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">		t-&gt;c[i] = <span class="string">&#x27;A&#x27;</span> + i;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; t-&gt;c &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">free</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印多少?</p>
<h4 id="第二题-8"><a href="#第二题-8" class="headerlink" title="第二题"></a>第二题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">size_t</span> x, <span class="type">int</span> a[*])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">size_t</span> x, <span class="type">int</span> a[x])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="built_in">sizeof</span>(a)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> n=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> array[n];</span><br><span class="line">    <span class="built_in">foo</span>(n,array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码是否正确?</p>
<h4 id="第三题-6"><a href="#第三题-6" class="headerlink" title="第三题"></a>第三题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> A[n];            </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">int</span> <span class="params">(*p2)</span>[n]</span>; </span><br><span class="line"><span class="type">int</span> B[<span class="number">100</span>];          </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fvla</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> C[m][m])</span></span>; </span><br></pre></td></tr></table></figure>

<p>下面声明的数组，哪些错误，哪些正确</p>
<p><strong>第四题</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">10</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> array[n];</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> array_[n];</span><br><span class="line">    <span class="type">int</span> array__[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面声明的数组，哪些错误，哪些正确</p>
<h4 id="第五题-4"><a href="#第五题-4" class="headerlink" title="第五题"></a>第五题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="type">int</span> array[<span class="number">6</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> array[];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">		std::cout &lt;&lt; array[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?</p>
<h4 id="第六题-3"><a href="#第六题-3" class="headerlink" title="第六题"></a>第六题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">0</span>]; </span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?</p>
<h4 id="第七题-2"><a href="#第七题-2" class="headerlink" title="第七题"></a>第七题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> array[<span class="number">6</span>]&#123;&#125;;</span><br><span class="line">	<span class="keyword">using</span> T = <span class="keyword">decltype</span>( + array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T的类型是什么?</p>
<h4 id="第八题-1"><a href="#第八题-1" class="headerlink" title="第八题"></a>第八题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">char</span> s[<span class="number">3</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">char</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">char</span>* s)</span></span>;</span><br></pre></td></tr></table></figure>

<p>以上代码声明了几个函数?</p>
<h4 id="第九题-1"><a href="#第九题-1" class="headerlink" title="第九题"></a>第九题</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a[<span class="number">0</span>])</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确</p>
<hr>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="第一题-11"><a href="#第一题-11" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">int</span>(<span class="type">void</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">int</span>())</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">int</span>(*)())</span></span>;</span><br></pre></td></tr></table></figure>

<p>以上代码声明了几个函数</p>
<h3 id="第二题-9"><a href="#第二题-9" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(X())</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>t</code>是什么?</p>
<hr>
<h2 id="形参包展开"><a href="#形参包展开" class="headerlink" title="形参包展开"></a>形参包展开</h2><p>我们前面的题目已经使用了很多包展开了，所以我们这里只写两个例子</p>
<h3 id="第一题-12"><a href="#第一题-12" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F,<span class="keyword">class</span>...Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">(F func,Args...args)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> _[] = &#123; (<span class="built_in">func</span>(args),<span class="number">0</span>)... &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">f</span>([](<span class="keyword">auto</span> t) &#123;std::cout &lt;&lt; t &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;, <span class="number">1</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印多少?</p>
<h3 id="第二题-10"><a href="#第二题-10" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>...Args&gt;</span></span><br><span class="line"><span class="function">std::initializer_list&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(Args...args)</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="keyword">auto</span> list = &#123; args * args + args... &#125;;</span><br><span class="line">	<span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> ret = <span class="built_in">f</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>); <span class="type">const</span> <span class="keyword">auto</span> &amp; i : ret) &#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问打印多少?</p>
<h2 id="并发支持库"><a href="#并发支持库" class="headerlink" title="并发支持库"></a>并发支持库</h2><h3 id="第一题-13"><a href="#第一题-13" class="headerlink" title="第一题"></a>第一题</h3><p><strong>实现<code>std::lock_guard</code></strong></p>
<h3 id="第二题-11"><a href="#第二题-11" class="headerlink" title="第二题"></a>第二题</h3><p>实现<code>std::scoped_lock</code></p>
<h3 id="第三题-7"><a href="#第三题-7" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::promise&lt;<span class="type">void</span>&gt;read;</span><br><span class="line">	std::future&lt;<span class="type">void</span>&gt;fu = read.<span class="built_in">get_future</span>();</span><br><span class="line">	std::thread t&#123; [&amp;] &#123;</span><br><span class="line">		fu.<span class="built_in">wait</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;乐\n&quot;</span>;</span><br><span class="line">	&#125; &#125;;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;main\n&quot;</span>;</span><br><span class="line">	read.<span class="built_in">set_value</span>();</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码打印什么?</p>
<hr>
<h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><h2 id="成员函数-1"><a href="#成员函数-1" class="headerlink" title="成员函数"></a>成员函数</h2><h3 id="第一题-14"><a href="#第一题-14" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span><span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;const\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X x;</span><br><span class="line">	x.<span class="built_in">f</span>();</span><br><span class="line">	std::<span class="built_in">move</span>(x).<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上 是否正确，如果正确，打印什么?</p>
<h3 id="第二题-12"><a href="#第二题-12" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span><span class="type">const</span>&amp; </span>&#123; std::cout &lt;&lt; <span class="string">&quot;const\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X x;</span><br><span class="line">	x.<span class="built_in">f</span>();</span><br><span class="line">	std::<span class="built_in">move</span>(x).<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上 是否正确，如果正确，打印什么?</p>
<h3 id="第三题-8"><a href="#第三题-8" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>&#123;</span><br><span class="line">	<span class="type">int</span> n&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span><span class="type">const</span>&amp; </span>&#123; std::cout &lt;&lt; <span class="string">&quot;const&amp;\n&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span><span class="keyword">volatile</span>&amp; </span>&#123; std::cout &lt;&lt; <span class="string">&quot;volatile&amp;\n&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span><span class="type">const</span> <span class="keyword">volatile</span>&amp; </span>&#123; std::cout &lt;&lt; <span class="string">&quot;const volatile&amp;\n&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span>&amp; </span>&#123; std::cout &lt;&lt; <span class="string">&quot;&amp;\n&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span>&amp;&amp; </span>&#123; std::cout &lt;&lt; <span class="string">&quot;&amp;&amp;\n&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span><span class="type">const</span>&amp;&amp; </span>&#123; std::cout &lt;&lt; <span class="string">&quot;const &amp;&amp;\n&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span><span class="keyword">volatile</span>&amp;&amp; </span>&#123; std::cout &lt;&lt; <span class="string">&quot;volatile &amp;&amp;\n&quot;</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span><span class="type">const</span> <span class="keyword">volatile</span>&amp;&amp; </span>&#123; std::cout &lt;&lt; <span class="string">&quot;const volatile &amp;&amp;\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	S s;</span><br><span class="line">	s.<span class="built_in">f</span>();</span><br><span class="line">	std::<span class="built_in">move</span>(s).<span class="built_in">f</span>();</span><br><span class="line">	<span class="built_in">S</span>().<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?如果正确，打印什么?</p>
<h3 id="C-23显式对象形参"><a href="#C-23显式对象形参" class="headerlink" title="C++23显式对象形参"></a>C++<code>23</code>显式对象形参</h3><h3 id="第一题-15"><a href="#第一题-15" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="keyword">this</span> X x)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;f\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">this</span> X&amp; x)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;f2\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> X x;</span><br><span class="line">	x.<span class="built_in">f</span>();</span><br><span class="line">	x.<span class="built_in">f2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?如果正确，打印什么?</p>
<h3 id="第二题-13"><a href="#第二题-13" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Self&gt;</span></span><br><span class="line"><span class="function">	<span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">this</span> Self&amp;&amp; self)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;bar\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">this</span> foo&amp; self)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;bar &amp;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">this</span> <span class="type">const</span> foo&amp; self)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;const bar &amp;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">this</span> foo&amp;&amp; self)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;bar &amp;&amp;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">this</span> <span class="type">const</span> foo&amp;&amp; self)</span> </span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;const bar &amp;&amp;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	foo a;</span><br><span class="line">	a.<span class="built_in">bar</span>();</span><br><span class="line">	std::<span class="built_in">move</span>(a).<span class="built_in">bar</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> foo b;</span><br><span class="line">	b.<span class="built_in">bar</span>();</span><br><span class="line">	std::<span class="built_in">move</span>(b).<span class="built_in">bar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?如果正确，打印什么?</p>
<h3 id="第三题-9"><a href="#第三题-9" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="type">int</span> n&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">plus</span><span class="params">(<span class="keyword">this</span> X x)</span> </span>&#123;</span><br><span class="line">		x.n++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X x;</span><br><span class="line">	x.<span class="built_in">plus</span>();</span><br><span class="line">	<span class="keyword">auto</span> p = &amp;X::plus;</span><br><span class="line">	<span class="built_in">p</span>(x);</span><br><span class="line">	std::cout &lt;&lt; x.n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?如果正确，打印什么?</p>
<h3 id="第四题-5"><a href="#第四题-5" class="headerlink" title="第四题"></a>第四题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> p = [n = <span class="number">0</span>](<span class="keyword">this</span> <span class="keyword">auto</span> self, <span class="keyword">auto</span> f, <span class="keyword">auto</span> x) &#123;</span><br><span class="line">		<span class="built_in">f</span>(x);</span><br><span class="line">		self.n++;</span><br><span class="line">		std::cout &lt;&lt; self.n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">p</span>([](<span class="keyword">auto</span> x) &#123;std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;, <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">p</span>([](<span class="keyword">auto</span> x) &#123;std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125;, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?如果正确，打印什么?</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="第一题-16"><a href="#第一题-16" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> std::string&amp; <span class="title">f</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; ret = <span class="built_in">f</span>(<span class="string">&quot;哈哈&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?</p>
<h3 id="第二题-14"><a href="#第二题-14" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n=<span class="number">1</span>)</span><span class="keyword">try</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n&#123; <span class="number">6</span> &#125;;</span><br><span class="line">&#125;<span class="built_in">catch</span>(...)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?</p>
<h3 id="第三题-10"><a href="#第三题-10" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="type">size_t</span> size)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	X* x = ::<span class="keyword">new</span> X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?</p>
<h3 id="第四题-6"><a href="#第四题-6" class="headerlink" title="第四题"></a>第四题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">t</span><span class="params">(<span class="type">int</span>)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">t</span><span class="params">(<span class="type">double</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">t</span>(<span class="number">1.</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是否正确?</p>
<h3 id="第五题-5"><a href="#第五题-5" class="headerlink" title="第五题"></a>第五题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::vector v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="function">std::function <span class="title">f</span><span class="params">([](<span class="type">int</span>&amp; i) &#123; i = i * i; &#125;)</span></span>;</span><br><span class="line">	<span class="function">std::function <span class="title">f2</span><span class="params">([](<span class="type">int</span>&amp; i) &#123;i = i + i; &#125;)</span></span>;</span><br><span class="line">	<span class="function">std::function <span class="title">f3</span><span class="params">([](<span class="type">int</span> i) &#123;std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;)</span></span>;</span><br><span class="line">	v | f | f2 | f3;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	v | [](<span class="type">int</span>&amp; i) &#123; i = i * i; &#125; | [](<span class="type">int</span> i) &#123;std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : v | [](<span class="type">int</span>&amp; i) &#123;i = i / <span class="number">10</span>; &#125;) &#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据以上使用代码，实现一个管道运算符</p>
<h3 id="第六题-4"><a href="#第六题-4" class="headerlink" title="第六题"></a>第六题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Ty</span>,<span class="type">size_t</span> size&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">array</span> &#123;</span><br><span class="line">	<span class="function">Ty* <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> arr; &#125;;</span><br><span class="line">	<span class="function">Ty* <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> arr + size; &#125;;</span><br><span class="line">	Ty arr[size];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	::array arr&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; i : arr) &#123;</span><br><span class="line">		std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出以上代码，请为模板类<code>array</code>添加推导指引，让main中代码合法</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然题目看着多，但是我依旧省略了很多,并发那块以后再详细出点题，基本上都只是视频讲过的罢了，这只是初稿，会有很多修改的，欢迎评论提建议。</p>
<p>对了，我们连UB都没详细介绍~~~</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">OSTEP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-15 20:20:57 / Modified: 20:22:10" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="OSTEP-jyy"><a href="#OSTEP-jyy" class="headerlink" title="OSTEP jyy"></a>OSTEP jyy</h1><h2 id="0x-01-reference"><a href="#0x-01-reference" class="headerlink" title="0x 01 reference"></a>0x 01 reference</h2><p><a target="_blank" rel="noopener" href="http://jyywiki.cn/OS/2022/">官网</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12L4y1379V/?spm_id_from=333.788&vd_source=38033fe3a1f136728a1d6f8acf710b51">教学视频</a></p>
<hr>
<h3 id="1-why-learn-OS"><a href="#1-why-learn-OS" class="headerlink" title="1.why learn OS"></a>1.why learn OS</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>解决一个问题的步骤：why-what-how</span><br><span class="line">为什么要学习操作系统</span><br><span class="line">什么是操作系统</span><br><span class="line">怎样学习操作系统</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>三个根本问题</span><br><span class="line">（<span class="number">1</span>）操作系统服务谁</span><br><span class="line">程序=状态机</span><br><span class="line">课程涉及：多线程Linux应用程序</span><br><span class="line">（<span class="number">2</span>）（乘机/应用视角）操作系统为程序提供什么服务</span><br><span class="line">操作系统=对象+API（用来操纵对象)</span><br><span class="line">课程涉及：POSIX+部分Linux特性</span><br><span class="line">（<span class="number">3</span>）（实现/硬件角度）如何实现操作系统提供的服务</span><br><span class="line">操作系统=C程序</span><br><span class="line">课程涉及：xv6,自制迷你操作系统</span><br></pre></td></tr></table></figure>

<h3 id="2-code"><a href="#2-code" class="headerlink" title="2.code"></a>2.code</h3><table>
<thead>
<tr>
<th>说明</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>查看用户名</td>
<td>uname -a</td>
</tr>
<tr>
<td>传送ACWing配置</td>
<td>scp .bashrc .vimrc .tmux.conf：…</td>
</tr>
<tr>
<td>下载tldr(too long dont read)</td>
<td>sudo apt-get install tldr</td>
</tr>
</tbody></table>
<h3 id="3-wrong-when-install-tldr"><a href="#3-wrong-when-install-tldr" class="headerlink" title="3. wrong when install tldr"></a>3. wrong when install tldr</h3><p>报错，出现用户名 is not in the sudoers file.<br>是因为当前的用户没有加入到sudo的配置文件里<br>解决方案：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>切换到root用户</td>
<td>su - root</td>
</tr>
<tr>
<td>修改配置文件</td>
<td>vim &#x2F;etc&#x2F;sudoers</td>
</tr>
<tr>
<td>修改</td>
<td>增加配置, 在打开的配置文件中，找到ununtu&#x2F;root ALL&#x3D;(ALL) ALL, 在下面添加一行：your_user_name ALL&#x3D;(ALL) ALL，wq!退出，这个文件是只读的，所以需要加！在ubuntu下是最后一行</td>
</tr>
</tbody></table>
<h3 id="4-some-jyy-wonderful-operating"><a href="#4-some-jyy-wonderful-operating" class="headerlink" title="4. some jyy wonderful operating"></a>4. some jyy wonderful operating</h3><table>
<thead>
<tr>
<th>功能</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>在vim里面编译C&#x2F;C++</td>
<td>:!gcc&#x2F;g++  %  -o  main (% 获取当前文件名)</td>
</tr>
<tr>
<td>在vim里面编译并运行C++</td>
<td>:!g++ % -o main &amp;&amp; .&#x2F;main</td>
</tr>
<tr>
<td>wget用于从网络上下载资源，没有指定目录，下载资源回默认为当前目录。wget支持HTTP，HTTPS和FTP协议，可以使用HTTP代理</td>
<td>wget url</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="0x-02-what-is-Programs-and-Compilers"><a href="#0x-02-what-is-Programs-and-Compilers" class="headerlink" title="0x 02 what is Programs and Compilers"></a>0x 02 what is Programs and Compilers</h2><h3 id="1-notes"><a href="#1-notes" class="headerlink" title="1. notes"></a>1. notes</h3><blockquote>
<p>程序就是状态机</p>
<blockquote>
<p>数字系统是状态机，程序运行在数字系统上，因而程序也应该是状态机。</p>
<p>在 C 语言中，程序中所有的东西（堆，栈）就是程序的状态，每执行一条一句，程序的状态就会变一下。</p>
</blockquote>
<p>include的形式语义就是复制粘贴，它是在预编译阶段处理的，例如我们 <code>#include &lt;tets.c&gt;</code> , 在预处理阶段，会从一个目录找到 include 的 test.c 文件，然后将它的内容复制粘贴到源代码中。</p>
</blockquote>
<h3 id="2-more-instruction"><a href="#2-more-instruction" class="headerlink" title="2. more instruction"></a>2. more instruction</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb layout src</span><br><span class="line">asm volatile(“rdrand %rax”);</span><br><span class="line">info proc mappings :查看进程信息</span><br><span class="line">unist: unix standard library</span><br></pre></td></tr></table></figure>

<h3 id="3-bug"><a href="#3-bug" class="headerlink" title="3. bug"></a>3. bug</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FOE_EACH(_) _(X) _(Y);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE(X) int X, X1;</span></span><br><span class="line"></span><br><span class="line">FOE_EACH(DEFINE)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    我们的本意是执行:</span></span><br><span class="line"><span class="comment">    int X, X1; int Y, Y1;</span></span><br><span class="line"><span class="comment">    但是我们执行是：</span></span><br><span class="line"><span class="comment">    int X, X1; int Y, X1;</span></span><br><span class="line"><span class="comment">  	这里的X1重复定义了</span></span><br><span class="line"><span class="comment">  	这是因为X1的X并不能被识别，它会被认为是一个字符串</span></span><br><span class="line"><span class="comment">	正确的写法是:</span></span><br><span class="line"><span class="comment">	#define DEFINE(X) int X, X##1</span></span><br><span class="line"><span class="comment">	这样X##1的X就可以被识别</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="4-Unix’s-philosophy"><a href="#4-Unix’s-philosophy" class="headerlink" title="4. Unix’s philosophy"></a>4. Unix’s philosophy</h3><ul>
<li>Make each program do one thing well</li>
<li>Expect the output of every program to become the input to anothe</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">Hashtable</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-15 20:20:57 / Modified: 20:26:53" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="0-题目地址"><a href="#0-题目地址" class="headerlink" title="0. 题目地址"></a>0. 题目地址</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-hashmap/solution/she-ji-ha-xi-ying-she-by-leetcode-soluti-klu9/">设计哈希映射</a></p>
<h2 id="1-链地址法"><a href="#1-链地址法" class="headerlink" title="1. 链地址法"></a>1. 链地址法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashMap</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> key;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="type">int</span> key,<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Node&gt;[] map;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> capacity = <span class="number">857</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> LinkedList[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> myHashCode = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(map[myHashCode] == null)&#123;</span><br><span class="line">            List&lt;Node&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            list.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">Node</span>(key,value));</span><br><span class="line">            map[myHashCode] = list;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            List&lt;Node&gt; list = map[myHashCode];</span><br><span class="line">            <span class="keyword">for</span>(Node m : list)&#123;</span><br><span class="line">                <span class="keyword">if</span>(m.key == key)&#123;</span><br><span class="line">                    m.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">Node</span>(key,value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> myHashCode = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(map[myHashCode] == null)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Node&gt; list = map[myHashCode];</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node m : list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.key == key)&#123;</span><br><span class="line">                res = m.value;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> myHashCode = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(map[myHashCode] == null)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Node&gt; list = map[myHashCode];</span><br><span class="line">        <span class="keyword">for</span>(Node m : list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.key == key)&#123;</span><br><span class="line">                list.<span class="built_in">remove</span>(m);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-开放寻址法"><a href="#2-开放寻址法" class="headerlink" title="2. 开放寻址法"></a>2. 开放寻址法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHashMap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">HashEntry</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        boolean remove; <span class="comment">// 记录元素是否被删除。</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">HashEntry</span>(<span class="type">int</span> key, <span class="type">int</span> value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashEntry[] table = <span class="keyword">new</span> HashEntry[<span class="number">101</span>]; <span class="comment">// 保存哈希表中的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size = <span class="number">0</span>; <span class="comment">// 哈希表中元素的数量。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">index</span>(key, table);</span><br><span class="line">        <span class="keyword">if</span> (table[index] != null &amp;&amp; !table[index].remove) &#123;</span><br><span class="line">            table[index].value = value; <span class="comment">// 哈希表中已存在该元素。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        table[index] = <span class="keyword">new</span> <span class="built_in">HashEntry</span>(key, value); <span class="comment">// 哈希表中不存在该元素。</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt;= table.length &gt;&gt; <span class="number">1</span>) <span class="built_in">resize</span>(); <span class="comment">// 元素数量超过数组的一半则进行扩容。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        HashEntry entry = table[<span class="built_in">index</span>(key, table)];</span><br><span class="line">        <span class="keyword">return</span> entry == null || entry.remove ? <span class="number">-1</span> : entry.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">index</span>(key, table);</span><br><span class="line">        <span class="keyword">if</span> (table[index] == null || table[index].remove)</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 哈希表中不存在该元素或该元素已被删除则直接返回。</span></span><br><span class="line">        table[index].remove = <span class="literal">true</span>; <span class="comment">// 将元素标记为已删除。</span></span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">int</span> <span class="title">index</span><span class="params">(<span class="type">int</span> key, HashEntry[] table)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = (index = key % table.length) &lt; <span class="number">0</span> ? index + table.length : index;</span><br><span class="line">        <span class="keyword">while</span> (table[index] != null &amp;&amp; table[index].key != key)</span><br><span class="line">            <span class="keyword">if</span> (++index &gt;= table.length)</span><br><span class="line">                index -= table.length;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断一个数是否为一个质数。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> boolean <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span> || n == <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || (n &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对哈希表进行扩容。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashEntry[] oldTable = table; <span class="comment">// 原来的数据。</span></span><br><span class="line">        <span class="comment">// 新数组的容量为原来容量的两倍。</span></span><br><span class="line">        HashEntry[] newTable = <span class="keyword">new</span> HashEntry[<span class="built_in">tableSizeFor</span>(oldTable.length &lt;&lt; <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">for</span> (HashEntry entry : oldTable) <span class="comment">// 将原数组中的元素复制到新数组中。</span></span><br><span class="line">            <span class="keyword">if</span> (entry != null &amp;&amp; !entry.remove) <span class="comment">// 已删除的元素不搬移到新数组中。</span></span><br><span class="line">                newTable[<span class="built_in">index</span>(entry.key, newTable)] = entry;</span><br><span class="line">        table = newTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证哈希表的容量是一个质数。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="type">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((capacity &amp; <span class="number">1</span>) == <span class="number">0</span>) capacity++;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isPrime</span>(capacity)) capacity += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-AV二叉树"><a href="#3-AV二叉树" class="headerlink" title="3. AV二叉树"></a>3. AV二叉树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashMap</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> ***LTree ***lTree;</span><br><span class="line">	<span class="keyword">private</span> NewNode node = null;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		***lTree = <span class="keyword">new</span> ***<span class="built_in">LTree</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">		node = ***lTree.<span class="built_in">insert</span>(node, key, value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">		NewNode nn = ***lTree.get***<span class="built_in">LTree</span>(key,node);</span><br><span class="line">		<span class="keyword">if</span>(nn!=null)&#123;</span><br><span class="line">			<span class="keyword">return</span> nn.val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//不存在，返回-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">		node = ***lTree.<span class="built_in">deleteNode</span>(node, key);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	NewNode left;</span><br><span class="line">	NewNode right;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点高度,高度是指节点到一片树叶的最长路径的长</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewNode</span><span class="params">(<span class="type">int</span> key,<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        height = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ***LTree &#123;</span><br><span class="line">    <span class="keyword">public</span> NewNode root;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算***L节点的高度的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">int</span> <span class="title">height</span><span class="params">(NewNode NewNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果为空，返回height为0</span></span><br><span class="line">        <span class="keyword">return</span> NewNode == null ? <span class="number">0</span> : NewNode.height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算两个的最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右旋转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">NewNode <span class="title">rightRotate</span><span class="params">(NewNode y)</span> </span>&#123;</span><br><span class="line">        NewNode x = y.left;</span><br><span class="line">        NewNode T1 = x.right;</span><br><span class="line">        x.right = y;</span><br><span class="line">        y.left = T1;</span><br><span class="line">        <span class="comment">//更新高度</span></span><br><span class="line">        y.height = <span class="built_in">max</span>(<span class="built_in">height</span>(y.left), <span class="built_in">height</span>(y.right)) + <span class="number">1</span>;</span><br><span class="line">        x.height = <span class="built_in">max</span>(<span class="built_in">height</span>(x.left), <span class="built_in">height</span>(x.right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左旋转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">NewNode <span class="title">leftRotate</span><span class="params">(NewNode x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        NewNode y = x.right;</span><br><span class="line">        NewNode T2 = y.left;</span><br><span class="line">        y.left = x;</span><br><span class="line">        x.right = T2;</span><br><span class="line">        <span class="comment">//更新高度</span></span><br><span class="line">        x.height = <span class="built_in">max</span>(<span class="built_in">height</span>(x.left), <span class="built_in">height</span>(x.right)) + <span class="number">1</span>;</span><br><span class="line">        y.height = <span class="built_in">max</span>(<span class="built_in">height</span>(y.left), <span class="built_in">height</span>(y.right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  获取平衡因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getBalance</span><span class="params">(NewNode NewNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NewNode == null ? <span class="number">0</span> : (<span class="built_in">height</span>(NewNode.left) - <span class="built_in">height</span>(NewNode.right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">NewNode <span class="title">insert</span><span class="params">(NewNode NewNode,<span class="type">int</span> key, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (NewNode == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NewNode</span>(key,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; NewNode.key) &#123;</span><br><span class="line">            NewNode.left = <span class="built_in">insert</span>(NewNode.left, key,val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; NewNode.key) &#123;</span><br><span class="line">            NewNode.right = <span class="built_in">insert</span>(NewNode.right, key,val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	NewNode.val = val;</span><br><span class="line">            <span class="keyword">return</span> NewNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新节点高度</span></span><br><span class="line">        NewNode.height = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">height</span>(NewNode.left), <span class="built_in">height</span>(NewNode.right));</span><br><span class="line">        <span class="comment">//这是插入完毕后的</span></span><br><span class="line">        <span class="type">int</span> balance = <span class="built_in">getBalance</span>(NewNode);</span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &lt; NewNode.left.key) &#123;</span><br><span class="line">            <span class="comment">//右旋</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(NewNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &gt; NewNode.right.key) &#123;</span><br><span class="line">            <span class="comment">//左旋</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(NewNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &gt; NewNode.left.key) &#123;</span><br><span class="line">            <span class="comment">//先左旋，再右旋</span></span><br><span class="line">            NewNode.left = <span class="built_in">leftRotate</span>(NewNode.left);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(NewNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &lt; NewNode.right.key) &#123;</span><br><span class="line">            <span class="comment">//先右旋再左旋</span></span><br><span class="line">            NewNode.right = <span class="built_in">rightRotate</span>(NewNode.right);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(NewNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NewNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">NewNode get***<span class="title">LTree</span><span class="params">(<span class="type">int</span> key,NewNode node)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(node==null) <span class="keyword">return</span> null;</span><br><span class="line">		<span class="keyword">if</span>(key&gt;node.key)&#123;</span><br><span class="line">			node = get***<span class="built_in">LTree</span>(key,node.right);</span><br><span class="line">	    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key&lt;node.key)&#123;</span><br><span class="line">	    	node = get***<span class="built_in">LTree</span>(key,node.left);</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">if</span>(node!=null&amp;&amp;key==node.key) <span class="keyword">return</span> node;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> null;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">NewNode <span class="title">deleteNode</span><span class="params">(NewNode root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; root.key) &#123;</span><br><span class="line">            root.left = <span class="built_in">deleteNode</span>(root.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root.key) &#123;</span><br><span class="line">            root.right = <span class="built_in">deleteNode</span>(root.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//删除节点有两个孩子</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != null &amp;&amp; root.right != null) &#123;</span><br><span class="line">                root.val = <span class="built_in">findMin</span>(root.right).val;</span><br><span class="line">                root.key = <span class="built_in">findMin</span>(root.right).key;</span><br><span class="line">                root.right = <span class="built_in">deleteNode</span>(root.right, root.key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//删除节点只有一个孩子或者没有孩子</span></span><br><span class="line">                root = (root.left != null) ? root.left : root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以下操作是为了恢复***L树的平衡性</span></span><br><span class="line">        <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        root.height = <span class="built_in">max</span>(<span class="built_in">height</span>(root.left), <span class="built_in">height</span>(root.right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> balance = <span class="built_in">getBalance</span>(root);</span><br><span class="line">        <span class="comment">//左-左情况，这里使用&gt;=而不是&gt;就是为了保证这些情形下使用的是单旋转而不是双旋转</span></span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">getBalance</span>(root.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左-右情况</span></span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">getBalance</span>(root.left) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root.left = <span class="built_in">leftRotate</span>(root.left);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右-右情况</span></span><br><span class="line">        <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; <span class="built_in">getBalance</span>(root.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右-左情况</span></span><br><span class="line">        <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; <span class="built_in">getBalance</span>(root.right) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root.right = <span class="built_in">rightRotate</span>(root.right);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> NewNode <span class="title">findMin</span><span class="params">(NewNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findMin</span>(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="4-红黑树"><a href="#4-红黑树" class="headerlink" title="4. 红黑树"></a>4. 红黑树</h2><pre><code class="c++">class MyHashMap &#123;
    private static class TreeNode &#123;
        private int key;
        private int value;
        private boolean color;
        private TreeNode left;
        private TreeNode right;
        private TreeNode parent;

        private TreeNode(int key, int value) &#123;
            this.key = key;
            this.value = value;
        &#125;
    &#125;

    private static final boolean RED = false;
    private static final boolean BLACK = true;
    private TreeNode[] hashtable = new TreeNode[1024];
    private int currentSize;

    public void put(int key, int value) &#123;
        if (currentSize &gt;= hashtable.length) &#123;
            resize(); // 从结果来看，加载因子选 1.0 效率较高。
        &#125;
        int index = key &amp; (hashtable.length - 1);
        insert(index, new TreeNode(key, value));
    &#125;

    public int get(int key) &#123;
        int index = key &amp; (hashtable.length - 1);
        TreeNode node = getNode(index, key);
        return node == null ? -1 : node.value;
    &#125;

    public void remove(int key) &#123;
        int index = key &amp; (hashtable.length - 1);
        delete(index, key);
    &#125;

    // 对哈希表进行扩容。
    private void resize() &#123;
        TreeNode[] oldTable = hashtable;
        hashtable = new TreeNode[hashtable.length &lt;&lt; 1];
        for (TreeNode root : oldTable) &#123;
            postorderTraversal(root);
        &#125;
        currentSize &gt;&gt;= 1;
    &#125;

    // 获取指定位置上的指定结点。
    private TreeNode getNode(int index, int key) &#123;
        TreeNode current = hashtable[index];
        while (current != null) &#123;
            if (current.key == key) &#123;
                break;
            &#125;
            if (current.key &lt; key) &#123;
                current = current.right;
            &#125; else &#123;
                current = current.left;
            &#125;
        &#125;
        return current;
    &#125;

    // 在指定位置上插入结点。
    private void insert(int index, TreeNode insert) &#123;
        TreeNode current = hashtable[index], parent = null; // 分别保存当前结点及其父结点。
        while (current != null) &#123;
            parent = current;
            if (current.key == insert.key) &#123;
                current.value = insert.value;
                return;
            &#125;
            if (current.key &lt; insert.key) &#123;
                current = current.right;
            &#125; else &#123;
                current = current.left;
            &#125;
        &#125;
        insert.parent = parent;
        if (parent == null) &#123;
            hashtable[index] = insert;
        &#125; else if (parent.key &lt; insert.key) &#123;
            parent.right = insert;
        &#125; else &#123;
            parent.left = insert;
        &#125;
        currentSize++;
        fixAfterInsertion(index, insert);
    &#125;

    // 删除指定位置上的指定结点。
    private void delete(int index, int key) &#123;
        TreeNode delete = getNode(index, key);
        if (delete == null) &#123;
            return;
        &#125;
        if (delete.left != null &amp;&amp; delete.right != null) &#123;
            TreeNode successor = delete.right;
            while (successor.left != null) &#123;
                successor = successor.left;
            &#125;
            delete.key = successor.key;
            delete.value = successor.value;
            delete = successor;
        &#125;
        TreeNode replacement = delete.left == null ? delete.right : delete.left;
        if (replacement == null) &#123;
            fixAfterDeletion(index, delete);
            if (delete.parent == null) &#123;
                hashtable[index] = null;
            &#125; else if (delete.parent.left == delete) &#123;
                delete.parent.left = null;
            &#125; else &#123;
                delete.parent.right = null;
            &#125;
        &#125; else &#123; // 被删除的结点只有一个子结点，那它一定是黑色结点，且它的子结点为红色。
            replacement.parent = delete.parent;
            if (delete.parent == null) &#123;
                hashtable[index] = replacement;
            &#125; else if (delete.parent.left == delete) &#123;
                delete.parent.left = replacement;
            &#125; else &#123;
                delete.parent.right = replacement;
            &#125;
            replacement.color = BLACK;
        &#125;
        currentSize--;
    &#125;

    // 对插入后的结点进行调整。
    private void fixAfterInsertion(int index, TreeNode insert) &#123;
        while (colorOf(insert.parent) == RED) &#123; // 只有父结点是红色才进行处理。
            // 分别保存当前结点的父结点、叔父结点、祖父结点。
            TreeNode parent = insert.parent, uncle = sibling(parent), grand = parent.parent;
            grand.color = RED; // 不管是哪种情况，祖父结点都需要染成红色。
            if (colorOf(uncle) == BLACK) &#123; // 叔父结点为黑色。
                if (grand.left == parent) &#123;
                    if (parent.right == insert) &#123;
                        rotationLeft(index, parent); // LR 情况：先对父结点进行左旋转。
                        parent = insert;
                    &#125;
                    rotationRight(index, grand); // LL 情况：对祖父结点进行右旋转。
                &#125; else &#123;
                    if (parent.left == insert) &#123;
                        rotationRight(index, parent); // RL 情况：先对父结点进行右旋转。
                        parent = insert;
                    &#125;
                    rotationLeft(index, grand); // RR 情况：对祖父结点进行左旋转。
                &#125;
                parent.color = BLACK; // 将旋转后的中心结点染成黑色。
                insert = hashtable[index]; // 处理完直接退出循环。
            &#125; else &#123; // 叔父结点为红色，则将父结点与叔父结点都染成黑色，将祖父结点作为新插入的结点继续处理。
                uncle.color = BLACK;
                parent.color = BLACK;
                insert = grand;
            &#125;
        &#125;
        hashtable[index].color = BLACK; // 根结点必须是黑色。
    &#125;

    // 对删除后的结点进行调整。
    private void fixAfterDeletion(int index, TreeNode delete) &#123;
        while (delete.parent != null &amp;&amp; delete.color == BLACK) &#123; // 只有删除的是黑色结点才进行处理。
            // 分别保存当前结点的父结点、兄弟结点。
            TreeNode parent = delete.parent, sibling = sibling(delete);
            if (sibling.color == BLACK) &#123; // 兄弟结点是黑色。
                if (colorOf(sibling.left) == BLACK &amp;&amp; colorOf(sibling.right) == BLACK) &#123; // 兄弟结点没有红色子结点。
                    if (parent.color == BLACK) &#123;
                        delete = parent;
                    &#125;
                    parent.color = BLACK;
                    sibling.color = RED;
                &#125; else &#123; // 兄弟结点有红色子结点。
                    if (parent.left == sibling) &#123;
                        if (colorOf(sibling.left) == BLACK) &#123;
                            rotationLeft(index, sibling); // LR 情况：先对兄弟结点进行左旋转。
                            sibling = sibling.parent;
                        &#125;
                        rotationRight(index, parent); // LL 情况：对父结点进行右旋转。
                    &#125; else &#123;
                        if (colorOf(sibling.right) == BLACK) &#123;
                            rotationRight(index, sibling); // RL 情况：先对兄弟结点进行右旋转。
                            sibling = sibling.parent;
                        &#125;
                        rotationLeft(index, parent); // RR 情况：对父结点进行左旋转。
                    &#125;
                    sibling.color = parent.color; // 旋转后中心结点继承父结点的颜色。
                    sibling.left.color = BLACK;
                    sibling.right.color = BLACK;
                    delete = hashtable[index]; // 处理完直接退出循环。
                &#125;
            &#125; else &#123; // 兄弟结点是红色。
                if (parent.left == sibling) &#123;
                    rotationRight(index, parent);
                &#125; else &#123;
                    rotationLeft(index, parent);
                &#125;
                parent.color = RED;
                sibling.color = BLACK;
            &#125;
        &#125;
    &#125;

    // 获取指定结点的兄弟结点。
    private TreeNode sibling(TreeNode node) &#123;
        if (node.parent.left == node) &#123;
            return node.parent.right;
        &#125;
        return node.parent.left;
    &#125;

    // 对指定位置上的指定结点进行左旋转。
    private void rotationLeft(int index, TreeNode node) &#123;
        TreeNode newRoot = node.right; // 结点的右子结点会成为这颗子树的根结点。
        node.right = newRoot.left;
        if (newRoot.left != null) &#123;
            newRoot.left.parent = node;
        &#125;
        newRoot.left = node;
        newRoot.parent = node.parent;
        if (node.parent == null) &#123;
            hashtable[index] = newRoot;
        &#125; else if (node.parent.left == node) &#123;
            node.parent.left = newRoot;
        &#125; else &#123;
            node.parent.right = newRoot;
        &#125;
        node.parent = newRoot;
    &#125;

    // 对指定位置上的指定结点进行右旋转。
    private void rotationRight(int index, TreeNode node) &#123;
        TreeNode newRoot = node.left; // 结点的左子结点会成为这颗子树的根结点。
        node.left = newRoot.right;
        if (newRoot.right != null) &#123;
            newRoot.right.parent = node;
        &#125;
        newRoot.right = node;
        newRoot.parent = node.parent;
        if (node.parent == null) &#123;
            hashtable[index] = newRoot;
        &#125; else if (node.parent.left == node) &#123;
            node.parent.left = newRoot;
        &#125; else &#123;
            node.parent.right = newRoot;
        &#125;
        node.parent = newRoot;
    &#125;

    // 获取指定结点的颜色。
    private boolean colorOf(TreeNode node) &#123;
        return node == null || node.color;
    &#125;

    // 对结点进行后序遍历。
    private void postorderTraversal(TreeNode node) &#123;
        if (node == null) &#123;
            return;
        &#125;
        postorderTraversal(node.left);
        postorderTraversal(node.right);
        node.left = node.right = node.parent = null;
        node.color = RED;
        int index = node.key &amp; (hashtable.length - 1);
        insert(index, node);
    &#125;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">RBTree</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-15 20:20:57 / Modified: 20:18:29" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RBT"><a href="#RBT" class="headerlink" title="RBT"></a>RBT</h1><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/SwgIJV/">LC</a></p>
<p><a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/rbtree/">OI WiKi</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/julycoding/The-Art-Of-Programming-By-July-2nd/blob/master/ebook/code/c/4.4%EF%BC%9A%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88LCA%E9%97%AE%E9%A2%98.LCAProblem.c">github</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e136ec79235c">illustrate</a></p>
<h2 id="insight"><a href="#insight" class="headerlink" title="insight"></a>insight</h2><h2 id="completement"><a href="#completement" class="headerlink" title="completement"></a>completement</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">design parteen & STL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-15 20:20:57 / Modified: 20:28:16" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/common/" itemprop="url" rel="index"><span itemprop="name">common</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Design-Patterns-TODO"><a href="#Design-Patterns-TODO" class="headerlink" title="Design Patterns[TODO]"></a>Design Patterns[TODO]</h1><h2 id="0x01-依赖转置原则"><a href="#0x01-依赖转置原则" class="headerlink" title="0x01. 依赖转置原则"></a>0x01. 依赖转置原则</h2><h3 id="ref1"><a href="#ref1" class="headerlink" title="ref1"></a>ref1</h3><p>例如人吃巧克力：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface IChocolates&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Oreo</span> implements IChocolates &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dove</span> implements IChocolates &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> interface Person &#123; <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">( IChocolates chocolates )</span></span>; &#125;</span><br></pre></td></tr></table></figure>



<p>上面的例子中人对巧克力产生了依赖，那人吃的行为依赖其实跟巧克力没有关系，在巧克力出现之前就已经存在了，因此吃的动作依赖的接口应该是人本身内部的概念，这个接口的归属权应该属于人，概念应该为可食用的（edible）。因此人对巧克力的依赖关系应该倒置为巧克力对可食用接口的依赖。这样倒置之后对人来说具有了更好的扩展性，不仅可以吃各种不同的巧克力，还可以吃饼干，米饭，鱼肉等等其它任何可吃的东西。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface IChocolates extends IEdible&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Oreo</span> implements IChocolates &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dove</span> implements IChocolates &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> interface Person &#123; <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">( IEdible edible )</span></span>; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ref2"><a href="#ref2" class="headerlink" title="ref2"></a>ref2</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/li1358159/article/details/123306664">REF</a></p>
<h3 id="ref3"><a href="#ref3" class="headerlink" title="ref3"></a>ref3</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012346890/article/details/111034907?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-111034907-blog-123306664.pc_relevant_aa2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-111034907-blog-123306664.pc_relevant_aa2&utm_relevant_index=1">REF</a></p>
<p>在例子中，如果我们让上层 dirver 依赖于底层的细节 car，那么就完全错误了。</p>
<p>我们应该让 diver 依赖于抽象的 CAR，让具体的 car 继承自抽象的 CAR。 </p>
<h2 id="0x02-装饰模式"><a href="#0x02-装饰模式" class="headerlink" title="0x02 装饰模式"></a>0x02 装饰模式</h2><h3 id="ref1-1"><a href="#ref1-1" class="headerlink" title="ref1"></a>ref1</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40594696/article/details/107611074">原文链接</a></p>
<p>1.什么是装饰模式</p>
<p>装饰模式是一种用于替代继承的技术。它无需定义子类却可以给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。</p>
<p>举个栗子：一张照片，不改变照片本身，给它增加一个相框，使他增加防潮的功能，这就是装饰模式。</p>
<p>装饰模式是一种对象结构型模式，他以对客户透明的方式动态的给一个对象附加上更多的责任，可以在不需要创建更多子类的情况下让对象的功能得以扩展。</p>
<p>2.装饰模式的结构</p>
<p>（1）<strong>Component（抽象构件）：</strong>它是具体构件和抽象装饰类的共同父类，声明了在具体构建中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。</p>
<p>（2）<strong>ConcreteComponent（具体构件）：</strong>它是抽象构件的子类，用于定义具体的构建对象，实现了在抽象构建中声明的方法，装饰类可以给它增加额外的职责。</p>
<p>（3）<strong>Decorator（抽象装饰类）：</strong>他也是抽象构件的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。</p>
<p>（4）<strong>ConcreteDecorator（具体装饰类）：</strong>它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，他可以调用在抽象装饰类中定义的方法，并可以增加新的方法用于扩充对象的行为。</p>
<h3 id="ref2-1"><a href="#ref2-1" class="headerlink" title="ref2"></a>ref2</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhshulin/article/details/38665187">refreence</a></p>
<p>####### <a target="_blank" rel="noopener" href="https://blog.csdn.net/NEXUS666/article/details/115672452">更好的 ref – c++ 实例</a></p>
<h2 id="0x03-代理模式"><a href="#0x03-代理模式" class="headerlink" title="0x03 代理模式"></a>0x03 代理模式</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/starlee/article/details/1647412">引用计数</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012344185/article/details/114497309">引用计数</a></p>
<p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/169263">jk时间 – 好文</a></p>
<h2 id="0x04-工厂模式"><a href="#0x04-工厂模式" class="headerlink" title="0x04 工厂模式"></a>0x04 工厂模式</h2><p>现实生活中，工厂是负责生产产品的；同样在设计模式中，简单工厂模式我们可以理解为<strong>负责生产对象</strong>的一个类，称为“工厂类”。</p>
<h2 id="0X05-原型模式"><a href="#0X05-原型模式" class="headerlink" title="0X05 原型模式"></a>0X05 原型模式</h2><p>原型模式定义了一个 virtual 拷贝构造函数，C++ 有吗？ C++ 没有虚拷贝构造</p>
<p><a href="cloud.tencent.com/developer/article/1686487">ref1</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/365222623">ref2</a></p>
<p><a href="cnblogs.com/jylz/p/10648439.html">ref3</a></p>
<h1 id="STL-TODO"><a href="#STL-TODO" class="headerlink" title="STL[TODO]"></a>STL[TODO]</h1><h2 id="prelogue"><a href="#prelogue" class="headerlink" title="prelogue"></a>prelogue</h2><h3 id="0x01-导读"><a href="#0x01-导读" class="headerlink" title="0x01 导读"></a>0x01 导读</h3><p>候捷 STL 与 范型编程学习笔记。</p>
<h3 id="0x02-英语"><a href="#0x02-英语" class="headerlink" title="0x02 英语"></a>0x02 英语</h3><p>identity：同一，本身</p>
<h3 id="0x03-problem"><a href="#0x03-problem" class="headerlink" title="0x03 problem"></a>0x03 problem</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/nirendao/article/details/115815599?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-115815599-blog-110736211.pc_relevant_3mothn_strategy_and_data_recovery&spm=1001.2101.3001.4242.1&utm_relevant_index=3">1</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/luolaihua2018/article/details/110736211">2</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013317445/article/details/89680330">3</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6b526aa481b1">4</a></p>
<h2 id="一、container"><a href="#一、container" class="headerlink" title="一、container"></a>一、container</h2><p>大家风范：用前置++，–实现后置++，–</p>
<p>仿函数：函数对象</p>
<p>关联：有key和value</p>
<p>array就是把数组包装成一个class</p>
<p>deque：dai ke</p>
<p>set, map:红黑树.c++并未规定必须使用红黑树，只不过红黑树效率高，因此各大制定标准库的公司都使用红黑树。</p>
<p>set的key就是value，value就是key。</p>
<p>哈希表由一个个桶（bucket）组成，每个桶都是一个链表（link）。现在哈希表大多采用分离链表发（yxc：拉链法）实现。</p>
<p>头文件有保护机制，多次引入没问题</p>
<p>vector空间两倍增长(成长)</p>
<p>（2）vector 有一个机制是这样的，如果新加入一个元素，比如通过push_back()，但是size 大于了capacity，那么vector 就会重新找一块更大的地方再把数据放进去。重新分配的过程：<strong>申请一块新的内存 &gt; 拷贝数据 &gt; 释放原内存</strong>。</p>
<p> 2、vector扩容怎么拷贝？</p>
<p>经常问的一个问题，vector怎么扩容？最简单的回答就是先申请内存，再拷贝，最后销毁原来的内存，然后是1.5倍还是2倍，解释一下。</p>
<p>但是！我看到有人问，怎么拷贝？？？what？？？</p>
<p>没想到吧，看书还是看漏了。</p>
<p>拷贝用的是uninitialized_copy，如果拷贝的是POD（标量型别，也就是trivial）调用的是copy（自己去看STL 的copy实现），如果是non-POD使用for循环遍历，调用construct，一个一个的构造，针对char<em>和wchar_t</em>，uninitialized_copy直接用memmove来执行复制行为，更加快。</p>
<p>版权声明：本文为CSDN博主「m0_60126088」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_60126088/article/details/119616254">https://blog.csdn.net/m0_60126088/article/details/119616254</a></p>
<p>虽然标准库提供了sort函数，但是一些函数也提供了自己的sort，当容器存在自己的sort的时候，优先使用容器自己的，它自己的肯定更好，不然它提供这个函数干嘛。</p>
<p>forward_list 和 list 提供了自己的 sort</p>
<p>forward_list使用头插法。因此只能在链表头插入元素。</p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6908.html">deque容器底层实现</a></p>
<p>queue 和 stack 由于元素进出的顺序是死的（固定的），因此他们没有迭代器，如果有迭代器的话，我们就有可能通过迭代器改变元素进出的顺序，这是不合理的。</p>
<p>set，map底层是红黑树（自平衡二叉查找树）</p>
<p>multimap不可以用下标做 iterator</p>
<p>hashtable 的 bucket 比 元素个数还有要多是合理的，因为元素中间会空出很多 bucket。事实上，bucket的个数肯定比元素个数多，否则的话 bucket 就要重新扩充变为原来的（大约）两倍。（经验法则，避免 bucket 的长度太长）（以空间换时间）</p>
<p>map的底部就是一个 pair</p>
<p>map，set 会丢掉重复元素</p>
<p>从测试结果我们可以看出，使用insert()插入元素的方式并不能覆盖掉相同key的值；而使用[]方式则可以覆盖掉之前的值。为什么会出现这样的结果呢？</p>
<p>原因分析<br>我们可以通过源码来找原因，在map的源码中，insert方法是这样定义的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; __x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> _M_t.<span class="built_in">insert_unique</span>(__x); &#125;</span><br></pre></td></tr></table></figure>

<p>他调用_M_t.insert_unique(_x)方法，该方法会首先遍历整个集合，判断是否存在相同的key，如果存在则直接返回，放弃插入操作。如果不存在才进行插入。<br>而[]方式是通过重载[]操作符来实现的，它直接进行插入或覆盖</p>
<blockquote>
<p> 今天调试程序，弄得有点纠结。无意间，和一帮同事讨论起一个问题：进程结束操作系统会回收new的内存吗？在自己的印象中，一直固执地认为，在使用C++操作分配对象内存后，如果程序员自己不用相应的delete操作回收的话，这块从堆内存是一直存在。在讨论中，有同事提醒说，在进程结束后，new操作的内存会被回收。但也只是结论，也说不出具体理由。</p>
<pre><code>没关系，何不google一下，一查下去，答案已是清晰：

“内存泄漏不是系统无法回收那片内存，而是你自己的应用程序无法使用那片内存。当你程序结束时，你所有分配的内存自动都被系统回收，不存在泄漏问题。但是在你程序的生命期内，如果你分配的内存都不回收，你将很快没内存使用。”再用自己的一句话来概括的话就是：操作系统本身就有内存管理的职责，一般而言，用malloc、new操作分配的内存，在进程结束后，操作系统是会自己的回收的。但某些系统态的资源，用特殊的系统API申请的内存就不一定了，比如：linux中的shmget申请的共享内存，就与进程结束无关了。

 经过这一番查找，不禁自己为自己汗颜了一把，之前还以为自己对内存管理理解较深，现在才明白：在没有认真深入地钻研过操作系统内核原理之前，所有对内存管理的理解还是浮在表面上的。这次讨论也分外地提醒自己，自己知识的盲区还有许多，还要不断的踏踏实实地努力学习啊！
</code></pre>
<hr>
<p> 版权声明：本文为CSDN博主「stanjiang2010」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/stanjiang2010/article/details/5386647">https://blog.csdn.net/stanjiang2010/article/details/5386647</a></p>
</blockquote>
<p>不建议使用分配器。</p>
<p>oop企图将data和method关联在一起</p>
<p>gp企图将data和method分离开</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/y1196645376/article/details/52938474">容器内存分配</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line">        PII p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">complex</span>(T _val) : <span class="built_in">val</span>(_val) &#123;&#125;</span><br><span class="line">        T val;</span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">        <span class="keyword">friend</span> complex&lt;U&gt; <span class="title">cal</span><span class="params">(complex&lt;U&gt; a, complex&lt;U&gt; b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">complex&lt;T&gt; <span class="title">cal</span><span class="params">(complex&lt;T&gt; a, complex &lt;T&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">complex&lt;T&gt; <span class="title">c</span><span class="params">(a.val + b.val)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">    <span class="comment">// return complex(a.val + b.val);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test3</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*====================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test::PII p = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    cout &lt;&lt; p.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">    <span class="function">complex&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">complex&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.val &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b.val &lt;&lt; endl;</span><br><span class="line">    complex&lt;<span class="type">int</span>&gt; c = <span class="built_in">cal</span>(a, b);</span><br><span class="line">    cout &lt;&lt; c.val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;vec &lt;&lt; endl;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);   <span class="comment">// add -&gt; cap:1</span></span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;vec &lt;&lt; endl;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);   <span class="comment">// add -&gt; cap:2</span></span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;(vec[<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);   <span class="comment">// add -&gt; cap:4</span></span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;(vec[<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);   <span class="comment">// add -&gt; cap:8</span></span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;(vec[<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i ++ )   vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; &amp;vec &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    cout &lt;&lt; m[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line">    cout &lt;&lt; m[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    m[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    m[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; m[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、alloactor"><a href="#二、alloactor" class="headerlink" title="二、alloactor"></a>二、alloactor</h2><p>容器的幕后英雄。</p>
<p>所有的分配和释放动作最后都会跑到 malloc 和 free 去。</p>
<p>分配器的 allocate 和 deallocate 最终都是使用 malloc 和 free</p>
<p>直接使用分配器在释放内存的时候，还需要指出需要释放的内存大小。</p>
<p>因此并不建议直接使用分配器分配内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *x = <span class="built_in">new</span>(<span class="string">&quot;hello&quot;</span>) <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;();   </span><br><span class="line">    <span class="type">int</span> *p = a.<span class="built_in">allocate</span>(<span class="number">512</span>, <span class="number">0</span>);</span><br><span class="line">    a.<span class="built_in">deallocate</span>(p, <span class="number">512</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="三、list"><a href="#三、list" class="headerlink" title="三、list"></a>三、list</h2><p>不允许 x++ ++</p>
<p>允许 ++ ++ x</p>
<p>所有的容器区间都是前闭后开</p>
<p>在链表中为了保证这个要求，必须要设置一个虚节点（为空）</p>
<h2 id="四、vector"><a href="#四、vector" class="headerlink" title="四、vector"></a>四、vector</h2><p>内存的扩充一般不会是原地扩充，它会在另一个地方找内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(vec) &lt;&lt; endl; <span class="comment">// 24 = 3 * 8(point)</span></span><br></pre></td></tr></table></figure>

<p>public 继承表示一种 is-a 的关系</p>
<h2 id="五、array"><a href="#五、array" class="headerlink" title="五、array"></a>五、array</h2><p>array 内部的数据就是一个真的数组，它没有tors</p>
<h2 id="六、deque"><a href="#六、deque" class="headerlink" title="六、deque"></a>六、deque</h2><p>号称自己拥有连续空间^^</p>
<p>连续是假象，分段是事实。</p>
<p>deque（dei ke）其实是分段连续的。deque的数据由许多个段组成，段与段之间不连续，每个段内连续。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i ++ )    q.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span> - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *x = &amp;q[i + <span class="number">1</span>], *y = &amp;q[i];</span><br><span class="line">        <span class="keyword">if</span>(y - x != <span class="number">-1</span>)  </span><br><span class="line">            cout &lt;&lt; y - x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; &amp;q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; &amp;q[i + <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试结果</span></span><br><span class="line"><span class="number">-5</span> <span class="number">0x19d4e6c</span> <span class="number">0x19d4e80</span></span><br><span class="line"><span class="number">-5</span> <span class="number">0x19d507c</span> <span class="number">0x19d5090</span></span><br><span class="line"><span class="number">-5</span> <span class="number">0x19d528c</span> <span class="number">0x19d52a0</span></span><br><span class="line"><span class="number">-5</span> <span class="number">0x19d549c</span> <span class="number">0x19d54b0</span></span><br><span class="line"><span class="number">-45</span> <span class="number">0x19d56ac</span> <span class="number">0x19d5760</span></span><br></pre></td></tr></table></figure>

<p>deque 的底部实现是一个 vector（称为 map ？？ ），vector 的每个元素是一个指针，每个指针指向一个缓冲区 buffer。</p>
<p>其迭代器是一个类</p>
<ol>
<li>first：当前所在 buffer 的起点</li>
<li>last：当前所在 buffer 的重点</li>
<li>node：处于（deque控制中心） 的那个段</li>
<li>cur：处于当前 buffer 的位置</li>
</ol>
<p>first 和 last 相当于两个哨兵[first，last) 前闭后开</p>
<p>迭代器在移动的过程中，每次移动都需要判断是否移动到了当前段的末尾，来决定是否需要调到下一个段。（效率低！每次都需要判断一下）</p>
<p>和 vector 一样，deque 也是 2 倍增长的，因此它也有 capacity，事实上标准库并未规定容器的增长细节，但是大多数实现都使用了 2 倍增长。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="type">clock_t</span> start;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )    q.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">clock</span>() - start) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )    vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">clock</span>() - start) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )    sum = q[i];</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">clock</span>() - start) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )    sum = vec[i];</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">clock</span>() - start) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15584</span></span><br><span class="line"><span class="number">16521</span></span><br><span class="line"><span class="number">79156</span></span><br><span class="line"><span class="number">3326</span></span><br></pre></td></tr></table></figure>

<p>deque 在拓展的时候 copy 方式是 copy 到新空间的中间位置，以方便前面和后面的扩充。</p>
<h2 id="八、queue"><a href="#八、queue" class="headerlink" title="八、queue"></a>八、queue</h2><p><code>queue&lt;int,  vector&lt;int&gt;&gt; q;</code> 可以通过编译</p>
<p>但是当我们使用 <code>q.pop();</code> 编译器报错</p>
<p>这说明编译器对模板不会进行一个全面的、完整的检测</p>
<p>只有当你用到时才会进行检测</p>
<h2 id="九、stack"><a href="#九、stack" class="headerlink" title="九、stack"></a>九、stack</h2><h2 id="十、Red-Black-tree"><a href="#十、Red-Black-tree" class="headerlink" title="十、Red-Black tree"></a>十、Red-Black tree</h2><p>关联式容器甚至可以看做一个小型数据库</p>
<p>关联式容器的两个重要的底层数据结构：红黑树和哈希表</p>
<p>红黑树就是一颗高度平衡的二叉搜索树</p>
<p>红黑树提供遍历操作和迭代器</p>
<p>编译器会将 size &#x3D; 0 的class 的size 设为 1</p>
<p>同 link，rb_tree 也设置了一个空节点实现前闭后开区间。</p>
<p>红黑树有【元素自动排序】特性</p>
<p>value[key,date]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; s; </span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : s)    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::value_type x = <span class="number">23.2332</span>;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::key_type y = <span class="number">2.3232</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::value_type p = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::value_type::first_type px = <span class="number">1</span>;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::value_type::second_type py = <span class="number">2</span>;</span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">char</span>&gt;::key_type c1 = <span class="number">65</span>;</span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">char</span>&gt;::mapped_type c2 = <span class="number">97</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; p.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; px &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; py &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c2 &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">test1</span>();</span><br><span class="line">    <span class="built_in">test2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="十一、hashtable"><a href="#十一、hashtable" class="headerlink" title="十一、hashtable"></a>十一、hashtable</h2><p>hashtable 中有很多经验值</p>
<p>经验法则：如果某个 bucket 的元素个数比 bucket 的个数还要多，就要两倍扩充 bucket 并重新放入元素（rehashing）。</p>
<h2 id="十二、-STL-六大部件"><a href="#十二、-STL-六大部件" class="headerlink" title="十二、 STL 六大部件"></a>十二、 STL 六大部件</h2><p>容器替我们处理了内存分配上的问题，我们只管往容器里面添加删除元素，至于数据在内存上是怎样分配的，容器替我们解决了。</p>
<p>容器本身并不能处理内存，它是通过分配器来实现内存的分配与回收的。</p>
<p>算法通过迭代器操作容器。</p>
<ol>
<li>容器</li>
<li>分配器</li>
<li>算法</li>
<li>迭代器</li>
<li>仿函数</li>
<li>适配器</li>
</ol>
<h2 id="十三、新添加待处理"><a href="#十三、新添加待处理" class="headerlink" title="十三、新添加待处理"></a>十三、新添加待处理</h2><p>ctor 有必要添加</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Base() &#123;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> val) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> val) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;   <span class="comment">// wrong</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>Explicitly specializer:全特化</p>
<hr>
<p>模版别名。</p>
<p>typedef 不可以使用参数</p>
<p>define 虽然可以指定参数，但是必须用（）包围起来，而我们希望使用 &lt;&gt; 包围起来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> v(T) vector<span class="string">&lt;T&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> vec = vector&lt;pair&lt;T,T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">v</span>(<span class="type">int</span>) a; <span class="comment">// 很奇怪</span></span><br><span class="line">    vec&lt;pair&lt;<span class="type">double</span>,<span class="type">double</span>&gt;&gt; v;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(Container c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从容器中取出迭代器</span></span><br><span class="line">    <span class="comment">// 每个迭代器都有一个 value_type</span></span><br><span class="line">    <span class="comment">// 通过 value_type 就可以得到容器元素的类型</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;<span class="keyword">typename</span> Container::iterator&gt;::value_type Valtype;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">        c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(), i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : c)    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">            <span class="keyword">typename</span> Container</span><br><span class="line">        &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container&lt;T&gt; c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">        c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(), i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : c)    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    C&lt;<span class="type">int</span>, vector&gt; c;</span><br><span class="line">    <span class="comment">// C&lt;int, list&gt; c;</span></span><br><span class="line">    <span class="comment">// C&lt;int, queue&gt; c;</span></span><br><span class="line">    <span class="comment">// C&lt;int, map&gt; c;</span></span><br><span class="line">    <span class="comment">// C&lt;int, set&gt; c;</span></span><br><span class="line">    <span class="comment">// C&lt;int, stack&gt; c;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/409436201">模板模板参数</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T a, b;</span><br><span class="line">    <span class="built_in">Foo</span>() &#123;</span><br><span class="line">        a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Ctor for Foo::&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dtor for Foo::&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">            <span class="keyword">class</span> <span class="title class_">Container</span></span><br><span class="line">        &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Foo&lt;T&gt; c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Ctor for C&quot;</span> &lt;&lt; endl;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;begin\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; c.a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c.b &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;end\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">            <span class="keyword">class</span> <span class="title class_">Container</span></span><br><span class="line">        &gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Container&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// f(Foo&lt;int&gt;());</span></span><br><span class="line">    C&lt;<span class="type">int</span>, Foo&gt; c;</span><br><span class="line">    c.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<p>stl</p>
<p>traits：特征，特性</p>
<p>萃取机。</p>
<p>你丢给他某个东西，它可以萃取出这个东西的某些特征。</p>
<p>associated type:</p>
<blockquote>
<p>category</p>
<p>Value_type</p>
<p>Difference_type</p>
<p>pointer</p>
<p>reference</p>
</blockquote>
<p>中间件 for：</p>
<blockquote>
<p>class iterator</p>
<p>Native pointer</p>
<p>const native pointer</p>
</blockquote>
<p>算法所需要的信息：主要是迭代器的是怎么移动的（方向，大小）</p>
<p>虽然虽然可以直接向迭代器询问，迭代器也可以直接回答，但是如果迭代器不是一个 class，即迭代器如果是一个 native point 的话，他就没有 associate type（5个type），也就无法回答。这时候我们需要一个中间层（trait）来回答算法的询问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator_traits&lt;iterator&gt;::type;</span><br></pre></td></tr></table></figure>

<p>Bidirectional:双向</p>
<hr>
<p>typeid</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line">typeid(type).name();</span><br></pre></td></tr></table></figure>

<p>给 typeid 传入一个 type（typeid(type)），他就会生成一个对象，这个对象有 name() 方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out_tag</span><span class="params">(random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;random_access_iterator&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out_tag</span><span class="params">(bidirectional_iterator_tag)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;bidrectional_iterator_tag&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out_tag</span><span class="params">(forward_iterator_tag)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;forward_iterator_tag&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Itr&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out</span><span class="params">(Itr iter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;Itr&gt;::iterator_category category_obj;</span><br><span class="line">    <span class="built_in">out_tag</span>(category_obj);</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Itr&gt;::iterator_category category_type;</span><br><span class="line">    <span class="built_in">out_tag</span>(<span class="built_in">category_type</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;typeid: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(category_obj).<span class="built_in">name</span>() &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;typeid: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(<span class="built_in">category_type</span>()).<span class="built_in">name</span>() &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">out</span>(vector&lt;<span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    <span class="built_in">out</span>(set&lt;<span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    <span class="built_in">out</span>(multiset&lt;<span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    <span class="built_in">out</span>(unordered_set&lt;<span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Base b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;you call f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(Base *b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;you call g(*)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    <span class="built_in">f</span>(d);</span><br><span class="line">    Base *b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="built_in">g</span>(b);</span><br><span class="line">    Derived *pd = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="built_in">g</span>(pd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 继承表示 is-a 关系</span></span><br><span class="line"><span class="comment">因此可以把子类放到父类里面(子类 is-a 父类)*/</span></span><br></pre></td></tr></table></figure>



<hr>
<p>11 个算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">Myclass</span>() &#123; cout &lt;&lt; <span class="string">&quot;Myclass&quot;</span> &lt;&lt; endl; val = <span class="number">0</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Myclass</span>() &#123; cout &lt;&lt; <span class="string">&quot;Dtor for Myclass&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mystruct</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;Mstruct;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">Myclass</span>()); <span class="comment">// 生成一个临时对象，在 main 函数结束之前便结束</span></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), Mstruct);</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main-end&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. accumulate 累计(不是累加，因为还可以指定其他运算方式)</span></span><br><span class="line"><span class="comment">** 指定运算操作时，如果我们传入的是一个函数，那么直接传递函数名即可，</span></span><br><span class="line"><span class="comment">    因为此时相当于我们传入了一个函数指针，函数指针可以类似于函数直接调用。</span></span><br><span class="line"><span class="comment">    例如：void (*ptr)() = &amp;func;</span></span><br><span class="line"><span class="comment">          ptr(); // &lt;==&gt; func();</span></span><br><span class="line"><span class="comment">    但如果我们传入的是一个重载了 () 的函数对象</span></span><br><span class="line"><span class="comment">    我们就必须穿入一个对象，因为只有 class 被实例化为一个 object，</span></span><br><span class="line"><span class="comment">    才能调用它自己的成员函数。</span></span><br><span class="line"><span class="comment">    例如： struct Myclass &#123;</span></span><br><span class="line"><span class="comment">                int operator(int x, int y) &#123; return x + y; &#125;</span></span><br><span class="line"><span class="comment">            &#125;myobj;</span></span><br><span class="line"><span class="comment">            class Myclass &#123; </span></span><br><span class="line"><span class="comment">                int operator(int x, int y) &#123; return x + y; &#125;</span></span><br><span class="line"><span class="comment">            &#125;;</span></span><br><span class="line"><span class="comment">            直接传入 myobj 或者 myclass() 即可，</span></span><br><span class="line"><span class="comment">    如果成员函数是一个模版，还需要指定 &lt;type&gt;</span></span><br><span class="line"><span class="comment">    例如：标准库的 minus</span></span><br><span class="line"><span class="comment">            此时我们传入 minus&lt;int&gt;(); // 传入一个临时对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  2. for_each()</span></span><br><span class="line"><span class="comment">**  例如：</span></span><br><span class="line"><span class="comment">        void func(int x)&#123; cout &lt;&lt; x &lt;&lt; &#x27; &#x27;; &#125;</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt; a&#123;1, 2, 3&#125;;   </span></span><br><span class="line"><span class="comment">        for_each(a.begin(), a.end(), func); // 1 2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  3. replace, replace_if, replace_copy</span></span><br><span class="line"><span class="comment">        count, count_if</span></span><br><span class="line"><span class="comment">    ``` c++</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; a&#123;1, 4, 3, 4, 5&#125;;</span></span><br><span class="line"><span class="comment">    replace(a.begin(), a.end(), 4, 10);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : a)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 1 10 3 10 5 </span></span><br><span class="line"><span class="comment">    replace_if(a.begin(), a.end(), bind2nd(less&lt;int&gt;(), 10), 0);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : a)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 0 10 0 10 0 </span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; b(a.size()); // 必须为 b 分配空间，copy 不会分配空间</span></span><br><span class="line"><span class="comment">    replace_copy(a.begin(), a.end(), b.begin(), 0, 1);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : b)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 1 10 1 10 1 </span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; c; // 或者使用 back_inserter</span></span><br><span class="line"><span class="comment">    replace_copy(a.begin(), a.end(), back_inserter(c), 0, 1);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : c)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 1 10 1 10 1 </span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include &lt;iterator&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">using namespace std;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/* 1. accumulate 累计(不是累加，因为还可以指定其他运算方式)</span></span><br><span class="line"><span class="comment">** 指定运算操作时，如果我们传入的是一个函数，那么直接传递函数名即可，</span></span><br><span class="line"><span class="comment">    因为此时相当于我们传入了一个函数指针，函数指针可以类似于函数直接调用。</span></span><br><span class="line"><span class="comment">    例如：void (*ptr)() = &amp;func;</span></span><br><span class="line"><span class="comment">          ptr(); // &lt;==&gt; func();</span></span><br><span class="line"><span class="comment">    但如果我们传入的是一个重载了 () 的函数对象</span></span><br><span class="line"><span class="comment">    我们就必须穿入一个对象，因为只有 class 被实例化为一个 object，</span></span><br><span class="line"><span class="comment">    才能调用它自己的成员函数。</span></span><br><span class="line"><span class="comment">    例如： struct Myclass &#123;</span></span><br><span class="line"><span class="comment">                int operator(int x, int y) &#123; return x + y; &#125;</span></span><br><span class="line"><span class="comment">            &#125;myobj;</span></span><br><span class="line"><span class="comment">            class Myclass &#123; </span></span><br><span class="line"><span class="comment">                int operator(int x, int y) &#123; return x + y; &#125;</span></span><br><span class="line"><span class="comment">            &#125;;</span></span><br><span class="line"><span class="comment">            直接传入 myobj 或者 myclass() 即可，</span></span><br><span class="line"><span class="comment">    如果成员函数是一个模版，还需要指定 &lt;type&gt;</span></span><br><span class="line"><span class="comment">    例如：标准库的 minus</span></span><br><span class="line"><span class="comment">            此时我们传入 minus&lt;int&gt;(); // 传入一个临时对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  2. for_each()</span></span><br><span class="line"><span class="comment">**  例如：</span></span><br><span class="line"><span class="comment">        void func(int x)&#123; cout &lt;&lt; x &lt;&lt; &#x27; &#x27;; &#125;</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt; a&#123;1, 2, 3&#125;;   </span></span><br><span class="line"><span class="comment">        for_each(a.begin(), a.end(), func); // 1 2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  3. replace, replace_if, replace_copy</span></span><br><span class="line"><span class="comment">        count, count_if</span></span><br><span class="line"><span class="comment">     c++</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; a&#123;1, 4, 3, 4, 5&#125;;</span></span><br><span class="line"><span class="comment">    replace(a.begin(), a.end(), 4, 10);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : a)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 1 10 3 10 5 </span></span><br><span class="line"><span class="comment">    replace_if(a.begin(), a.end(), bind2nd(less&lt;int&gt;(), 10), 0);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : a)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 0 10 0 10 0 </span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; b(a.size()); // 必须为 b 分配空间，copy 不会分配空间</span></span><br><span class="line"><span class="comment">    replace_copy(a.begin(), a.end(), b.begin(), 0, 1);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : b)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 1 10 1 10 1 </span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; c; // 或者使用 back_inserter</span></span><br><span class="line"><span class="comment">    replace_copy(a.begin(), a.end(), back_inserter(c), 0, 1);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : c)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 1 10 1 10 1 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    如果函数名后面跟着 _if 表示你要传入一个“条件”</span></span><br><span class="line"><span class="comment">    如果函数名后面跟着 _copy 表示你要传入一个 iterator 用来放置 copy 的元素</span></span><br><span class="line"><span class="comment">        并且作用结果不会作用到原迭代器身上，只是 copy 到新迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  4. find &amp; find_if -- 线性时间复杂度 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  5. sort</span></span><br><span class="line"><span class="comment">**   不要拿我们写的 cmp 用于 sort list 和 forward_list</span></span><br><span class="line"><span class="comment">      因为他们的地址不是连续的。而我们写的 cmp 是连续的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  6. binary_search</span></span><br><span class="line"><span class="comment">**   二分查找的前提是有序</span></span><br><span class="line"><span class="comment">     binary_search() 调用了 lower_bound()</span></span><br><span class="line"><span class="comment">     然后对 lower_bound 找到的位置进行比较</span></span><br><span class="line"><span class="comment">        first = lower_bound(first, val);</span></span><br><span class="line"><span class="comment">        return (first != last) &amp;&amp; (val &gt;= *first);</span></span><br><span class="line"><span class="comment">        // 我感觉后面的 val&gt;=*first 不太必要的，因为如果你 first != last 的话</span></span><br><span class="line"><span class="comment">            // 就说明你肯定找到了，既然找到了，那就应该是合理的！</span></span><br><span class="line"><span class="comment">                // 很奇怪，不知道为啥</span></span><br><span class="line"><span class="comment">     关于 lower/upper_bound</span></span><br><span class="line"><span class="comment">     候捷的解释：</span></span><br><span class="line"><span class="comment">        lower_bound 查找的是 在不改变原数据顺序的前提下</span></span><br><span class="line"><span class="comment">            插入元素可以放入的 最低点</span></span><br><span class="line"><span class="comment">        upper_bound 查找的是 在不改变原数据顺序的前提下</span></span><br><span class="line"><span class="comment">            插入元素可以放入的 最高点</span></span><br><span class="line"><span class="comment">     网络上一般的解释为：</span></span><br><span class="line"><span class="comment">        lower 查找 &lt;=</span></span><br><span class="line"><span class="comment">        upper 查找 &gt;</span></span><br><span class="line"><span class="comment">     其实一样，只不过说法不同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> begin = <span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(),<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> end = <span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(),<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; *begin &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; *end &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>adapter</p>
<ol>
<li>容器适配器</li>
<li>迭代器适配器</li>
<li>仿函数适配器</li>
</ol>
<p>一个对象 A 想拥有对象 B  的功能，有两种方式：</p>
<ol>
<li>inherit，继承</li>
<li>composition，复合</li>
</ol>
<p>adapter 是复合</p>
<p>typedef:</p>
<p>binary_function</p>
<ol>
<li>first_arguement_type</li>
<li>second_arguement_type</li>
<li>result_type</li>
</ol>
<p>unary_function</p>
<ol>
<li>Argument_type</li>
<li>Result_type</li>
</ol>
<p><code>typename + ()</code> 产生临时对象</p>
<p>借用函数模版的实参推导来完成类模板的实参。</p>
<blockquote>
<p>如果我们直接写类模板的实参 <code>&lt;&gt;</code>，我们可能不太好写出类型，我们可以添加一层中间层（函数模板），让函数模板来完成实参类型的推导，然后将类型传给类模板。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">typename</span> less&lt;<span class="type">int</span>&gt;::second_argument_type x = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">typename</span> less&lt;<span class="type">int</span>&gt;::first_argument_type y = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">typename</span> less&lt;<span class="type">int</span>&gt;::result_type z = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>);</span><br><span class="line">    binder2nd&lt;less&lt;<span class="type">int</span>&gt;&gt; b2;  <span class="comment">// wrong，已经弃用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Argument 并无参数的意思，之所以被拿来做(参数、变量)的意思是历史原因。</p>
<hr>
<p>bind</p>
<p>取代了 bind2nd, binder2nd, bind1st, binder1st</p>
<p>没写构造函数也可以用 <code>&#123;&#125;</code> 初始化</p>
<p>placeholoders</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">typename</span> less&lt;<span class="type">int</span>&gt;::second_argument_type x = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">typename</span> less&lt;<span class="type">int</span>&gt;::first_argument_type y = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">typename</span> less&lt;<span class="type">int</span>&gt;::result_type z = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// binder2nd&lt;less&lt;int&gt;&gt; b2;  // wrong，已经弃用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">my_divide</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// _1, _2。。 在 std::placeholders 里面</span></span><br><span class="line">    <span class="comment">// auto f1 = bind(my_divide, std::placeholders::_1, std::placeholders::_2);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; f1(10, 2) &lt;&lt; endl;   // 5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// auto f2 = bind(my_divide, std::placeholders::_2, std::placeholders::_1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; f2(10, 2) &lt;&lt; endl;   // 0.5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// auto f3 = bind(my_divide, 10, std::placeholders::_1);   // 这里 10 被绑定到第一个参数</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; f3(200) &lt;&lt; endl;  // 10 / 200</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// auto f5 = bind(my_divide, std::placeholders::_1, 10);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; f5(100) &lt;&lt; endl;    // 10</span></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    <span class="comment">/*  --  */</span></span><br><span class="line">    <span class="comment">/* 占位符_n会选择 [我们传入的] 第n个参数 */</span></span><br><span class="line">    <span class="keyword">auto</span> f4 = <span class="built_in">bind</span>(my_divide, <span class="number">10</span>, std::placeholders::_2);   <span class="comment">// 这里 10 被绑定到第一个参数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f4</span>(<span class="number">3</span>,<span class="number">2</span>) &lt;&lt; endl;   <span class="comment">// 3.33，选择我们传入的第二个参数2</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">auto</span> f6 = <span class="built_in">bind</span>(my_divide, std::placeholders::_2, <span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f6</span>(<span class="number">3</span>,<span class="number">5</span>) &lt;&lt; endl;    <span class="comment">// 5 / 10，选择我们传入的第二个参数5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test3</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">C note</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-15 20:20:57 / Modified: 20:27:36" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C和指针"><a href="#C和指针" class="headerlink" title="C和指针"></a>C和指针</h1><h2 id="1-宏函数与自定义函数"><a href="#1-宏函数与自定义函数" class="headerlink" title="1. 宏函数与自定义函数"></a>1. 宏函数与自定义函数</h2><p>宏函数与自定义函数是对立的，宏函数的优点就是自定义函数的缺点，自定义函数的缺点就是宏函数的优点。<br>宏函数的优点：1·执行效率高  2·节省空间<br>宏函数的缺点：1编译时间长   2·不安全，没有语法检查</p>
<p>因为宏函数在编译时直接展开，所以不像自定义函数一样需要进行函数调用，因此宏函数运行时没有通过函数名找到函数的入口地址，保存返回地址，为形参分配空间，实参分配给形参，形参入栈等操作。因此步骤少，并且不需要在栈上分配额外空间。但因此宏函数需要在编译时替换，因此编译时间长。另外，宏函数也没有语法检查，不安全。</p>
<h2 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2. 关键字"></a>2. 关键字</h2><h3 id="2-1-extern，static"><a href="#2-1-extern，static" class="headerlink" title="2.1 extern，static"></a>2.1 extern，static</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//static int num = 100; // 1.static修饰全局变量，改变变量的作用域，只能在本文件中被调用，采用这种声明，编译1.c和2.c就会报错。</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">100</span>;  <span class="comment">// 声明并初始化一个变量，会分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span>;       <span class="comment">// 声明一个函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅声明变量num，但不初始化，否则就会为其分配内存</span></span><br><span class="line"><span class="comment">// extern表示该变量在别处定义并初始化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static void f()    // 2.static修饰函数，改变函数的作用域，只能在本文件中被调用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc 1.c 2.c -o main</span><br><span class="line">./main</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译多个文件时，要保证只有一个main函数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = <span class="number">0</span>; <span class="comment">// 3.static修饰局部变量，叫静态变量（存放在静态数据区），改变变量的生命周期，直到程序结束释放</span></span><br><span class="line">    <span class="comment">//int x = 0;</span></span><br><span class="line">    x ++ ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">    	Add();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-const"><a href="#2-2-const" class="headerlink" title="2.2 const"></a>2.2 const</h3><p>1.const 修饰普通变量即const修饰只读变量，不能通过变量本身修改变量的值，但可以通过其他方式(指针)修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)&amp;a;</span><br><span class="line">    *p ++ ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行上面的程序之后可以发现a的值仍然被修改了，所以说这也就说明了一个常见的误解，认为const修饰的就是常量，实际上并不是</p>
</blockquote>
<p>2.const修饰指针 （<strong>就近原则</strong>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向常量的指针</span></span><br><span class="line"><span class="comment">// 由于const和int的位置可以互换，所以可以忽略int，原式就成了 const *q，const距离*最近，因此const修饰的是*q</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *q = &amp;a;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *q = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针常量</span></span><br><span class="line"><span class="comment">// const距离q最近，因此const修饰的是q</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> q = &amp;a;</span><br></pre></td></tr></table></figure>

<p>3.const修饰函数形参</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">new_strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>((*dest ++ = *src++) != <span class="string">&#x27;\0&#x27;</span>)  ;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> d[<span class="number">20</span>] = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">20</span>] = <span class="string">&quot;newstr&quot;</span>;</span><br><span class="line">    new_strcpy(d, s);</span><br><span class="line">    <span class="built_in">puts</span>(d);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.const修饰函数的返回值</p>
<p>若函数的返回值是指针，且用const修饰，则函数返回值指向的内容是常数，不可被修改，此返回值仅能赋值给const修饰的相同类型的指针。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="title function_">f1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> * p;</span><br><span class="line">	p = new <span class="type">int</span>;</span><br><span class="line">	*p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *p; <span class="comment">// 改为int *p1;则编译时报错：“[8] error: invalid conversion from &#x27;const int*&#x27; to &#x27;int*&#x27;” (编译器code::block);</span></span><br><span class="line">    p = f1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若主函数改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> * p1;</span><br><span class="line">	p1 = f1();</span><br><span class="line">	*p1 = <span class="number">2</span>; <span class="comment">//则编译时报错：&quot;[10] error: assignment of read-only location &#x27;* p1&#x27;&quot;  (编译器code::block);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数返回值是数值（by value），因C++中，返回值会被复制到外部临时的存储单元中，故const 修饰是没有任何价值的。例：不要把函数int fun1() 写成const int func1()。<br>同理不要把函数A GetA(void) 写成const A GetA(void)，其中A 为用户自定义的数据类型。</p>
<p>如果返回值是对象，将函数A fun2() 改写为const A &amp; fun2()的确能提高效率。但此要注意，要确定函数究竟是想返回一个对象的“copy”,还是仅返回对象的“别名”即可，否则程序会出错。</p>
<h2 id="3-危险的指针"><a href="#3-危险的指针" class="headerlink" title="3. 危险的指针"></a>3. 危险的指针</h2><p><strong>警告⚠️：没有将一个free掉的指针置NULL</strong></p>
<p>一个指针被free之后，它仍然指向原来指向的内存区域。但是该空间的内容已经不再是之前的值了，已经释放掉了。</p>
<p>这时候的指针我们称为野指针。将它<strong>置为NULL</strong>后，可以防止被误用，同时也可以后续作为判断该指针是否已经释放的标记</p>
<h3 id="3-1-悬挂-悬空-指针"><a href="#3-1-悬挂-悬空-指针" class="headerlink" title="3.1 悬挂(悬空)指针"></a>3.1 悬挂(悬空)指针</h3><p>悬挂指针：当指针所指向的对象被释放，但是该指针没有任何改变，以至于其仍然指向已经被回收的内存地址，这种情况下该指针被称为悬挂指针；</p>
<h3 id="3-2-野指针"><a href="#3-2-野指针" class="headerlink" title="3.2 野指针"></a>3.2 野指针</h3><p>野指针：未初始化的指针被称为野指针。</p>
<h2 id="4-gcc编译器"><a href="#4-gcc编译器" class="headerlink" title="4. gcc编译器"></a>4. gcc编译器</h2><h3 id="4-1-编译过程"><a href="#4-1-编译过程" class="headerlink" title="4.1 编译过程"></a>4.1 编译过程</h3><h4 id="4-1-1-预处理"><a href="#4-1-1-预处理" class="headerlink" title="4.1.1 预处理"></a>4.1.1 预处理</h4><p>命令 <code>gcc -E x.c -o x.i</code> ，生成一个 <code>.i</code> 文件（预处理文件）</p>
<p>预处理就是处理所有<code>#</code> 开头的行，即展开头文件和宏定义和条件编译。</p>
<p>其中 <code>#include &lt;stdio.h&gt;</code> 中的 <code>&lt;&gt;</code> 表示在系统里面找 <code>stdio.h</code> 文件。在 <code>/usr/include</code> 目录下有很多头文件。</p>
<h4 id="4-1-2-编译"><a href="#4-1-2-编译" class="headerlink" title="4.1.2 编译"></a>4.1.2 编译</h4><p>命令 <code>gcc -S x.i -o x.s</code> ，生成一个<code>.s</code> 文件（汇编文件）</p>
<h4 id="4-1-3-汇编"><a href="#4-1-3-汇编" class="headerlink" title="4.1.3 汇编"></a>4.1.3 汇编</h4><p>命令 <code>gcc -c x.s -o x.o</code> ，生成一个<code>.o</code> 文件（二进制文件）</p>
<h4 id="4-1-4-链接"><a href="#4-1-4-链接" class="headerlink" title="4.1.4 链接"></a>4.1.4 链接</h4><p>生成一个可执行二进制文件。默认链接方式是动态链接。</p>
<p>对于一条语句 <code>printf(&quot;xxx&quot;)</code> ，动态链接会链接 printf 的位置信息，静态链接会链接 printf  的具体实现。因此，静态链接的文件大小比静态链接的文件大得多。但是静态链接对环境的依赖比动态链接要小，加入系统中不存在 printf 的实现，那么动态链接就无法执行。</p>
<h3 id="4-2-其它常用参数"><a href="#4-2-其它常用参数" class="headerlink" title="4.2 其它常用参数"></a>4.2 其它常用参数</h3><ul>
<li>-g：在可执行程序中包含标准调试信息。</li>
<li>-v：打印出编译器内部个过程的命令行信息和编译器的版本</li>
<li>-I dir：在头文件的搜索路径列表中添加 dir 目录</li>
<li>-L dir：在库文件的搜索路径列表中添加 dir 目录</li>
<li>-static：链接静态库</li>
<li>-l library：链接名为 library 的库文件</li>
</ul>
<h3 id="4-3-静态库"><a href="#4-3-静态库" class="headerlink" title="4.3 静态库"></a>4.3 静态库</h3><p>静态库文件格式：<code>.a</code>  结尾，<code>lib</code>  开头。</p>
<p>创建静态库文件步骤：</p>
<ol>
<li>写源文件，通过 <code>gcc -c xxx.c</code> 生成目标文件。</li>
<li>用 <code>ar</code> 归档目标文件，生成静态库。具体位为：<code>ar -crv libname.a lib1.o lib2.o</code>，执行该命令即可创建名为 <code>name</code> 的静态库。</li>
</ol>
<p>上述命令中 crv 是 ar的命令选项：</p>
<ul>
<li>c 如果需要生成新的库文件，不要警告</li>
<li>r 代替库中现有的文件或者插入新的文件</li>
<li>v 输出详细信息</li>
</ul>
<p>创建静态库举例：</p>
<p>f1.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;this is f1...\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>f2.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;this is f1...\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f1</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	f1();</span><br><span class="line">	f2();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 <code>f1.c</code>, <code> f2.c</code>为源文件创建静态库:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c f1.c f2.c  #生成目标文件f1.o f2.o</span><br><span class="line">ar -crv libmylib.a f1.o f2.o</span><br></pre></td></tr></table></figure>

<p>链接静态库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main -staic -l mylib -L .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虽然静态库文件为：libmylib.a，但是该静态库的名字是 mylib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-l mylib 表示链接名为 mylib 的静态库</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-L . 表示将当前目录添加到搜索静态库文件的目录</span></span><br></pre></td></tr></table></figure>



<h3 id="4-4-动态库"><a href="#4-4-动态库" class="headerlink" title="4.4 动态库"></a>4.4 动态库</h3><p>动态库文件格式：<code>.so</code> 结尾</p>
<p>创建并链接动态库：</p>
<ol>
<li><code>gcc -fPIC -shared -o libxxx.so xx1.c xx2.c</code></li>
<li><code>gcc main.c -o main -L . -l xxx</code></li>
</ol>
<blockquote>
<p>fPIC 作用于编译阶段，告诉编译器产生与位置无关代码(Position-Independent Code)，<strong>则产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意位置，都可以正确的执行。</strong>这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。</p>
<p>PIC就是position independent code</p>
<p>PIC使.so文件的代码段变为真正意义上的共享</p>
<p><strong>如果不加 -fPIC,则加载 .so文件的代码段时,代码段引用的数据对象需要重定位, 重定位会修改代码段的内容,这就造成每个使用这个 .so文件代码段的进程在内核里都会生成这个 .so文件代码段的copy.每个 copy都不一样,取决于这个 .so文件代码段和数据段内存映射的位置.</strong></p>
<p><strong>不加 fPIC编译出来的 so,是要再加载时根据加载到的位置再次重定位的.(因为它里面的代码并不是位置无关代码)</strong></p>
<p>如果被多个应用程序共同使用,那么它们必须每个程序维护一份so的代码副本了.(因为so被每个程序加载的位置都不同,显然这些重定位后的代码也不同,当然不能共享)<br>我们总是用fPIC来生成so,也从来不用fPIC来生成a.<br>fPIC与动态链接可以说基本没有关系,libc.so一样可以不用fPIC编译,只是这样的so必须要在加载到用户程序的地址空间时重定向所有表目.</p>
<p>因此,不用fPIC编译so并不总是不好.<br>如果你满足以下4个需求&#x2F;条件:<br>1.该库可能需要经常更新<br>2.该库需要非常高的效率(尤其是有很多全局量的使用时)<br>3.该库并不很大.<br>4.该库基本不需要被多个应用程序共享</p>
<p>如果用没有加这个参数的编译后的共享库，也可以使用的话，可能是两个原因：<br>1：gcc默认开启-fPIC选项<br>2：loader使你的代码位置无关</p>
<p>从GCC来看，shared应该是包含fPIC选项的，但似乎不是所以系统都支持，所以最好显式加上fPIC选项。</p>
</blockquote>
<p>还是上面的三个文件。执行完上述两个操作之后，执行 <code>./main</code> ，报错：<code>./main: error while loading shared libraries: libmylib.so: cannot open shared object file: No such file or directory</code></p>
<p>这是因为链接动态库虽然是在当前目录下链接的，但是在程序执行的时候并不在当前目录下找，我们可以用命令 <code>ldd main</code> 查看 <code>main</code> 程序在哪里寻找动态库。</p>
<blockquote>
<p>ldd命令用于查看二进制文件所有用到的动态库在哪</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">linux-vdso.so.1 (0x00007ffc4edf3000)</span><br><span class="line">libmylib.so =&gt; not found</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f23af86c000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f23afa6e000)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  可以看到，我们的动态库 <code>libmylib.so</code> 显示 <code>not found</code>，而系统自带的动态库 <code>libc.so.6</code> 在目录 <code>/lib/x86_64-linux-gnu/</code> 下。</p>
<p>因此我们只需要把 <code>libmylib.so</code> 复制到该目录下即可：<code>sudo cp libmylib.so /lib/x86_64-linux-gnu/</code>，然后 <code>main</code> 程序就可以正常执行了。</p>
<h2 id="5-sizeof-产生的问题"><a href="#5-sizeof-产生的问题" class="headerlink" title="5. sizeof 产生的问题"></a>5. sizeof 产生的问题</h2><h3 id="5-1-仍然需要加括号的情况"><a href="#5-1-仍然需要加括号的情况" class="headerlink" title="5.1 仍然需要加括号的情况"></a>5.1 仍然需要加括号的情况</h3><p>首先，sizeof是一个<strong>关键字</strong>而不是一个函数。其次，当我们用sizeof求字节长度时，最好加上括号，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>；</span></span><br><span class="line"><span class="class">// 上面的代码编译起就会报错，因为他被解释为:</span><span class="keyword">sizeof</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class"><span class="title">sizeof</span> <span class="title">a</span> + 1</span></span><br><span class="line"><span class="class">// 会被解释为:</span> <span class="keyword">sizeof</span>(a) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 而不是 sizeof(a + 1)</span></span><br></pre></td></tr></table></figure>

<p>所以说为了避免由于优先级问题导致的二义性，还是加上括号吧！</p>
<p>另外，看下面的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="number">0</span> == <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="keyword">sizeof</span>(a = <span class="number">4</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-sizeof到底是什么"><a href="#5-2-sizeof到底是什么" class="headerlink" title="5.2 sizeof到底是什么"></a>5.2 sizeof到底是什么</h3><p>网上有人说sizeof是一个操作符，但我觉得它更像一个<strong>特殊的宏</strong>，因为它是在编译阶段求值的。</p>
<p>在上面的例子中，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="number">0</span> == <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="keyword">sizeof</span>(a = <span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<p>在编译阶段会被翻译为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="number">4</span>;   </span><br></pre></td></tr></table></figure>

<p>因为C语言中没有bool类型，而是以int类型表示，所以</p>
<p><code>sizeof(0 == 1)</code> 就相当于 <code>sizeof(int)</code></p>
<p>并且我们在第二条语句中令a&#x3D;4，但输出的仍然是1，这说明a的值没有被改变，并且<code>sizeof(a=4)</code>被解释为<code>sizeof(int)</code></p>
<p>其原因就在于sizeof在编译阶段处理的特性。由于sizeof不能被编译成机器码，所以sizeof作用范围内，也就是()里面的内容也不能被编译，而是被替换成类型。&#x3D;操作符返回左操作数的类型，所以a&#x3D;3相当于int.</p>
<h3 id="5-3-总结"><a href="#5-3-总结" class="headerlink" title="5.3 总结"></a>5.3 总结</h3><p>所以，sizeof是不可能支持链式表达式的，这也是和一元操作符不一样的地方。</p>
<p><strong>结论：不要把sizeof当成函数，也不要看作一元操作符，把他当成一个特殊的编译预处理。</strong></p>
<h2 id="6-内存管理"><a href="#6-内存管理" class="headerlink" title="6. 内存管理"></a>6. 内存管理</h2><h3 id="6-1-内存结构"><a href="#6-1-内存结构" class="headerlink" title="6.1 内存结构"></a>6.1 内存结构</h3><p>在实际的程序当中，我们操作的都是虚拟内存，而不是实际的物理内存（因为操作者不一定能正确操纵内存，如果直接操作物理内存，可能会导致操作系统死掉等问题）。</p>
<p>虚拟内存与物理内存之间是映射关系，虚拟内存映射一小部分物理内存。在linux中，虚拟内存一般是4g，默认按照1:3分配（可以调整）。1个g是内核态、另外3个g是用户态。</p>
<p>其中3个g一般又分为5块。</p>
<p><img src="https://pic1.zhimg.com/v2-db1beae537441e72682b5932b97770b0_1440w.jpg?source=172ae18b" alt="再谈应用程序分段： 数据段、代码段、BSS段以及堆和栈"></p>
<p>相关段总结如下。</p>
<table>
<thead>
<tr>
<th>段名</th>
<th>存储属性</th>
<th>内存分配</th>
</tr>
</thead>
<tbody><tr>
<td>代码段 .text</td>
<td>存放可执行程序的指令，存储态和运行态都有</td>
<td>静态</td>
</tr>
<tr>
<td>数据段 .data</td>
<td>存放已初始化（非零初始化的全局变量和静态局部变量）的数据，存储态和运行态都有</td>
<td>静态</td>
</tr>
<tr>
<td>bss段 .bss</td>
<td>存放未初始化（未初始化或者0初始化的全局变量和静态局部变量）的数据，存储态和运行态都有</td>
<td>静态</td>
</tr>
<tr>
<td>堆 heap</td>
<td>动态分配内存，需要通过malloc手动申请，free手动释放，适合大块内存。容易造成内存泄漏和内存碎片。运行态才有。由程序员手动申请。</td>
<td>动态</td>
</tr>
<tr>
<td>栈 stack</td>
<td>存放函数局部变量和参数以及返回值，函数返回后，由操作系统立即回收。栈空间不大，使用不当容易栈溢出。运行态才有。系统自动分配。</td>
<td>静态</td>
</tr>
</tbody></table>
<p>看下面的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s1[size] = <span class="string">&quot;hello,world!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *s2 = <span class="string">&quot;hello,world!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *s3 = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码中，s1，s2，s3都是局部变量，s1是一个数组，s2，s3是一个指针，其本身被分配在栈中。</p>
<p>但是s2中的“hello，world！”是一个字符串常量，其也占用内存，并且分配在数据段，s2指向这个字符串常量的地址。</p>
<p>s3中malloc分配的大小为128字节的内存在堆中，s3指向堆中分配的这块内存。</p>
<p>可以看出，同样是局部变量，s1只占用了一块内存，而s2，s3占用了两块内存。</p>
</blockquote>
<h3 id="6-2-堆和栈的区别"><a href="#6-2-堆和栈的区别" class="headerlink" title="6.2 堆和栈的区别"></a>6.2 堆和栈的区别</h3><ol>
<li>管理方式不同：堆由程序员管理，栈由系统管理。</li>
<li>空间大小不同：栈的空间比较小，堆的空间比较大。</li>
<li>是否产生碎片：堆由于malloc&#x2F;new，从而产生大量的碎片，使程序效率降低（虽然程序结束后操作系统会对内存进行回收管理），对于栈来讲，内存连续分配，则不存在这个问题。</li>
<li>增长方向不同：栈向下（低地址）增长，堆向上（高地址）增长。</li>
<li>分配效率不同：栈是极其系统提供的数据结构，计算机会在底层对栈提供支持，分配专门的寄存器存放栈的地址，压栈出zhan都有专门的指令执行。堆则是C函数库提供的，它的机制很复杂，例如为了分配一块内存，库函数会按照一定的算法，在堆内存中搜索可用的，足够大的空间，如果没有（可能是由于内存碎片太多），就有需要操作系统来重新整理内存空间，这样就有机会分到足够大的内存，然后返回。显然，堆的效率比栈要低得多。</li>
<li>分配方式不同：堆都是程序中由malloc()函数动态申请分配并由free()函数释放的，栈的分配和释放是由编译器完成的，栈的动态分配由alloca()函数完成，但是栈的动态分配是和堆不同的，它的动态分配是由编译器完成申请和释放的，无需手工实现。</li>
</ol>
<h3 id="6-3-常见内存错误及对策"><a href="#6-3-常见内存错误及对策" class="headerlink" title="6. 3 常见内存错误及对策"></a>6. 3 常见内存错误及对策</h3><ol>
<li>指针没有指向一块合法的内存（野指针）：例如声明了一个指针但没有初始化就使用这个指针。</li>
<li>为指针分配的内存太小：例如为字符串str，malloc内存时，大小为strlen(str)+1，如果没有+1，malloc的大小就不够。</li>
<li>内存分配成功但未初始化：对于未初始化的指针，其值是未定义的。可以使用memset初始化。</li>
<li>内存越界：段错误。</li>
<li>内存泄露：没有释放掉分配的内存。</li>
<li>内存释放之后：虽然内存释放了，但是指针仍然指向该内存，所以要将指针置为空吗，否则就会变为野指针。free(p)释放的是p指向的内存，而不是p本身。</li>
<li>内存已经释放，但是继续通过指针来使用：分为堆释放（使用已经free掉内存的指针），栈释放（返回一个局部变量的地址）。</li>
</ol>
<h2 id="7-可变参数"><a href="#7-可变参数" class="headerlink" title="7. 可变参数"></a>7. 可变参数</h2><h3 id="7-1-带可变参数的函数由来"><a href="#7-1-带可变参数的函数由来" class="headerlink" title="7.1 带可变参数的函数由来"></a>7.1 带可变参数的函数由来</h3><p>当<strong>函数中的参数个数不确定</strong>时，这时候就需要带可变参数的函数！<br>如我们经常使用的C库函数printf()实际就是一个可变参数的函数，<br><strong>其原型为：</strong></p>
<p>int printf( const char* format, …);</p>
<p>它除了有一个参数format固定以外,后面跟的参数的个数和类型是可变的。例如我们可以有以下不同的调用方法：</p>
<p>printf( “%d “,i); printf( “%s “,s); printf( “the number is %d ,string is:%s “, i, s);</p>
<h3 id="7-2-带可变参数函数的实现"><a href="#7-2-带可变参数函数的实现" class="headerlink" title="7.2 带可变参数函数的实现"></a>7.2 带可变参数函数的实现</h3><h4 id="7-2-1-原理"><a href="#7-2-1-原理" class="headerlink" title="7.2.1 原理"></a>7.2.1 原理</h4><ul>
<li>使用了<strong>指针参数</strong>来解决参数的可变问题，指针参数随着其移动指向不同的参数；</li>
<li>C语言的函数形参是从右向左压入堆栈的，以保证栈顶是第一个参数。</li>
</ul>
<p>C语言标准库中头文件stdarg.h索引的接口包含了一组能够遍历变长参数列表的宏。<br>头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br></pre></td></tr></table></figure>



<h4 id="7-2-2-几个宏"><a href="#7-2-2-几个宏" class="headerlink" title="7.2.2 几个宏"></a>7.2.2 几个宏</h4><p>(1). <strong>va_list</strong> 定义一个指针<br>用来<strong>定义</strong>一个<strong>表示参数表中各个参数</strong>的<strong>变量</strong>，即定义了一个指向参数的指针， 用于指示可选的参数.<br>如：<strong>va_list ap</strong>;<br>(2). <strong>va_start(ap,v)</strong> 初始化指针<br>使参数列表指针<strong>ap</strong>指向函数参数列表中的第一个<strong>可选参数</strong>，<strong>v</strong>是位于第一个可选参数之前的<strong>固定参数</strong>, 或者说最后一个固定参数.通常用于指定可变参数列表中参数的个数！<br>如有一va函数的声明是void va_test(char a, char b, char c, …), 则它的固定参数依次是a,b,c, 最后一个固定参数v为c, 因此就是va_start(<strong>ap</strong>, c).</p>
<p>(3). va_arg(<strong>ap</strong>, type) 返回参数列表中指针<strong>ap</strong>所指的参数, 返回类型为type. <strong>并使指针ap指向参数列表中下一个参数</strong>.返回的是可选参数, 不包括固定参数.</p>
<p>(4). va_end(<strong>ap</strong>) 清空参数列表, 并置参数指针arg_ptr无效.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simple_va_fun</span><span class="params">(<span class="type">int</span> i,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	va_list arg_ptr; <span class="comment">//定义可变参数指针</span></span><br><span class="line">	<span class="built_in">va_start</span>(arg_ptr,i); <span class="comment">// i为最后一个固定参数</span></span><br><span class="line">	<span class="type">int</span> j = <span class="built_in">va_arg</span>(arg_ptr,<span class="type">int</span>); <span class="comment">//返回第一个可变参数，类型为int</span></span><br><span class="line">	<span class="type">char</span> c = <span class="built_in">va_arg</span>(arg_ptr,<span class="type">char</span>); <span class="comment">//返回第二个可变参数，类型为char</span></span><br><span class="line">	<span class="built_in">va_end</span>(arg_ptr); <span class="comment">// 清空参数指针</span></span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">&quot;%d %d %c\n&quot;</span>,i,j,c);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">simple_va_fun</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">simple_va_fun</span>(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">simple_va_fun</span>(<span class="number">100</span>,<span class="number">200</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出为</span></span><br><span class="line"><span class="comment">100 4193388 ?100 200 ?100 200 a</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>




<h4 id="7-2-3-思路"><a href="#7-2-3-思路" class="headerlink" title="7.2.3 思路"></a>7.2.3 思路</h4><p>（1）首先在函数里定义一个va_list型的变量,这里是arg_ptr,这个变量是指向参数的指针.</p>
<p>（2）然后用va_start宏初始化变量arg_ptr,这个宏的第二个参数是第一个可变参数的前一个参数,是一个固定的参数.<br>（3）然后用va_arg返回第一个可变的参数,并赋值给整数j。va_arg的第二个参数是你要返回的参数的类型,这里是int型. 返回第一个可变参数后arg_ptr指向第二个可变参数，用同样的方法返回并赋值给c，类型为char类型。<br>（4）最后用va_end宏结束可变参数的获取。<br><strong>小结：</strong><br>可变参数的函数原理其实很简单,而va系列是以宏定义来定义的,实现跟堆栈相关.我们写一个可变函数的C函数时,有利也有弊,所以在不必要的场合,我们无需用到可变参数.如果在C++里,我们应该利用C++的多态性来实现可变参数的功能,尽量避免用C语言的方式来实现。</p>
<h1 id="指针专题"><a href="#指针专题" class="headerlink" title="指针专题"></a>指针专题</h1><h2 id="1-指针简介"><a href="#1-指针简介" class="headerlink" title="1. 指针简介"></a>1. 指针简介</h2><h3 id="1-1-指针的声明"><a href="#1-1-指针的声明" class="headerlink" title="1.1 指针的声明"></a>1.1 指针的声明</h3><p>指针的标准写法：<code>type* p;</code>	<br>常见的不标准的写法：<code>type *p = &amp;a;</code></p>
<blockquote>
<p>在不标准的写法中，我们常常会把 解引用符号（*）与变量名联系在一起，这就导致了一些直观上的不舒服？。</p>
<p>例如代码：<code>int *p = &amp;a;</code> 我们会自觉的把等号左边分成两个部分，类型和变量名，如果把 <code>*</code> 和变量名连在一起，那么看上去就好像是把 <code>a</code> 的地址放到了<code>*p</code> 里面，而类型也变成了 <code>int</code> 而不是 <code>int*</code>。</p>
<p>但如果我们写成：<code>int* p = &amp;a;</code> 这样看起来就很舒服了，<code>a</code> 的地址存放在了指针变量 <code>p</code> 中，<code>p</code> 它就是一个变量，它存储的是 <code>a</code> 的地址，而 <code>*p</code> 表示解引用指针变量 <code>p</code> 里面的地址，得到该地址存放的值。</p>
</blockquote>
<p>所以说，推荐写成标准的形式，看起来更舒服！</p>
<h3 id="1-2-指针的常识"><a href="#1-2-指针的常识" class="headerlink" title="1.2 指针的常识"></a>1.2 指针的常识</h3><ol>
<li><strong>指针是不占用内存空间的</strong>，其本身是地址，地址怎么会占内存空间。<strong>指针变量才占用内存空间。</strong></li>
<li>当我们仅使用数组名时，返回的是<strong>数组首元素的地址</strong>。</li>
<li>函数用来指向或引用内存中的数据（变量或常量）。</li>
<li>指针是由地址的，指针的地址不等同于指针变量的地址。</li>
</ol>
<h3 id="1-3-指针的算术运算"><a href="#1-3-指针的算术运算" class="headerlink" title="1.3 指针的算术运算"></a>1.3 指针的算术运算</h3><p>指针变量+&#x2F;-1：这里的1是指针类型的长度，而不是数字 1  </p>
<p>Code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl; 	   <span class="comment">// -&gt; x</span></span><br><span class="line">cout &lt;&lt; (p + <span class="number">1</span>) &lt;&lt; endl;  <span class="comment">// -&gt; x + sizeof(int)</span></span><br></pre></td></tr></table></figure>



<h2 id="2-输出char类型的地址"><a href="#2-输出char类型的地址" class="headerlink" title="2. 输出char类型的地址"></a>2. 输出char类型的地址</h2><p>在C++中，如果cout一个字符数组的话，那么它会沿着这个地址，一直输出这个字符串，直到遇到’\0’,例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>*c = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">输出的结果是：hello</span><br></pre></td></tr></table></figure>

<p>如果我们自作聪明的想输出第一个字符的地址，例如这样输出：</p>
<p><code> cout &lt;&lt; &amp;c[0] &lt;&lt; endl;</code></p>
<p>不幸的是，这样输出的结果依旧不是我们需要的地址。实际上输出结果仍然是整个字符串。</p>
<p>但是，如果我们回归到C语言的话，例如用printf的话，如下：</p>
<p> <code>printf(&quot;%x\n&quot;, &amp;c[0]);</code></p>
<p>幸福的事情发生了，输出的结果是：</p>
<p><code> 46f020</code></p>
<p>的确是字符串的首地址，但是，如果我们要输出字符串的地址，难道就这一种方法吗？难道我们就不可以用我们C++上的cout达到我们的效果吗？</p>
<p><strong>原因：</strong><strong><em>c是靠%s, %x, %p来区分指针表达式&amp;a[0]的输出形式的；c++没有这个格式控制，只能按一种形式输出，对char</em>类型的指针值就理解为串输出，所以必须对这个指针表达式做类型转换处理。</strong></p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;c:&quot;</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">输出的仍然不是字符变量c的地址，而是乱码。</span><br></pre></td></tr></table></figure>



<p>在C++中，字符串是以空终止符（’&#x2F;0’）结尾的字符数组，通过字符串中第一个字符的指针访问字符串。也就是说，字符串的值是字符串中第一个字符的（常量）地址。如下的面3种形式表示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str1  = <span class="string">&quot;string1&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;string2&quot;</span>;</span><br><span class="line"><span class="type">char</span> str3[] = &#123;<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;line 1:str1=&quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;line 2:str2=&quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;line 3:str3=&quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">line <span class="number">1</span>:str  = string1</span><br><span class="line">line <span class="number">2</span>:str2 = string2</span><br><span class="line">line <span class="number">3</span>:str3 = string3</span><br></pre></td></tr></table></figure>

<p>运行可知，这3行的输出就是保存的字符串的值，而并非我们认为的地址。那么，我们可以联系到前面&amp;c，其实这就是一个char *的变量，所以，输出的自然就应该是字符串的值。可是，&amp;c保存的字符串是没有终止符的，因此输出的也就是乱码了。</p>
<p>最近，在读到《C++程序设计教程》（第4版）第12章的时候，我才解决了这个疑惑。实际上，**C++标准库中I&#x2F;O类对输出操作符&lt;&lt;重载，在遇到字符型指针时会将其当做字符串名来处理，输出指针所指的字符串。既然这样，我们就别让他知道那是字符型指针，所以得进行类型转换，即：希望任何字符型的指针变量输出为地址的话，都要作一个转换，即强制char *转换成void *，**如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">&quot;static_cast&lt;void *&gt;(&amp;c)=&quot;</span>&lt;&lt;<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;c)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;static_cast&lt;void *&gt;(str)=&quot;</span>&lt;&lt;<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(str)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>此时，可以看到输出的结果就是char类型变量和字符串变量的地址了。</p>
<h2 id="3-为什么指针要使用强类型"><a href="#3-为什么指针要使用强类型" class="headerlink" title="3. 为什么指针要使用强类型"></a>3. 为什么指针要使用强类型</h2><h3 id="3-1-强类型语言和弱类型语言"><a href="#3-1-强类型语言和弱类型语言" class="headerlink" title="3.1 强类型语言和弱类型语言"></a>3.1 强类型语言和弱类型语言</h3><p><strong>强类型语言是一种强制类型定义的语言，即一旦某一个变量被定义类型，如果不经强制转换，那么它永远就是该数据类型。而弱类型语言是一种弱类型定义的语言，某一个变量被定义类型，该变量可以根据环境变化自动进行转换，不需要经过现行强制转换。</strong></p>
<p>其中</p>
<p>强类型语言包括：Java、.net、Python、C++等语言。其中Python是动态语言，是强类型定义语言，是类型安全的语言，Java是静态语言，是强类型定义语言，也是；类型安全的语言；</p>
<p>弱类型语言包括：VB，PHP，JavaScript等语言。其中VBScript是动态语言，是一种类型不安全的原因。</p>
<p><strong>举个栗子吧：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var A=5;</span><br><span class="line">var B=&quot;5&quot;</span><br><span class="line">sumA=A+B;</span><br><span class="line">sumB=A-B;</span><br></pre></td></tr></table></figure>

<p><strong>sumA&#x3D;55,系统默认+字符连接符，将A转化为字符串类型；而sumB&#x3D;0；系统认为-是算数运算符，从而将B转化为int类型，所以sum为5-5&#x3D;0；</strong></p>
<p><em>上面就是一个弱类型语言的例子；</em></p>
<hr>
<p><em>那么强类型语言与弱类型语言有什么优缺点呢？</em></p>
<p><strong>强类型语言和弱类型原因其判断的根本是是否会隐形进行语言类型转变。强类型原因在速度上可能略逊于弱类型语言，但是强类型定义语带来的严谨性又避免了不必要的错误。</strong></p>
<p>上面提到了动态语言与静态语言，那就讲讲动态语言静态语言的区别：</p>
<p><strong>动态类型语言：动态性语言是指在运行期间才去做数据类型检查的语言，也就是说动态类型语言编程时，永远不用给任何变量指定数据类型，该语言会在第一次赋值给变量时，在内部将数据类型记录下来。Python和Ruby就是一种典型的动态类型语言，其他的各种脚本语言如VBScript也多少属于动态类型语言。</strong></p>
<p><strong>静态类型语言：静态类型语言与动态类则刚好相反，它的数据类型在编译期间检查，也就是说在写程序时要声明所有变量的数据类型，C&#x2F;C++是静态类型语言的典型代表，其他静态语言还有C#、Java等。</strong></p>
<p>对于动态语言与静态语言的区分，其根本在<strong>于判断是在运行期间去做数据类型还是在编译期间检查。</strong></p>
<h3 id="3-2-指针为什么要使用强类型"><a href="#3-2-指针为什么要使用强类型" class="headerlink" title="3.2 指针为什么要使用强类型"></a>3.2 指针为什么要使用强类型</h3><p>Q：指针保存的地址的类型都是一样的，为什么还要为指针指定类型呢？</p>
<p>A：我们使用指针不仅仅只是用到地址，还需要经常解引用(*)来获得指针所指向地址的值或者写数据，因此我们就需要知道两个信息：①我们需要获得多少字节的内容；②采用何种方式解析数据。例如：char占用1字节，int占用4字节，他们占用字节大小是不一样的，float也占用 4字节，但是float和int的解析方式是不一样的。</p>
<p>Eg：<strong>指针变量保存的地址是首地址</strong></p>
<h2 id="4-通用指针类型（void-）"><a href="#4-通用指针类型（void-）" class="headerlink" title="4. 通用指针类型（void *）"></a>4. 通用指针类型（void *）</h2><h2 id="5-指向指针的指针"><a href="#5-指向指针的指针" class="headerlink" title="5. 指向指针的指针"></a>5. 指向指针的指针</h2><p>理解多重指针的最好方法是<strong>画图</strong>。</p>
<p>如果我们让一个指针指向一片内存，那么就在指针和内存之间加上一个箭头，表示指针指向内存。假设有指针p指向内存s，那么*p就可以在图中表示为由p沿着指向s的指针到s，这样多重指针不过就是多走几次罢了。</p>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p= &amp;x;</span><br><span class="line"><span class="type">int</span>** q = &amp;p;</span><br><span class="line"><span class="type">int</span>*** r = &amp;q;</span><br></pre></td></tr></table></figure>

<p>对面上面的代码，表现在图形中就是：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/07/14/ec141bc6c035f827.png" alt="IMAGE"></p>
<h2 id="6-传值调用"><a href="#6-传值调用" class="headerlink" title="6. 传值调用"></a>6. 传值调用</h2><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increamet</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">Increment</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，main中的a是实参，Increment中的x是形参，传值调用的过程就是实参映射到实参，也就是将实参的值拷贝到形参中。</p>
<h2 id="7-数组与指针"><a href="#7-数组与指针" class="headerlink" title="7. 数组与指针"></a>7. 数组与指针</h2><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">cout &lt;&lt; &amp;a[i] &lt;&lt; endl; 	<span class="comment">// &lt;==&gt; cout &lt;&lt; (a + i) &lt;&lt; endl;</span></span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; endl;	<span class="comment">// &lt;==&gt; cout &lt;&lt; *(a + i) &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = a;</span><br><span class="line">*p ++ ; <span class="comment">// valid</span></span><br><span class="line">a ++ ;	<span class="comment">// invalid</span></span><br></pre></td></tr></table></figure>

<p><strong>指针就是数组，数组就是指针</strong></p>
<p>数组的基地址就是数组首元素的地址，直接使用数组名就可以得到数组的基地址</p>
<h2 id="8-数组作为函数参数"><a href="#8-数组作为函数参数" class="headerlink" title="8. 数组作为函数参数"></a>8. 数组作为函数参数</h2><h3 id="8-1-例1"><a href="#8-1-例1" class="headerlink" title="8.1 例1"></a>8.1 例1</h3><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> t[])</span> <span class="comment">// &lt;==&gt; int getSum(int *t)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> Size = <span class="built_in">sizeof</span>(t) / <span class="built_in">sizeof</span>(t[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size-t : &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(t) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;getSum-size: &quot;</span> &lt;&lt; Size &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; Size; i ++ ) sum += t[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> Size = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size-a: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main-size: &quot;</span> &lt;&lt; Size &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">getSum</span>(a);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sum: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size-a: <span class="number">20</span></span><br><span class="line">main-size: <span class="number">5</span></span><br><span class="line">size-t : <span class="number">8</span></span><br><span class="line">getSum-size: <span class="number">2</span></span><br><span class="line">sum: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>Explaion：</p>
<blockquote>
<p>在上面的程序中，我们希望将数组 a 传递给函数 getSum 来求得数组 a 中所有元素的和（15）。</p>
<p>我们通过一个巧妙的方法得到数组 a 中元素的个数：sizeof(a) &#x2F; sizeof(a[0]);</p>
<p>sizeof(a) 是数组 a 所占用的字节数，同理如果有一个 int 类型变量 i，那么 sizeof(i) &#x3D; 4；sizeof(a[0]) 是数组 a 中一个元素占用的字节数。</p>
<p>在 main 函数中我们正确求得了 数组 a 的元素个数（5），数组 a 占用的字节数（20），然而当我们把数组 a 传递给函数 getSum 时，我们在函数内求得数组 a 的元素个数为 2，并且数组 a 占用的字节大小为 8，而不是 20 (5*sizeof(int))。</p>
<p>这是为什么呢？</p>
</blockquote>
<h3 id="8-2-例2"><a href="#8-2-例2" class="headerlink" title="8.2 例2"></a>8.2 例2</h3><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> t[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        t[i] = t[i] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before change: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">change</span>(a, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after change: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before change: 1 2 3 4 5 </span><br><span class="line">after change: 2 4 6 8 10 </span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>我们发现，将数组 a 传递给函数 change 之后，在 change 中执行的操作返回到了实参中。</p>
<p>这说明数组的传递是传引用而不是传值。</p>
</blockquote>
<h3 id="8-3-例3"><a href="#8-3-例3" class="headerlink" title="8.3 例3"></a>8.3 例3</h3><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out</span><span class="params">(<span class="type">int</span> t[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;t: &quot;</span> &lt;&lt; &amp;t &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*t: &quot;</span> &lt;&lt; *t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;a: &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*a: &quot;</span> &lt;&lt; *a &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">out</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;a: 0x7fff33a6e2d0</span><br><span class="line">a: 0x7fff33a6e2d0</span><br><span class="line">*a: 1</span><br><span class="line">&amp;t: 0x7fff33a6e2b8</span><br><span class="line">t: 0x7fff33a6e2d0</span><br><span class="line">*t: 1</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>我们发现，将数组 a 传递给函数 out 之后，数组 t 的首地址和数组 a 的首地址是一样的，但是在数组中，理应来说 &amp;t 和 t 的结果应该是一样的，例如在 main中 &amp;a 和 a 的结果就是一致的，但实际上打印出来的结果是不同的，这又是为什么呢？</p>
</blockquote>
<h3 id="8-4-例4"><a href="#8-4-例4" class="headerlink" title="8.4 例4"></a>8.4 例4</h3><p>Code：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void out(int *t)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;&amp;t: &quot; &lt;&lt; &amp;t &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;t: &quot; &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*t: &quot; &lt;&lt; *t &lt;&lt; endl;</span><br><span class="line">    for(int i = 0; i &lt; 5; i ++ )</span><br><span class="line">        printf(&quot;&amp;(t + %d)[%p] = %d\n&quot;, i, t + i, *(t + i));</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[5] = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">    cout &lt;&lt; &quot;&amp;a: &quot; &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*a: &quot; &lt;&lt; *a &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    out(a);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&amp;a: 0x7fff9a681e00</span><br><span class="line">a: 0x7fff9a681e00</span><br><span class="line">*a: 1</span><br><span class="line">&amp;t: 0x7fff9a681dd8</span><br><span class="line">t: 0x7fff9a681e00</span><br><span class="line">*t: 1</span><br><span class="line">&amp;(t + 0)[0x7fff9a681e00] = 1</span><br><span class="line">&amp;(t + 1)[0x7fff9a681e04] = 2</span><br><span class="line">&amp;(t + 2)[0x7fff9a681e08] = 3</span><br><span class="line">&amp;(t + 3)[0x7fff9a681e0c] = 4</span><br><span class="line">&amp;(t + 4)[0x7fff9a681e10] = 5</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>我们发现，将数组 a 传递给函数 out，out 的形参是一个 int 型指针，依然可以遍历数组。</p>
</blockquote>
<h3 id="8-5-总结"><a href="#8-5-总结" class="headerlink" title="8.5 总结"></a>8.5 总结</h3><ol>
<li>由例4和例2可得出： **type function(int a[]) &lt;&#x3D;&#x3D;&gt; type function(int *a)<strong>，当我们把一个数组作为参数传递给函数时，并不会传递整个数组的内容，而是仅仅传递数组的首地址。同时这也印证了那句话：</strong>数组就是指针，指针就是数组**</li>
<li>由结论1，对于数组来说，不使用传值方式，总是<strong>传引用</strong>。因为有时候数组可能很大，拷贝整个数组没有太大意义，它会耗费大量内存。</li>
<li>由结论2，我们便可以知道为什么例3中，在函数 out 中打印 &amp;t 和 t是不一样结果了，因为编译器把 int t[] 转换成了 int *t，因此 t 本质上不是一个数组，而是一个指向数组的指针。所以在栈中，只会申请 8 字节（64位机器一个指针占用的内存空间）空间，用来存放这个指针 t，所以说&amp;t 实际上打印的是在栈中 t 的地址，而 t 则打印的是指针变量 t 的内容，也就是它指向的地址（即数组 a 的地址）。</li>
<li>由2和3，也就解释了例1 中为什么在函数 getSum中，sizeof(t) &#x3D; 8，因为我们传递过去的不是一个完整的数组，而是指向这个数组的指针。</li>
</ol>
<h2 id="9-指针和字符数组"><a href="#9-指针和字符数组" class="headerlink" title="9. 指针和字符数组"></a>9. 指针和字符数组</h2><p>——当我们在 C 语言中谈论字符数组时，基本上就是在讨论字符串</p>
<h3 id="9-1如何把字符串存入字符数组"><a href="#9-1如何把字符串存入字符数组" class="headerlink" title="9.1如何把字符串存入字符数组"></a>9.1如何把字符串存入字符数组</h3><p>——首要的需求就是字符数组必须足够大，大到能够容纳字符串</p>
<p>一个足够大的字符数组是指它的大小&gt;&#x3D;字符的数量 +1，因为在字符串中必须指明结束标志（\0），但整型和浮点型数组没有结束符， 完全要自己严格控制元素的数量。</p>
<h3 id="9-2-字符数组的声明"><a href="#9-2-字符数组的声明" class="headerlink" title="9.2 字符数组的声明"></a>9.2 字符数组的声明</h3><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;john&quot;</span>; <span class="comment">// 用双引号给字符数组复制，编译器会自动给字符串添加结束标志&#x27;\0&#x27;，因为字符数组的长度就是字符串长度+1（\0）</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl; <span class="comment">// 5，  包含&#x27;\0&#x27;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(s) &lt;&lt; endl; <span class="comment">// 4，不包含 &#x27;\0&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> a[] = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>&#125;; <span class="comment">// 需要手动添加结束标志，这里因为没有添加 &#x27;\0&#x27;，strlen(a)出错</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; 	<span class="comment">// 4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(a) &lt;&lt; endl;  <span class="comment">// 8，出错</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> b[] = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; 	<span class="comment">// 手动添加&#x27;\0&#x27;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; endl;  <span class="comment">// 3</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(b) &lt;&lt; endl;	<span class="comment">// 2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tips：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;john&quot;</span>;</span><br><span class="line"><span class="comment">// 不可以写为下面的形式：</span></span><br><span class="line"><span class="type">char</span> s[<span class="number">107</span>];</span><br><span class="line">s = <span class="string">&quot;john&quot;</span>;</span><br><span class="line"><span class="comment">// 用双引号初始化必须在同一行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其次，下面的声明方式是不严谨的，因为我们不知道字符串的结束在那</span></span><br><span class="line"><span class="comment">// 因此，可能发生奇怪的问题</span></span><br><span class="line"><span class="type">char</span> a[] = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如下面：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a[] = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *s = a;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="number">1234</span>t��M�</span><br><span class="line"><span class="number">1234</span>t��M�</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 可以发现出现了乱码    </span></span><br></pre></td></tr></table></figure>



<h3 id="9-3-char"><a href="#9-3-char" class="headerlink" title="9.3  char *"></a>9.3  char *</h3><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>上面的代码会报错，因此把  “Hello” 的值—-也就是<strong>字符串常量字面值</strong>，也就是 “Hello” 的地址，准确来说是起始地址—-赋给字符指针 str，Linux下 “Hello”字符串常量是存放于<strong>只读数据区</strong>（常量区）的，不可以修改。</p>
<p>因此如果我们要把 char* 传递到函数中，那么形参的类型最好是 const char*</p>
<p>对于 <code>char s[] = &quot;Hello&quot;; </code></p>
<p>s[] 是一个字符数组，编译器首先在栈中分配一定的连续空间用于存放 “Hello” 中的字符以及结尾符，然后把字符串常量的内容，也就是<br>“Hello” 中的各个字符和结尾符复制到这个<strong>栈</strong>中的连续空间中。str是数组名，用来表示这个连续栈空间的起始地址，所以str中存放的是栈地址，这个地址的数据是可写的。</p>
<p><strong>在 Linux 中，堆，全局数据，常量等都是存放于从 0x8048000 开始的内存地址，向上增长。一般来说，32位机器上，在Linux中，栈地址空间从3G（0xbfffffff）开始向下增长。</strong></p>
</blockquote>
<p>Tips：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *s = ch;</span><br><span class="line">    s ++ ;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;	<span class="comment">//ello</span></span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;	<span class="comment">// Xllo</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>char*s = ch;</code>中的 ch 不是字符串常量，因此 s 可以修改。</p>
<h2 id="10-指针和二维数组"><a href="#10-指针和二维数组" class="headerlink" title="10. 指针和二维数组"></a>10. 指针和二维数组</h2><p>多维数组本质上是<strong>数组的数组</strong>，由于一个指针可以表示一个数组，因此可以把二维数组看做一维指针数组。</p>
<p><strong>数组</strong>可以看做是同类事物的集合，<strong>多维数组</strong>基本上可以理解为数组的集合。</p>
<p>例如二维数组<code>A[3][2]</code>，如下图所示：</p>
<p><img src="https://s1.328888.xyz/2022/07/14/LtB4I.png"></p>
<blockquote>
<p>对 A 解引用就可以得到 A[0], A[1], A[2]</p>
<p>对 A[i] 解引用就可以得到 A[i][0], A[i][1]</p>
<p>对 A[i][j] 解引用就可以得到具体的值</p>
<p><strong>注意别把指针数组和二维指针搞混了，根本不是一回事！</strong></p>
</blockquote>
<h3 id="10-1-二维数组在内存中的存放方式"><a href="#10-1-二维数组在内存中的存放方式" class="headerlink" title="10.1 二维数组在内存中的存放方式"></a>10.1 二维数组在内存中的存放方式</h3><p>假设我们生成了一个数组 <code>A[3][2]</code></p>
<p><img src="https://i.bmp.ovh/imgs/2022/07/14/2e64b6aa12631e70.png" alt="IMAGE"></p>
<p>此时如果我们定义一个指针 <code>int *p = &amp;A;</code> 会编译错误，因为这里的 int 类型指针 p 指向了一个一维数组，这与指针的类型不匹配。</p>
<h3 id="10-2-二维数组的运算"><a href="#10-2-二维数组的运算" class="headerlink" title="10.2 二维数组的运算"></a>10.2 二维数组的运算</h3><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;二维数组b的首地址: &quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> (*p)[<span class="number">3</span>] = b; <span class="comment">// 一维指针数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// b是二维数组b[][]的数组名,它的地址就是首地址b[0]</span></span><br><span class="line">    cout &lt;&lt; b     &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b[<span class="number">0</span>] &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; b + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// b &lt;==&gt; &amp;b，b[i] &lt;==&gt; &amp;b[i]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对b直接解引用得到的是b[0]，b[0]是一维数组b[0]的数组名，因此b[0]的地址就是首地址b[0][0]</span></span><br><span class="line">    cout &lt;&lt; *b       &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; &amp;b[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; endl; <span class="comment">// *b = *(b + 0)</span></span><br><span class="line">    cout &lt;&lt; *(b + <span class="number">1</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; &amp;b[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    cout &lt;&lt; *(b + <span class="number">1</span>) + <span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b[<span class="number">1</span>] + <span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; &amp;b[<span class="number">1</span>][<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    cout &lt;&lt; *(*b + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">二维数组b的首地址: 0x7fff0e673980</span><br><span class="line">0x7fff0e673980 0x7fff0e673980</span><br><span class="line">0x7fff0e67398c 0x7fff0e67398c</span><br><span class="line">0x7fff0e673980 0x7fff0e673980 0x7fff0e673980</span><br><span class="line">0x7fff0e67398c 0x7fff0e67398c 0x7fff0e67398c</span><br><span class="line">0x7fff0e673994 0x7fff0e673994 0x7fff0e673994</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>Tips：</p>
<blockquote>
<p>在二维数组中，有以下两条等式</p>
<p><strong>取地址：</strong><code>&amp;b[i][j] &lt;=&gt; b[i] + j &lt;=&gt; *(b + i) + j</code></p>
<p><strong>取值：</strong>    <code>b[i][j] &lt;==&gt; *(b[i] + j ) &lt;==&gt; *(*(b + i) + j)</code></p>
</blockquote>
<h2 id="11-指针和多维数组"><a href="#11-指针和多维数组" class="headerlink" title="11. 指针和多维数组"></a>11. 指针和多维数组</h2><h3 id="11-1-指针和三维数组"><a href="#11-1-指针和三维数组" class="headerlink" title="11.1 指针和三维数组"></a>11.1 指针和三维数组</h3><p>Code：</p>
<p>要注意解引用运算符(*)的优先级</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">int</span> (*p)[<span class="number">2</span>][<span class="number">2</span>] = c;</span><br><span class="line">    <span class="comment">//int *p[2][2] = c; // Wrong!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tips：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c[i][j][k] </span><br><span class="line">	= *(c[i][j] + k) </span><br><span class="line">	= *(*(c[i] + j) + k) </span><br><span class="line">	= *(*(*(c + i) + j) + k)</span><br></pre></td></tr></table></figure>

<p>对于上面的转换，只需要牢记指针和数组之间的转换就可以了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c[i] = *(c + i);</span><br><span class="line">&amp;c[i] = c + i;</span><br></pre></td></tr></table></figure>



<h3 id="11-2-多维数组作为参数传递给函数"><a href="#11-2-多维数组作为参数传递给函数" class="headerlink" title="11.2 多维数组作为参数传递给函数"></a>11.2 多维数组作为参数传递给函数</h3><p>我们在第 8 章中已经知道，将数组作为参数传递给函数时，实际上不会拷贝整个数组，只会以指针的形式传它的引用。例如：</p>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a[])</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fundc</span><span class="params">(<span class="type">int</span> *a)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子是一维数组的情况，那么如果传递的是多维数组呢？</p>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> d[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> a[][])</span>  </span>&#123; 	<span class="comment">// test 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> *a)</span>     </span>&#123; 	<span class="comment">// test 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> a[][<span class="number">3</span>])</span> </span>&#123; 	<span class="comment">// test 3  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">(<span class="type">int</span> *a[<span class="number">3</span>])</span>  </span>&#123; 	<span class="comment">// test 4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func5</span><span class="params">(<span class="type">int</span> **a)</span>    </span>&#123;	<span class="comment">// test 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>在第一种形式中，编译器会报错，因为我们执行了一个二维数组作为形参，形式上虽然是 <code>a[][]</code>，但编译器会将其转化为  <code>(*a)[]</code>, 也就是说，我们指定了一个指针数组作为参数，但我们没有指定这个指针数组的大小，因此编译器报错。 </p>
<p>在第二种形式中，编译时不会报错，但如果我们将数组 <code>c</code> 作为参数执行 <code>func()</code> 函数，编译器会报错，因为 <code>c[][]</code> 的类型为 <code>(int *)[]</code>，而参数的类型为 <code>int *</code>，显然类型不匹配。</p>
<p>第三种形式和第四种形式都是正确的，因为我们指定了指针数组的大小。</p>
<p>将数组 <code>c</code> 传递给 <code>func3()</code> 和 <code>func4()</code> 是正确的，但如果传入数组 <code>d</code>  就会报错，因为数组的第二维不匹配。</p>
</blockquote>
<p>Tips：</p>
<blockquote>
<p>也就是说，在我们将数组作为参数传递给函数时，数组的第一维是可以省略的，但是剩下的维必须指定大小。</p>
<p>另外，一个常见的误区是：对于二维数组，我们传入一个指针的指针，对于三维数组，传递一个指针的指针的指针，这是不对的。</p>
</blockquote>
<h2 id="12-指针和内存管理"><a href="#12-指针和内存管理" class="headerlink" title="12. 指针和内存管理"></a>12. 指针和内存管理</h2><h3 id="12-1-内存架构"><a href="#12-1-内存架构" class="headerlink" title="12.1 内存架构"></a>12.1 内存架构</h3><p>在一个典型的架构中，分配给应用程序的内存可以分为四个区段：</p>
<ol>
<li>Test(Code)：用来存放需要执行的<strong>指令</strong></li>
<li>Static&#x2F;Global：用来存放<strong>静态变量</strong>或<strong>全局变量</strong>，也就是不在函数中声明的变量，它们的声明周期贯穿整个程序周期</li>
<li>Stack：用来存放<strong>函数调用的所有信息</strong>和<strong>所有局部变量</strong>，局部变量在函数内部声明</li>
<li>Heap：用来存放<strong>动态分配</strong>的变量</li>
</ol>
<p>Tips:</p>
<ol>
<li><strong>代码段，静态&#x2F;全局数据段，栈区在运行期间的大小是不会增长的。</strong></li>
<li>一个函数的帧栈大小，是在编译期间就决定了的。</li>
<li>程序在任何时间，都是栈顶的函数在执行。</li>
</ol>
<h3 id="12-2-堆的引入"><a href="#12-2-堆的引入" class="headerlink" title="12.2 堆的引入"></a>12.2 堆的引入</h3><p>内存在栈上的分配和销毁有一定的规则，当一个函数被调用的时候，它被压入堆栈，结束时，弹出堆栈。如果变量是在栈上分配的，那你就不能操纵变量的范围。</p>
<p>另外一个限制，如果我们需要声明一个很大的数据类型，或者一个很大的数组作为局部变量，我们需要在编译期间知道数组的大小。如果我们有这样一个场景：需要在运行期间根据参数决定数组的大小，那么使用栈就会有问题了。</p>
<p>针对这些问题，比如分配很大的内存，或者把变量预留在内存中直到我们想用的时候为止，我们就有了堆。</p>
<h3 id="12-3-堆简介和引应用"><a href="#12-3-堆简介和引应用" class="headerlink" title="12.3 堆简介和引应用"></a>12.3 堆简介和引应用</h3><p>不像栈，应用程序的堆的大小是<strong>不固定</strong>的，它的大小在应用程序的整个声明周期是可变的，也没有特定的规则来分配和销毁特定的内存，程序员可以完全控制在堆上分配多少存在，数据保留到什么时候，你几乎可以任意使用堆上的内存，只要不超出系统自身的内存限制，但有时候随意使用堆也是危险的（内存泄露）</p>
<p>有时候我们把堆称为<strong>内存的空闲池</strong>，或者内存空闲存取区，我们可以在堆中获得我们想要的内存，尽管不同的操作系统对分配堆的方式不同，但可以把堆抽象看做一块很大的自由使用的内存空间</p>
<p>注意不要把这里的堆和数据结构中的堆混淆了，它们是完全不同的概念，这里的堆表示的只是空闲的内存池。另外栈区是栈的一种实现，而堆不是的。</p>
<p>使用堆内存意味着<strong>动态内存分配</strong>，在 C 或者 C++ 中使用堆的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C：</span><br><span class="line">    malloc();</span><br><span class="line">    calloc();</span><br><span class="line">    realloc();</span><br><span class="line">    free();</span><br><span class="line">C ++ :</span><br><span class="line">	new;</span><br><span class="line">    delete();</span><br><span class="line">    C ++ 也可以使用 C 的四个函数，因为 C ++ 向后兼容 C</span><br></pre></td></tr></table></figure>

<p>malloc会返回一个指向这块内存起始地址的**(void *)指针<strong>，因此需要做类型转换，但是在 C ++ 里面则不需要，因此new 和 delete 操作符是</strong>类型安全**的，这意味着，他们是带着类型的，返回指向特定类型的指针。</p>
<p>事实上<strong>使用堆的唯一方式就是通过引用。</strong>malloc函数所做的事情仅仅是，从堆上找到空闲的内存，为你预留空间然后通过指针返回给你，你去访问这块内存的方式就是自己维护一个指针。</p>
<p>分配在堆上的内存在函数调用结束之后并不会像栈上那样自动释放，因此，对于分配的内存，要注意回收（free） ，否则可能导致内存泄露</p>
<p>Code：C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a; <span class="comment">// goes on stack</span></span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">20</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Code：C++</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;              <span class="comment">// 分配在栈上</span></span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *p = <span class="number">10</span>;            </span><br><span class="line">    <span class="keyword">delete</span> p;           <span class="comment">// 释放空间</span></span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>];    <span class="comment">// 分配一个数组</span></span><br><span class="line">    <span class="keyword">delete</span>[] p;         <span class="comment">// 释放空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-4-库函数"><a href="#12-4-库函数" class="headerlink" title="12.4 库函数"></a>12.4 库函数</h3><p>介绍 C 语言支持中支持动态内存分配的各种库函数。</p>
<h4 id="12-4-1-malloc"><a href="#12-4-1-malloc" class="headerlink" title="12.4.1 malloc()"></a>12.4.1 malloc()</h4><p>malloc 的全称是 <strong>memory allocation</strong>，中文叫<strong>动态内存分配</strong>，用于申请一块连续的指定大小的内存块区域以 void* 类型返回分配的内存区域地址，当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态的分配内存，且分配的大小就是程序要求的大小。 </p>
<p>如果分配成功则返回指向被分配内存的指针**(此空间中的初始值不确定)**，否则返回空指针 NULL。当内存不再使用时，应使用 free() 函数将内存块释放。</p>
<p>原型为：<em><em>void</em> malloc(size_t size);</em>*</p>
<blockquote>
<p>可以把 size_t看做 unsigned_int（&gt;&#x3D;0），显然我们不能指定一个负数。</p>
<p>malloc 返回一个 void* 指针，这个指针指向分配给我们的内存块的第一个地址。</p>
<p>size &#x3D; 单元的数量 * 每个单元的字节数</p>
</blockquote>
<p>例如：如果我们希望分配一个单元的 int 类型的空间</p>
<blockquote>
<figure class="highlight plaintext"><figcaption><span>*p </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们最好写成这样的形式：```void *p = malloc(sizeof(int));```</span><br><span class="line"></span><br><span class="line">我们不可以解引用一个 void 指针，因此为了能够使用这块内存，我们需要把 malloc 返回的指针转成一个特定类型的指针。</span><br><span class="line"></span><br><span class="line">malloc 之所以返回一个 void 指针是因为可以确保它的通用性，它做的仅仅只是分配内存，而不关心这块内存你是拿来存整形还是字符还是浮点数。</span><br><span class="line"></span><br><span class="line">Code：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int *p = (int *)malloc(3 * sizeof(int));</span><br><span class="line">   // 通过指针操纵</span><br><span class="line">   *p = 1;</span><br><span class="line">   *(p + 1) = 2;</span><br><span class="line">   *(p + 2) = 3;</span><br><span class="line">   </span><br><span class="line">   // 因为我们分配的是一个int数组，因此我们可以直接通过数组的方式操纵</span><br><span class="line">   p[0] = 4;</span><br><span class="line">   p[1] = 5;</span><br><span class="line">   p[2] = 6;</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="12-4-2-calloc"><a href="#12-4-2-calloc" class="headerlink" title="12.4.2 calloc()"></a>12.4.2 calloc()</h4><p>使用 malloc 初始化时不会进行初始化，因此如果没有填入值得话，会得到一些随机值。但是使用 calloc 的话，会对其进行初始化为 0，如果分配成功则返回指向被分配内存的指针(**此空间中的初始值为 0 **)，否则返回空指针 NULL，</p>
<p>calloc 的全称是 <strong>clear allocation</strong>，中文名为<strong>动态内存分配并清零</strong></p>
<p>函数原型为：*<em>void <em>calloc(unsigned int num，unsigned int size);</em></em></p>
<blockquote>
<p>num 表示分配的单元数量，size表示单元大小</p>
</blockquote>
<h4 id="12-4-3-realloc"><a href="#12-4-3-realloc" class="headerlink" title="12.4.3 realloc()"></a>12.4.3 realloc()</h4><p>如果你有一块内存，动态分配的内存，然后你想修改内存块的大小，就可以使用 realloc，realloc 的全称是 <strong>reset allocation</strong>，中文名为<strong>动态内存调整</strong>。</p>
<p>函数原型为：<em><em>extern void * realloc(void</em> mem_address, unsigned int newsize);</em>*</p>
<blockquote>
<p>mem_address 指向已分配内存的起始地址的指针，如果 mem_address &#x3D; NULL , 那么此时就相当于 malloc</p>
<p>newsize 为新内存块的大小</p>
<p>先判断当前的指针是否有足够的连续空间，如果有，扩大 mem_address 指向的地址，并且将 mem_address 返回，如果空间不够，先按照 newsize 指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来 mem_address 所指内存区域(<strong>原来的指针会自动释放，不需要再使用 free</strong>)，同时返回新分配的内存区域的首地址。重新分配成功返回指向被分配内存的指针，否则返回空指针 NULL。</p>
<p>注意：调整后的大小可大可小(如果新的大小大于原内存大小，新分配部分不会被初始化；如果新的大小小于原内存大小，可能会导致数据丢失）。</p>
</blockquote>
<h4 id="12-4-4-free"><a href="#12-4-4-free" class="headerlink" title="12.4.4 free()"></a>12.4.4 free()</h4><p>函数原型为：*<em>void free(void <em>ptr);</em></em></p>
<p>一般使用 malloc, calloc, realloc 函数进行内存分配后要使用 free(<strong>起始地址的指针</strong>) 对内存进行释放，不然内存申请过多会影响计算机的性能，以至于重启电脑。但是若使用动态内存分配函数后未使用 free 函数进行释放，还可以使用指针对该块内存进行访问，如果释放则不能再访问。</p>
<p><strong>注意：使用后该指针变量一定要重新指向 NULL，防止野指针出现，有效规避错误操作。</strong></p>
<h4 id="12-4-5-示例"><a href="#12-4-5-示例" class="headerlink" title="12.4.5 示例"></a>12.4.5 示例</h4><p>上面函数的使用需要引入头文件 <code>#include &lt;stdlib.h&gt;</code></p>
<p>Code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入数组的大小: &quot;</span> &lt;&lt; endl;   </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编译错误,不能在运行时定义数组</span></span><br><span class="line">    <span class="comment">//int A[n]; </span></span><br><span class="line">    <span class="comment">//正确方法</span></span><br><span class="line">    <span class="type">int</span>* A = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mallo分配的数组: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    cout &lt;&lt; A[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> *B = (<span class="type">int</span>*)<span class="built_in">calloc</span>(n, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;callo分配的数组: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    cout &lt;&lt; B[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Input &amp;&amp; Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请输入数组的大小: </span><br><span class="line">25</span><br><span class="line">mallo分配的数组: </span><br><span class="line">39855248 0 7365248 0 0 0 0 0 0 0 -1694498661 43847 39855248 0 7340368 0 0 -1 -1728053095 43846 39855248 0 7340368 0 0</span><br><span class="line">callo分配的数组:</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>在上面的代码中，我们实现了在程序运行过程当中分配一个数组，并且可以验证，malloc 不会进行初始化，因此我们得到一堆随机数，而 calloc 会进行0初始化，因此数组元素全为 0</p>
</blockquote>
<hr>
<p>Code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入数组的大小: &quot;</span> &lt;&lt; endl;   </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span>* A = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    A[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    cout &lt;&lt; A[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(A);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    cout &lt;&lt; A[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// free之后再次修改内存中的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    A[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    cout &lt;&lt; A[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Input &amp;&amp; Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请输入数组的大小: </span><br><span class="line">5</span><br><span class="line">1 2 3 4 5 </span><br><span class="line">16279024 0 16253264 0 5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>



<p>Expalin：</p>
<blockquote>
<p>可以发现，在释放掉动态分配的内存之后，仍然可以访问该内存，并打印出一些随机值(完全取决于编译器和机器)，甚至可以再次修改内存中的值并正常执行，但在其他的机器上这个程序可能会崩溃（可能另一个指针指向这块内存，而你修改了它）。</p>
<p>所以说 free 并不是真的 “销毁” 了一块内存，它只是说实现这个内存不属于你这个指针了。</p>
<p>这是使用指针的时候一个危险的地方。</p>
</blockquote>
<hr>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入数组的大小: &quot;</span> &lt;&lt; endl;   </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span>* A = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入数组改编后的大小:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> *B = (<span class="type">int</span> *)<span class="built_in">realloc</span>(A, n * <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 包含 free(A)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) B[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    cout &lt;&lt; B[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Input &amp;&amp; Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请输入数组的大小: </span><br><span class="line">5</span><br><span class="line">请输入数组改编后的大小:</span><br><span class="line">10</span><br><span class="line">1 2 3 4 5 6 7 8 9 10 </span><br></pre></td></tr></table></figure>



<h3 id="12-5-内存泄露"><a href="#12-5-内存泄露" class="headerlink" title="12.5 内存泄露"></a>12.5 内存泄露</h3><p>**所谓内存泄露，是指不当地使用动态内存或者内存的堆区，也就是在堆长增加”垃圾”**。其他语言诸如 Java 和 C# ，堆上的垃圾会被自动回收（垃圾回收机制）。</p>
<p>内存泄漏总是因为堆中未使用和未引用的内存块才发生的。</p>
<p>栈上的内存是自动回收的，栈的大小是固定的，会多就是会发生栈溢出。</p>
<p>常见的错误：在函数内部 malloc 一块内存，但是在函数结束时没有释放，如果这个函数执行非常多次，就造成内存泄漏。不要误以为在函数中 malloc 的内存会在函数结束时自动释放，函数结束时只会自动释放栈中的内存，而 malloc 是在堆上分配的内存，所以函数结束时不会释放。</p>
<h2 id="13-函数返回指针"><a href="#13-函数返回指针" class="headerlink" title="13. 函数返回指针"></a>13. 函数返回指针</h2><p><strong>重点：什么时候可以从函数返回一个指针</strong></p>
<blockquote>
<p>如果我们在堆上有一个内存地址或者在全局区有一个变量，那么我们就可以安全的返回他们的地址</p>
</blockquote>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int* Add1(int *a, int *b)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     int c = (*a) + (*b);</span></span><br><span class="line"><span class="comment">//     return &amp;c;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">Add</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *c = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *c = *a + *b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span>* c = <span class="built_in">Add</span>(&amp;a, &amp;b);</span><br><span class="line">    <span class="comment">//int *c = Add1(&amp;a, &amp;b); 报错</span></span><br><span class="line">    cout &lt;&lt; (*c) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>在上面的代码中，Add1函数并不是一个正确的函数返回指针的例子，因为它返回的是一个 《被调用的函数的中的局部变量的地址》，我们知道，一个函数的栈帧会随着函数的结束而被释放，所以当 Add1 函数结束的时候，局部变量 c 的地址就被释放了，所以说返回 c 的地址是错误的。</p>
<p>因此，<strong>从函数返回地址时，我们需要小心它们的作用范围</strong><br>从栈底向上传一个局部变量或者局部变量的地址是可以的。<br>但是，从栈顶想下传一个局部变量或者局部变量的地址是不可以的。</p>
<p>因为被调函数的地址在主调函数的上面，当被调函数执行时，主调函数一定还没结束，而主调函数在执行时，被调函数分配的内存空间也一定被释放掉了。</p>
<p>正确的做法是返回全局变量取的地址或者堆区的地址，因为那里的地址不会被自动释放。</p>
</blockquote>
<h2 id="14-函数指针"><a href="#14-函数指针" class="headerlink" title="14. 函数指针"></a>14. 函数指针</h2><h3 id="14-1-简介"><a href="#14-1-简介" class="headerlink" title="14.1 简介"></a>14.1 简介</h3><p>根据定义可以知道，函数指针是用来保存函数的地址的指针。</p>
<p>那么问题来了，<strong>函数的地址是什么？</strong></p>
<blockquote>
<p>在内存中，一个函数就是一块连续的内存（里面是指令）</p>
<p><strong>函数的地址，我们也把它称为函数的入口点，它是函数的第一条指令的地址（最低地址）</strong></p>
<p>通过直接使用函数名或者取地址可以得到函数的地址。</p>
<p><code>function = &amp;function</code></p>
</blockquote>
<h3 id="14-2-函数指针的使用"><a href="#14-2-函数指针的使用" class="headerlink" title="14.2 函数指针的使用"></a>14.2 函数指针的使用</h3><p>对于下面这个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>函数指针的声明和初始化：</p>
<blockquote>
<p>声明一个函数指针的步骤：</p>
<ol>
<li>首先输入的是，指向这个函数的返回类型，add 函数的返回类型是 int；</li>
<li>然后跟一个括号，括号里面是 *name，name就是函数指针的名字；</li>
<li>然后再跟一个括号，括号里面是所指向这个函数的所有参数的类型，要和所指向的这个函数的类型是一致的。</li>
</ol>
<p>即：function_type (*pointer_name)(arguments_type);</p>
<p>声明一个指向 add 函数的指针 p：</p>
<p>**–&gt; int (<em>p)(int, int);	 &#x2F;&#x2F; 声明了一个函数指针</em>*<br><strong>–&gt; p &#x3D; &amp;add;				&#x2F;&#x2F; 将函数指针 p 指向函数 add</strong></p>
<p>通过上面两条语句我们就实现了声明一个函数指针并让其指向一个函数，当然也可以写为一条语句。</p>
<p>调用函数指针：</p>
<p>**–&gt; int c &#x3D; (<em>p)(2, 3); &#x2F;&#x2F; 调用函数add</em>*</p>
<p>(*p)表示解引用，来获得这个函数，然后把两个参数传递给这个函数。</p>
<p>作为代替，我们也可以直接使用函数指针名（就像在使用函数名一样）：</p>
<p><strong>–&gt;int c &#x3D; p(2, 3); 	 &#x2F;&#x2F;  等价于上面的语句</strong></p>
</blockquote>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello,World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="built_in">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>) = &amp;add;</span><br><span class="line">    c = (*p)(<span class="number">2</span>, <span class="number">3</span>);     </span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;  <span class="comment">// 5</span></span><br><span class="line">    c = <span class="built_in">p</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;  <span class="comment">// 9</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">void</span> (*p1)();</span><br><span class="line">    p1 = printStr;</span><br><span class="line">    <span class="built_in">p1</span>();				<span class="comment">// Hello,World!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14-3-使用案例（回调函数）"><a href="#14-3-使用案例（回调函数）" class="headerlink" title="14.3 使用案例（回调函数）"></a>14.3 使用案例（回调函数）</h3><p><strong>回调函数：</strong>一个函数引用传递给另一个函数时，那个函数被称作回调函数。</p>
<p>函数指针可以被用来做函数参数，接受函数指针的那个函数可以回调函数指针所指向的那个函数，举个例子：</p>
<p>Code：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">B</span><span class="params">(<span class="type">void</span> (*ptr)())</span> &#123;</span><br><span class="line">    (*ptr)();    <span class="comment">// &lt;==&gt; ptr();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> (*ptr)() = A;</span><br><span class="line">    B(ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// &lt;==&gt;</span></span><br><span class="line">    B(A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>在上面的函数中，我们声明了两个函数 <code>A</code> 和 <code>B</code></p>
<figure class="highlight plaintext"><figcaption><span>没有参数，返回值类型为 ```void```；</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">```B ```有一个参数，参数类型为一个返回值类型为 ```void```，没有参数的函数指针，返回值类型为 ```void```；</span><br><span class="line"></span><br><span class="line">在 ```main```中，我们声明了一个返回值类型为 ```void```，没有参数的指针 ```ptr```，并让其指向函数 ```A```（类型匹配），返回将这个指针作为参数传递给函数 ```B```，函数 ```B``` 又通过函数指针 ```ptr``` 调用函数 ```A```。</span><br><span class="line"></span><br><span class="line">函数 ```B``` 可以通过函数指针回调函数 ```A```</span><br><span class="line"></span><br><span class="line">**另外也可以写成 ```B(A)```的形式，因为函数的名字返回的就是指针。**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">****</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">更清晰的例子：</span><br><span class="line"></span><br><span class="line">Code：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">void bubbleSort(int *a, int n) &#123;</span><br><span class="line">for(int i = 0; i &lt; n - 1; i ++ ) &#123;</span><br><span class="line">	for(int j = 0; j &lt; n - 1 - i; j ++ ) &#123;</span><br><span class="line">           if(a[i] &gt; a[i + 1]) &#123;</span><br><span class="line">               swap(a[i], a[i + 1])</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Explain：</p>
<blockquote>
<p>通过上面的冒泡排序，我们可以实现对一个数组升序排序。现在有这样一种情况，我们有时候需要升序排序，有时候又需要降序排序。</p>
<p>最简单的方式就是写两份冒泡排序，然后修改判断条件，但是这样代码的冗余度太高。</p>
<p>另一种冗余度低且比较简单的方法是在函数中额外传递一个参数 <code>flag</code> ，用来标记这是升序排序还是降序排序。但这样的话如果 <code>flag</code> 很大的话，那么函数内部的 <code>if</code> 比较函数就会很多（我们需要判断依据何种判断条件）。</p>
<p>还有一种方式就是在函数中额外传递一个比较函数，这样就不要额外添加判断语句。</p>
</blockquote>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> (*compare)(<span class="type">int</span>, <span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ ) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">compare</span>(a[j], a[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = a[j];</span><br><span class="line">                a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                a[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">74</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = (<span class="type">int</span>)<span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">bubbleSort</span>(arr, n, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>在 <code>bubbleSort</code> 函数中回调 <code>cmp</code> 函数实现自定义的排序方案。</p>
</blockquote>
<h2 id="15-第15章-C文件操作"><a href="#15-第15章-C文件操作" class="headerlink" title="15. 第15章 C文件操作"></a>15. 第15章 C文件操作</h2><h3 id="15-0-简介和参考"><a href="#15-0-简介和参考" class="headerlink" title="15.0 简介和参考"></a>15.0 简介和参考</h3><p><a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_6778368b0100vidz.html">c&amp;c++文件流参考</a></p>
<p>在ANSI C中，对文件的操作分为两种方式，即：</p>
<ul>
<li><p><strong>流式文件操作</strong></p>
</li>
<li><p><strong>I&#x2F;O文件操作</strong></p>
</li>
</ul>
<h3 id="15-1-英文名词"><a href="#15-1-英文名词" class="headerlink" title="15.1 英文名词"></a>15.1 英文名词</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">perror：错误</span><br><span class="line">flow：流</span><br><span class="line">reind：倒带,back to the begining</span><br></pre></td></tr></table></figure>



<h3 id="15-2-流式文件操作"><a href="#15-2-流式文件操作" class="headerlink" title="15.2 流式文件操作"></a>15.2 流式文件操作</h3><h4 id="15-2-0-FIle结构"><a href="#15-2-0-FIle结构" class="headerlink" title="15.2.0 FIle结构"></a>15.2.0 FIle结构</h4><p>这种方式的文件操作有一个重要的结构FILE，FILE在stdio.h中定义如下：　　</p>
<p><strong>以下是引用片段：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">　　<span class="type">int</span> level; </span><br><span class="line">　　<span class="type">unsigned</span> flags; </span><br><span class="line">　　<span class="type">char</span> fd; </span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">char</span> hold; </span><br><span class="line">　　<span class="type">int</span> bsize; </span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">char</span> _FAR *buffer; </span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">char</span> _FAR *curp; </span><br><span class="line">　　<span class="type">unsigned</span> istemp; </span><br><span class="line">　　<span class="type">short</span> token; </span><br><span class="line">　&#125; FILE;</span><br></pre></td></tr></table></figure>

<p> 　　FILE这个结构包含了文件操作的基本属性，对文件的操作都要通过这个结构的指针来进行，此种文件操作常用的函数如下，下面是这些函数的功能使用说明：</p>
<h4 id="15-2-1-perror"><a href="#15-2-1-perror" class="headerlink" title="15.2.1 perror()"></a>15.2.1 perror()</h4><p><code>void perror(const char *message);</code></p>
<p>在发生错误时，该函数会简化向用户报告这些指定错误的过程。</p>
<p>打印格式为  message: [“wrong message”]，message后面跟一个冒号和空格，然后就是错误信息。</p>
<h4 id="15-2-2-fopen"><a href="#15-2-2-fopen" class="headerlink" title="15.2.2 fopen()"></a>15.2.2 fopen()</h4><p><code>FILE *fopen(path, mode); // 打开一个流</code></p>
<p><code>FILE *freopen(path, mode); //重新打开一个流</code></p>
<p>Mode:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r 打开只读文件，该文件必须存在。 </span><br><span class="line"></span><br><span class="line">r+ 打开可读写的文件，该文件必须存在。 </span><br><span class="line">w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。 </span><br><span class="line">w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。 </span><br><span class="line">a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。 </span><br><span class="line">a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 </span><br><span class="line">上述的形态字符串都可以再加一个b字符，如rb、w+b或ab+等组合，加入b 字符用来告诉函数库打开的文件为二进制文件，而非纯文字文件。不过在POSIX系统，包含Linux都会忽略该字符。</span><br></pre></td></tr></table></figure>

<h4 id="15-2-3-fclose"><a href="#15-2-3-fclose" class="headerlink" title="15.2.3 fclose()"></a>15.2.3 fclose()</h4><p><code>int fclose (FILE *f*);</code></p>
<p>关闭fopen()打开的文件。</p>
<p>对于输出流，fclose函数在文件关闭之前刷新缓冲区。如果它执行成功，返回零值，否则返回EOEF(-1)</p>
<p>在程序结束时一定要记得关闭打开的文件，不然可能会造成数据的丢失。</p>
<h4 id="15-2-4-fputc-fgetc"><a href="#15-2-4-fputc-fgetc" class="headerlink" title="15.2.4 fputc(), fgetc()"></a>15.2.4 fputc(), fgetc()</h4><p><code>int fputc(int c, FILE *Stream);</code></p>
<p><code>int fgetc(FILE *Stream);</code></p>
<p>成功时都返回put&#x2F;get的字符，失败时都返回EOF</p>
<h4 id="15-2-5-fgets-fputs"><a href="#15-2-5-fgets-fputs" class="headerlink" title="15.2.5 fgets(), fputs()"></a>15.2.5 fgets(), fputs()</h4><p><code>int fputs(const char *s, FILE *Stream);</code></p>
<p>写入一个字符串到流中</p>
<p><code>char *fgets(char *s, int n, FILE *Strem)</code></p>
<p>从流中读取一行或指定个字符，注意是读取n-1个字符(还有一个默认的‘\0’)，除非读完一行。参数s是用来接收字符串，如果成功则返回s的指针，否则返回NULL。</p>
<p>注意fgets会读取回车, fputs不换行。</p>
<h4 id="15-2-6-fseek"><a href="#15-2-6-fseek" class="headerlink" title="15.2.6 fseek()"></a>15.2.6 fseek()</h4><p>fseek() 在流中定位到指定的字符</p>
<p>此函数一般用于二进制模式打开的文件中，功能是定位到流中指定的位置，原型是:</p>
<p><code>int fseek(FILE *stream, long offset, int whence);</code></p>
<p>如果成功返回0，参数offset是移动的字符数，whence是移动的基准，取值是：</p>
<p>符号常量 值 基准位置</p>
<ul>
<li><p><strong>SEEK_SET 0</strong> <strong>文件开头</strong></p>
</li>
<li><p><strong>SEEK_CUR 1</strong> <strong>当前读写的位置</strong></p>
</li>
<li><p><strong>SEEK_END 2</strong> <strong>文件尾部</strong></p>
</li>
</ul>
<p>例：fseek(fp,1234L,SEEK_CUR);&#x2F;&#x2F;把读写位置从当前位置向后移动1234字节(L后缀表示长整数)</p>
<p>fseek(fp,0L,2);&#x2F;&#x2F;把读写位置移动到文件尾</p>
<h4 id="15-2-7-fprintf-fscanf"><a href="#15-2-7-fprintf-fscanf" class="headerlink" title="15.2.7 fprintf(), fscanf()"></a>15.2.7 fprintf(), fscanf()</h4><p>fprintf按格式输入到流，其原型是:</p>
<p>&#96;&#96;&#96;int fprintf(FILE *stream, const char *format[, argument, …]);&#96;&#96;</p>
<p>其用法和printf()相同，不过不是写到控制台，而是写到流罢了。</p>
<p>例：fprintf(fp,”%d-%s”,4,”Hahaha”);</p>
<hr>
<p>fscanf从流中按格式读取，其原型是</p>
<p><code>int fscanf(FILE *stream, const char *format[, address, …]);</code></p>
<p>其用法和scanf()相同，不过不是从控制台读取，而是从流读取罢了。</p>
<p>例：fscanf(fp,”%d%d” ,&amp;x,&amp;y);</p>
<hr>
<p>如果想用scanf实现逐行读取，需要在fscanf中读取一个换行，否则第一次fscanf是正常读如，但第二次会读入一个换行，之后就全错了。</p>
<h4 id="15-2-8-rewind"><a href="#15-2-8-rewind" class="headerlink" title="15.2.8 rewind()"></a>15.2.8 rewind()</h4><p>把当前的读写位置回到文件开始，原型是:</p>
<p><code>void rewind(FILE *stream);</code></p>
<p>其实本函数相当于<code>fseek(fp,0L,SEEK_SET);</code></p>
<h4 id="15-2-9-remove"><a href="#15-2-9-remove" class="headerlink" title="15.2.9 remove()"></a>15.2.9 remove()</h4><p>删除文件，原型是</p>
<p><code>int remove(const char *filename);</code></p>
<p> 参数就是要删除的文件名，成功返回0。</p>
<h4 id="15-2-10-ferror"><a href="#15-2-10-ferror" class="headerlink" title="15.2.10 ferror()"></a>15.2.10 ferror()</h4><p><code>int ferror(FILE *stream);</code></p>
<p>返回流最近的<a target="_blank" rel="noopener" href="http://www.pcdog.com/special/1077/index.html">错误代码</a>，可用clearerr()来清除它，clearerr()的原型是:</p>
<p><code>void clearerr(FILE *stream);</code></p>
<h4 id="15-2-11-tmpname"><a href="#15-2-11-tmpname" class="headerlink" title="15.2.11 tmpname()"></a>15.2.11 tmpname()</h4><p><code>char *tmpname(char *s);</code></p>
<p> 生成一个唯一的文件名，其实tmpfile()就调用了此函数，参数s用来保存得到的文件名，并返回这个指针，如果失败，返回NULL。</p>
<h4 id="15-2-12-tmpfile"><a href="#15-2-12-tmpfile" class="headerlink" title="15.2.12 tmpfile()"></a>15.2.12 tmpfile()</h4><p><code>FILE *tmpfile(void);</code></p>
<p> 生成一个临时文件，以”w+b”的模式打开，并返回这个临时流的指针，如果失败返回NULL。在程序结束时，这个文件会被自动删除。</p>
<h4 id="15-2-13-fread-fwrite"><a href="#15-2-13-fread-fwrite" class="headerlink" title="15.2.13 fread(), fwrite()"></a>15.2.13 fread(), fwrite()</h4><p>fread()从流中读指定个数的字符，原型是</p>
<p><code>size_t fread(void *ptr, size_t size, size_t n, FILE *stream);</code></p>
<p>参数ptr是保存读取的数据，void*的指针可用任何类型的指针来替换，如char*、int *等等来替换;size是每块的字节数;n是读取的块数，如果成功，返回实际读取的块数(不是字节数)，本函数一般用于二进制模式打开的文件中。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以下是引用片段： </span><br><span class="line">char x[4230]; </span><br><span class="line">FILE *file1=fopen(&quot;file&quot;,&quot;r&quot;);  </span><br><span class="line">fread(x, 200, 12, file1);</span><br><span class="line">//共读取200*12=2400个字节 </span><br></pre></td></tr></table></figure>

<p>与fread对应，fwrite()向流中写指定的数据，原型是:</p>
<p><code>size_t fwrite(const void *ptr, size_t size, size_t n, FILE *stream);</code></p>
<p>参数ptr是要写入的数据指针，void<em>的指针可用任何类型的指针来替换，如char</em>、int *等等来替换;size是每块的字节数;n是要写的块数，如果成功，返回实际写入的块数(不是字节数)，本函数一般用于二进制模式打开的文件中。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">以下是引用片段： 　　</span><br><span class="line">char x[]=&quot;I Love You&quot;;  　　</span><br><span class="line">fwire(x, 6, 12, fp);//写入6*12=72字节  　　</span><br><span class="line">// 将把&quot;I Love&quot;写到流fp中12次，共72字节</span><br></pre></td></tr></table></figure>





<h3 id="15-2-I-x2F-O-文件操作"><a href="#15-2-I-x2F-O-文件操作" class="headerlink" title="15.2 I&#x2F;O 文件操作"></a>15.2 I&#x2F;O 文件操作</h3><p>参考博客吧！</p>
<p>暂时用不到！</p>
<hr>
<hr>
<h1 id="C陷阱与缺陷"><a href="#C陷阱与缺陷" class="headerlink" title="C陷阱与缺陷"></a>C陷阱与缺陷</h1><h2 id="第一章-词法陷阱"><a href="#第一章-词法陷阱" class="headerlink" title="第一章 词法陷阱"></a>第一章 词法陷阱</h2><h3 id="1-0-引子"><a href="#1-0-引子" class="headerlink" title="1.0 引子"></a>1.0 引子</h3><p>&#x3D;&#x3D;符号&#x3D;&#x3D; 指的是程序的一个基本组成单元，其作用相当于一个句子中的单词，但是同一个单词在不同的句子中意思是基本一样的，而符号可能完全不同。</p>
<p>编译器中负责将程序分解为一个一个符号的部分，一般称为&#x3D;&#x3D;“词法分析器”&#x3D;&#x3D;。</p>
<p>例如 <code>if （x &gt; big）big = x；</code>经过词法分析之后，可以写为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span></span><br><span class="line">(</span><br><span class="line">&gt;</span><br><span class="line">big</span><br><span class="line">)</span><br><span class="line">big</span><br><span class="line">=</span><br><span class="line">x</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-x3D-不同于-x3D-x3D"><a href="#1-1-x3D-不同于-x3D-x3D" class="headerlink" title="1.1 &#x3D;不同于&#x3D;&#x3D;"></a>1.1 &#x3D;不同于&#x3D;&#x3D;</h3><p>在C语言中，之所以使用&#x3D;作为赋值运算符，&#x3D;&#x3D;作为比较运算符，主要是因为赋值运算出现的更为频繁，因而字符较少的&#x3D;就被赋予了更常用的含义—赋值运算。</p>
<p>某些编译器在发现条件判断的条件判断表达式中出现类似于<code>e1 = e2</code> 的赋值语句时会给出警告。但当我们确实需要使用赋值语句时，不应该关闭警告选项，而是显示的进行比较。</p>
<p>例如表达式<code>if (x = y)</code></p>
<p>可以写为：<code>if ((x = y) != 0)</code></p>
<h3 id="1-2-amp-和-不同于-amp-amp-和"><a href="#1-2-amp-和-不同于-amp-amp-和" class="headerlink" title="1.2 &amp;和 | 不同于 &amp;&amp;和 ||"></a>1.2 &amp;和 | 不同于 &amp;&amp;和 ||</h3><h3 id="1-3-词法分析中的贪心法"><a href="#1-3-词法分析中的贪心法" class="headerlink" title="1.3 词法分析中的贪心法"></a>1.3 词法分析中的贪心法</h3><p>C语言划分符号的规则：每一个符号应该包含尽可能多的字符。</p>
<p>例如 <code>a---b;</code></p>
<p>将会被划分为<code>(a--) - b;</code>，而不是<code>a - (--b);</code></p>
<h3 id="1-4-整形常量"><a href="#1-4-整形常量" class="headerlink" title="1.4 整形常量"></a>1.4 整形常量</h3><p>&#x3D;&#x3D;八进制（octonary system）&#x3D;&#x3D;</p>
<p>如果一个整形常量第一个字符是数字0，或者以字符Q结尾，那么该常量将被视作八进制。</p>
<p>所以有时用O结尾，有时用Q结尾，原因：为避免把字母O误认作零，改由Q代替</p>
<p>&#x3D;&#x3D;十六进制（hexadecimal system）&#x3D;&#x3D;</p>
<p>0x开头，或者以字符H结尾。</p>
<p>&#x3D;&#x3D;二进制（binary system）&#x3D;&#x3D;</p>
<p>以字符B结尾。</p>
<p>&#x3D;&#x3D;十进制（decimal system）&#x3D;&#x3D;</p>
<p>开头不能是0，以 字符D结尾。</p>
<h3 id="1-5-字符和字符串"><a href="#1-5-字符和字符串" class="headerlink" title="1.5 字符和字符串"></a>1.5 字符和字符串</h3><p>C语言中的单引号和双引号的含义迥异。</p>
<p>用单引号引起的一个字符实际上代表一个<strong>整数</strong>，整数值对应于该字符在编译器采用的字符集中的序列值。因此，对于采用 ASCLL 字符集的编译器而言，’a’ 的含义与 97（十进制）严格一致。</p>
<p>用双引号引起的字符串，代表的却是一个指向无名数组起始字符的<strong>指针</strong>，该指针被双引号之间的字符以及一个额外的二进制为零的字符 ‘\0’ 初始化。</p>
<p>例如，下面的语句是等价的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等价于 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[] = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span> (str);</span><br></pre></td></tr></table></figure>



<h2 id="第二章-语法陷阱"><a href="#第二章-语法陷阱" class="headerlink" title="第二章 语法陷阱"></a>第二章 语法陷阱</h2><h3 id="2-1-理解函数声明"><a href="#2-1-理解函数声明" class="headerlink" title="2.1 理解函数声明"></a>2.1 理解函数声明</h3><p>任何 C 变量的声明都由两部分组成：类型以及一组类似表达式的声明符。</p>
<p><strong>一旦我们知道了如何声明一个给定类型的变量，那么该类型的类型转换符就很容易得到了：只需要把声明中的变量名和声明末尾的分号去掉，再将剩余的部分用一个括号整个“封装”起来即可。</strong></p>
<h3 id="2-2-优先级问题"><a href="#2-2-优先级问题" class="headerlink" title="2.2 优先级问题"></a>2.2 优先级问题</h3><p>C 语言运算符优先级表</p>
<p><img src="https://images2015.cnblogs.com/blog/550032/201609/550032-20160927115252031-1960111031.png" alt="img"></p>
<blockquote>
<p>单目运算符，赋值运算符，三目运算符自右向左结合。</p>
<p>任何一个逻辑运算符的优先级比任何一个关系运算符的优先级要低。</p>
<p>移位运算符的优先级比算术运算符要低，但是比关系运算符要高。</p>
<p>六个关系运算符的优先级并不相同。因此，如果我们要比较 a 和 b 的大小顺序是否和 c 和 d 的大小顺序一样，可以这样写：<code>a &lt; b == c &lt; d</code></p>
<p>任意两个逻辑运算符的具有不同的优先级，所有的按位运算符优先级（&amp; , | , ^）要比顺序运算符（&amp;&amp;， ||）的优先级高；每个与运算的优先级比或运算的优先级高，异或运算的优先级介于两者之间。</p>
<p>三目运算符的优先级最低，这样我们就可以在三目运算符的条件表达式中包含关系运算符的逻辑组合。例如：<code>tax_rate = income &gt; 4000 &amp;&amp; residency &lt; 5 ? 3.5 : 2.0;</code> 本例其实还说明赋值运算符的优先级低于条件运算符的优先级是有意义的。</p>
</blockquote>
<p>C++ 运算符优先级和结合性</p>
<table>
<thead>
<tr>
<th align="left">优先级</th>
<th>运算符</th>
<th>说明</th>
<th>结合性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td>::</td>
<td>范围解析</td>
<td>自左向右</td>
</tr>
<tr>
<td align="left">2</td>
<td>++  –</td>
<td>后缀自增&#x2F;后缀自减</td>
<td></td>
</tr>
<tr>
<td align="left">()</td>
<td>括号</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">[]</td>
<td>数组下标</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">.</td>
<td>成员选择（对象）</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">−&gt;</td>
<td>成员选择（指针）</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">3</td>
<td>++  –</td>
<td>前缀自增&#x2F;前缀自减</td>
<td>自右向左</td>
</tr>
<tr>
<td align="left">+  −</td>
<td>正&#x2F;负号</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">!  ~</td>
<td>逻辑非&#x2F;按位取反</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">(type)</td>
<td>强制类型转换</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">*</td>
<td>取指针指向的值</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">&amp;</td>
<td>某某的地址</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">sizeof</td>
<td>某某的大小</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">new, new[]</td>
<td>动态内存分配&#x2F;动态数组内存分配</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">delete, delete[]</td>
<td>动态内存释放&#x2F;动态数组内存释放</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">4</td>
<td>.*  -&gt;*</td>
<td>成员对象选择&#x2F;成员指针选择</td>
<td>自左向右</td>
</tr>
<tr>
<td align="left">5</td>
<td>*  &#x2F;  %</td>
<td>乘法&#x2F;除法&#x2F;取余</td>
<td></td>
</tr>
<tr>
<td align="left">6</td>
<td>+  −</td>
<td>加号&#x2F;减号</td>
<td></td>
</tr>
<tr>
<td align="left">7</td>
<td>&lt;&lt;  &gt;&gt;</td>
<td>位左移&#x2F;位右移</td>
<td></td>
</tr>
<tr>
<td align="left">8</td>
<td>&lt;  &lt;&#x3D;</td>
<td>小于&#x2F;小于等于</td>
<td></td>
</tr>
<tr>
<td align="left">&gt;  &gt;&#x3D;</td>
<td>大于&#x2F;大于等于</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">9</td>
<td>&#x3D;&#x3D;  !&#x3D;</td>
<td>等于&#x2F;不等于</td>
<td></td>
</tr>
<tr>
<td align="left">10</td>
<td>&amp;</td>
<td>按位与</td>
<td></td>
</tr>
<tr>
<td align="left">11</td>
<td>^</td>
<td>按位异或</td>
<td></td>
</tr>
<tr>
<td align="left">12</td>
<td>|</td>
<td>按位或</td>
<td></td>
</tr>
<tr>
<td align="left">13</td>
<td>&amp;&amp;</td>
<td>与运算</td>
<td></td>
</tr>
<tr>
<td align="left">14</td>
<td>||</td>
<td>或运算</td>
<td></td>
</tr>
<tr>
<td align="left">15</td>
<td>?:</td>
<td>三目运算符</td>
<td>自右向左</td>
</tr>
<tr>
<td align="left">16</td>
<td>&#x3D;</td>
<td>赋值</td>
<td></td>
</tr>
<tr>
<td align="left">+&#x3D;  −&#x3D;</td>
<td>相加后赋值&#x2F;相减后赋值</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">*&#x3D;  &#x2F;&#x3D;  %&#x3D;</td>
<td>相乘后赋值&#x2F;相除后赋值&#x2F;取余后赋值</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">&lt;&lt;&#x3D;  &gt;&gt;&#x3D;</td>
<td>位左移赋值&#x2F;位右移赋值</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">&amp;&#x3D;  ^&#x3D;  |&#x3D;</td>
<td>位与运算后赋值&#x2F;位异或运算后赋值&#x2F;位或运算后赋值</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">17</td>
<td>throw</td>
<td>抛出异常</td>
<td></td>
</tr>
<tr>
<td align="left">18</td>
<td>,</td>
<td>逗号</td>
<td>自左向右</td>
</tr>
</tbody></table>
<h3 id="2-3-注意作为语句结束标志的分号"><a href="#2-3-注意作为语句结束标志的分号" class="headerlink" title="2.3 注意作为语句结束标志的分号"></a>2.3 注意作为语句结束标志的分号</h3><p>例子1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">10</span>);</span><br><span class="line">    x = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>在 if 的后面，我们多加了一个分号，上述语句就相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>例子2：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">c = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>在 return 的后面，我们遗漏了分号，但是不会报错，上述语句就相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">return</span> a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-switch-语句"><a href="#2-4-switch-语句" class="headerlink" title="2.4 switch 语句"></a>2.4 switch 语句</h3><p><strong>由 switch 控制的流程在执行第一个 case 之后，会自然而然的顺序执行下去</strong>，C 语言的这种特性，既是它的优势所在，也是它的劣势。</p>
<p>因为程序员可能会遗漏 break 语句，而有时候，我们或许需要故意省略 break 语句来实现某种效果。</p>
<h3 id="2-5-函数调用"><a href="#2-5-函数调用" class="headerlink" title="2.5 函数调用"></a>2.5 函数调用</h3><p>与其他程序设计语言不同，C 语言要求：<strong>在函数调用时，即使函数不带参数，也应该包括参数列表。</strong></p>
<p>因此，如果 f 是一个函数，那么<code>f();</code>是一个函数调用语句，而<code>f</code>却是一个什么也不做的语句。更准确的说，它计算函数 f 的地址，却并不调用这个函数。</p>
<h3 id="2-6-悬挂-else-引发的额问题"><a href="#2-6-悬挂-else-引发的额问题" class="headerlink" title="2.6 悬挂 else 引发的额问题"></a>2.6 悬挂 else 引发的额问题</h3><p>C 语言有这样的规则：<strong>else 始终与同一括号内最近的未匹配的 if 结合。</strong></p>
<p>例如下面的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> (y == <span class="number">0</span>)	error();</span><br><span class="line"><span class="keyword">else</span> z = x + y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码，看起来像是：</span></span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">0</span>)	error();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    z = x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际上是：</span></span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">0</span>)	error();</span><br><span class="line">    <span class="keyword">else</span>		z = x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第三章-语义陷阱"><a href="#第三章-语义陷阱" class="headerlink" title="第三章 语义陷阱"></a>第三章 语义陷阱</h2><h3 id="3-1-指针与数组"><a href="#3-1-指针与数组" class="headerlink" title="3.1 指针与数组"></a>3.1 指针与数组</h3><p>C 语言中的数组值得注意的地方有以下两点：</p>
<ol>
<li>C 语言中只有一维数组，并且数组的大小必须在编译器就作为一个常数确定下来。所谓多维数组其实就是数组的元素可以是任意类型的对象，包括数组。</li>
<li>对于一个数组，我们能做的只有两件事：确定该数组的大小以及获得指向该数组下标为 0 的指针。有关数组的其他操作，哪怕他们乍看上去是以数组下标进行运算的，实际上都是通过指针进行的。换言之，任何一个数组下标运算都等同于一个对应的指针运算，因此我们完全可以根据指针行为定义数组下标的行为。</li>
</ol>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure>

<p>这种写法在 ANSI C 中是非法的，以为 <code>&amp;a</code> 是一个指向数组的指针，而 <code>p</code> 是一个指向整型变量的对象，它们的类型不匹配。</p>
<p>正确的写法应该是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = a;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>a</code> 就是 <code>a[0]</code> 的地址。</p>
<p><strong>除了 <code>a</code> 被用作运算符 <code>sizeof</code> 的参数这一情形，在其他所有情形中使用数组名 <code>a</code> 都代表指向数组 <code>a</code> 中下标为 <code>0</code>  的元素的指针</strong>。</p>
<p>另外，在上文中我们说过“有关数组的其他操作，哪怕他们乍看上去是以数组下标进行运算的，实际上都是通过指针进行的。”</p>
<p>例如 <code>a[i]</code> 表示取数组 <code>a</code> 下标为 <code>i</code> 的元素的值，它实际表示的是： <code>*(a + i)</code>，只不过这种写法非常常用，因此被简记为 <code>a[i]</code>。实际上，由于 <code>a + i</code> 和 <code>i + a</code> 一样，因此 <code>a[i]</code> 和 <code>i[a]</code> 具有相同的含义。(也许某些汇编程序员会觉得很熟悉–偏移量)</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">      &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> (*p)[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(p = a; p &lt; &amp;a[<span class="number">3</span>]; p ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> *j;</span><br><span class="line">        <span class="keyword">for</span>(j = *p; j &lt; &amp;(*p)[<span class="number">3</span>]; j ++ ) </span><br><span class="line">            cout &lt;&lt; *j &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*<em>对指针的 <em>(解引用) 可以理解为让指针指向某个地方。</em></em> </p>
<h3 id="3-2-非数组的指针"><a href="#3-2-非数组的指针" class="headerlink" title="3.2 非数组的指针"></a>3.2 非数组的指针</h3><p>在 C 语言中，<strong>字符串常量</strong>代表了一块包括字符串中所有字符以及一个空字符 <code>&#39;\0&#39;</code> 的内存区域的地址。</p>
<p>如果我们想要拼接两个字符串 s 和 t，正确的写法为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;Hello,&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *t = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *r;</span><br><span class="line">    r = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s) + <span class="built_in">strlen</span>(t) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!r) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;分配失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(r, s);</span><br><span class="line">    <span class="built_in">puts</span>(r);</span><br><span class="line">    <span class="built_in">strcat</span>(r, t);</span><br><span class="line">    <span class="built_in">puts</span>(r);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-作为参数的数组声明"><a href="#3-3-作为参数的数组声明" class="headerlink" title="3.3 作为参数的数组声明"></a>3.3 作为参数的数组声明</h3><p>在 C 语言中，我们无法将一个数组作为函数参数直接传递。如果我们将数组名作为参数，那么数组会立即被转换为指向该数组第一个元素的指针。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">    <span class="built_in">puts</span>(s);</span><br><span class="line">    <span class="built_in">puts</span>(&amp;s[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 传递一个数组名和传递数组第一个元素的地址是等价的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，将数组作为函数参数毫无意义。所以，C 语言会自动将作为参数的数组声明转换为对应的指针声明。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strlen</span><span class="params">(<span class="type">char</span> s[])</span> &#123;</span><br><span class="line">	<span class="comment">/* do something */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与下面的写法完全相同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strlen</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">	<span class="comment">/* do something */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-避免“举隅法”"><a href="#3-4-避免“举隅法”" class="headerlink" title="3.4 避免“举隅法”"></a>3.4 避免“举隅法”</h3><p><strong>举隅(yu2)法</strong>：举一端为例。意在使人由此一端而推知其他。意在以更宽泛的词语来代替含义相对较窄的词语，或者相反：例如，以整体代表部分，或者以部分代表整体。</p>
<p>C 语言中一个常见的陷阱：混淆指针与指针所指向的数据。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p, *q;</span><br><span class="line">p = <span class="string">&quot;xyz&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>尽管有时候我们不妨认为，上面的赋值语句使得 <code>p</code> 的值就是字符串 <code>&quot;xyz&quot;</code> ，然而实际情况并不是这样。实际上， <code>p</code> 的值是一个指向由 <code>&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;\0&#39;</code> 四个字符组成的数组的起始元素的指针。</p>
<p>因此，如果我们执行下面语句：</p>
<p><code>p = q;</code></p>
<figure class="highlight plaintext"><figcaption><span>和 ```q``` 现在是指向内存中同一个地址的指针。这个赋值语句并没有复制内存中的字符。需要记住的是，复制指针并不同时复制指针所指向的数据。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3.5 空指针并非空字符串</span><br><span class="line"></span><br><span class="line">在 C 语言中，编译器保证由 0 转换而来的指针并不等同与任何有效的指针。出于代码文档化的考虑，常数 0 这一个值常用一个符号来代替：</span><br><span class="line"></span><br><span class="line">```#define NULL 0```</span><br><span class="line"></span><br><span class="line">当常数 0 被转换为指针使用时，这个指针绝对不能被解除引用。换句话说，我们绝对不能企图用该指针所指向的内存中存储的内容。</span><br><span class="line"></span><br><span class="line">### 3.6 边界计算与不对称边界</span><br><span class="line"></span><br><span class="line">在所有常见的程序设计错误中，最难于察觉的一类是**“栏杆错误”**，也常被称为“差一错误”。典型的例子是：100 米长的围栏每隔 10 米 需要提跟支撑用的围栏，则总共需要多少根围栏？如果不假思索，最“显而易见”的答案是将 100 除以 10，得到的答案是 10，即需要 10 根栏杆。当然这个答案是错误的，正确答案是 11。</span><br><span class="line"></span><br><span class="line">也即，得出正确答案的最容易方式是这样考虑：要支撑 10 米长的围栏实际需要两根栏杆，两段各一根。这个问题的另一种考虑方式是：除了最右侧的一段围栏，其他每一段 10 米长的围栏都只在左侧有一根围栏；而例外的最右侧不仅左侧有一根围栏，右侧也有一根围栏。</span><br><span class="line"></span><br><span class="line">前面一段讨论了解决问题的两种方法，实际上提示了我们**避免“栏杆错误”的两个通用原则：**</span><br><span class="line"></span><br><span class="line">1.  首先考虑最简单情况下的特例，然后将得到的结果外推，这是原则一。</span><br><span class="line">2.  仔细计算边界，绝不掉以轻心，这是原则二。</span><br><span class="line"></span><br><span class="line">将上面总结的两个原则牢记于心之后，来看一个典型的例子：计算整数范围的边界。例如，假设整数 x 的边界条件为 x&gt;=16 且 x&lt;=27，那么此范围内 x 的可能取值个数有多少？</span><br><span class="line"></span><br><span class="line">根据原则一，我们考虑最简单情况下的特例：x&gt;=16 且 x&lt;=16，此时显然只有一个元素，也即上边界和下边界重合时，此范围内满足条件的整数只有一个。因此答案就是 27-16+1=12。</span><br><span class="line"></span><br><span class="line">然而有时稍不留意，我们会想当然的认为答案为：27-16=11个整数 ，那么是否存在一些编程技巧，可以降低这类错误发生的可能性呢？</span><br><span class="line"></span><br><span class="line">这个编程技巧不但存在，而且可以一言以蔽之：**用第一个入界点和第一个出界点来表示一个数值范围**。具体而言，对于上面的例子我们不应该说整数 x 的边界条件为 x&gt;=16 且 x&lt;=27，而应该说整数 x 的边界条件为 x&gt;=16 且 x&lt;28。注意，这里下界 16 是“入界点”，包含在取值范围之中；而上界是“出界点”，即不包含在取值范围之中，这种不对称或许从数学上而言并不优美，但是它对于程序设计的简化效果却令人吃惊。</span><br><span class="line"></span><br><span class="line">1. 取值范围的大小就是上界与下界之差。28-16的值恰好是12。</span><br><span class="line">2. 如果取值范围为空，那么上界等于下界。</span><br><span class="line">3. 即是取值范围为空，上界也永远不可能小于下界。</span><br><span class="line"></span><br><span class="line">对于像 C 语言这样数组下标从 0 开始的语言，不对称的边界给程序设计带来的便利要更加明显：这种数组的上界（即第一个“出界点”）恰好是数组元素的个数。</span><br><span class="line"></span><br><span class="line">另一种考虑不对称边界的方式是，把上界视作某序列中第一个被占用的元素，而把下界视作序列中第一个被释放的元素。当处理各种不同类型的缓冲区时，这种看待问题的方式特别有用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3.7 求值顺序</span><br><span class="line"></span><br><span class="line">C 语言中只有 4 个运算符（&amp;&amp;、||、 ?: 和 ,）存在规定的求值顺序。运算符 &amp;&amp; 和 || 先对左侧操作数求值，只在需要的时候才对右侧操作数求值。运算符 ?: 有三个操作数：在 a?b:c 中，操作数 a 首先被求值，根据 a 的值再去求操作数 b 或 c 的值。逗号运算符首先对左侧操作数求值，然后“丢弃”该值，再对右侧操作数求值。</span><br><span class="line"></span><br><span class="line">&gt; 注：分隔函数参数的逗号并非逗号运算符，例如，x 和 y 在函数 f(x, y) 中的求值顺序是未定义的，而在函数 g((x, y)) 中却是确定的先 x 后 y的顺序。  </span><br><span class="line">&gt;</span><br><span class="line">&gt; 在后一个例子中，函数 g 只有一个参数。这个参数的值是这样求得的：先对 x 求值，然后“丢弃” x 的值，接下来求 y 的值。因此最后的值永远是 y。</span><br><span class="line"></span><br><span class="line">C 语言中其它所有运算符对齐操作数求值的顺序是未定义的，特别是，赋值运算符并不保证任何求值顺序。另外，运算符 &amp;&amp; 和 || 对于保证检查操作按照正确的顺序执行至关重要，在语句``if(y != 0 &amp;&amp; x / y &gt; tolerate)`` 中，就必须保证 y 非 0 时才能执行 x/y 的操作。</span><br><span class="line"></span><br><span class="line">下面这种从数组 x 中复制前 n 个元素到数组 y 中的做法是不正确的，它对求值顺序做了太多假设：</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">i = 0;</span><br><span class="line">while(i &lt; n) &#123;</span><br><span class="line">    y[i] = x[i ++ ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们假设 <code>y[i] = x[i ++ ];</code> 执行的是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y[i] = x[i];</span><br><span class="line">i ++ ;</span><br></pre></td></tr></table></figure>

<p>但也有可能是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y[i + <span class="number">1</span>] = x[i];</span><br><span class="line">i ++ ;</span><br></pre></td></tr></table></figure>

<p>之所以会出现后面的情况是因为 <code>y[i]</code> 的地址将有可能在 <code>i</code> 自增之后被求值。而我们假设 <code>y[i]</code> 的地址在 <code>i</code> 自增之前被求值。</p>
<h3 id="3-8-操作符-amp-amp-、-和-！"><a href="#3-8-操作符-amp-amp-、-和-！" class="headerlink" title="3.8 操作符 &amp;&amp;、|| 和 ！"></a>3.8 操作符 &amp;&amp;、|| 和 ！</h3><p>不要把 &amp;&amp; 和 &amp; 混淆，以及 || 和 | 混淆。它们一类是逻辑运算符，一类是按位运算符。尽管有时候用错了可能也会得到理想的结果。</p>
<h3 id="3-9-整数溢出"><a href="#3-9-整数溢出" class="headerlink" title="3.9 整数溢出"></a>3.9 整数溢出</h3><p>C 语言中有两倍整数算术运算：有符号运算和无符号运算。在无符号算术运算中，没有所谓“溢出”一说：所有无符号数运算都以 2 的 n 次方为模，这里 n 是结果中的位数。</p>
<p>溢出的结果是未定义的，有时候会简单的利用符号来判断是否溢出，例如两个正数相加结果如果是负数那么肯定溢出，但是溢出不一定就是负数。</p>
<h3 id="3-10-为-main-函数提供返回值"><a href="#3-10-为-main-函数提供返回值" class="headerlink" title="3.10 为 main 函数提供返回值"></a>3.10 为 main 函数提供返回值</h3><p>对于一个函数而言，如果没有显式声明返回类型，那么函数返回类型就默认为整形。但是这个程序并没有给出任何返回值。</p>
<h2 id="第四章-链接"><a href="#第四章-链接" class="headerlink" title="第四章 链接"></a>第四章 链接</h2><h3 id="4-1-什么是链接器"><a href="#4-1-什么是链接器" class="headerlink" title="4.1 什么是链接器"></a>4.1 什么是链接器</h3><p>C 语言的一个重要思想就是分别编译，即若干个源程序可以在不同的时候单独进行编译，然后在恰当的时候整合到一起。</p>
<h2 id="第五章-库函数"><a href="#第五章-库函数" class="headerlink" title="第五章 库函数"></a>第五章 库函数</h2><h3 id="5-1-返回整数的-getchar-函数"><a href="#5-1-返回整数的-getchar-函数" class="headerlink" title="5.1 返回整数的 getchar 函数"></a>5.1 返回整数的 getchar 函数</h3><h2 id="第六章-预处理器"><a href="#第六章-预处理器" class="headerlink" title="第六章 预处理器"></a>第六章 预处理器</h2><h2 id="第七章-可移植性缺陷"><a href="#第七章-可移植性缺陷" class="headerlink" title="第七章 可移植性缺陷"></a>第七章 可移植性缺陷</h2><ul>
<li></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">NP probelm</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-15 20:20:57 / Modified: 20:17:41" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NP/" itemprop="url" rel="index"><span itemprop="name">NP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="NP-completeness"><a href="#NP-completeness" class="headerlink" title="NP completeness"></a>NP completeness</h1><h2 id="proface"><a href="#proface" class="headerlink" title="proface"></a>proface</h2><p>P：Polynomial</p>
<p>NP：Non-determinstic Polynomial</p>
<p>NPC：Non-deterministic Polynomial complete</p>
<p>RP：人品</p>
<p>reducibility：归约，约化</p>
<h2 id="time-compleity"><a href="#time-compleity" class="headerlink" title="time compleity"></a>time compleity</h2><p>时间复杂度并不是表示一个程序解决问题需要花费的时间，而是当问题规模扩大后，程序需要的时间长度增长的多快</p>
<h2 id="whats-polynomial？"><a href="#whats-polynomial？" class="headerlink" title="whats polynomial？"></a>whats polynomial？</h2><p>假设有一个自变量 <code>n</code></p>
<p><code>n + n^2 + 3n^3</code> 这就是一个多项式</p>
<p><code>2^n</code> , <code>n!</code>  不是多项式，他们也有自己的名字：超多项式</p>
<blockquote>
<p>一般而言，当 <code>n</code> 作为底数时，就是多项式，当 <code>n</code> 作为指数时或者阶乘时，就是超多项式。</p>
</blockquote>
<h2 id="reducibility"><a href="#reducibility" class="headerlink" title="reducibility"></a>reducibility</h2><p>  简单地说，一个问题A可以约化为问题B的含义即是，可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个“规则”，按照这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能得到一样的结果。这个规则即是：两个方程的对应项系数不变，一元二次方程的二次项系数为0。按照这个规则把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton回路可以约化为TSP问题(Travelling Salesman Problem，旅行商问题)：在Hamilton回路问题中，两点相连即这两点距离为0，两点不直接相连则令其距离为1，于是问题转化为在TSP问题中，是否存在一条长为0的路径。Hamilton回路存在当且仅当TSP问题中存在长为0的回路。<br>  “问题A可约化为问题B”有一个重要的直观意义：B的时间复杂度高于或者等于A的时间复杂度。也就是说，问题A不比问题B难。这很容易理解。既然问题A能用问题B来解决，倘若B的时间复杂度比A的时间复杂度还低了，那A的算法就可以改进为B的算法，两者的时间复杂度还是相同。正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者。<br>  很显然，约化具有一项重要的性质：约化具有传递性。如果问题A可约化为问题B，问题B可约化为问题C，则问题A一定可约化为问题C。这个道理非常简单，就不必阐述了。<br>  现在再来说一下约化的标准概念就不难理解了：如果能找到这样一个变化法则，对任意一个程序A的输入，都能按这个法则变换成程序B的输入，使两程序的输出相同，那么我们说，问题A可约化为问题B。<br>  当然，我们所说的“可约化”是指的可“多项式地”约化(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的。约化的过程只有用多项式的时间完成才有意义。</p>
<h2 id="p-np-npc-np-hard"><a href="#p-np-npc-np-hard" class="headerlink" title="p,np,npc,np-hard"></a>p,np,npc,np-hard</h2><h3 id="1-P问题"><a href="#1-P问题" class="headerlink" title="1. P问题"></a>1. P问题</h3><p>在多项式时间内可解的问题</p>
<h3 id="2-NP问题"><a href="#2-NP问题" class="headerlink" title="2. NP问题"></a>2. NP问题</h3><p>首先，NP问题不是指： not P问题。</p>
<p>它指的是可以在多项式的时间里验证一个解的问题。</p>
<p>但这并不意味着Np问题可以在多项式时间内可解，在多项式时间内可验证和在多项式时间内可解没有任何关联。</p>
<p>换句话来说，NP问题指的是可以在多项式的时间里才出一个解的问题。</p>
<blockquote>
<p> 哈密顿回路就是一个NP问题</p>
<p>之所以要定义NP问题，是因为通常只有NP问题才可能找到多项式的算法。我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。</p>
</blockquote>
<p>因此，显然的，&lt;font color &#x3D; “blue”&gt;所有的 P 类问题都是 NP 问题。</font>也就是说，能在多项式时间内解决一个问题，必然能在多项式时间验证一个问题的解。</p>
<p>关键是，人们想知道，是否所有的 NP 问题都是 P 类问题？也即，是否有 P&#x3D;NP？</p>
<p>通常所谓的“NP问题”，其实就一句话：证明或推翻P&#x3D;NP。</p>
<p>NP问题很难解决，但现在有一个总的趋势，然们普遍倾向于认为：P!&#x3D;NP，因为人们在研究NP问题的时候找到了一类特殊的NP问题叫做NP-完全问题，也就是NPC问题。</p>
<h3 id="3-NPC问题"><a href="#3-NPC问题" class="headerlink" title="3. NPC问题"></a>3. NPC问题</h3><p>  好了，从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。再回想前面讲的P和NP问题，联想起约化的传递性，自然地，我们会想问，如果不断地约化上去，不断找到能“通吃”若干小NP问题的一个稍复杂的大NP问题，那么最后是否有可能找到一个时间复杂度最高，并且能“通吃”所有的 NP问题的这样一个超级NP问题？答案居然是肯定的。也就是说，存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是传说中的NPC 问题，也就是NP-完全问题。NPC问题的出现使整个NP问题的研究得到了飞跃式的发展。我们有理由相信，NPC问题是最复杂的问题。</p>
<p>  NPC问题的定义非常简单。同时满足下面两个条件的问题就是NPC问题。首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。证明一个问题是 NPC问题也很简单。先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它（由约化的传递性，则NPC问题定义的第二条也得以满足；至于第一个NPC问题是怎么来的，下文将介绍），这样就可以说它是NPC问题了。</p>
<p>  既然所有的NP问题都能约化成NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决了，NP也就等于P 了。因此，给NPC找一个多项式算法太不可思议了。因此，前文才说，“正是NPC问题的存在，使人们相信P≠NP”。我们可以就此直观地理解，NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。</p>
<h3 id="4-np-hard"><a href="#4-np-hard" class="headerlink" title="4. np-hard"></a>4. np-hard</h3><p>  顺便讲一下NP-Hard问题。NP-Hard问题是这样一种问题，它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广）。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。</p>
<h2 id="case-npc-problem"><a href="#case-npc-problem" class="headerlink" title="case: npc problem"></a>case: npc problem</h2><p>逻辑电路问题。这是第一个NPC问题。其它的NPC问题都是由这个问题约化而来的。因此，逻辑电路问题是NPC类问题的“鼻祖”。</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><a href="%5Bref%5D(https://www.zhihu.com/question/24653072)">知乎：什么是多项式？</a></p>
<p><a target="_blank" rel="noopener" href="http://www.matrix67.com/blog/archives/105">Matrix67: 什么是P问题、NP问题和NPC问题</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">DataBase kernel learn</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-15 20:20:57 / Modified: 20:23:14" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DB/" itemprop="url" rel="index"><span itemprop="name">DB</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="必备"><a href="#必备" class="headerlink" title="必备"></a>必备</h2><ul>
<li>C&#x2F;C++&#x2F;Java&#x2F;Go&#x2F;Rust</li>
<li>数据库原理</li>
<li>操作系统</li>
<li>算法与数据结构</li>
<li>分布式原理</li>
<li>编译原理</li>
<li>网络编程</li>
<li>数据库架构原理</li>
<li>工程化能力</li>
</ul>
<h2 id="OLAP"><a href="#OLAP" class="headerlink" title="OLAP"></a>OLAP</h2><ul>
<li>ClickHouse</li>
<li>Doris</li>
</ul>
<h2 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h2><ul>
<li>TiDB</li>
<li>OceanBase</li>
<li>CockRoachDB</li>
</ul>
<h2 id="云原生数据库"><a href="#云原生数据库" class="headerlink" title="云原生数据库"></a>云原生数据库</h2><ul>
<li>Aurora</li>
<li>Snowflake</li>
<li>PolarDB</li>
</ul>
<h3 id="云原生的特点"><a href="#云原生的特点" class="headerlink" title="云原生的特点"></a>云原生的特点</h3><blockquote>
<p>本质：池化和弹性</p>
</blockquote>
<ul>
<li>计算存储弹性伸缩</li>
<li>存算分离</li>
<li>计算节点无状态</li>
<li>资源调用K8s operator</li>
</ul>
<h2 id="国外课程"><a href="#国外课程" class="headerlink" title="国外课程"></a>国外课程</h2><ul>
<li>MIT6.824 分布式系统</li>
<li>CMU15-445 数据库系统概论</li>
<li>CMU15-721 高级数据库设计</li>
<li>MIT6.S081 操作系统概论</li>
<li>MIT6.828 高级操作系统设计</li>
</ul>
<h2 id="三大顶会"><a href="#三大顶会" class="headerlink" title="三大顶会"></a>三大顶会</h2><ul>
<li>SIGMOD</li>
<li>VLDB</li>
<li>ICDE</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li>存储</li>
<li>索引</li>
<li>查询</li>
<li>优化</li>
<li>并发控制</li>
<li>日志和恢复</li>
<li>分布式</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul>
<li>Oracle（#0）</li>
<li>MySQL（#1）</li>
<li>PostgreSQL（#2）</li>
<li>PolarDB（#3）</li>
<li>TiDB（#3）</li>
<li>openGauss</li>
<li>Redis</li>
<li>ElasticSearch</li>
<li>MongoDB</li>
<li>Aurora</li>
<li>CockRoachDB</li>
<li>InfluxDB</li>
</ul>
<h2 id="优质开源项目"><a href="#优质开源项目" class="headerlink" title="优质开源项目"></a>优质开源项目</h2><ul>
<li>TiDB</li>
<li>Doris</li>
<li>Arrow</li>
<li>RocksDB</li>
</ul>
<h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ul>
<li>《Database System Concepts》简称DBC</li>
<li>《Designing Data-Intensive Application》简称DDIA</li>
<li>《深入理解计算机系统》简称CSAPP</li>
<li>《Unix网络编程》简称APUE</li>
</ul>
<h2 id="学术大佬"><a href="#学术大佬" class="headerlink" title="学术大佬"></a>学术大佬</h2><ul>
<li>清华姚班AP<a target="_blank" rel="noopener" href="http://people.iiis.tsinghua.edu.cn/~huanchen/index.html">张焕晨</a></li>
<li>卡耐基梅隆CMU<a target="_blank" rel="noopener" href="http://www.cs.cmu.edu/~pavlo/">Andy Pavlo</a></li>
<li>慕尼黑工业<a target="_blank" rel="noopener" href="https://scholar.google.com/citations?hl=zh-CN&user=xSDfDpsAAAAJ&view_op=list_works&sortby=pubdate">Thomas Neumann</a></li>
</ul>
<h2 id="工程技能"><a href="#工程技能" class="headerlink" title="工程技能"></a>工程技能</h2><ul>
<li>git 版本管理</li>
<li>Linux&#x2F;shell 命令</li>
<li>Flame Graph 火焰图</li>
<li>gdb 调试</li>
</ul>
<h2 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h2><ul>
<li>大厂（阿里，腾讯，华为）</li>
<li>四朵金花（达梦，人大金仓，南大通用，神舟通用）</li>
<li>开源界扛把子：PingCAP</li>
<li>大牛初创公司<ul>
<li>Singularity data </li>
<li>天谋科技</li>
<li>偶数科技</li>
<li>四维纵横</li>
<li>Hashdata</li>
<li>Starrocks</li>
<li>selectDB</li>
<li>zilliz</li>
<li>OpenPie</li>
</ul>
</li>
</ul>
<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.inlighting.org/archives/how-to-find-a-database-job">沧海月明</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/undefined/undefined/undefined/undefined/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/undefined/undefined/undefined/" class="post-title-link" itemprop="url">csapp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-06-15 20:20:57 / Modified: 20:26:29" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/csapp/" itemprop="url" rel="index"><span itemprop="name">csapp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h1><h2 id="0x-ff-杂项"><a href="#0x-ff-杂项" class="headerlink" title="0x ff 杂项"></a>0x ff 杂项</h2><p>Instruction set Architecture：ISA,指令集体系架构</p>
<p>软件和硬件之间的一层抽象层</p>
<p>冯诺依曼计算机，即程序<strong>存储型</strong>计算机</p>
<p>重要思想：程序就是一系列被编码了的字节序列（看上去和数据一模一样）</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/SovietPower/p/14877143.html">https://www.cnblogs.com/SovietPower/p/14877143.html</a></p>
<h2 id="0x-00-参考资料-amp-amp-lab"><a href="#0x-00-参考资料-amp-amp-lab" class="headerlink" title="0x 00 参考资料 &amp;&amp; lab"></a>0x 00 参考资料 &amp;&amp; lab</h2><p>official：</p>
<p><a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/students.html">官网</a></p>
<p><a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/labs.html">实验</a></p>
<hr>
<p>note:</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17K4y1N7Q2?spm_id_from=333.999.0.0&vd_source=38033fe3a1f136728a1d6f8acf710b51">视频详解</a> </p>
<p><a target="_blank" rel="noopener" href="https://github.com/yangminz/bcst_csapp">笔记参考视频的源码</a></p>
<hr>
<p>lab：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/wuxueqian14/CSAPP-Lab#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">比较详细的Attack，Data，Boom Lab参考</a></p>
<p><a target="_blank" rel="noopener" href="https://kazamayc.github.io/2021/02/05/csapp-lab/">Boom，Attack，Shell Lab</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/505497911">全部实验的详细参考–知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43362650/article/details/122890142">全部实验的详细参考–CSDN</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Exely/CSAPP-Labs">全部实验的详细参考–Github</a></p>
<hr>
<p>video:</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1RK4y1R7Kf?spm_id_from=333.999.0.0&vd_source=38033fe3a1f136728a1d6f8acf710b51">导读</a>        <a target="_blank" rel="noopener" href="https://fengmuzi2003.gitbook.io/csapp3e/">导读笔记</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cD4y1D7uR?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click&vd_source=38033fe3a1f136728a1d6f8acf710b51">小视频复习</a></p>
<hr>
<p>book：</p>
<p><a target="_blank" rel="noopener" href="https://hansimov.gitbook.io/csapp/">学生版重点知识</a></p>
<p><a href="instructor">讲师版重点知识</a></p>
<hr>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lab操作流程</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.datalab：</span></span><br><span class="line">在源文件 bits.c 中完善函数即可</span><br><span class="line">./dlc bits.c 	 // 用于检查程序是否合法，是否使用了程序规定的符号</span><br><span class="line">make btest   	 // btest是评分(检查对错工具)，每次执行btets前都要重新make一下</span><br><span class="line">./btest bits.c   // 评分</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.bomblab</span></span><br><span class="line">./bomb</span><br><span class="line">输入答案</span><br><span class="line">导读P3-52分钟有第一关的实操</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.attacklab</span></span><br><span class="line">./hex2raw &lt; att1.txt &gt; attraw1.txt // 将字节序列at t1转换为字符串attraw1</span><br><span class="line">./ctarget -q -i attraw1.txt     //测试答案</span><br><span class="line">// (https://github.com/wuxueqian14/csapp-lab/tree/master/Attack%20Lab)</span><br></pre></td></tr></table></figure>



<h2 id="0x-01-二进制"><a href="#0x-01-二进制" class="headerlink" title="0x 01 二进制"></a>0x 01 二进制</h2><p>内存中存储的是电压，然后通过（不知道）某种方式<strong>抽象</strong>为数字01，然而计算机的内存太大了，以致于01的个数实在太多了，于是，我们把原有的0和1分块，并再次抽象为0,1…。</p>
<p><img src="file:///C:\Users\24072\AppData\Roaming\Tencent\Users\2407217576\QQ\WinTemp\RichOle\7E[W6J9]YPX$8MS~3CCM[DG.png" alt="img"></p>
<p>加入内存中有n bit,每m bit分为一块，则最多可以分为2^m块，因为m bit的排列组合数为2 ^ n个序列（sequence）</p>
<p>例如十进制数字123，它应该表示为<code>1*10^2 + 2*10^1 + 3*10^0</code>，所以这里的123准确来说应该是一个sequence，而不是一个数。</p>
<p>数是一个比较唯心的抽象的概念，你说一个数3，它可以是十进制序列3，也可以是二进制序列11…，3和11都是这个真正的（唯心的）3，这些序列之间是一一对应的，不仅如此，他们的运算也是一一对应的。十进制的序列1+2，对应的二进制下序列为1+01</p>
<p><strong>取反对称</strong>：对称轴的两侧是相反数</p>
<p>对于1,2,3,4，他们分别取反对称于-1，-2，-3，-4</p>
<p>对于二进制000,001,010,011，他们分别取反对称于111,110,101,100</p>
<p><img src="https://s1.328888.xyz/2022/08/29/CrzXC.png" alt="IMAGE"></p>
<h2 id="0x-02-二进制运算"><a href="#0x-02-二进制运算" class="headerlink" title="0x 02 二进制运算"></a>0x 02 二进制运算</h2><p><strong>位运算的循环圈：</strong></p>
<p><img src="https://s1.328888.xyz/2022/09/06/5OAqi.png" alt="IMG"></p>
<p>​										（int类型有符号数）</p>
<p><img src="https://s1.328888.xyz/2022/09/06/5jEa0.png" alt="img"></p>
<p>​										(int类型无符号数)</p>
<p>通过这张图，你可能会更好地理解补码和无符号数运算是在mod 2^n 下计算的意义。</p>
<p>看一下树状数组lowbit函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x; <span class="comment">// &lt;==&gt; x &amp; (~x + 1);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数为什么能求得最后一个1所在位置的代表的权值呢？</p>
<p>首先 -x，其实就是x的补码。关于补码，我们有一个求补码的方法：从右到左直到第一个1保持不变，后面的位取反，我们将x和x的补码做与运算，最后得到的结果一定是这样的形式：00..010..0，最后一个1左侧全为0，右侧也全为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">func1</span><span class="params">(<span class="type">unsigned</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 输出一个无符号数x，判断x在十六进制下的的每一位是不是字母</span></span><br><span class="line">    <span class="comment">// 如果该位是字母就返回1，否则返回0</span></span><br><span class="line">    <span class="comment">// 并以一个16进制数的形式返回</span></span><br><span class="line">    <span class="type">unsigned</span> x1 = (x &amp; <span class="number">0x22222222</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> x2 = (x &amp; <span class="number">0x44444444</span>) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> x3 = (x &amp; <span class="number">0x88888888</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;[1]:%04x\n[2]:%04x\n[3]:%04x\n&quot;, x1, x2, x3);</span></span><br><span class="line">    <span class="keyword">return</span> x3 &amp; (x2 | x1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">func2</span><span class="params">(<span class="type">unsigned</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 输出一个无符号数x，判断x在十六进制下的每一位是不是字母</span></span><br><span class="line">    <span class="comment">// 如果所有位都是字母返回1，否则返回0</span></span><br><span class="line">    x = func1(x); <span class="comment">//得到了每一位的结果</span></span><br><span class="line">    x = x &amp; (x &gt;&gt; <span class="number">16</span>); <span class="comment">// 每次判断一半</span></span><br><span class="line">    x = x &amp; (x &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">    x = x &amp; (x &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">func3</span><span class="params">(<span class="type">unsigned</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// bigCount</span></span><br><span class="line">    <span class="type">unsigned</span> c;</span><br><span class="line">    c = (x &amp; <span class="number">0x55555555</span>) + ((x &gt;&gt;  <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    c = (c &amp; <span class="number">0x33333333</span>) + ((c &gt;&gt;  <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    c = (c &amp; <span class="number">0x0f0f0f0f</span>) + ((c &gt;&gt;  <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>);</span><br><span class="line">    c = (c &amp; <span class="number">0x00ff00ff</span>) + ((c &gt;&gt;  <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>);</span><br><span class="line">    c = (c &amp; <span class="number">0x0000ffff</span>) + ((c &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> x = <span class="number">0x1</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;0x%X = %X\n&quot;, x, func1(x));</span></span><br><span class="line">    <span class="comment">// printf(&quot;0x%X = %X\n&quot;, x, func2(x));</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%X = %d\n&quot;</span>, x, func3(x));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0x-03-浮点数"><a href="#0x-03-浮点数" class="headerlink" title="0x 03 浮点数"></a>0x 03 浮点数</h2><p>为什么 IEEE 754浮点数Float类型的bias&#x3D;127而不是128？</p>
<p>其实这也没有一个官方的说法，不过为了让自己接受这个设定，我们可以从两个角度考虑：</p>
<ol>
<li>首先，bias采用127时绝对值的范围比较对称</li>
<li>其次，bias采用127时最大的指数是127比bias&#x3D;128时的126大，虽然只大1，但是我们直到指数的增长是“爆炸”的，因此其表示的范围也大得多。</li>
</ol>
<p>浮点的根据exp和frac分为三种情况：</p>
<ol>
<li>exp&#x3D;111..1，指数全1。此时又分为两种情况：（1）当frac全0时表示无穷大，根据符号位又分为正无穷和负无穷。（2）frac不全为0，表示NaN，一种未定义行为。（可以这样区分无穷和NaN，由于未定义的行为有很多，因此需要根据frac进一步区分，所以frac不是固定的全0，（胡乱猜的），可以这样记忆）。</li>
<li>exp&#x3D;000..0，指数全0。表示不规格化的浮点数。这里的主要目的是为了拓展精度和范围（往值小的方向）。</li>
<li>else，规格化浮点数。</li>
</ol>
<p>将一个无符号数转换为一个浮点数的表示形式并保存在一个无符号数字中</p>
<p><a target="_blank" rel="noopener" href="https://lostphp.com/hexconvert/">IEEE 754浮点数十六进制相互转换</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/68131179">关于浮点数舍入的讨论</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">uint2float</span><span class="params">(<span class="type">uint32_t</span> u)</span>&#123; <span class="comment">// 将一个服务号数u转换成浮点数存储的形式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 特判</span></span><br><span class="line">    <span class="keyword">if</span> (u == <span class="number">0x00000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x00000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到最后一个1的后面的一个位置，求得该1后面还有多少个数</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">0</span> &amp;&amp; (((u &gt;&gt; n) &amp; <span class="number">0x1</span>) == <span class="number">0x0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        n = n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n: &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint32_t</span> e, f; <span class="comment">// exp, frac</span></span><br><span class="line">    <span class="comment">// &lt;= 0000 0000 1.111 1111 1111 1111 1111 1111 : 32位</span></span><br><span class="line">    <span class="comment">// u的位数&lt;=24，此时再隐藏一个1，就&lt;=23位，于是frac就可以保存所有位，不需要舍入</span></span><br><span class="line">    <span class="keyword">if</span> (u &lt;= <span class="number">0x00ffffff</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// no need rounding</span></span><br><span class="line">        <span class="type">uint32_t</span> mask = <span class="number">0xffffffff</span> &gt;&gt; (<span class="number">32</span> - n); <span class="comment">// mask就是frac的掩码</span></span><br><span class="line">        f = (u &amp; mask) &lt;&lt; (<span class="number">23</span> - n);             <span class="comment">// f = u &amp; mask得到frac，但还需要左移移动到最右侧[frac00..0]，而不是[00..0frac]</span></span><br><span class="line">        e = n + <span class="number">127</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;e: 0x%x, f: 0x%x\n&quot;</span>, e, f);</span><br><span class="line">        <span class="keyword">return</span> (e &lt;&lt; <span class="number">23</span>) | f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;= 0000 0001 0000 0000 0000 0000 0000 0000 </span></span><br><span class="line">    <span class="comment">// 总位数&gt;=25，一位可以隐藏，还剩下至少24位，frac无法全部保存，需要舍入(rounding)</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// expand to 64 bit for situations like 0xffffffff</span></span><br><span class="line">        <span class="type">uint64_t</span> a = <span class="number">0</span>;</span><br><span class="line">        a += u;</span><br><span class="line">        <span class="comment">// compute g, r, s</span></span><br><span class="line">        <span class="type">uint32_t</span> g = (a &gt;&gt; (n - <span class="number">23</span>)) &amp; <span class="number">0x1</span>;</span><br><span class="line">        <span class="type">uint32_t</span> r = (a &gt;&gt; (n - <span class="number">23</span> - <span class="number">1</span>)) &amp; <span class="number">0x1</span>;</span><br><span class="line">        <span class="type">uint32_t</span> s = <span class="number">0x0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">23</span> - <span class="number">1</span>; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            s = s | ((u &gt;&gt; j) &amp; <span class="number">0x1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// compute carry</span></span><br><span class="line">        a = a &gt;&gt; (n - <span class="number">23</span>);</span><br><span class="line">        <span class="comment">// 0    1    ?    ... ?</span></span><br><span class="line">        <span class="comment">// [24] [23] [22] ... [0]</span></span><br><span class="line">        <span class="keyword">if</span> (r &amp; (g | s) == <span class="number">0x1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = a + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check carry</span></span><br><span class="line">        <span class="keyword">if</span> ((a &gt;&gt; <span class="number">23</span>) == <span class="number">0x1</span>) /</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 0    1    ?    ... ?</span></span><br><span class="line">            <span class="comment">// [24] [23] [22] ... [0]</span></span><br><span class="line">            f = a &amp; <span class="number">0x007fffff</span>; <span class="comment">// 0x0000 0000 0111 1111 1111 1111 1111 1111只保留frac</span></span><br><span class="line">            e = n + <span class="number">127</span>;</span><br><span class="line">            <span class="keyword">return</span> (e &lt;&lt; <span class="number">23</span>) | f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((a &gt;&gt; <span class="number">23</span>) == <span class="number">0x2</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1    0    0    ... 0</span></span><br><span class="line">            <span class="comment">// [24] [23] [22] ... [0]</span></span><br><span class="line">            e = n + <span class="number">1</span> + <span class="number">127</span>;</span><br><span class="line">            <span class="keyword">return</span> (e &lt;&lt; <span class="number">23</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// INF as default error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x7f800000</span>; <span class="comment">// 0 1111 1111 000 0000 0000 0000 0000 0000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;  <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, uint2float(<span class="number">0x10000000</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0x-04-时序电路和组合电路"><a href="#0x-04-时序电路和组合电路" class="headerlink" title="0x 04 时序电路和组合电路"></a>0x 04 时序电路和组合电路</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_20265495/article/details/41314577">原文链接：</a></p>
<hr>
<p><strong>数字电路</strong>根据逻辑功能的不同特点，可以分成两大类，一类叫<strong>组合逻辑电路</strong>（简称组合电路），另一类叫做<strong>时序逻辑电路</strong>（简称时序电路）。组合逻辑电路在逻辑功能上的特点是任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关。而时序逻辑电路在逻辑功能上的特点是任意时刻的输出不仅取决于当时的输入信号，而且还取决于电路原来的状态，或者说，还与以前的输入有关。</p>
<p>时序电路，是由最基本的逻辑门电路加上反馈逻辑回路（输出到输入）或器件组合而成的电路，与组合电路最本质的区别在于时序电路具有记忆功能。</p>
<p>时序电路的特点是：输出不仅取决于当时的输入值，而且还与电路过去的状态有关。它类似于含储能元件的电感或电容的电路，如触发器、锁存器、计数器、移位寄存器、存储器等电路都是时序电路的典型器件，时序逻辑电路的状态是由存储电路来记忆和表示的。</p>
<p>时序电路和组合电路的区别：<br>时序电路具有<strong>记忆功能</strong>。时序电路的特点是：输出不仅取决于当时的输入值，而且还与电路过去的状态有关。组合逻辑电路在逻辑功能上的特点是任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关</p>
<p>时序电路是 时序 逻辑 电路。时序，时间 顺序，是在时钟的推动下工作的，cpu就是一个复杂的时序电路。</p>
<p>组合逻辑电路和时序逻辑电路的最根本区别在于：组合逻辑电路的输出在任一时刻只取决于当时的输入信号；而时序逻辑电路的输出，不仅和当前的输入有关，还和上时刻的输出有关，它具有记忆元件（触发器），可以记录前一时刻的输出状态，它可以没有输入，仅在时钟的驱动下，给出输出。</p>
<p>时序电路的基本结构：</p>
<p><img src="https://img-blog.csdn.net/20151210201333026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>结构特征：<em>电路由组合电路和存储电路组成</em>，电路存在反馈 </p>
<h2 id="0x-05-缓冲区漏洞实验"><a href="#0x-05-缓冲区漏洞实验" class="headerlink" title="0x 05 缓冲区漏洞实验"></a>0x 05 缓冲区漏洞实验</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//bomb.c</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">4</span>];</span><br><span class="line">	gets(buffer); <span class="comment">//缓冲区溢出的关键</span></span><br><span class="line">	<span class="built_in">puts</span>(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;pls input: &quot;</span>);</span><br><span class="line">	echo();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">操作步骤：</span><br><span class="line">1. gcc bomb.c -o main -fno-stack-protector -g</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-fno-stack-protector取消栈保护？</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-g调试模式，因为后面还需要调试</span></span><br><span class="line"></span><br><span class="line">2. gdb main</span><br><span class="line">2.1 在echo函数的gets函数加上一个断点：b 6</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span>函数位于main.c的第六行</span></span><br><span class="line">2.2 r</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">run运行程序，此时会在断点gets函数停下</span></span><br><span class="line">2.3 info f </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示栈信息，如下方图-栈信息所示</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在这些信息中，我们需要注意三个地址：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(1)frame at 0x7ff.f3d0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(2)rbp at   0x7ff.f3c0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(3)bip at.  0x7ff.f3c8</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中frame at的地址是函数<span class="built_in">echo</span>占用栈的地址</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时，返回地址rip和旧的栈顶指针rbp已经入栈</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">由此可见，程序还没运行，返回地址和旧的栈顶指针就会入栈</span></span><br><span class="line">2.4 p/a &amp;buffer[0]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印数组buffer的首地址</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过结构图，我们可以发现，数组与返回地址rip之间差了12（c8-bc）字节，如果我们gets的数组大于等于12字节，那么返回地址的数据就会被破坏，</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>![image-20220907100422585](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220907100422585.png)</p>
<p>(图-栈信息)</p>
<p>![13C288AA-6A07-463D-A689-CC7FEF2DCB91](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;13C288AA-6A07-463D-A689-CC7FEF2DCB91.png)</p>
<p>(图-数组地址)</p>
<p><img src="https://1484576603-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MV9vJFv4kmvRLgEog6g%2F-MZuBW3GNKr5zld5JHFH%2F-MZuER6OHxdJ7z3gtPNL%2Fimage.png?alt=media&token=ecba360a-06d3-4734-9430-aab5fd84cbee" alt="img"></p>
<p>(图-视频测试运行gets前的栈)</p>
<p><img src="https://1484576603-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MV9vJFv4kmvRLgEog6g%2F-MZrajFxkCIYEw7i-1-F%2F-MZrrKB09-F7NqAWNBKB%2Finitpintu_%E5%89%AF%E6%9C%AC.jpg?alt=media&token=35b89f3f-e6d2-4aa9-b7d0-2da8ad86450b" alt="img"></p>
<p>（图-视频测试运行gets后的栈）</p>
<h2 id="0x-06-Computer-English"><a href="#0x-06-Computer-English" class="headerlink" title="0x 06 Computer English"></a>0x 06 Computer English</h2><hr>
<p>common：注释</p>
<p>override：覆盖</p>
<p>entry：入口，条目，输入</p>
<p>Place holder：站位</p>
<p>ascending：升序</p>
<p>descending：降序</p>
<p>comma：逗号</p>
<p>brackets：括号</p>
<p>determine: 确定，决定，判定，下决心</p>
<p>deterministic: 确定行</p>
<p>finite: 有限的</p>
<p>infinite: 无限的</p>
<p>automaton: 自动机</p>
<p>positive: 正数</p>
<p>negative: 负数</p>
<p>decimal: 十进制</p>
<p>hexadecimal：十六进制</p>
<p>octal: 八进制</p>
<p>optimazation：优化</p>
<p>pruning：剪枝</p>
<p>decode:译码</p>
<p>instance: 例子，实例</p>
<p>cpu和memory 就组成了一个状态机</p>
<p>operand 操作数</p>
<p>opreator：操作符</p>
<p>memory：内存&#x2F;存储器</p>
<p>recursion：递归</p>
<p>reduce：归约</p>
<p>iterate: 迭代</p>
<p>transistor：晶体管</p>
<p>complement：补充，补运算(～)，辅</p>
<p>parse: 解析</p>
<p>simulator: 模拟器</p>
<p>simulate: 模拟，仿真，假装</p>
<p>converter：转换器</p>
<p>verbose: 冗长的，啰嗦</p>
<p>handler: 管理者，处理程序</p>
<p>illustrate: 说明</p>
<p>universal: 通用的</p>
<p>pecuilar:  特有，奇特，一场</p>
<hr>
<h2 id="0x-07-makefile"><a href="#0x-07-makefile" class="headerlink" title="0x 07 makefile"></a>0x 07 <a target="_blank" rel="noopener" href="https://subingwen.cn/linux/makefile/#3-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F">makefile</a></h2><h3 id="1-规则"><a href="#1-规则" class="headerlink" title=".1 规则"></a>.1 规则</h3><p>（1）make命令具有<strong>自动推导</strong>的功能，例如依赖中的.o文件，即使不存在，make会使用内部默认的构造规则生成这些.o文件。</p>
<p>（2）make后面<strong>不带参数</strong>默认执行第一条命令</p>
<p>（3）mak的<strong>时间戳规则</strong>：</p>
<blockquote>
<p>make 命令执行的时候会根据文件的时间戳判定是否执行 makefile 文件中相关规则中的命令。</p>
<ol>
<li>目标是通过依赖生成的，因此正常情况下：目标时间戳 &gt; 所有依赖的时间戳 , 如果执行 make 命令的时候检测到规则中的目标和依赖满足这个条件，那么规则中的命令就不会被执行。</li>
<li>当依赖文件被更新了，文件时间戳也会随之被更新，这时候 目标时间戳 &lt; 某些依赖的时间戳 , 在这种情况下目标文件会通过规则中的命令被重新生成。</li>
<li>如果规则中的目标对应的文件根本就不存在， 那么规则中的命令肯定会被执行。</li>
</ol>
</blockquote>
<p>（4）对于不生成目标文件的目标称为伪目标，为了避免微伪目标的名字和真实的文件名重复，我们可以在伪目标的前面加上关键字：.PHONY(假) 例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean: </span></span><br><span class="line">	rm *.o</span><br></pre></td></tr></table></figure>

<p>声明位伪目标主要是避免这种情况：</p>
<blockquote>
<p>如果目标不存在规则的命令肯定被执行， 如果目标文件存在了就需要比较规则中目标文件和依赖文件的时间戳，满足条件才执行规则的命令，否则不执行。</p>
<p>加入目标是clean，而恰好有一个真实的clean文件，只要clean文件不更新，那么clean目标就无法执行。</p>
</blockquote>
<p>（提醒）<strong>目录连接到博客中的实例6可以好好看看👀</strong></p>
<h3 id="2-变量"><a href="#2-变量" class="headerlink" title=".2 变量"></a>.2 变量</h3><p>make中的变量分为三种：</p>
<p><strong>1.自定义变量</strong>：即用户自己定义的变量，makefile中的变量是<strong>没有类型</strong>的，直接创建变量然后给其赋值就可以了。通过$(obj) 可以取出自定义的obj变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">obj = main.c</span><br><span class="line">target = main</span><br><span class="line">depend = main.o</span><br><span class="line"></span><br><span class="line">$(target): $(depend)</span><br><span class="line">	gcc $(obj) -o $(target)</span><br><span class="line"></span><br><span class="line"># --------------</span><br><span class="line"># 上面的命令等价于下面：</span><br><span class="line"></span><br><span class="line">main: main.o</span><br><span class="line">	gcc main.c -o main</span><br></pre></td></tr></table></figure>

<p><strong>2.预定义变量：</strong>在makefile中有一些已经定义好的变量，用户可以直接使用这些变量，不用进行定义，预定义变量的名字一般是大写的。</p>
<p>![96D31374-3040-4B27-8A65-B9DE685E3351](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;96D31374-3040-4B27-8A65-B9DE685E3351.png)</p>
<p><strong>3.自动变量：</strong>makefile智能鼓的规则语句经常会出现目标文件和依赖文件，<strong>自动变量用来代表这些规则中的目标文件和依赖文件，并且衙门只能在规则的命令总使用。</strong></p>
<p>![DC05ED8E-B70B-44FB-A799-E6D0C938CF7F](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;DC05ED8E-B70B-44FB-A799-E6D0C938CF7F.png)</p>
<h3 id="3-模式匹配"><a href="#3-模式匹配" class="headerlink" title=".3 模式匹配"></a>.3 模式匹配</h3><p>模式匹配常常与自动变量结合使用，用来简化makefile，减少冗余和重复书写。</p>
<h3 id="4-函数"><a href="#4-函数" class="headerlink" title=".4 函数"></a>.4 函数</h3><p>1.wildcard：通配符，用来匹配制定目录下的文件</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用举例: 分别搜索三个不同目录下的 .c 格式的源文件</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> /home/robin/a/*.c /home/robin/b/*.c *.c)</span>  <span class="comment"># *.c == ./*.c</span></span><br><span class="line"><span class="comment"># 返回值: 得到一个大的字符串, 里边有若干个满足条件的文件名, 文件名之间使用空格间隔</span></span><br><span class="line">/home/robin/a/a.c /home/robin/a/b.c /home/robin/b/c.c /home/robin/b/d.c e.c f.c</span><br></pre></td></tr></table></figure>



<p>2.patsubst：pattern subsitude，匹配代替，用来替换文件名的后缀</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src = a.cpp b.cpp c.cpp e.cpp</span><br><span class="line"><span class="comment"># 把变量 src 中的所有文件名的后缀从 .cpp 替换为 .o</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(src)</span>)</span> </span><br><span class="line"><span class="comment"># obj 的值为: a.o b.o c.o e.o</span></span><br></pre></td></tr></table></figure>



<h2 id="0x-08-gdb"><a href="#0x-08-gdb" class="headerlink" title="0x 08 gdb"></a>0x 08 gdb</h2><h3 id="0-参考"><a href="#0-参考" class="headerlink" title=".0 参考"></a>.0 参考</h3><p>![9523F5A0-416A-4635-99DB-47685282748F](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;9523F5A0-416A-4635-99DB-47685282748F.png)</p>
<p><a target="_blank" rel="noopener" href="https://subingwen.cn/linux/gdb/#5-3-3-next">本文档参考来源，功能基础而简单</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/XxPIfrQ3E0GR88UsmQNggg">设计多线程，多进城等高级功能，较为复杂</a></p>
<p><a target="_blank" rel="noopener" href="https://www.yanbinghu.com/2019/04/20/41283.html">知乎</a></p>
<h3 id="1-添加命令行参数"><a href="#1-添加命令行参数" class="headerlink" title=".1 添加命令行参数"></a>.1 添加命令行参数</h3><figure class="highlight plaintext"><figcaption><span>args …```	启动gdb后，在程序启动之前设置参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```show args```	查看设置的命令行参数</span><br><span class="line"></span><br><span class="line">### .2 启动程序</span><br><span class="line"></span><br><span class="line">在整个gdb调试过程中，启动饮用程序的命令只能使用一次。</span><br><span class="line"></span><br><span class="line">```run```		可以缩写为 `r`，如果程序中设置了断点会停在第一个断点的位置，如果没有设置断点，程序就执行完了。</span><br><span class="line"></span><br><span class="line">`start` 	启动程序，最终会阻塞在main函数的第一行，等待输入后续其他 gdb 命令。</span><br><span class="line"></span><br><span class="line">&gt; start 是要开始运行， run 是真的运行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### .3 退出 gdb</span><br><span class="line"></span><br><span class="line">`quit`  缩写为 `q`</span><br><span class="line"></span><br><span class="line">### .4 查看代码</span><br><span class="line"></span><br><span class="line">`list`	可以缩写为 `l` ，通过这个命令可以查看项目中任意一个文件中的内容，并且还可以通过文件行号，函数名等方式查看。</span><br><span class="line"></span><br><span class="line">``` shell</span><br><span class="line">(gdb) list</span><br><span class="line">(gdb) list 行号</span><br><span class="line">(gdb) list 函数名</span><br></pre></td></tr></table></figure>

<p>一个项目通常由多个源文件构成，默认情况下通过 list 查看的是程序入口 main 函数对应的文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list 文件名：行号</span><br><span class="line">(gdb) list 文件名：函数名</span><br></pre></td></tr></table></figure>

<p>默认情况下 list 之显示 10 行的内容。如果想显示更多，可以通过 <code>set listsize</code> 设置，同时如果想查看当前显示的行数可以通过 <code>show listsize</code> 查看。这里的 	<code>listsize</code> 可以缩写为 <code>list</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set listsize 行号</span><br><span class="line">(gdb) show listsize</span><br></pre></td></tr></table></figure>



<h3 id="5-断点操作"><a href="#5-断点操作" class="headerlink" title=".5 断点操作"></a>.5 断点操作</h3><p>如果想通过 gdb 掉时某一行或者得到某个变量在运行状态下的实际值，就需要在这一行设置断点，程序指定到断点的位置就会阻塞。我们就可以通过 gdb 的调试命令得到我们想要的信息了。</p>
<p>设置断点：<code>break</code> 缩写为 <code>b</code></p>
<p>断点的设置方式由两种：</p>
<ol>
<li>常规断点：程序只要运行到这个位置就会阻塞</li>
<li>条件断点：只有指定的条件被满足了程序才会在断点处阻塞</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置普通断点到当前文件</span></span><br><span class="line">(gdb) b 行号</span><br><span class="line">(gdb) b 函数名 # 停在函数的第一行</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置普通断点到某个非当前文件</span></span><br><span class="line">(gdb) b 文件名：行号</span><br><span class="line">(gdb) b 问价名：函数名 # 停在函数的第一行</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置条件断点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通常情况下，在循环中条件断点用的比较多</span></span><br><span class="line">(gdb)  b 行号 if 变量名 == 某个值</span><br></pre></td></tr></table></figure>

<hr>
<p>查看断点：<code>info break</code> ，其中 <code>info</code> 可以缩写为 <code>i</code> , <code>break</code> 可以缩写为 <code>b</code></p>
<blockquote>
<p>info break 查看断点信息时的一些常用的属性：Num:   断点的编号，删除断点或者设置断点状态的时候都需要使用<br>Enb:    当前断点的状态，y 表示断点可用，n 表示断点不可用<br>What:  描述断点被设置在了哪个文件的哪一行或者哪个函数上</p>
</blockquote>
<hr>
<p>如果确定设置的某个断点不再被使用了，可用将其删除，删除命令是 <code>delete</code> 断点编号 , 这个 <code>delete</code> 可以简写为 <code>del</code> 也可以再简写为 <code>d</code>。</p>
<p>删除断点的方式有两种: <strong>删除(一个或者多个)指定断点</strong>或者<strong>删除一个连续的断点区间</strong>，具体操作如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">delete == del == d</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要 info b 查看断点的信息, 第一列就是编号</span></span><br><span class="line">(gdb) d 断点的编号1 [断点编号2 ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例:</span> </span><br><span class="line">(gdb) d 1          # 删除第1个断点</span><br><span class="line">(gdb) d 2 4 6      # 删除第2,4,6个断点</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除一个范围, 断点编号 num1 - numN 是一个连续区间</span></span><br><span class="line">(gdb) d num1-numN</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例, 删除第1到第5个断点</span></span><br><span class="line">(gdb) d 1-5</span><br></pre></td></tr></table></figure>



<hr>
<p>如果某个断点只是临时不需要了，我们可以将其设置为不可用状态，设置命令为 <code>disable</code> 断点编号，当需要的时候再将其设置回可用状态，设置命令为 <code>enable</code> 断点编号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 让断点失效之后, gdb调试过程中程序是不会停在这个位置的</span><br><span class="line"># disable == dis</span><br><span class="line"># 设置某一个或者某几个断点无效</span><br><span class="line">(gdb) dis 断点1的编号 [断点2的编号 ...]</span><br><span class="line"></span><br><span class="line"># 设置某个区间断点无效</span><br><span class="line">(gdb) dis 断点1编号-断点n编号</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 查看断点信息</span><br><span class="line">(gdb) i b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       breakpoint     keep y   0x0000000000400cce in main() at test.cpp:14</span><br><span class="line">4       breakpoint     keep y   0x0000000000400cdd in main() at test.cpp:16</span><br><span class="line">5       breakpoint     keep y   0x0000000000400d46 in main() at test.cpp:23</span><br><span class="line">6       breakpoint     keep y   0x0000000000400d4e in main() at test.cpp:25</span><br><span class="line">7       breakpoint     keep y   0x0000000000400d6e in main() at test.cpp:28</span><br><span class="line">8       breakpoint     keep y   0x0000000000400d7d in main() at test.cpp:30</span><br><span class="line"></span><br><span class="line"># 设置第2, 第4 个断点无效</span><br><span class="line">(gdb) dis 2 4</span><br><span class="line"></span><br><span class="line"># 查看断点信息</span><br><span class="line">(gdb) i b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       breakpoint     keep n   0x0000000000400cce in main() at test.cpp:14</span><br><span class="line">4       breakpoint     keep n   0x0000000000400cdd in main() at test.cpp:16</span><br><span class="line">5       breakpoint     keep y   0x0000000000400d46 in main() at test.cpp:23</span><br><span class="line">6       breakpoint     keep y   0x0000000000400d4e in main() at test.cpp:25</span><br><span class="line">7       breakpoint     keep y   0x0000000000400d6e in main() at test.cpp:28</span><br><span class="line">8       breakpoint     keep y   0x0000000000400d7d in main() at test.cpp:30</span><br><span class="line"></span><br><span class="line"># 设置 第5,6,7,8个 断点无效</span><br><span class="line">(gdb) dis 5-8</span><br><span class="line"></span><br><span class="line"># 查看断点信息</span><br><span class="line">(gdb) i b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       breakpoint     keep n   0x0000000000400cce in main() at test.cpp:14</span><br><span class="line">4       breakpoint     keep n   0x0000000000400cdd in main() at test.cpp:16</span><br><span class="line">5       breakpoint     keep n   0x0000000000400d46 in main() at test.cpp:23</span><br><span class="line">6       breakpoint     keep n   0x0000000000400d4e in main() at test.cpp:25</span><br><span class="line">7       breakpoint     keep n   0x0000000000400d6e in main() at test.cpp:28</span><br><span class="line">8       breakpoint     keep n   0x0000000000400d7d in main() at test.cpp:30</span><br></pre></td></tr></table></figure>

<p>让无效的断点生效：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">enable</span> == ena</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置某一个或者某几个断点有效</span></span><br><span class="line">(gdb) ena 断点1的编号 [断点2的编号 ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置某个区间断点有效</span></span><br><span class="line">(gdb) ena 断点1编号-断点n编号</span><br></pre></td></tr></table></figure>



<h3 id="6-调试命令"><a href="#6-调试命令" class="headerlink" title=".6 调试命令"></a>.6 调试命令</h3><p>如果调试的程序被断点阻塞了又想让程序继续执行，这时候就可以使用 <code>continue</code> 命令。程序会继续运行，直到遇到下一个有效的断点。&#96;&#96;continue<code>可以缩写为</code>c&#96;。</p>
<p>在 gdb 调试的时候如果需要打印变量的值， 使用的命令是 <code>print</code>, 可缩写为 <code>p</code>。如果打印的变量是整数还可以指定输出的整数的格式，格式化输出的整数对应的字符表如下：</p>
<p>![9BDD57D6-6D87-4080-B269-951C45DEC259](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;9BDD57D6-6D87-4080-B269-951C45DEC259.png)</p>
<p><code>printf</code> 的语法格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">print</span> == p</span></span><br><span class="line">(gdb) p 变量名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果变量是一个整形, 默认对应的值是以10进制格式输出, 其他格式请参考上表</span></span><br><span class="line">(gdb) p/fmt 变量名</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例</span></span><br><span class="line">(gdb) p i       # 10进制</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">5 = 3</span></span><br><span class="line">(gdb) p/x i     # 16进制</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">6 = 0x3</span></span><br><span class="line">(gdb) p/o i     # 8进制</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">7 = 03</span></span><br></pre></td></tr></table></figure>

<p>如果在调试过程中需要查看某个变量的类型，可以使用命令 <code>ptype</code>, 语法格式如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法格式</span></span><br><span class="line">(gdb) ptype 变量名</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印变量类型</span></span><br><span class="line">(gdb) ptype i</span><br><span class="line">type = int</span><br><span class="line">(gdb) ptype array[i]</span><br><span class="line">type = int</span><br><span class="line">(gdb) ptype array</span><br><span class="line">type = int [12]</span><br></pre></td></tr></table></figure>

<hr>
<p>单步调试</p>
<p><code>step</code> 命令可以缩写为 <code>s</code>, 命令被执行一次代码被向下执行一行，如果这一行是一个函数调用，那么程序会进入到函数体内部。</p>
<p>如果通过 <code>s</code> 单步调试进入到函数内部，<strong>想要跳出这个函数体， 可以执行 <code>finish</code> 命令。如果想要跳出函数体必须要保证函数体内不能有有效断点，否则无法跳出。</strong></p>
<p><code>next</code> 命令和 <code>step</code> 命令功能是相似的，只是在使用 <code>next</code> 调试程序的时候不会进入到函数体内部，<code>next</code> 可以缩写为 <code>n</code></p>
<p>通过 <code>until</code> 命令可以直接跳出某个循环体，这样就能提高调试效率了。如果想直接从循环体中跳出，必须要满足以下的条件，否则命令不会生效：</p>
<h2 id="0x-e5-结构体字节对齐规则"><a href="#0x-e5-结构体字节对齐规则" class="headerlink" title="0x e5 结构体字节对齐规则"></a>0x e5 结构体字节对齐规则</h2><p>结构体的大小绝大部分情况下不会直接等于各个成员大小的总和，编译器为了优化对结构体成员的访问总会在结构体中插入一些空白字节，有如下结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">align_basic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么此时<code>sizeof(align_basic)</code>的值会是<code>sizeof(char)+sizeof(int)+sizeof(double)</code>的值么？</p>
<p><img src="https://pic3.zhimg.com/80/v2-dca7f4f607fdbc884079e30c10ceb7ae_1440w.png" alt="img"></p>
<p>如上图经过测试我们发现其大小为16个字节并不等于1+4+8&#x3D;13个字节，可知编译器给align_basic结构体插入了另外3个字节，接下来我们将分析编译器对齐字节的规则以及结构体在内存中的结构，首先感谢<a href="https://link.zhihu.com/?target=http://blog.csdn.net/liukun321/article/details/6974282">结构体在内存中的对齐规则 - 咕唧咕唧shubo.lk的专栏 - 博客频道 - CSDN.NET</a>这篇文章的作者，在此之前我对内存对齐也是一知半解，很多时候也解释不明白。</p>
<p>&#x3D;&#x3D;规则一：结构体中元素按照定义顺序依次置于内存中，但并不是紧密排列。从结构体首地址开始依次将元素放入内存时，元素会被放置在其自身对齐大小的整数倍地址上。&#x3D;&#x3D;这里说的地址是元素在结构体中的偏移量，结构体首地址偏移量为0。</p>
<p>在align_basic中元素c是第一个元素，那么它的地址为0，第二个元素i不会被放在地址1处，int的对齐大小为4个字节，此时虽然元素c只占据一个字节，但是由于i的地址必须在4字节的整数倍上，所以地址必须再向后在移动三个字节，故而需要放在地址4上，此时前两个元素已经占据了8个字节的空间，第三个元素d会被直接放在地址8上，因为double的对齐大小为8个字节，而前面两个元素已经占据了8个字节，正好是double对齐大小的整数倍，所以元素d不需要再往后移动。说了这么多也不如让机器给我们验证下有说服力：</p>
<p><code>printf(&quot;%d %d %d %d\n&quot;, sizeof(align_basic), &amp;align_basic::c, &amp;align_basic::i, &amp;align_basic::d);</code></p>
<p><img src="https://pic3.zhimg.com/80/v2-d729bea11322919cc59e03e03d3e221a_1440w.png" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-25407fa9c8f77c2f3d17a12546793a0d_1440w.png" alt="img"></p>
<p>那么这样就够了吗，会不会太简单？我们把元素i和d的位置交换下，此时结构体的大小会是20吗，我们仍然先让机器说话，(⊙o⊙)…毕竟后面打脸有证据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">align_basic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">double</span> d;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(align_basic));</span><br></pre></td></tr></table></figure>

<p><img src="https://pic4.zhimg.com/80/v2-cbfea1a547f205a2d4b2306748da3953_1440w.png" alt="img"></p>
<p>我们发现此时结构体的大小并不是20而是24，那么多出来的这4个字节如何解释？我们引出第二条规则。</p>
<p>&#x3D;&#x3D;规则二：如果结构体大小不是所有元素中最大对齐大小的整数倍，则结构体对齐到最大元素对齐大小的整数倍，填充空间放置到结构体末尾。&#x3D;&#x3D;</p>
<p>运用规则一，此时c仍然是第一个元素，其地址为0，第二个元素地址为8， 第三个元素地址为16，然后运用规则二，c，d，i中d的对齐大小为8最大所以整个结构必须对齐到8的整数倍，前面是三个元素已经占据了20个字节的空间，只需要在结构体的尾部填充4个字节的空间就是8的倍数了，所以此时整个结构体的大小为24个字节。</p>
<p><code>printf(&quot;%d %d %d %d\n&quot;, sizeof(align_basic), &amp;align_basic::c, &amp;align_basic::d, &amp;align_basic::i);</code></p>
<p><img src="https://pic3.zhimg.com/80/v2-c66b0aa643b60eecb9dbf06916c56482_1440w.png" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-0294208ed70bb94feb9868310a191eb3_1440w.png" alt="img"></p>
<p>&#x3D;&#x3D;规则三：基本数据类型的对齐大小为其自身的大小，结构体数据类型的对齐大小为其元素中最大对齐大小元素的对齐大小。&#x3D;&#x3D; 规则三可以由规则二推导出来。</p>
<p>char类型的对齐大小为1字节，short类型的对齐大小为2字节，int类型的大小为4字节，double的对齐大小为8字节，align_basic结构体中最大对齐大小元素为d是double类型，所以align_basic的对齐大小是8。有人会问如果结构体中有数组呢？很简单将数组看做是连续数个相同类型的元素即可。</p>
<h2 id="0x-e6-第一章小结"><a href="#0x-e6-第一章小结" class="headerlink" title="0x e6 第一章小结"></a>0x e6 第一章小结</h2><p>深入理解计算机系统的“系统”，并不是操作系统，这个系统包括了硬件，操作系统，网络，编译等等</p>
<p>学习计算机系统应该具备的三个<strong>抽象能力</strong>：问题抽象，系统抽象（csapp），数据抽象</p>
<p>计算机系统是由硬件和<strong>系统软件</strong>组成的。</p>
<p>数字的机器表示方法是对真值的<strong>有限近似值</strong>。</p>
<p>指令的执行：</p>
<ol>
<li>从磁盘读取指令和数据到内存</li>
<li>从内存送到cpu中去执行</li>
<li>将返回的数据送到屏幕</li>
</ol>
<h2 id="0x-e7-bomb-lab"><a href="#0x-e7-bomb-lab" class="headerlink" title="0x e7 bomb lab"></a>0x e7 bomb lab</h2><h3 id="1-phase1"><a href="#1-phase1" class="headerlink" title=".1 phase1"></a>.1 phase1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">disas main，可以发现我们输入的字符串赋值给了 $rdi</span><br><span class="line">并且之后调用了函数&lt;phase_1&gt;</span><br><span class="line">disas phase_1</span><br><span class="line">发现没有修改寄存器 $rdi 的值</span><br><span class="line">然后把一个立即数 0x402400 传给了寄存器 $esi</span><br><span class="line">之后调用函数 &lt;strings_not_euqal&gt;</span><br><span class="line">在之后test $eax $eax</span><br><span class="line">如果 je，即 $eax = 0</span><br><span class="line">调用函数 &lt;eoplode_bomb&gt;，炸弹爆炸</span><br><span class="line">否则正常返回</span><br><span class="line"></span><br><span class="line">进入函数 &lt;strings_not_equal&gt;</span><br><span class="line">该函数又会调用 &lt;string_length&gt; 函数</span><br><span class="line">这个函数会计算 $rdi 内字符串的长度</span><br><span class="line"></span><br><span class="line">p/x $rdx :以x(16进制)方式打印寄存器$rdx的值</span><br><span class="line">x $rdx 检查(examine) $rdx内存中的值</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/36809923">watch &#x3D; sepcial break</a></p>
<h3 id="2-phase2"><a href="#2-phase2" class="headerlink" title=".2 phase2"></a>.2 phase2</h3><h3 id="3-phase3"><a href="#3-phase3" class="headerlink" title=".3 phase3"></a>.3 phase3</h3><p>![78E9B95E-D7EC-4E49-8A30-94EF4B0A4D48](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;78E9B95E-D7EC-4E49-8A30-94EF4B0A4D48.png)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># phase_3</span><br><span class="line"><span class="title function_">if</span><span class="params">(eax &gt; <span class="number">1</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">7</span> &lt; rsp + <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        eax = rsp + <span class="number">0x8</span>; <span class="comment">// first input</span></span><br><span class="line">        <span class="keyword">switch</span>(eax)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">                eax = <span class="number">0xcf</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                eax = <span class="number">0x137</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                eax = <span class="number">0x2c3</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                eax = <span class="number">0x100</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                eax = <span class="number">0x185</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                eax = <span class="number">0xce</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                eax = <span class="number">0x2aa</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">        &#125;</span><br><span class="line">        	<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        		eax = <span class="number">0x147</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;       		</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BOOM!!!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有多组答案：注意第二个参数不能输入十六进制数，只能输入10进制数，因为这里的数据的读如是采用sscanf，把我们的输入作为str,如果我们的第二个参数是个十六进制数，那么一定以0x开头，结果0会被读取到第二个参数，读到x不合法就结束了。</p>
<table>
<thead>
<tr>
<th>第一个参数</th>
<th>第二个参数</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>207</td>
</tr>
<tr>
<td>1</td>
<td>311</td>
</tr>
<tr>
<td>2</td>
<td>707</td>
</tr>
<tr>
<td>3</td>
<td>256</td>
</tr>
<tr>
<td>4</td>
<td>389</td>
</tr>
<tr>
<td>5</td>
<td>206</td>
</tr>
<tr>
<td>6</td>
<td>682</td>
</tr>
<tr>
<td>7</td>
<td>327</td>
</tr>
</tbody></table>
<h3 id="4-phase4"><a href="#4-phase4" class="headerlink" title=".4 phase4"></a>.4 phase4</h3><p>第一个参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.func4:</span><br><span class="line">eax = edx</span><br><span class="line">eax -= edx</span><br><span class="line">ecx = eax</span><br><span class="line">ecx &gt;&gt;= <span class="number">0x1f</span> <span class="comment">// unsigned</span></span><br><span class="line">eax += ecx</span><br><span class="line">eax &gt;&gt;= <span class="number">1</span></span><br><span class="line">ecx = &amp;(rax+rso+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span>(ecx &lt;= edi)  </span><br><span class="line">&#123;</span><br><span class="line">    eax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(exc &gt;= edi)  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 只有当 ecx&lt;=edi&lt;=ecx，即edi=ecx=7时可以正常退出并返回0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        。。。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    edx = &amp;(rcx - <span class="number">1</span>)</span><br><span class="line">    call func4</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// goal: make eax = 0</span></span><br></pre></td></tr></table></figure>



<p>第二个参数看phrase4的汇编很容易得出为0</p>
<h3 id="5-phase5"><a href="#5-phase5" class="headerlink" title=".5 phase5"></a>.5 phase5</h3><p><a target="_blank" rel="noopener" href="https://github.com/wuxueqian14/csapp-lab/tree/master/Bomb%20Lab">reference</a></p>
<h3 id="6-phase6"><a href="#6-phase6" class="headerlink" title=".6 phase6"></a>.6 phase6</h3><p>不想做了</p>
<h3 id="7-phase7"><a href="#7-phase7" class="headerlink" title=".7 phase7"></a>.7 phase7</h3><p>no</p>
<h3 id="8-answer-2016"><a href="#8-answer-2016" class="headerlink" title=".8 answer(2016)"></a>.8 answer(2016)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">7 327</span><br><span class="line">7 0</span><br><span class="line">)/.%&amp;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="0x-09-Assembly实验"><a href="#0x-09-Assembly实验" class="headerlink" title="0x 09 Assembly实验"></a>0x 09 Assembly实验</h2><p><img src="/Users/epoch/Library/Containers/com.tencent.qq/Data/Library/Caches/Images/BE9A5FC6EBB55797FF78C5D5105D31DF.png" alt="BE9A5FC6EBB55797FF78C5D5105D31DF"></p>
<p>如上图，我们用(gdb) x mingling打印 0x7fffffffe3b0附近的值，这个地址是个虚拟地址，它在内存中的值为0x0</p>
<p>栈指针是会浮动的！但是rsp和rbp的差值应该是不变的。</p>
<p>gdb(ni) ：会跳出函数执行</p>
<p>gdb(si)：会进入函数执行</p>
<p>![A44D5C36-2816-49B3-9E01-23E15BC5DA72](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;A44D5C36-2816-49B3-9E01-23E15BC5DA72.png)</p>
<p>小端存储的又一个例子啊，我们把寄存器 %rbp(0x7fffffffe3d0) 放入 %rsp，观察可以发现，0x00007ffff倍放在了后面的地址，而0xffffe3d0被放在了前面的地址。x命令打印的地址从左到右，从上到下是以4为单位递增的，</p>
<h2 id="0x-0a-ld-preload环境变量劫持函数"><a href="#0x-0a-ld-preload环境变量劫持函数" class="headerlink" title="0x 0a ld_preload环境变量劫持函数"></a>0x 0a ld_preload环境变量劫持函数</h2><p>首先在目录下创建两个文件 main.c 和 txt</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> <span class="comment">// main.c</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE *fd = fopen(<span class="string">&quot;txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;*** open file error!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;open file success!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常来说最后程序会正确执行</p>
<p>但如果我们更改动态链接库</p>
<p>先创建一个trik动态链接库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">// trik.c</span></span></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*** Always open error!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC trik.c -o trik.so</span><br><span class="line">LD_PRELOAD=$PWD/trik.so ./a.out</span><br></pre></td></tr></table></figure>

<p>最后文件会打开失败</p>
<p>![53DE4182-359A-4F3E-80BB-4B97508E7F9B](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;53DE4182-359A-4F3E-80BB-4B97508E7F9B.png)</p>
<p>原理就是通过自己写的库函数劫持系统的库函数，使得程序执行我们的库函数。</p>
<h2 id="0x-0b-attack-lab"><a href="#0x-0b-attack-lab" class="headerlink" title="0x 0b attack lab"></a>0x 0b attack lab</h2><h2 id="0x0c-链接-points"><a href="#0x0c-链接-points" class="headerlink" title="0x0c 链接 points"></a>0x0c 链接 points</h2><p>1.引入哑节点dummy</p>
<p>2.引入数据结构–elf</p>
<p>3.静态链接的过程：elf定位到符号-&gt;符号解析-&gt;重定位</p>
<p>4.*.o, elf 都是二进制文件</p>
<p>5.unix下大部分工具都在&#x2F;usr&#x2F;bin或者&#x2F;bin目录下的。使用hexdump可以查看二进制文件</p>
<p>6.第一个section的name为空（其实叫做 undefine section），且数据全为0，里面存放的内容是undefine的数据。</p>
<p>7.将函数定义为一个弱符号：<code>attribute__((weak)) int add*() &#123;&#125;</code> ,这里的 <code>add</code> 函数被定义为一个弱符号，它可以被强符号函数 <code>add</code> 覆盖。</p>
<p>8.对于 <code>C Language</code> 来说，出现 <code>Warning</code> 说明你的语句有<strong>歧义</strong> ，但是 C 语言为你选择了一种结果，注意这种结果可能与你的本意不同！</p>
<p>9.对于初始化为 <code>0</code> 的全局变量和静态变量，也被划分到 <code>.bss</code>，这是因为全局变量和静态变量默认初始化就是 <code>0</code>。</p>
<p>10.为什么在可重定位目标文件中有 <code>COMMON</code>，在可执行目标文件中就没有 <code>COMMON</code> 了呢。</p>
<blockquote>
<p> 回想一下<code>COMMON</code>的定义，对于未初始化的全局变量， 属于<code>COMMON</code>。</p>
<p>对于未初始化的全局变量， 在链接之后它有三种可能的情况（假设这里有两个文件 <code>s1.c</code>, <code>s2.c</code>，在 <code>s1.c</code> 中定义有未初始化的全局变量 <code>g</code>）</p>
<ol>
<li><p>如果在 <code>s2.c</code> 中也定义了一个全局变量 <code>g</code> 并且初始化为 <code>0</code>，则 <code>g</code> 属于 <code>.bss</code> 节</p>
</li>
<li><p>如果初始化不是 <code>0</code>，就属于 <code>.data</code></p>
</li>
<li><p>如果 <code>s2.c</code> 没有定义 <code>g</code> ，那么 s2 就属于 <code>.bss</code></p>
<p>因为有如上三种（合法）情况，所以把它划分到 <code>COMMON</code>，而之所以在可执行目标文件中没有了 <code>COMMON</code> ,是因为此时已经链接完了，<code>g</code> 属于那个节已经很明确了，因此也就不需要了。</p>
</li>
</ol>
</blockquote>
<ol start="11">
<li></li>
</ol>
<h2 id="0x0d-修改-ROF-信息的实验"><a href="#0x0d-修改-ROF-信息的实验" class="headerlink" title="0x0d 修改 ROF 信息的实验"></a>0x0d 修改 ROF 信息的实验</h2><p>首先编译源文件 <code>add.c</code> 生成可重定位目标文件 <code>add.o</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> addcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	addcnt ++ ;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用 <code>hexdump -S add.o</code> 查看 <code>Section Headers</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000003c  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000228</span><br><span class="line">       0000000000000060  0000000000000018   I       9     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  0000007c</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  0000007c</span><br><span class="line">       0000000000000004  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .comment          PROGBITS         0000000000000000  0000007c</span><br><span class="line">       0000000000000027  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  000000a3</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .eh_frame         PROGBITS         0000000000000000  000000a8</span><br><span class="line">       0000000000000030  0000000000000000   A       0     0     8</span><br><span class="line">  [ 8] .rela.eh_frame    RELA             0000000000000000  00000288</span><br><span class="line">       0000000000000018  0000000000000018   I       9     7     8</span><br><span class="line">  [ 9] .symtab           SYMTAB           0000000000000000  000000d8</span><br><span class="line">       0000000000000138  0000000000000018          10    11     8</span><br><span class="line">  [10] .strtab           STRTAB           0000000000000000  00000210</span><br><span class="line">       0000000000000018  0000000000000000           0     0     1</span><br><span class="line">  [11] .shstrtab         STRTAB           0000000000000000  000002a0</span><br><span class="line">       0000000000000059  0000000000000000           0     0     1</span><br></pre></td></tr></table></figure>

<p>可以发现下标为 <code>1</code> 的节是 <code>.text</code> 节</p>
<p>我们现在要修改 <code>add.o</code> 使其显示为 <code>.ext</code> 节</p>
<p>首先需要下载 <code>hexedit</code></p>
<p>然后拷贝一份 <code>add.o</code> 的副本 <code>badadd.o</code></p>
<p>（不在源文件上直接修改是个好习惯）</p>
<p>然后执行命令<code>hexdump -c badadd.o</code> 找到 <code>.text</code> 的位置。</p>
<p>通过 <code>elf header</code> 中的信息可以得到 <code>Section header table</code> 的 <code>offset</code> 为 <code>0x300</code>，其中每个条目(<code>entry</code>) 的 <code>size</code> 为 <code>0x40</code> ，由此可以得到第二个条目（下标为1）的 <code>.text</code> 节的位置为 <code>0x340</code>，并通过 <code>struct elf64_shdr</code> 得到前 <code>4</code> 个字节为 <code>name</code>。</p>
<p><code>00000340  20 00 00 00 01 00 00 00  06 00 00 00 00 00 00 00  | ...............|</code></p>
<p><code>name = 0x00000020</code> ,我们只需要修改其为 <code>0x00000022</code>，就可以实现 <code>name</code> 往后偏移两个字节</p>
<p>这样 <code>name</code> 就从 &#96;&#96;.text<code>变成了</code>ext&#96;</p>
<p>执行命令：<code>hexedit badadd.o</code> 找到位置并修改即可。</p>
<p>按 <code>F10</code> 退出</p>
<p>最后结果如下：</p>
<p><code>readelf -S badadd.o</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] ext               PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000003c  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000228</span><br><span class="line">       0000000000000060  0000000000000018   I       9     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  0000007c</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  0000007c</span><br><span class="line">       0000000000000004  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .comment          PROGBITS         0000000000000000  0000007c</span><br><span class="line">       0000000000000027  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  000000a3</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .eh_frame         PROGBITS         0000000000000000  000000a8</span><br><span class="line">       0000000000000030  0000000000000000   A       0     0     8</span><br><span class="line">  [ 8] .rela.eh_frame    RELA             0000000000000000  00000288</span><br><span class="line">       0000000000000018  0000000000000018   I       9     7     8</span><br><span class="line">  [ 9] .symtab           SYMTAB           0000000000000000  000000d8</span><br><span class="line">       0000000000000138  0000000000000018          10    11     8</span><br><span class="line">  [10] .strtab           STRTAB           0000000000000000  00000210</span><br><span class="line">       0000000000000018  0000000000000000           0     0     1</span><br><span class="line">  [11] .shstrtab         STRTAB           0000000000000000  000002a0</span><br><span class="line">       0000000000000059  0000000000000000           0     0     1</span><br></pre></td></tr></table></figure>







<h2 id="0x0e-vim-tabe"><a href="#0x0e-vim-tabe" class="headerlink" title="0x0e vim tabe"></a>0x0e vim tabe</h2><p>vim中的分页命令，多窗口vim</p>
<p>通过<code>help tab-page-intro</code>命令，可以获得关于标签页使用的更多信息。</p>
<table>
<thead>
<tr>
<th><code>:tabnew</code></th>
<th align="left">新建标签页</th>
</tr>
</thead>
<tbody><tr>
<td><code>:tabs</code></td>
<td align="left">显示已打开标签页的列表</td>
</tr>
<tr>
<td><code>:tabc</code></td>
<td align="left">关闭当前标签页</td>
</tr>
<tr>
<td><code>:tabe &lt;filename&gt;</code></td>
<td align="left">打开新文件(tabedit)</td>
</tr>
<tr>
<td><code>:tabp</code></td>
<td align="left">移动到上一个标签页</td>
</tr>
<tr>
<td><code>:tabn</code></td>
<td align="left">移动到下一个标签页(tabnext)</td>
</tr>
<tr>
<td><code>:gt</code></td>
<td align="left">移动到下一个标签页</td>
</tr>
<tr>
<td><code>:tabr</code></td>
<td align="left">移动到第一个标签页(tabrewind,tabfirst)</td>
</tr>
<tr>
<td><code>:tabl</code></td>
<td align="left">移动到最后一个标签页(tablast)</td>
</tr>
<tr>
<td><code>$vim -p &lt;f1&gt; &lt;f2&gt; &lt;f3&gt;</code></td>
<td align="left">vim开启多个标签页</td>
</tr>
</tbody></table>
<h2 id="0x0f-bilbili-链接"><a href="#0x0f-bilbili-链接" class="headerlink" title="0x0f bilbili 链接"></a>0x0f bilbili 链接</h2><p>链接步骤：</p>
<blockquote>
<ol>
<li>parse text</li>
<li>symbol parse</li>
<li>Relocation</li>
</ol>
<p>2 和 3 都依赖于 1 的 text</p>
</blockquote>
<h1 id="Csapp-Link"><a href="#Csapp-Link" class="headerlink" title="Csapp Link"></a>Csapp Link</h1><h2 id="English"><a href="#English" class="headerlink" title="::English"></a>::English</h2><p>separate compliation：分离编译</p>
<p>mangling：重整</p>
<h2 id="Tool"><a href="#Tool" class="headerlink" title=":: Tool"></a>:: Tool</h2><p>GNU READELF：查看目标文件内容的很方便的工具。</p>
<h2 id="0x00-introduce"><a href="#0x00-introduce" class="headerlink" title="0x00 introduce"></a>0x00 introduce</h2><h3 id="1-链接的执行阶段"><a href="#1-链接的执行阶段" class="headerlink" title="1. 链接的执行阶段"></a>1. 链接的执行阶段</h3><ol>
<li>compile time</li>
<li>load time</li>
<li>run time</li>
</ol>
<h3 id="2-why-learn-link"><a href="#2-why-learn-link" class="headerlink" title="2. why learn link"></a>2. <strong>why</strong> learn link</h3><ol>
<li>理解链接器将帮助你构造大型程序</li>
<li>理解链接器将帮助你避免一些危险的编程错误。</li>
<li>理解链接器将帮助你理解语言的作用域规则是如何实现的。</li>
<li>理解链接将帮助你理解其他重要的系统概念。（加载和运行程序，虚拟内存，分页，内存映射）</li>
<li>理解链接将使你能够利用共享库。</li>
</ol>
<h2 id="0x01-compiler-driver"><a href="#0x01-compiler-driver" class="headerlink" title="0x01 compiler driver"></a>0x01 compiler driver</h2><p>compiler dirver：编译器驱动程序</p>
<p>它代表用户在需要的时候调用：</p>
<ol>
<li>cpp</li>
<li>cc1</li>
<li>as</li>
<li>ld</li>
</ol>
<p>可以使用 -v 选项查看这个过程</p>
<p>当我们在 Linux 命令行输入：<code>./proc</code></p>
<p>shell 调用操作系统中一个叫做<strong>加载器</strong>的函数，它将可执行文件 proc 中的代码和数据复制到内存，然后将控制转移到这个程序的开头。</p>
<h2 id="0x02-static-link"><a href="#0x02-static-link" class="headerlink" title="0x02 static link"></a>0x02 static link</h2><p>Relocaable object file: 由各种不同的代码和数据节（section）组成，每一节都是一个连续的字节序列。</p>
<p>为了构造 executable file，linker 必须完成两个主要任务：</p>
<ol>
<li>Symbol resolution（符号解析）：符号解析的目的是将每个符号引用正好和一个符号定义关联起来。</li>
<li>relocation（重定位）。</li>
</ol>
<p>Symbol（符号）：目标文件定义和引用符号，每个符号对应于一个函数，一个局部变量或一个静态变量（即C语言任何非 static 属性声明的变量）。</p>
<p>Compiler and Assembly generate code and data section start at address 0, linker connect every symbol define with one memory address, so can relocate those sections, and then modify all the symbol define, make them point the address. Linker use the detailed instructions of relocation entry(重定位条目) which generated by assembly to execute those relocation with no check.</p>
<h2 id="0x03-object-file"><a href="#0x03-object-file" class="headerlink" title="0x03 object file"></a>0x03 object file</h2><p>object file（目标文件） types:</p>
<ol>
<li>relocatable object file：在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li>
<li>executable object file</li>
<li>Share object file（共享目标文件）: 一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。</li>
</ol>
<p>Compiler and Assembly generate relocatable object file.  Linker generate executable  object file.</p>
<p>Technically talking, a object module(目标模块) is a byte sequence,  and a object file is a object module which storage in disk as a type of file.</p>
<p>目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。</p>
<ol>
<li>Unix: a.out</li>
<li>Windows: PE(Portable Executable)(可移植可执行)</li>
<li>MacOS-X: Mach-O </li>
<li>Modern x86-64 and Unix: ELF(Executable and Linkable Format)(可执行可链接格式)</li>
</ol>
<h2 id="0x04-relocatable-object-file"><a href="#0x04-relocatable-object-file" class="headerlink" title="0x04 relocatable object file"></a>0x04 relocatable object file</h2><p>典型的ELF可重定位目标文件</p>
<p><img src="https://s1.328888.xyz/2022/09/28/spfaF.png" alt="IMG"></p>
<p>ELF contains:   ELF header，Sections，Section header table(节头部表)。</p>
<p>(1) ELF header：</p>
<ol>
<li>以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的<strong>字的大小</strong>和<strong>字节顺序。</strong></li>
<li>剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包含：<ul>
<li>ELF 头的大小</li>
<li>目标文件的类型（可重定位、可执行或者共享）</li>
<li>机器类型（x86-64）</li>
<li>节头部表的文件偏移</li>
<li>节头部表中条目的大小和数量</li>
</ul>
</li>
</ol>
<p>(2) Section headere table: 不同 Section 的位置和大小是由节头部表描述的，其中目标文件中的每个节都有一个固定大小的条目（entry）。</p>
<p>(3) Section:</p>
<ol>
<li>.text：已编译程序的<strong>机器代码。</strong></li>
<li>.rodata：只读数据。</li>
<li>.data：已初始化的全局和静态 C 变量。（局部变量在栈中，既不出现在 .data中，也不出现在 .bss汇总）</li>
<li>.bss：未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量（默认初始化）。在目标文件中<strong>这个节不占用实际的空间，它仅仅是一个占位符。</strong> 目标文件中区分 .bss 和 .data 是为了<strong>空间效率</strong>：在目标文件中，未初始化变量不需要占用任何实际的磁盘空间。运行时，在内存中分配这些变量，初始化为0。</li>
<li>.symtab；符号表。存放在程序中<strong>引用</strong>和<strong>定义</strong>的函数和全局变量的信息。（不包含局部变量的条目）。</li>
<li>.rel.text：relocation。一个 .text 节总位置的列表。当 Linker 把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的<strong>指令</strong>都需要修改。</li>
<li>.rel.data：被模块定义或引用的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的值是一个全局变量地址或者外部定义的函数的<strong>地址</strong>，都需要被修改。</li>
<li>.debug：调试符号表。只有使用 -g 选项时才会得到这张表。</li>
<li>.line：原始 C 源程序中的行好和 .text 节 中机器指令之间的<strong>映射</strong>。只有使用 -g 选项时才会得到这张表。</li>
<li>.strtab：字符串表。其内容包含 .symbol 和 .debug节中的符号表，已经节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。</li>
</ol>
<p>为什么未初始化的数据成为  .bss</p>
<blockquote>
<p>起始于 IMB 704 汇编语言（大约在1957年） Block Storage Start(块存储开始)指令的首字母缩写。并沿用至今。</p>
<p>你可以这样理解并区分于 .data：Better Save Space（更好的节省空间）的缩写。</p>
</blockquote>
<h2 id="0x05-symbol-and-symbol-table"><a href="#0x05-symbol-and-symbol-table" class="headerlink" title="0x05 symbol and symbol table"></a>0x05 symbol and symbol table</h2><p>​			 	</p>
<p>每个 relocatable object module m 都有一个符号表，它包含 m 定义和引用的符号的信息。在 Linker 的上下文中，有三种不同的符号：</p>
<ol>
<li>m 定义的并且能被其他 module 引用的全局符号。</li>
<li>其他 module 定义并被模块 m 引用的全局符号，</li>
<li>只被 m 定义和引用的局部符号。</li>
</ol>
<p>符号表是由 Assembly 构造的，使用 Compiler 输出到汇编语言 .s 文件中的符号。</p>
<p>.symtab 节的内容是一个数组，数组的元素是一个符号条目：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="type">char</span> type: <span class="number">4</span>,</span><br><span class="line">    	binding: <span class="number">4</span>;</span><br><span class="line">    <span class="type">char</span> reserved;</span><br><span class="line">    <span class="type">short</span> section;</span><br><span class="line">    <span class="type">long</span> value;</span><br><span class="line">    <span class="type">long</span> size;</span><br><span class="line">&#125; Elf_64_Symbol;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>name：是字符串表中的字节串，指向符号的以 null 结尾的字符串名字。</p>
<p>section（base_address）：到节头部表的索引，指明被分配到那个节。</p>
<p>value（offset_address）：是符号的地址。对于可重定位的 module 来说，value 是距定义目标的节的其实地址的 offset。</p>
<p>size：是目标的大小（byte）。</p>
<p>type：data or function。</p>
<p>binding：static or global</p>
<p>有三个特殊的<strong>伪节</strong>，它们在节头部表中是没有条目的（只有可重定位目标模块才有）：</p>
<ol>
<li>ABS：不应该被重定位的符号。</li>
<li>UNDEF：未定义的符号，也就是在本目标模块中引用，但是在其它地方定义的符号。</li>
<li>COMMON：还未被分配位置的未初始化的数据目标。对于 common u符号，value 字段给出<strong>对其要求</strong>。</li>
</ol>
<p>common 和 .bss 的区别很细微，现代的 GCC 根据以下规则分配符号：</p>
<ol>
<li>Common: 未初始化的全局变量</li>
<li>.bss：未初始化的静态变量，及其初始化为0的全局变量和静态变量</li>
</ol>
</blockquote>
<h2 id="0x06-symbol-parse"><a href="#0x06-symbol-parse" class="headerlink" title="0x06 symbol parse"></a>0x06 symbol parse</h2><h3 id="1-链接器解析符号引用的方法"><a href="#1-链接器解析符号引用的方法" class="headerlink" title="1.链接器解析符号引用的方法"></a>1.链接器解析符号引用的方法</h3><p>链接器解析符号引用的方法是将每个引用于它输入的可重定位目标文件的符号表的一个确定的符号定义关联起来。</p>
<p>对那些和引用定义在相同模块中的局部符号的引用，符号解析是非常简单明了的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保他们拥有唯一的名字。</p>
<p>不过，对全局符号的引用解析就棘手的多。当编译器遇到一个不是在当前模块中定义的符号（变量或者函数名）时，会假设该符号是在其它某个模块中定义的，升成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条（通常很难阅读的）错误信息并终止。</p>
<h3 id="2-c-和-java-中的重整和恢复"><a href="#2-c-和-java-中的重整和恢复" class="headerlink" title="2.c++ 和 java 中的重整和恢复"></a>2.c++ 和 java 中的<strong>重整</strong>和<strong>恢复</strong></h3><p>C++ 和 Java 都允许重载方法，这些方法在源代码中有相同名字，却有着不同的参数列表。那么链接器是如何区别这些不同的重载函数之间的差异呢？</p>
<p>因此编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。这种编码过程叫做重整（mangling），而相反的过程叫做恢复（demangling）。</p>
<p>幸运的事，C++ 和 Java使用兼容的重整策略。一个被重整的类名字是由名字中字符的整数数量，后面跟上原始名字组成的。例如：类 Foo 被编码成 3Foo。方法被编码为原始方法名，后面加上‘__’（下划线），加上被重整的雷鸣，再加上每个参数的单字母编码。比如：Foo::bar(int, long) 被编码为 bar_3fooil。</p>
<p>重整全局变量和模版名字的策略是相似的。</p>
<p>例如 C++程序 ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> sum1, sum2;</span><br><span class="line">	sum1 = <span class="built_in">get</span>(a, b, c);</span><br><span class="line">	sum2 = <span class="built_in">get</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum1: &quot;</span> &lt;&lt; sum1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum2: &quot;</span> &lt;&lt; sum2 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<p><code>readelf mangling.o --syms</code></p>
<p>得到如下符号表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Symbol table &#x27;.symtab&#x27; contains 30 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS mangling.cpp</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text</span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 .data</span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 .bss</span><br><span class="line">     5: 0000000000000000     1 OBJECT  LOCAL  DEFAULT    4 _ZStL8__ioinit</span><br><span class="line">     6: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    4 $d</span><br><span class="line">     7: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    1 $x</span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 .rodata</span><br><span class="line">     9: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    5 $d</span><br><span class="line">    10: 00000000000000fc    96 FUNC    LOCAL  DEFAULT    1 _Z41__static_ini[...]</span><br><span class="line">    11: 000000000000015c    28 FUNC    LOCAL  DEFAULT    1 _GLOBAL__sub_I__[...]</span><br><span class="line">    12: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 .init_array</span><br><span class="line">    13: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    6 $d</span><br><span class="line">    14: 0000000000000000     0 SECTION LOCAL  DEFAULT    9 .note.GNU-stack</span><br><span class="line">    15: 0000000000000014     0 NOTYPE  LOCAL  DEFAULT   10 $d</span><br><span class="line">    16: 0000000000000000     0 SECTION LOCAL  DEFAULT   10 .eh_frame</span><br><span class="line">    17: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 .comment</span><br><span class="line">    18: 0000000000000000    32 FUNC    GLOBAL DEFAULT    1 _Z3getii</span><br><span class="line">    19: 0000000000000020    44 FUNC    GLOBAL DEFAULT    1 _Z3getiii</span><br><span class="line">    20: 000000000000004c   176 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    21: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZSt4cout</span><br><span class="line">    22: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZStlsISt11char_[...]</span><br><span class="line">    23: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSolsEi</span><br><span class="line">    24: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZSt4endlIcSt11c[...]</span><br><span class="line">    25: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSolsEPFRSoS_E</span><br><span class="line">    26: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSt8ios_base4I[...]</span><br><span class="line">    27: 0000000000000000     0 NOTYPE  GLOBAL HIDDEN   UND __dso_handle</span><br><span class="line">    28: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSt8ios_base4I[...]</span><br><span class="line">    29: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND __cxa_atexit</span><br></pre></td></tr></table></figure>

<p>可以观察到，两个 get 函数分别被标识为：<code>_Z3getii</code> 和 <code>_Z3getiii</code></p>
<h3 id="3-Linux-处理多重定义的符号"><a href="#3-Linux-处理多重定义的符号" class="headerlink" title="3. Linux 处理多重定义的符号"></a>3. Linux 处理多重定义的符号</h3><p>强符号：函数和已初始化的全局变量</p>
<p>弱符号：未初始化的全局变量</p>
<p>Linux 处理多重定义的符号名的三个规则：</p>
<ol>
<li>不允许多个同名的强符号。</li>
<li>如果有一个强符号和多个弱符号同名，选择强符号。</li>
<li>如果有多个弱符号同名，任意选择一个。</li>
</ol>
<h3 id="4-静态库"><a href="#4-静态库" class="headerlink" title="4. 静态库"></a>4. 静态库</h3><h4 id="4-1-为什么要引入静态库？"><a href="#4-1-为什么要引入静态库？" class="headerlink" title="4.1 为什么要引入静态库？"></a>4.1 为什么要引入静态库？</h4><p>如果不引入静态库的话，试想一下编译器开发人员会使用什么方法来向用户提供这些函数。</p>
<blockquote>
<p>编译器代劳！</p>
</blockquote>
<p>一种方法是让编译器辨认出对标准函数的调用，并直接生成相应的代码。对于那些提供了一小部分标准函数的语言（例如 Pascal）是可以的，但是对于 C 这种标准定义了大量的标准函数是不可以的。因为每次添加、修改或删除一个标准库函数时，就需要一个新的编译器版本。然而，对于应用程序猿而言，这种方法是非常方便的，因为标准函数将总是可用（只需要你编译器开发人员搞定就行了，管我什么事 - -</p>
<blockquote>
<p>所有函数对应一个可重定位目标模块！</p>
</blockquote>
<p>另一种方法是将所有的 C 函数都放在一个单独的可重定位目标模块中（比如说 libc.a），应用程序猿可以把这个模块连接到他们的可执行文件中：</p>
<p><code>gcc main.c /usr/lib/libc.o</code></p>
<p>IOS C99 定义的 C库：libc.a; 数学函数库：libm.a</p>
<p>通过把函数放在目标模块中，可以把编译器的实现与标准函数的实现分离开来。但是，现在每个可执行文件都包含着一份标准函数集合的副本（除非你不链接它，但这怎么可能呢？），这是对<strong>磁盘的极度浪费</strong>！在一个典型的系统中，libc.a 大约是 5MB，llib.a 大约是 2MB）。另外，每个运行的程序都将它的这些函数的副本放在内存中，这是<strong>对内存的极大浪费</strong>。此外，只要标准库修改了一个小小的地方，无论多么小，你都要重新编译整个源文件，非常<strong>耗时</strong>。</p>
<blockquote>
<p>每个函数对应一个可重定位目标模块！</p>
</blockquote>
<p>我们可以通过为每个库函数创建一个独立的可重定位模块，把他们放在一个为大家都知道的目录中来解决其中的一些问题。然而，问题也是相当明显的：</p>
<ol>
<li>那你要手写多少模块啊？</li>
<li>太多了不小心写错名字了怎么办？从头再检查一遍吧！</li>
<li>太多了，你得写到什么时候？</li>
<li>。。。</li>
<li>真是一个麻烦又耗时又糟心的过程！</li>
</ol>
<p><code> gcc main.c /usr/lib/printf.o /usr/lib/scanf.o ........</code></p>
<blockquote>
<p>静态库！</p>
</blockquote>
<p>于是，为了解决这些问题，静态库诞生了！！！</p>
<p>我们可以结合上面的方法，既不把所有函数划分到一个模块，也不每个函数对应一个模块，而是把一些相关的函数划分到一个模块（例如 C 标准库和数学库等），然后封装成一个单独的静态库文件。而不是每个函数对应一个模块。</p>
<p><code>gcc main.c /usr/lib/libc.a /usr/lib/libm.a .. </code></p>
<p>你可能会问：这个静态库和前面把所有函数放在一个可重定位目标模块有什么区别吗？不就是一个叫（模块 .o)，一个叫静态库（.a）罢了！</p>
<p>那我可就得给你好好讲讲了：当所有函数封装在一个模块中，那我们链接的时候，就不得不链接所有库函数了。</p>
<p>但是！接下来好好听了！</p>
<p>如果说模块是函数的集合，那么静态库就是模块的集合！所以，你可能想到了，虽然我们链接到了静态库，但并不链接静态库中的所有模块，而是只链接需要用到的模块，这样既避免了类似于一个函数一个模块那样链接模块太多的问题，又避免了链接所有模块的问题。</p>
<p>你可能会问：这怎么实现呢？</p>
<p>答案是：暴力出奇迹，循环判断是否用到就好了。用不到的模块就舍弃掉。</p>
<p>妙不妙！再看一看静态库的定义吧。</p>
<blockquote>
<p>在 Linux 中，静态库是以一种称为 <strong>存档(archive)</strong> 的特殊文件形式存放在<strong>磁盘</strong>中的。存档是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件由后缀（.a)标识。</p>
</blockquote>
<h3 id="4-2-创建静态库"><a href="#4-2-创建静态库" class="headerlink" title="4.2 创建静态库"></a>4.2 创建静态库</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/x_wukong/p/5713437.html">静态库和动态库创建参考</a></p>
<blockquote>
<p>(1) 首先，我们需要源文件（.c）</p>
<p>这里为 mul.c 和 add.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mulcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	mulcnt ++ ;</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125;<span class="comment">// mul.c</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> addcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	addcnt ++ ;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;<span class="comment">// add.c</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>(2) 然后，我们需要将源文件处理成可重定位目标文件</p>
</blockquote>
<p><code>gcc -c add.c mul.c</code></p>
<blockquote>
<p>(3) 最后，将需要的可重定位目标文件封装到静态库中。</p>
<p>例如： <code>ar rcs mylib.a a.o b.o...</code></p>
<p>r: replace and insert</p>
<p>c : create</p>
<p>s: add index</p>
</blockquote>
<p><code>ar rcs mylib.a add.o mul.o</code></p>
<blockquote>
<p>(4) 别以为就这样结束了，编写个 main 程序测试你下你的库吧！</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> s1 = add(x, y);</span><br><span class="line">	<span class="type">int</span> s2 = mul(x, y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;x = %d, y = %d\nsum = %d, mul = %d\n&quot;</span>, x, y, s1, s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c testar.c # 先编译生成可执行文件</span><br><span class="line">gcc --static -o main testar.o -L. mylib.a # 与静态库链接</span><br></pre></td></tr></table></figure>

<blockquote>
<p>–static 参数告诉编译器驱动程序，链接器应该构建一个完全链接的可执行目标文件，它可以加载到内存并运行，在加载时无需更进一步的链接。所以说不加也是可以的。</p>
<p>-Ldir 指明了链接器在那个目录下查找 mylib.a，dot就表示当前目录。</p>
</blockquote>
<h2 id="0x07-relocation"><a href="#0x07-relocation" class="headerlink" title="0x07 relocation"></a>0x07 relocation</h2><h3 id="1-重定位的任务："><a href="#1-重定位的任务：" class="headerlink" title="1. 重定位的任务："></a>1. 重定位的任务：</h3><p>重定位合并输入模块，并为每个符号分配运行时地址。</p>
<p>由两步组成：</p>
<ol>
<li><p>重定位节和符号定义：</p>
<ol>
<li>将所有相同类型的节合并为一个节</li>
<li>将运行时内存地址赋给新的聚合节</li>
<li>赋给输入模块定义的每个符号</li>
</ol>
<p>完成后，程序中的每条指令和全局变量都有唯一的运行时内存地址了。</p>
</li>
<li><p>重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为<strong>重定位条目</strong>的数据结构。</p>
</li>
</ol>
<h3 id="2-重定位条目"><a href="#2-重定位条目" class="headerlink" title="2. 重定位条目"></a>2. 重定位条目</h3><p>为什么需要重定位条目？</p>
<blockquote>
<p>当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。</p>
<p>它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。</p>
<p>所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个 <strong>“重定位条目”</strong>，告诉链接器在将目标文件合并成可执行文件时许和修改这个引用。</p>
<p>代码的重定位条目放在 .rel.text 中，已初始化数据的重定位条目放在 .rel.data 中。</p>
</blockquote>
<p>ELF 重定位条目的格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> offset;	<span class="comment">// 我在那</span></span><br><span class="line">    <span class="type">long</span> type: <span class="number">32</span>;	<span class="comment">// 怎么引用</span></span><br><span class="line">    	smybol: <span class="number">32</span>; <span class="comment">// 我引用了谁</span></span><br><span class="line">    <span class="type">long</span> addend;	<span class="comment">// 我的偏移量</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>offset 是需要被修改的引用的在节内的偏移。（一般是一个地址）</p>
<p>symbol 标识被修改引用应该指向的符号。</p>
<p>type 告知链接器如何修改新的引用。</p>
<p>addend 是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。（addend的值一般是当前引用的地址距离下一条指令的偏移）（讲的标准一点就是对 rip 的修正，因为重定位所在的地址并不是下一条指令的 rip 地址）</p>
</blockquote>
<p>两种最基本的重定位类型（type）：</p>
<ol>
<li><p>R_X86_64_PC32：重定位一个使用 32 位 PC 相对地址的引用。（一个 PC 相对地址就是距程序计数器(PC)的当前运行时值的偏移量。当 CPU 执行一条使用 PC 相对寻址的指令时，它就将在指令中编码的 32 位值加上 PC 的当前运行时值，得到有效地址， PC 值通常是<strong>下一条</strong>指令在内存中的地址）。</p>
<blockquote>
<p>简而言之，<strong>相对</strong>的意思就是，相对于<strong>下一条指令</strong>的偏移量。</p>
</blockquote>
</li>
<li><p>R_X86_64_32：重定位一个 32 位绝对地址的引用。通过绝对寻址，CPU 直接使用在指令中编码的 32 位值作为有效地址。</p>
</li>
</ol>
<h3 id="3-重定位符号引用"><a href="#3-重定位符号引用" class="headerlink" title="3. 重定位符号引用"></a>3. 重定位符号引用</h3><blockquote>
<p> 相对引用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call addr </span><br><span class="line">	sym.offset: R_X86_64_PC32 sym</span><br></pre></td></tr></table></figure>

<p>首先，要清楚我们的目标：通过 addr 的<strong>相对偏移</strong>得到该符号的运行时地址，这个地址我们是已知的。（我们用ADDR(x)表示符号 x 的运行时地址）</p>
<p>当前引用的地址 + 距离下一条指令的偏移量 +  addr &#x3D; 目标符号的运行时地址</p>
<p>addr &#x3D; ADDR(sym) - （当前引用的地址 + 距离下一条指令的偏移量）</p>
<p>不过，距离下一条指令的偏移量通常以 sym.addend 的形式存在，于是，上式变成了：</p>
<p>addr &#x3D; ADDR(sym) - 当前引用的地址 + sym.addend</p>
<blockquote>
<p>我们发现，公式在经过转换后，由 “距离” 下一条指令的偏移量变成了 “加上”  sym.addend。</p>
<p>而偏移量肯定是一个正数（不然怎么偏移到下一条指令），所以说 sym.addend 肯定是个负数。</p>
<p>自己推导的，不一定对？？</p>
</blockquote>
<p>而当前引用的地址 &#x3D; 引用所在节的运行时地址 + 引用的偏移(sym.offset)</p>
<p>所以，上式最终等于如下：</p>
<p>addr &#x3D; ADDR(sym) - （ADDR(Section) + sym.offset）+ sym.addend</p>
<hr>
<blockquote>
<p>绝对引用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call addr</span><br><span class="line">	sym.offset: R-X86_64_32 sym</span><br></pre></td></tr></table></figure>

<p>addr &#x3D; ADDR(sym) + sym.addend</p>
<p>在绝对引用中，我们依然需要加上偏移量addend，只不过 sym.addend&#x3D;0。</p>
<p>可以发现，相较于绝对引用，相对引用只需要减去当前引用的地址即可，距离下一条指令的偏移保存在了 addend 中。</p>
<h2 id="0x08-executable-object-file"><a href="#0x08-executable-object-file" class="headerlink" title="0x08 executable object file"></a>0x08 executable object file</h2><p>典型的 ELF 可执行目标文件（EOF，段和节）：</p>
<p><img src="https://s1.328888.xyz/2022/09/28/spsQp.png" alt="img"></p>
<p>ELF头还包括了程序的入口点？也就是程序的第一条指令的地址。</p>
<p>通过图可以发现，EOF 文件中还多了 .init 节。.init节定义了一个小函数，叫做 _init_，程序的初始化代码会调用它。</p>
<p>.text，.data，.rodata 与可重定位目标文件的节是相似的，除了这些节已经被重定位到它们最终的运行时内存地址以外。</p>
<p>因为 EOF 文件是<strong>完全链接</strong>的（已被重定位），所以它不再需要 .rel 节。</p>
<blockquote>
<p>EOF 文件还有对其要求。这主要与虚拟内存有关</p>
</blockquote>
<h2 id="0x09-load-EOF"><a href="#0x09-load-EOF" class="headerlink" title="0x09 load EOF"></a>0x09 load EOF</h2><p>我们通常在 Linux Shell 命令行输入可执行目标文件的名字 (例如prog) 来执行它:</p>
<p><code>Linux&gt; ./prog</code></p>
<p>因为 prog 不是一个内置的 shell 命令，所以 shell 会认为 prog 是一个可执行目标文件。</p>
<p>通过调用某个驻留在内存中称为<strong>加载器（loader）</strong>的操作系统代码来运行它。</p>
<p>任何 Linux 程序都可以通过调用 <strong>execve()</strong> 调用加载器。</p>
<p>加载器将 EOF 文件的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序从磁盘复制到内存并运行的过程叫做 “加载”。</p>
<p><img src="https://s1.328888.xyz/2022/10/12/8jGhJ.png" alt="img"></p>
<h2 id="0x0a-dynamic-link-shared-library"><a href="#0x0a-dynamic-link-shared-library" class="headerlink" title="0x0a dynamic link shared library"></a>0x0a dynamic link shared library</h2><h3 id="1-为什么引入动态库"><a href="#1-为什么引入动态库" class="headerlink" title="1. 为什么引入动态库"></a>1. 为什么引入动态库</h3><p>当然是因为静态库有一些缺点了。</p>
<p>第一个问题，静态库不方便后续的更新和维护。</p>
<blockquote>
<p>静态库和所有软件一样，需要定期维护和更新。</p>
<p>如果应用程序员想要使用一个库的最新版本，他们必须以某种方式了解到该库的更新情况，然后显式的将他们的程序与更新了的库重新链接。</p>
</blockquote>
<p>第二个问题，静态户仍然会造成对内存资源的极大浪费。 </p>
<blockquote>
<p>虽然在上面 “引入静态库” 一节中我们已经说明了，静态库已经是一种比较节约内存资源的方式。</p>
<p>但那仅仅是在只针对一个文件的情况下，我们尽可能只引用必须用到的模块而避免引用了许多不会用到的模块造成内存浪费。</p>
<p>但试想一下，如果我们存在许多文件呢，几乎每个文件都会用到 printf() 函数等标准 IO 函数。在运行时，这些函数的代码会被复制到每个运行进程的文本段中（试想一下如果我们 printf() 了几百次，难道每一次调用都要复制一份 printf() 的代码吗？那也太浪费内存了！）。</p>
<p>特别是在一个运行上百个金层的典型系统上，这将是对稀缺的内存资源的极大浪费。</p>
<p><strong>（内存的一个有趣属性就是无论系统的内存多大，他总是一种奇缺资源。磁盘空间和厨房的垃圾桶具有同样的属性）。</strong></p>
</blockquote>
<p>于是，为了致力解决静态库的缺憾，共享库诞生了。</p>
<p><strong>共享库是一个目标模块</strong>，在运行或加载时，<strong>可以加载到任意的内存空间</strong>，并和一个在内存中的程序<strong>链接</strong>起来。这个链接的过程就叫做 <strong>“动态链接”</strong>，是由一个叫做动态链接器的程序来执行的。</p>
<p>共享库也称为 **“共享目标”(shared object)**。在 Linux 系统中用 <strong>.so</strong> 后缀来标识。微软的操作系统大量的使用了共享库，它们称为 **DLL(动态链接库)**。</p>
<h3 id="2-共享库的工作方式"><a href="#2-共享库的工作方式" class="headerlink" title="2. 共享库的工作方式"></a>2. 共享库的工作方式</h3><p>共享库是以两种不同的方式来实现 “共享”的。</p>
<p>首先，在任何给定的文件系统中，对于一个酷只有一个 .so 文件，所有引用该库的可执行目标文件分享这个 .so 文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行目标文件中。（解决了静态库内存浪费的问题）</p>
<p>其次，再内存中，一个共享库的 .text 节的一个副本可以被不同的正在运行的进程共享（与虚拟内存有关）。</p>
<p><img src="https://s1.328888.xyz/2022/10/12/86kb0.png" alt="img"></p>
<p>如何构造一个共享库：</p>
<p><code>gcc -shared -fpic -o libname.so module1.o module2.o ....</code></p>
<blockquote>
<p>-fpic 选项指示编译器生成与位置无关的代码。</p>
<p>-shared 选项指示编译器创建一个共享的目标文件。</p>
</blockquote>
<p>下面将将这个共享库链接到程序当中：</p>
<p><code>gcc -o prog main.c ./libname.so</code></p>
<p>根据上图(7-16)我们可以发现，可执行目标文件 prog21 在加载之后，也就是运行时可以和动态库 livvector.so 链接。基本的思路就是当创建可执行文件时，静态执行一些链接，然后在程序加载时，<strong>动态完成链接过程</strong>。</p>
<blockquote>
<p>by xjy：</p>
<p>注意上面的话并不矛盾，前一句话说程序运行时和动态库链接，下一句又说在程序加载时动态完成链接。一个是在运行时，一个是在加载时。</p>
<p>这可能是因为程序并不是直接全部加载到内存的（操作系统），它用到一点就加载一点，所以说，加载和运行是交叉的。</p>
</blockquote>
<p>注意，再整个链接的过程当没有任何动态库的代码和数据真的被复制到可执行文件 prog21 当中。反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对动态库中代码和数据的引用。</p>
<h3 id="3-小实验"><a href="#3-小实验" class="headerlink" title="3. 小实验"></a>3. 小实验</h3><p>下面是一个小实验，1.c，2.c 用来构建动态库和静态库，main.c 是测试函数。</p>
<p>app 是链接静态库生成的可执行文件。</p>
<p>prog 是链接动态库生成的可执行文件。</p>
<p>可以发现，prog 的大小比 app 小的多（小了50多倍）。</p>
<p><img src="https://s1.328888.xyz/2022/10/12/86JI6.png" alt="IMG"></p>
<h1 id="csapp-memory"><a href="#csapp-memory" class="headerlink" title="csapp memory"></a>csapp memory</h1><h2 id="一、cache"><a href="#一、cache" class="headerlink" title="一、cache"></a>一、cache</h2><h3 id="0x01-一种初始化方式"><a href="#0x01-一种初始化方式" class="headerlink" title="0x01 一种初始化方式"></a>0x01 一种初始化方式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">&#125; <span class="type">node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">node_t</span> p = &#123;</span><br><span class="line">        .l = <span class="number">100</span>,</span><br><span class="line">        .r = <span class="number">200</span>,</span><br><span class="line">        .s = <span class="string">&quot;hello,world!&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;node: %d %d %s\n&quot;</span>, p.l, p.r, p.s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="0x02-note"><a href="#0x02-note" class="headerlink" title="0x02 note"></a>0x02 note</h3><p>我们知道内存是分页的，cache的 line 只会存在于某一个页，它不会跨页存在。</p>
<h3 id="0x03-true-x2F-fake-sharing"><a href="#0x03-true-x2F-fake-sharing" class="headerlink" title="0x03 true&#x2F;fake sharing"></a>0x03 true&#x2F;fake sharing</h3><p>罪魁祸首：MESI 协议</p>
<p>false sharing有一个问题，就是对于sum求和这个例子，虽然我们设置sum1和sum2分别求和，但是sum1和sum2都是分配在栈上的，并且地址十分接近，所以它们可能在同一个cache当中，这样不管是sum1修改还是sum2修改，都会触法 MESI 的同步协议，这样 false sharing的速度和true sharing相差几乎无几。</p>
<h3 id="0x04-MESI-protocol"><a href="#0x04-MESI-protocol" class="headerlink" title="0x04 MESI protocol"></a>0x04 MESI protocol</h3><p>exclusive：独有的</p>
<p>exclusive 和 shared 不能共存</p>
<p>四种状态：（由于读数据不会产生数据一致性问题，因此这里只考虑写数据操作）</p>
<p>M: (exclusive) modify, like dirty. 物理地址被缓存到某一个 cache，并且数据已经被修改</p>
<p>E:  exclusive (clean).物理地址被缓存到某一个 cache，并且数据没有被修改</p>
<p>S:  (exclusive) shared clean.物理地址被缓存到 cache，并且多个 cache 共享。</p>
<blockquote>
<p>如果修改一个状态为 s 的 cache，它会发送一个广播，将所有其他状态为 s 的 cache 的状态修改为 invalid（具体方法是将其拥有数据写入到 dram，然后修改状态为 invalid），然后将自己的状态修改为 M，这样就可以保证全局状态下只有一个 M，也就是 exclusive的。</p>
</blockquote>
<p>I: invalid.物理地址并没有缓存到 cache。</p>
<blockquote>
<p>此时如果发生 cache write</p>
<ol>
<li>如果其他 cache 的状态都是 invalid，从内存 load 数据，修改器状态为 M。</li>
<li>如果存在 (shared)S状态 的 cache，将它们的数据写入到 dram，然后修改状态为 invalid。</li>
</ol>
</blockquote>
<p>每个处理器的cache line都是 dram 的 cache line 的拷贝</p>
<h2 id="二、page-table"><a href="#二、page-table" class="headerlink" title="二、page table"></a>二、page table</h2><h3 id="0x01-tips"><a href="#0x01-tips" class="headerlink" title="0x01 tips"></a>0x01 tips</h3><p>地址翻译由硬件实现，操作系统为应用提供这个功能。</p>
<p>TLB 也是一个 cache。</p>
<p>现在 64 位的处理器(cpu)的虚拟地址一般其实只有 48 位，剩下的 16 位属于内核。</p>
<p>虚拟地址空间呈现局部密集，整体稀疏的特征。</p>
<p>多级页表在最坏的情况下（满映射，每页都必须有有效数据）是一棵完全二叉树，此时页表条目会比朴素页表多出来一倍。但这种情况几乎不可能出现（虚拟地址空间的稀疏性和程序的局部性）。</p>
<p>页表分配在操作系统的内核态。</p>
<p>在windows下，资源管理器的内存中可以看到：分页缓冲池和非分页缓冲池。分页缓冲池指的是可以和磁盘进行换入(page in)和换出(page out)的页，而非分页并不是指不分页，而是不能喝磁盘进行 swap。</p>
<h3 id="0x02-how-to-reflect-va2pa"><a href="#0x02-how-to-reflect-va2pa" class="headerlink" title="0x02 how to reflect va2pa"></a>0x02 how to reflect va2pa</h3><p>在我们编写的地址转换函数中，我们简单的通过去模数将物理地址转换为虚拟地址，然而，这是极为不合理的，例如：</p>
<ol>
<li>产生不合法的地址（地址越界）。例如：0x200(1024)%0x200&#x3D;0x000，它产生了一个地址为 0 的地址，这显然是错误的。</li>
<li>不同进程间地址冲突的问题。因为每个进程的地址都是从 0x00400000 开始的，而相同地址取模之后的值是相同的，这就会导致地址冲突。</li>
</ol>
<p>一种可行的方法是使用 hashmap 完成物理地址到虚拟地址地址映射。它解决了使用取模方法产生的冲突和越界问题，但是，它又会产生以下两个问题：</p>
<ol>
<li>内存浪费严重。在 hashmap 中，我们需要额外的两份空间来分别存储物理地址和虚拟地址以记录他们的映射关系，并且，由于 hashmap 并不是全部使用的，它的内部会有空闲，因此我们还需要乘上一个空闲率 k(k&gt;&#x3D;1)，因此 hashmap 就需要额外的 2k 倍的额外内存空间要保存映射信息。</li>
<li>破坏程序的局部性。由于 hashmap 的映射是离散的，这就会导致程序会被离散化，破坏程序的局部性。</li>
</ol>
<p>但是，hashmap 产生的这两个问题属于 性能 问题，它只是导致程序运行效率不好，并不会导致程序运行错误。而取模方法则会导致程序运行出错。</p>
<p>现在我们再来想，hashmap 中记录如此之多的映射信息是否有必要？</p>
<p>肯定是有必要的，不然我们就无法找到物理地址了。但是！如果我们通过虚拟地址映射到物理地址不是离散的，例如：</p>
<blockquote>
<p>虚拟地址 0x1,0x2，通过 hashmap 地址映射为物理地址：0xa, 0xabcd。如果我们想找到这两个物理地址，我们必须保存映射信息，因为 0xa, 0xabcd 之间毫无关联。但是这种离散性是毫无必要的，如果我们将地址映射为 0xa, 0xb 这种连续的地址的话，它不仅可以避免破坏程序的局部性，还能减少地址映射需要保存的信息。</p>
<p>比如虚拟地址 [0x0, 0xffff] 这一块区域，如果我们采用 hashmap，它需要 0xffff 份映射信息，这也太多了。但是，如果 hashmap 映射的地址是连续的，我们就可以通过三元组(va0, pa0, offset) （offset表示偏移量）来找到这个区域内任意一个地址的映射，并且仅仅只需要一份映射信息，对于任意 va，pa&#x3D;pa0+va-va0（va &gt;&#x3D; va0 &amp;&amp; va &lt;&#x3D; va0 + offset）。</p>
<p>现在， 完成地址映射需要的额外信息由 2k 变成了 3M，M 就是上述三元组的数量，这个 M 远小于地址的数量。</p>
</blockquote>
<p>这就是分段思想。</p>
<p>当然，分段也是有问题的，例如：</p>
<ol>
<li>碎片。内部碎片和外部碎片。</li>
<li>每次计算都需要比较 va 是否越界。(va &gt;&#x3D; va0 &amp;&amp; va &lt;&#x3D; va0 + offset)</li>
<li>不方便拓展。当我们的段太大或者或许频繁拓展的时候，寻找一个合适的空间比较麻烦。</li>
</ol>
<p>所以说，我们需要把 offset 变成一个较小且固定的数值，这就是分页思想。</p>
<h3 id="0x03-address-transfer"><a href="#0x03-address-transfer" class="headerlink" title="0x03 address transfer"></a>0x03 address transfer</h3><p><a target="_blank" rel="noopener" href="http://www.wowotech.net/memory_management/arm64-memory-addressing.html">ARM64架构下地址翻译相关的宏定义</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/muahao/p/10297852.html">else</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1374439">else</a></p>
<h3 id="0x04-page-falult"><a href="#0x04-page-falult" class="headerlink" title="0x04 page falult"></a>0x04 page falult</h3><p>MM: main memory，主存</p>
<p>page table is the <strong>cache</strong> from disk to main memory</p>
<p>交换空间：当我们页表缓存的页满了之后，我们想再往内存映射一页，此时需要将该页 page out，但是如果该页的数据被修改了 dirty，我们该怎么办？</p>
<ol>
<li>不管它，这肯定不行</li>
<li>将该页写回文件 program file，这也肯定不行，我们不应该修改源文件。</li>
<li>放到别的地方 – swap space。</li>
</ol>
<p>将一页从 mm 放到 swap space 的过程就叫做 swap out</p>
<p>相反的，将页从 swap space 再放到 mm 的过程叫做 swap in</p>
<p>所以说，一个文件占用的空间包括了 mm 和 swap</p>
<p>swap space 也在磁盘</p>
<p><strong>demand paging</strong>:  waiting until the miss to copy the page to DRAM is konwn as deman paging</p>
<p>程序的代码文件，例如 .data 段它是存储在磁盘当中的，所以它与内存之间可以存在映射关系，但是 .data 段，stack, heap 不是存储在磁盘当中的，当我们需要把这些短存放在磁盘当中时，我们需要放入 swap space 中。它们又称为<strong>“匿名页”</strong>(在磁盘中没有文件与它对应)。 </p>
<h2 id="三、virtual-memory-overview"><a href="#三、virtual-memory-overview" class="headerlink" title="三、virtual memory overview"></a>三、virtual memory overview</h2><p>​       virtual memory 主要是为了解决物理内存和进程所看到的虚拟内存不匹配的问题，所以说每个 virtual memory 肯定是提供给每一个<strong>进程</strong>的。</p>
<p>每个进程就是一段 active 的内存，例如：</p>
<ol>
<li>.text 是死的</li>
<li>.data 是活的，因为它需要写入操作等</li>
</ol>
<p>如果区分 user 的虚拟地址空间和 kernel 的虚拟地址空间：kernel 的64位虚拟地址的最高位是1，user 的64位虚拟地址的最高位是 0。</p>
<p>我们通常看到的程序的虚拟地址空间图中， user 的虚拟地址空间地址的高部分都被 stack 占用了，但是这通常是作者的简化，实际上地址的最高部分被 kernel 部分占用了，只不过一半不标识出来。</p>
<p>只有第一级页表可以区分user mode or kernel mode，因为只有第一级页表可以得到地址的最高位。</p>
<p>用户的虚拟地址空间中的 user 部分映射到程序的虚拟地址空间的user 部分，映射方法为：0x0 + addr，kernel mode 部分的映射方法为：0xffff + addr，user的虚拟地址空间的地址最高为2^48。0xffff正好是16位。</p>
<p>pgb 在 kernel 中只有唯一一份。</p>
<p>kernel 的虚拟地址从 2^47？</p>
<p>内核的地址翻译全局一致。</p>
<h2 id="四、TLB"><a href="#四、TLB" class="headerlink" title="四、TLB"></a>四、TLB</h2><p>hardware acceleration：硬件加速</p>
<p>TLB is the cache of va2pa</p>
<p>我们可以把 cache 看作一个 key-value 库</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jyyyx</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jyyyx</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
