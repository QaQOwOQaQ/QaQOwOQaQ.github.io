<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qaqowoqaq.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="jyyyyyx">
<meta property="og:url" content="https://qaqowoqaq.github.io/index.html">
<meta property="og:site_name" content="jyyyyyx">
<meta property="og:locale">
<meta property="article:author" content="jyyyx">
<meta property="article:tag" content="cs">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://qaqowoqaq.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'cn'
  };
</script>

  <title>jyyyyyx</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">jyyyyyx</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">think twice before you do it</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/2023/06/15/C++%20templates/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/15/C++%20templates/" class="post-title-link" itemprop="url">C++ template</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-15 20:20:57" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-16 10:15:13" itemprop="dateModified" datetime="2023-06-16T10:15:13+08:00">2023-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-templates"><a href="#C-templates" class="headerlink" title="C++ templates"></a>C++ templates</h1><h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><h2 id="English"><a href="#English" class="headerlink" title="English"></a>English</h2><p>instantiation：实例化</p>
<p>paradigm：范例</p>
<h2 id="P1-基础"><a href="#P1-基础" class="headerlink" title="P1 基础"></a>P1 基础</h2><h3 id="1-函数模板"><a href="#1-函数模板" class="headerlink" title="1. 函数模板"></a>1. 函数模板</h3><p>当自定义的函数和 <code>std</code> 的函数名重复时，使用 <code>::</code> 调用我们定义的全局函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="type">const</span>&amp; <span class="title">max</span><span class="params">(T <span class="type">const</span>&amp; a, T <span class="type">const</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; ::<span class="built_in">max</span>(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板会被编译两次：</p>
<ol>
<li>实例化之前，先检查模板代码本身，查看语法是否正确。</li>
<li>实例化期间，检查模板代码，查看是否所有的调用都有效，例如某些类型可能无法调用某些函数，以及类型是否匹配，在上面的例子中，如果我们传入两个不同的类型，就会编译错误。</li>
</ol>
<p>模板类型可以显示制定，例如下面形式编译可以通过：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i= <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> d =<span class="number">3.13</span>;</span><br><span class="line">cout &lt;&lt; ::<span class="built_in">max</span>&lt;<span class="type">double</span>&gt;(i, d) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>为了解决参数必须相同的问题，我们可以指定两个模板参数，但是我们必须指定返回类型，指定返回类型比较麻烦：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">max</span><span class="params">(T2 <span class="type">const</span>&amp; a, T1 <span class="type">const</span>&amp; b)</span> -&gt; <span class="title">decltype</span><span class="params">(a + b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; ::<span class="built_in">max</span>(<span class="number">3</span>, <span class="number">3.13</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，你还可以重载模板函数，但要确保函数模板的所有重载版本的声明都位于它们被调用的位置之前。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/2023/06/15/HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/15/HashMap/" class="post-title-link" itemprop="url">Hashtable</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-15 20:20:57" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-16 10:06:57" itemprop="dateModified" datetime="2023-06-16T10:06:57+08:00">2023-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="0-题目地址"><a href="#0-题目地址" class="headerlink" title="0. 题目地址"></a>0. 题目地址</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-hashmap/solution/she-ji-ha-xi-ying-she-by-leetcode-soluti-klu9/">设计哈希映射</a></p>
<h2 id="1-链地址法"><a href="#1-链地址法" class="headerlink" title="1. 链地址法"></a>1. 链地址法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashMap</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> key;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="type">int</span> key,<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Node&gt;[] map;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> capacity = <span class="number">857</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> LinkedList[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> myHashCode = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(map[myHashCode] == null)&#123;</span><br><span class="line">            List&lt;Node&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            list.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">Node</span>(key,value));</span><br><span class="line">            map[myHashCode] = list;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            List&lt;Node&gt; list = map[myHashCode];</span><br><span class="line">            <span class="keyword">for</span>(Node m : list)&#123;</span><br><span class="line">                <span class="keyword">if</span>(m.key == key)&#123;</span><br><span class="line">                    m.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">Node</span>(key,value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> myHashCode = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(map[myHashCode] == null)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Node&gt; list = map[myHashCode];</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node m : list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.key == key)&#123;</span><br><span class="line">                res = m.value;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> myHashCode = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(map[myHashCode] == null)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Node&gt; list = map[myHashCode];</span><br><span class="line">        <span class="keyword">for</span>(Node m : list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.key == key)&#123;</span><br><span class="line">                list.<span class="built_in">remove</span>(m);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-开放寻址法"><a href="#2-开放寻址法" class="headerlink" title="2. 开放寻址法"></a>2. 开放寻址法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHashMap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">HashEntry</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        boolean remove; <span class="comment">// 记录元素是否被删除。</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">HashEntry</span>(<span class="type">int</span> key, <span class="type">int</span> value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashEntry[] table = <span class="keyword">new</span> HashEntry[<span class="number">101</span>]; <span class="comment">// 保存哈希表中的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size = <span class="number">0</span>; <span class="comment">// 哈希表中元素的数量。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">index</span>(key, table);</span><br><span class="line">        <span class="keyword">if</span> (table[index] != null &amp;&amp; !table[index].remove) &#123;</span><br><span class="line">            table[index].value = value; <span class="comment">// 哈希表中已存在该元素。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        table[index] = <span class="keyword">new</span> <span class="built_in">HashEntry</span>(key, value); <span class="comment">// 哈希表中不存在该元素。</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt;= table.length &gt;&gt; <span class="number">1</span>) <span class="built_in">resize</span>(); <span class="comment">// 元素数量超过数组的一半则进行扩容。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        HashEntry entry = table[<span class="built_in">index</span>(key, table)];</span><br><span class="line">        <span class="keyword">return</span> entry == null || entry.remove ? <span class="number">-1</span> : entry.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">index</span>(key, table);</span><br><span class="line">        <span class="keyword">if</span> (table[index] == null || table[index].remove)</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 哈希表中不存在该元素或该元素已被删除则直接返回。</span></span><br><span class="line">        table[index].remove = <span class="literal">true</span>; <span class="comment">// 将元素标记为已删除。</span></span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">int</span> <span class="title">index</span><span class="params">(<span class="type">int</span> key, HashEntry[] table)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = (index = key % table.length) &lt; <span class="number">0</span> ? index + table.length : index;</span><br><span class="line">        <span class="keyword">while</span> (table[index] != null &amp;&amp; table[index].key != key)</span><br><span class="line">            <span class="keyword">if</span> (++index &gt;= table.length)</span><br><span class="line">                index -= table.length;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断一个数是否为一个质数。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> boolean <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span> || n == <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || (n &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对哈希表进行扩容。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashEntry[] oldTable = table; <span class="comment">// 原来的数据。</span></span><br><span class="line">        <span class="comment">// 新数组的容量为原来容量的两倍。</span></span><br><span class="line">        HashEntry[] newTable = <span class="keyword">new</span> HashEntry[<span class="built_in">tableSizeFor</span>(oldTable.length &lt;&lt; <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">for</span> (HashEntry entry : oldTable) <span class="comment">// 将原数组中的元素复制到新数组中。</span></span><br><span class="line">            <span class="keyword">if</span> (entry != null &amp;&amp; !entry.remove) <span class="comment">// 已删除的元素不搬移到新数组中。</span></span><br><span class="line">                newTable[<span class="built_in">index</span>(entry.key, newTable)] = entry;</span><br><span class="line">        table = newTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证哈希表的容量是一个质数。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="type">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((capacity &amp; <span class="number">1</span>) == <span class="number">0</span>) capacity++;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isPrime</span>(capacity)) capacity += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-AV二叉树"><a href="#3-AV二叉树" class="headerlink" title="3. AV二叉树"></a>3. AV二叉树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashMap</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> ***LTree ***lTree;</span><br><span class="line">	<span class="keyword">private</span> NewNode node = null;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		***lTree = <span class="keyword">new</span> ***<span class="built_in">LTree</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">		node = ***lTree.<span class="built_in">insert</span>(node, key, value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">		NewNode nn = ***lTree.get***<span class="built_in">LTree</span>(key,node);</span><br><span class="line">		<span class="keyword">if</span>(nn!=null)&#123;</span><br><span class="line">			<span class="keyword">return</span> nn.val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//不存在，返回-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">		node = ***lTree.<span class="built_in">deleteNode</span>(node, key);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	NewNode left;</span><br><span class="line">	NewNode right;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点高度,高度是指节点到一片树叶的最长路径的长</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NewNode</span><span class="params">(<span class="type">int</span> key,<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        height = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ***LTree &#123;</span><br><span class="line">    <span class="keyword">public</span> NewNode root;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算***L节点的高度的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">int</span> <span class="title">height</span><span class="params">(NewNode NewNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果为空，返回height为0</span></span><br><span class="line">        <span class="keyword">return</span> NewNode == null ? <span class="number">0</span> : NewNode.height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算两个的最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右旋转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">NewNode <span class="title">rightRotate</span><span class="params">(NewNode y)</span> </span>&#123;</span><br><span class="line">        NewNode x = y.left;</span><br><span class="line">        NewNode T1 = x.right;</span><br><span class="line">        x.right = y;</span><br><span class="line">        y.left = T1;</span><br><span class="line">        <span class="comment">//更新高度</span></span><br><span class="line">        y.height = <span class="built_in">max</span>(<span class="built_in">height</span>(y.left), <span class="built_in">height</span>(y.right)) + <span class="number">1</span>;</span><br><span class="line">        x.height = <span class="built_in">max</span>(<span class="built_in">height</span>(x.left), <span class="built_in">height</span>(x.right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左旋转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">NewNode <span class="title">leftRotate</span><span class="params">(NewNode x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        NewNode y = x.right;</span><br><span class="line">        NewNode T2 = y.left;</span><br><span class="line">        y.left = x;</span><br><span class="line">        x.right = T2;</span><br><span class="line">        <span class="comment">//更新高度</span></span><br><span class="line">        x.height = <span class="built_in">max</span>(<span class="built_in">height</span>(x.left), <span class="built_in">height</span>(x.right)) + <span class="number">1</span>;</span><br><span class="line">        y.height = <span class="built_in">max</span>(<span class="built_in">height</span>(y.left), <span class="built_in">height</span>(y.right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  获取平衡因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getBalance</span><span class="params">(NewNode NewNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NewNode == null ? <span class="number">0</span> : (<span class="built_in">height</span>(NewNode.left) - <span class="built_in">height</span>(NewNode.right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">NewNode <span class="title">insert</span><span class="params">(NewNode NewNode,<span class="type">int</span> key, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (NewNode == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">NewNode</span>(key,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; NewNode.key) &#123;</span><br><span class="line">            NewNode.left = <span class="built_in">insert</span>(NewNode.left, key,val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; NewNode.key) &#123;</span><br><span class="line">            NewNode.right = <span class="built_in">insert</span>(NewNode.right, key,val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	NewNode.val = val;</span><br><span class="line">            <span class="keyword">return</span> NewNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新节点高度</span></span><br><span class="line">        NewNode.height = <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">height</span>(NewNode.left), <span class="built_in">height</span>(NewNode.right));</span><br><span class="line">        <span class="comment">//这是插入完毕后的</span></span><br><span class="line">        <span class="type">int</span> balance = <span class="built_in">getBalance</span>(NewNode);</span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &lt; NewNode.left.key) &#123;</span><br><span class="line">            <span class="comment">//右旋</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(NewNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &gt; NewNode.right.key) &#123;</span><br><span class="line">            <span class="comment">//左旋</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(NewNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &gt; NewNode.left.key) &#123;</span><br><span class="line">            <span class="comment">//先左旋，再右旋</span></span><br><span class="line">            NewNode.left = <span class="built_in">leftRotate</span>(NewNode.left);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(NewNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &lt; NewNode.right.key) &#123;</span><br><span class="line">            <span class="comment">//先右旋再左旋</span></span><br><span class="line">            NewNode.right = <span class="built_in">rightRotate</span>(NewNode.right);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(NewNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NewNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">NewNode get***<span class="title">LTree</span><span class="params">(<span class="type">int</span> key,NewNode node)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(node==null) <span class="keyword">return</span> null;</span><br><span class="line">		<span class="keyword">if</span>(key&gt;node.key)&#123;</span><br><span class="line">			node = get***<span class="built_in">LTree</span>(key,node.right);</span><br><span class="line">	    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key&lt;node.key)&#123;</span><br><span class="line">	    	node = get***<span class="built_in">LTree</span>(key,node.left);</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">if</span>(node!=null&amp;&amp;key==node.key) <span class="keyword">return</span> node;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> null;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">NewNode <span class="title">deleteNode</span><span class="params">(NewNode root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; root.key) &#123;</span><br><span class="line">            root.left = <span class="built_in">deleteNode</span>(root.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root.key) &#123;</span><br><span class="line">            root.right = <span class="built_in">deleteNode</span>(root.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//删除节点有两个孩子</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != null &amp;&amp; root.right != null) &#123;</span><br><span class="line">                root.val = <span class="built_in">findMin</span>(root.right).val;</span><br><span class="line">                root.key = <span class="built_in">findMin</span>(root.right).key;</span><br><span class="line">                root.right = <span class="built_in">deleteNode</span>(root.right, root.key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//删除节点只有一个孩子或者没有孩子</span></span><br><span class="line">                root = (root.left != null) ? root.left : root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以下操作是为了恢复***L树的平衡性</span></span><br><span class="line">        <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        root.height = <span class="built_in">max</span>(<span class="built_in">height</span>(root.left), <span class="built_in">height</span>(root.right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> balance = <span class="built_in">getBalance</span>(root);</span><br><span class="line">        <span class="comment">//左-左情况，这里使用&gt;=而不是&gt;就是为了保证这些情形下使用的是单旋转而不是双旋转</span></span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">getBalance</span>(root.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左-右情况</span></span><br><span class="line">        <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">getBalance</span>(root.left) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root.left = <span class="built_in">leftRotate</span>(root.left);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右-右情况</span></span><br><span class="line">        <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; <span class="built_in">getBalance</span>(root.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右-左情况</span></span><br><span class="line">        <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; <span class="built_in">getBalance</span>(root.right) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root.right = <span class="built_in">rightRotate</span>(root.right);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> NewNode <span class="title">findMin</span><span class="params">(NewNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findMin</span>(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="4-红黑树"><a href="#4-红黑树" class="headerlink" title="4. 红黑树"></a>4. 红黑树</h2><pre><code class="c++">class MyHashMap &#123;
    private static class TreeNode &#123;
        private int key;
        private int value;
        private boolean color;
        private TreeNode left;
        private TreeNode right;
        private TreeNode parent;

        private TreeNode(int key, int value) &#123;
            this.key = key;
            this.value = value;
        &#125;
    &#125;

    private static final boolean RED = false;
    private static final boolean BLACK = true;
    private TreeNode[] hashtable = new TreeNode[1024];
    private int currentSize;

    public void put(int key, int value) &#123;
        if (currentSize &gt;= hashtable.length) &#123;
            resize(); // 从结果来看，加载因子选 1.0 效率较高。
        &#125;
        int index = key &amp; (hashtable.length - 1);
        insert(index, new TreeNode(key, value));
    &#125;

    public int get(int key) &#123;
        int index = key &amp; (hashtable.length - 1);
        TreeNode node = getNode(index, key);
        return node == null ? -1 : node.value;
    &#125;

    public void remove(int key) &#123;
        int index = key &amp; (hashtable.length - 1);
        delete(index, key);
    &#125;

    // 对哈希表进行扩容。
    private void resize() &#123;
        TreeNode[] oldTable = hashtable;
        hashtable = new TreeNode[hashtable.length &lt;&lt; 1];
        for (TreeNode root : oldTable) &#123;
            postorderTraversal(root);
        &#125;
        currentSize &gt;&gt;= 1;
    &#125;

    // 获取指定位置上的指定结点。
    private TreeNode getNode(int index, int key) &#123;
        TreeNode current = hashtable[index];
        while (current != null) &#123;
            if (current.key == key) &#123;
                break;
            &#125;
            if (current.key &lt; key) &#123;
                current = current.right;
            &#125; else &#123;
                current = current.left;
            &#125;
        &#125;
        return current;
    &#125;

    // 在指定位置上插入结点。
    private void insert(int index, TreeNode insert) &#123;
        TreeNode current = hashtable[index], parent = null; // 分别保存当前结点及其父结点。
        while (current != null) &#123;
            parent = current;
            if (current.key == insert.key) &#123;
                current.value = insert.value;
                return;
            &#125;
            if (current.key &lt; insert.key) &#123;
                current = current.right;
            &#125; else &#123;
                current = current.left;
            &#125;
        &#125;
        insert.parent = parent;
        if (parent == null) &#123;
            hashtable[index] = insert;
        &#125; else if (parent.key &lt; insert.key) &#123;
            parent.right = insert;
        &#125; else &#123;
            parent.left = insert;
        &#125;
        currentSize++;
        fixAfterInsertion(index, insert);
    &#125;

    // 删除指定位置上的指定结点。
    private void delete(int index, int key) &#123;
        TreeNode delete = getNode(index, key);
        if (delete == null) &#123;
            return;
        &#125;
        if (delete.left != null &amp;&amp; delete.right != null) &#123;
            TreeNode successor = delete.right;
            while (successor.left != null) &#123;
                successor = successor.left;
            &#125;
            delete.key = successor.key;
            delete.value = successor.value;
            delete = successor;
        &#125;
        TreeNode replacement = delete.left == null ? delete.right : delete.left;
        if (replacement == null) &#123;
            fixAfterDeletion(index, delete);
            if (delete.parent == null) &#123;
                hashtable[index] = null;
            &#125; else if (delete.parent.left == delete) &#123;
                delete.parent.left = null;
            &#125; else &#123;
                delete.parent.right = null;
            &#125;
        &#125; else &#123; // 被删除的结点只有一个子结点，那它一定是黑色结点，且它的子结点为红色。
            replacement.parent = delete.parent;
            if (delete.parent == null) &#123;
                hashtable[index] = replacement;
            &#125; else if (delete.parent.left == delete) &#123;
                delete.parent.left = replacement;
            &#125; else &#123;
                delete.parent.right = replacement;
            &#125;
            replacement.color = BLACK;
        &#125;
        currentSize--;
    &#125;

    // 对插入后的结点进行调整。
    private void fixAfterInsertion(int index, TreeNode insert) &#123;
        while (colorOf(insert.parent) == RED) &#123; // 只有父结点是红色才进行处理。
            // 分别保存当前结点的父结点、叔父结点、祖父结点。
            TreeNode parent = insert.parent, uncle = sibling(parent), grand = parent.parent;
            grand.color = RED; // 不管是哪种情况，祖父结点都需要染成红色。
            if (colorOf(uncle) == BLACK) &#123; // 叔父结点为黑色。
                if (grand.left == parent) &#123;
                    if (parent.right == insert) &#123;
                        rotationLeft(index, parent); // LR 情况：先对父结点进行左旋转。
                        parent = insert;
                    &#125;
                    rotationRight(index, grand); // LL 情况：对祖父结点进行右旋转。
                &#125; else &#123;
                    if (parent.left == insert) &#123;
                        rotationRight(index, parent); // RL 情况：先对父结点进行右旋转。
                        parent = insert;
                    &#125;
                    rotationLeft(index, grand); // RR 情况：对祖父结点进行左旋转。
                &#125;
                parent.color = BLACK; // 将旋转后的中心结点染成黑色。
                insert = hashtable[index]; // 处理完直接退出循环。
            &#125; else &#123; // 叔父结点为红色，则将父结点与叔父结点都染成黑色，将祖父结点作为新插入的结点继续处理。
                uncle.color = BLACK;
                parent.color = BLACK;
                insert = grand;
            &#125;
        &#125;
        hashtable[index].color = BLACK; // 根结点必须是黑色。
    &#125;

    // 对删除后的结点进行调整。
    private void fixAfterDeletion(int index, TreeNode delete) &#123;
        while (delete.parent != null &amp;&amp; delete.color == BLACK) &#123; // 只有删除的是黑色结点才进行处理。
            // 分别保存当前结点的父结点、兄弟结点。
            TreeNode parent = delete.parent, sibling = sibling(delete);
            if (sibling.color == BLACK) &#123; // 兄弟结点是黑色。
                if (colorOf(sibling.left) == BLACK &amp;&amp; colorOf(sibling.right) == BLACK) &#123; // 兄弟结点没有红色子结点。
                    if (parent.color == BLACK) &#123;
                        delete = parent;
                    &#125;
                    parent.color = BLACK;
                    sibling.color = RED;
                &#125; else &#123; // 兄弟结点有红色子结点。
                    if (parent.left == sibling) &#123;
                        if (colorOf(sibling.left) == BLACK) &#123;
                            rotationLeft(index, sibling); // LR 情况：先对兄弟结点进行左旋转。
                            sibling = sibling.parent;
                        &#125;
                        rotationRight(index, parent); // LL 情况：对父结点进行右旋转。
                    &#125; else &#123;
                        if (colorOf(sibling.right) == BLACK) &#123;
                            rotationRight(index, sibling); // RL 情况：先对兄弟结点进行右旋转。
                            sibling = sibling.parent;
                        &#125;
                        rotationLeft(index, parent); // RR 情况：对父结点进行左旋转。
                    &#125;
                    sibling.color = parent.color; // 旋转后中心结点继承父结点的颜色。
                    sibling.left.color = BLACK;
                    sibling.right.color = BLACK;
                    delete = hashtable[index]; // 处理完直接退出循环。
                &#125;
            &#125; else &#123; // 兄弟结点是红色。
                if (parent.left == sibling) &#123;
                    rotationRight(index, parent);
                &#125; else &#123;
                    rotationLeft(index, parent);
                &#125;
                parent.color = RED;
                sibling.color = BLACK;
            &#125;
        &#125;
    &#125;

    // 获取指定结点的兄弟结点。
    private TreeNode sibling(TreeNode node) &#123;
        if (node.parent.left == node) &#123;
            return node.parent.right;
        &#125;
        return node.parent.left;
    &#125;

    // 对指定位置上的指定结点进行左旋转。
    private void rotationLeft(int index, TreeNode node) &#123;
        TreeNode newRoot = node.right; // 结点的右子结点会成为这颗子树的根结点。
        node.right = newRoot.left;
        if (newRoot.left != null) &#123;
            newRoot.left.parent = node;
        &#125;
        newRoot.left = node;
        newRoot.parent = node.parent;
        if (node.parent == null) &#123;
            hashtable[index] = newRoot;
        &#125; else if (node.parent.left == node) &#123;
            node.parent.left = newRoot;
        &#125; else &#123;
            node.parent.right = newRoot;
        &#125;
        node.parent = newRoot;
    &#125;

    // 对指定位置上的指定结点进行右旋转。
    private void rotationRight(int index, TreeNode node) &#123;
        TreeNode newRoot = node.left; // 结点的左子结点会成为这颗子树的根结点。
        node.left = newRoot.right;
        if (newRoot.right != null) &#123;
            newRoot.right.parent = node;
        &#125;
        newRoot.right = node;
        newRoot.parent = node.parent;
        if (node.parent == null) &#123;
            hashtable[index] = newRoot;
        &#125; else if (node.parent.left == node) &#123;
            node.parent.left = newRoot;
        &#125; else &#123;
            node.parent.right = newRoot;
        &#125;
        node.parent = newRoot;
    &#125;

    // 获取指定结点的颜色。
    private boolean colorOf(TreeNode node) &#123;
        return node == null || node.color;
    &#125;

    // 对结点进行后序遍历。
    private void postorderTraversal(TreeNode node) &#123;
        if (node == null) &#123;
            return;
        &#125;
        postorderTraversal(node.left);
        postorderTraversal(node.right);
        node.left = node.right = node.parent = null;
        node.color = RED;
        int index = node.key &amp; (hashtable.length - 1);
        insert(index, node);
    &#125;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/2023/06/15/OSTEP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/15/OSTEP/" class="post-title-link" itemprop="url">OSTEP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-15 20:20:57" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-16 10:07:04" itemprop="dateModified" datetime="2023-06-16T10:07:04+08:00">2023-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="OSTEP-jyy"><a href="#OSTEP-jyy" class="headerlink" title="OSTEP jyy"></a>OSTEP jyy</h1><h2 id="0x-01-reference"><a href="#0x-01-reference" class="headerlink" title="0x 01 reference"></a>0x 01 reference</h2><p><a target="_blank" rel="noopener" href="http://jyywiki.cn/OS/2022/">官网</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12L4y1379V/?spm_id_from=333.788&vd_source=38033fe3a1f136728a1d6f8acf710b51">教学视频</a></p>
<hr>
<h3 id="1-why-learn-OS"><a href="#1-why-learn-OS" class="headerlink" title="1.why learn OS"></a>1.why learn OS</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>解决一个问题的步骤：why-what-how</span><br><span class="line">为什么要学习操作系统</span><br><span class="line">什么是操作系统</span><br><span class="line">怎样学习操作系统</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>三个根本问题</span><br><span class="line">（<span class="number">1</span>）操作系统服务谁</span><br><span class="line">程序=状态机</span><br><span class="line">课程涉及：多线程Linux应用程序</span><br><span class="line">（<span class="number">2</span>）（乘机/应用视角）操作系统为程序提供什么服务</span><br><span class="line">操作系统=对象+API（用来操纵对象)</span><br><span class="line">课程涉及：POSIX+部分Linux特性</span><br><span class="line">（<span class="number">3</span>）（实现/硬件角度）如何实现操作系统提供的服务</span><br><span class="line">操作系统=C程序</span><br><span class="line">课程涉及：xv6,自制迷你操作系统</span><br></pre></td></tr></table></figure>

<h3 id="2-code"><a href="#2-code" class="headerlink" title="2.code"></a>2.code</h3><table>
<thead>
<tr>
<th>说明</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>查看用户名</td>
<td>uname -a</td>
</tr>
<tr>
<td>传送ACWing配置</td>
<td>scp .bashrc .vimrc .tmux.conf：…</td>
</tr>
<tr>
<td>下载tldr(too long dont read)</td>
<td>sudo apt-get install tldr</td>
</tr>
</tbody></table>
<h3 id="3-wrong-when-install-tldr"><a href="#3-wrong-when-install-tldr" class="headerlink" title="3. wrong when install tldr"></a>3. wrong when install tldr</h3><p>报错，出现用户名 is not in the sudoers file.<br>是因为当前的用户没有加入到sudo的配置文件里<br>解决方案：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>切换到root用户</td>
<td>su - root</td>
</tr>
<tr>
<td>修改配置文件</td>
<td>vim &#x2F;etc&#x2F;sudoers</td>
</tr>
<tr>
<td>修改</td>
<td>增加配置, 在打开的配置文件中，找到ununtu&#x2F;root ALL&#x3D;(ALL) ALL, 在下面添加一行：your_user_name ALL&#x3D;(ALL) ALL，wq!退出，这个文件是只读的，所以需要加！在ubuntu下是最后一行</td>
</tr>
</tbody></table>
<h3 id="4-some-jyy-wonderful-operating"><a href="#4-some-jyy-wonderful-operating" class="headerlink" title="4. some jyy wonderful operating"></a>4. some jyy wonderful operating</h3><table>
<thead>
<tr>
<th>功能</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>在vim里面编译C&#x2F;C++</td>
<td>:!gcc&#x2F;g++  %  -o  main (% 获取当前文件名)</td>
</tr>
<tr>
<td>在vim里面编译并运行C++</td>
<td>:!g++ % -o main &amp;&amp; .&#x2F;main</td>
</tr>
<tr>
<td>wget用于从网络上下载资源，没有指定目录，下载资源回默认为当前目录。wget支持HTTP，HTTPS和FTP协议，可以使用HTTP代理</td>
<td>wget url</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="0x-02-what-is-Programs-and-Compilers"><a href="#0x-02-what-is-Programs-and-Compilers" class="headerlink" title="0x 02 what is Programs and Compilers"></a>0x 02 what is Programs and Compilers</h2><h3 id="1-notes"><a href="#1-notes" class="headerlink" title="1. notes"></a>1. notes</h3><blockquote>
<p>程序就是状态机</p>
<blockquote>
<p>数字系统是状态机，程序运行在数字系统上，因而程序也应该是状态机。</p>
<p>在 C 语言中，程序中所有的东西（堆，栈）就是程序的状态，每执行一条一句，程序的状态就会变一下。</p>
</blockquote>
<p>include的形式语义就是复制粘贴，它是在预编译阶段处理的，例如我们 <code>#include &lt;tets.c&gt;</code> , 在预处理阶段，会从一个目录找到 include 的 test.c 文件，然后将它的内容复制粘贴到源代码中。</p>
</blockquote>
<h3 id="2-more-instruction"><a href="#2-more-instruction" class="headerlink" title="2. more instruction"></a>2. more instruction</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb layout src</span><br><span class="line">asm volatile(“rdrand %rax”);</span><br><span class="line">info proc mappings :查看进程信息</span><br><span class="line">unist: unix standard library</span><br></pre></td></tr></table></figure>

<h3 id="3-bug"><a href="#3-bug" class="headerlink" title="3. bug"></a>3. bug</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FOE_EACH(_) _(X) _(Y);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE(X) int X, X1;</span></span><br><span class="line"></span><br><span class="line">FOE_EACH(DEFINE)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    我们的本意是执行:</span></span><br><span class="line"><span class="comment">    int X, X1; int Y, Y1;</span></span><br><span class="line"><span class="comment">    但是我们执行是：</span></span><br><span class="line"><span class="comment">    int X, X1; int Y, X1;</span></span><br><span class="line"><span class="comment">  	这里的X1重复定义了</span></span><br><span class="line"><span class="comment">  	这是因为X1的X并不能被识别，它会被认为是一个字符串</span></span><br><span class="line"><span class="comment">	正确的写法是:</span></span><br><span class="line"><span class="comment">	#define DEFINE(X) int X, X##1</span></span><br><span class="line"><span class="comment">	这样X##1的X就可以被识别</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="4-Unix’s-philosophy"><a href="#4-Unix’s-philosophy" class="headerlink" title="4. Unix’s philosophy"></a>4. Unix’s philosophy</h3><ul>
<li>Make each program do one thing well</li>
<li>Expect the output of every program to become the input to anothe</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/2023/06/15/P-NP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/15/P-NP/" class="post-title-link" itemprop="url">NP probelm</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-15 20:20:57" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-16 10:07:08" itemprop="dateModified" datetime="2023-06-16T10:07:08+08:00">2023-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NP/" itemprop="url" rel="index"><span itemprop="name">NP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="NP-completeness"><a href="#NP-completeness" class="headerlink" title="NP completeness"></a>NP completeness</h1><h2 id="proface"><a href="#proface" class="headerlink" title="proface"></a>proface</h2><p>P：Polynomial</p>
<p>NP：Non-determinstic Polynomial</p>
<p>NPC：Non-deterministic Polynomial complete</p>
<p>RP：人品</p>
<p>reducibility：归约，约化</p>
<h2 id="time-compleity"><a href="#time-compleity" class="headerlink" title="time compleity"></a>time compleity</h2><p>时间复杂度并不是表示一个程序解决问题需要花费的时间，而是当问题规模扩大后，程序需要的时间长度增长的多快</p>
<h2 id="whats-polynomial？"><a href="#whats-polynomial？" class="headerlink" title="whats polynomial？"></a>whats polynomial？</h2><p>假设有一个自变量 <code>n</code></p>
<p><code>n + n^2 + 3n^3</code> 这就是一个多项式</p>
<p><code>2^n</code> , <code>n!</code>  不是多项式，他们也有自己的名字：超多项式</p>
<blockquote>
<p>一般而言，当 <code>n</code> 作为底数时，就是多项式，当 <code>n</code> 作为指数时或者阶乘时，就是超多项式。</p>
</blockquote>
<h2 id="reducibility"><a href="#reducibility" class="headerlink" title="reducibility"></a>reducibility</h2><p>  简单地说，一个问题A可以约化为问题B的含义即是，可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个“规则”，按照这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能得到一样的结果。这个规则即是：两个方程的对应项系数不变，一元二次方程的二次项系数为0。按照这个规则把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton回路可以约化为TSP问题(Travelling Salesman Problem，旅行商问题)：在Hamilton回路问题中，两点相连即这两点距离为0，两点不直接相连则令其距离为1，于是问题转化为在TSP问题中，是否存在一条长为0的路径。Hamilton回路存在当且仅当TSP问题中存在长为0的回路。<br>  “问题A可约化为问题B”有一个重要的直观意义：B的时间复杂度高于或者等于A的时间复杂度。也就是说，问题A不比问题B难。这很容易理解。既然问题A能用问题B来解决，倘若B的时间复杂度比A的时间复杂度还低了，那A的算法就可以改进为B的算法，两者的时间复杂度还是相同。正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者。<br>  很显然，约化具有一项重要的性质：约化具有传递性。如果问题A可约化为问题B，问题B可约化为问题C，则问题A一定可约化为问题C。这个道理非常简单，就不必阐述了。<br>  现在再来说一下约化的标准概念就不难理解了：如果能找到这样一个变化法则，对任意一个程序A的输入，都能按这个法则变换成程序B的输入，使两程序的输出相同，那么我们说，问题A可约化为问题B。<br>  当然，我们所说的“可约化”是指的可“多项式地”约化(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的。约化的过程只有用多项式的时间完成才有意义。</p>
<h2 id="p-np-npc-np-hard"><a href="#p-np-npc-np-hard" class="headerlink" title="p,np,npc,np-hard"></a>p,np,npc,np-hard</h2><h3 id="1-P问题"><a href="#1-P问题" class="headerlink" title="1. P问题"></a>1. P问题</h3><p>在多项式时间内可解的问题</p>
<h3 id="2-NP问题"><a href="#2-NP问题" class="headerlink" title="2. NP问题"></a>2. NP问题</h3><p>首先，NP问题不是指： not P问题。</p>
<p>它指的是可以在多项式的时间里验证一个解的问题。</p>
<p>但这并不意味着Np问题可以在多项式时间内可解，在多项式时间内可验证和在多项式时间内可解没有任何关联。</p>
<p>换句话来说，NP问题指的是可以在多项式的时间里才出一个解的问题。</p>
<blockquote>
<p> 哈密顿回路就是一个NP问题</p>
<p>之所以要定义NP问题，是因为通常只有NP问题才可能找到多项式的算法。我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。</p>
</blockquote>
<p>因此，显然的，&lt;font color &#x3D; “blue”&gt;所有的 P 类问题都是 NP 问题。</font>也就是说，能在多项式时间内解决一个问题，必然能在多项式时间验证一个问题的解。</p>
<p>关键是，人们想知道，是否所有的 NP 问题都是 P 类问题？也即，是否有 P&#x3D;NP？</p>
<p>通常所谓的“NP问题”，其实就一句话：证明或推翻P&#x3D;NP。</p>
<p>NP问题很难解决，但现在有一个总的趋势，然们普遍倾向于认为：P!&#x3D;NP，因为人们在研究NP问题的时候找到了一类特殊的NP问题叫做NP-完全问题，也就是NPC问题。</p>
<h3 id="3-NPC问题"><a href="#3-NPC问题" class="headerlink" title="3. NPC问题"></a>3. NPC问题</h3><p>  好了，从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。再回想前面讲的P和NP问题，联想起约化的传递性，自然地，我们会想问，如果不断地约化上去，不断找到能“通吃”若干小NP问题的一个稍复杂的大NP问题，那么最后是否有可能找到一个时间复杂度最高，并且能“通吃”所有的 NP问题的这样一个超级NP问题？答案居然是肯定的。也就是说，存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是传说中的NPC 问题，也就是NP-完全问题。NPC问题的出现使整个NP问题的研究得到了飞跃式的发展。我们有理由相信，NPC问题是最复杂的问题。</p>
<p>  NPC问题的定义非常简单。同时满足下面两个条件的问题就是NPC问题。首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。证明一个问题是 NPC问题也很简单。先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它（由约化的传递性，则NPC问题定义的第二条也得以满足；至于第一个NPC问题是怎么来的，下文将介绍），这样就可以说它是NPC问题了。</p>
<p>  既然所有的NP问题都能约化成NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决了，NP也就等于P 了。因此，给NPC找一个多项式算法太不可思议了。因此，前文才说，“正是NPC问题的存在，使人们相信P≠NP”。我们可以就此直观地理解，NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。</p>
<h3 id="4-np-hard"><a href="#4-np-hard" class="headerlink" title="4. np-hard"></a>4. np-hard</h3><p>  顺便讲一下NP-Hard问题。NP-Hard问题是这样一种问题，它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广）。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。</p>
<h2 id="case-npc-problem"><a href="#case-npc-problem" class="headerlink" title="case: npc problem"></a>case: npc problem</h2><p>逻辑电路问题。这是第一个NPC问题。其它的NPC问题都是由这个问题约化而来的。因此，逻辑电路问题是NPC类问题的“鼻祖”。</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><a href="%5Bref%5D(https://www.zhihu.com/question/24653072)">知乎：什么是多项式？</a></p>
<p><a target="_blank" rel="noopener" href="http://www.matrix67.com/blog/archives/105">Matrix67: 什么是P问题、NP问题和NPC问题</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/2023/06/15/C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/15/C/" class="post-title-link" itemprop="url">C note</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-15 20:20:57" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-16 09:46:39" itemprop="dateModified" datetime="2023-06-16T09:46:39+08:00">2023-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C和指针"><a href="#C和指针" class="headerlink" title="C和指针"></a>C和指针</h1><h2 id="1-宏函数与自定义函数"><a href="#1-宏函数与自定义函数" class="headerlink" title="1. 宏函数与自定义函数"></a>1. 宏函数与自定义函数</h2><p>宏函数与自定义函数是对立的，宏函数的优点就是自定义函数的缺点，自定义函数的缺点就是宏函数的优点。<br>宏函数的优点：1·执行效率高  2·节省空间<br>宏函数的缺点：1编译时间长   2·不安全，没有语法检查</p>
<p>因为宏函数在编译时直接展开，所以不像自定义函数一样需要进行函数调用，因此宏函数运行时没有通过函数名找到函数的入口地址，保存返回地址，为形参分配空间，实参分配给形参，形参入栈等操作。因此步骤少，并且不需要在栈上分配额外空间。但因此宏函数需要在编译时替换，因此编译时间长。另外，宏函数也没有语法检查，不安全。</p>
<h2 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2. 关键字"></a>2. 关键字</h2><h3 id="2-1-extern，static"><a href="#2-1-extern，static" class="headerlink" title="2.1 extern，static"></a>2.1 extern，static</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//static int num = 100; // 1.static修饰全局变量，改变变量的作用域，只能在本文件中被调用，采用这种声明，编译1.c和2.c就会报错。</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">100</span>;  <span class="comment">// 声明并初始化一个变量，会分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span>;       <span class="comment">// 声明一个函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅声明变量num，但不初始化，否则就会为其分配内存</span></span><br><span class="line"><span class="comment">// extern表示该变量在别处定义并初始化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static void f()    // 2.static修饰函数，改变函数的作用域，只能在本文件中被调用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc 1.c 2.c -o main</span><br><span class="line">./main</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译多个文件时，要保证只有一个main函数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = <span class="number">0</span>; <span class="comment">// 3.static修饰局部变量，叫静态变量（存放在静态数据区），改变变量的生命周期，直到程序结束释放</span></span><br><span class="line">    <span class="comment">//int x = 0;</span></span><br><span class="line">    x ++ ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">    	Add();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-const"><a href="#2-2-const" class="headerlink" title="2.2 const"></a>2.2 const</h3><p>1.const 修饰普通变量即const修饰只读变量，不能通过变量本身修改变量的值，但可以通过其他方式(指针)修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)&amp;a;</span><br><span class="line">    *p ++ ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行上面的程序之后可以发现a的值仍然被修改了，所以说这也就说明了一个常见的误解，认为const修饰的就是常量，实际上并不是</p>
</blockquote>
<p>2.const修饰指针 （<strong>就近原则</strong>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向常量的指针</span></span><br><span class="line"><span class="comment">// 由于const和int的位置可以互换，所以可以忽略int，原式就成了 const *q，const距离*最近，因此const修饰的是*q</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *q = &amp;a;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *q = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针常量</span></span><br><span class="line"><span class="comment">// const距离q最近，因此const修饰的是q</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> q = &amp;a;</span><br></pre></td></tr></table></figure>

<p>3.const修饰函数形参</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">new_strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>((*dest ++ = *src++) != <span class="string">&#x27;\0&#x27;</span>)  ;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> d[<span class="number">20</span>] = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">20</span>] = <span class="string">&quot;newstr&quot;</span>;</span><br><span class="line">    new_strcpy(d, s);</span><br><span class="line">    <span class="built_in">puts</span>(d);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.const修饰函数的返回值</p>
<p>若函数的返回值是指针，且用const修饰，则函数返回值指向的内容是常数，不可被修改，此返回值仅能赋值给const修饰的相同类型的指针。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="title function_">f1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> * p;</span><br><span class="line">	p = new <span class="type">int</span>;</span><br><span class="line">	*p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *p; <span class="comment">// 改为int *p1;则编译时报错：“[8] error: invalid conversion from &#x27;const int*&#x27; to &#x27;int*&#x27;” (编译器code::block);</span></span><br><span class="line">    p = f1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>若主函数改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> * p1;</span><br><span class="line">	p1 = f1();</span><br><span class="line">	*p1 = <span class="number">2</span>; <span class="comment">//则编译时报错：&quot;[10] error: assignment of read-only location &#x27;* p1&#x27;&quot;  (编译器code::block);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数返回值是数值（by value），因C++中，返回值会被复制到外部临时的存储单元中，故const 修饰是没有任何价值的。例：不要把函数int fun1() 写成const int func1()。<br>同理不要把函数A GetA(void) 写成const A GetA(void)，其中A 为用户自定义的数据类型。</p>
<p>如果返回值是对象，将函数A fun2() 改写为const A &amp; fun2()的确能提高效率。但此要注意，要确定函数究竟是想返回一个对象的“copy”,还是仅返回对象的“别名”即可，否则程序会出错。</p>
<h2 id="3-危险的指针"><a href="#3-危险的指针" class="headerlink" title="3. 危险的指针"></a>3. 危险的指针</h2><p><strong>警告⚠️：没有将一个free掉的指针置NULL</strong></p>
<p>一个指针被free之后，它仍然指向原来指向的内存区域。但是该空间的内容已经不再是之前的值了，已经释放掉了。</p>
<p>这时候的指针我们称为野指针。将它<strong>置为NULL</strong>后，可以防止被误用，同时也可以后续作为判断该指针是否已经释放的标记</p>
<h3 id="3-1-悬挂-悬空-指针"><a href="#3-1-悬挂-悬空-指针" class="headerlink" title="3.1 悬挂(悬空)指针"></a>3.1 悬挂(悬空)指针</h3><p>悬挂指针：当指针所指向的对象被释放，但是该指针没有任何改变，以至于其仍然指向已经被回收的内存地址，这种情况下该指针被称为悬挂指针；</p>
<h3 id="3-2-野指针"><a href="#3-2-野指针" class="headerlink" title="3.2 野指针"></a>3.2 野指针</h3><p>野指针：未初始化的指针被称为野指针。</p>
<h2 id="4-gcc编译器"><a href="#4-gcc编译器" class="headerlink" title="4. gcc编译器"></a>4. gcc编译器</h2><h3 id="4-1-编译过程"><a href="#4-1-编译过程" class="headerlink" title="4.1 编译过程"></a>4.1 编译过程</h3><h4 id="4-1-1-预处理"><a href="#4-1-1-预处理" class="headerlink" title="4.1.1 预处理"></a>4.1.1 预处理</h4><p>命令 <code>gcc -E x.c -o x.i</code> ，生成一个 <code>.i</code> 文件（预处理文件）</p>
<p>预处理就是处理所有<code>#</code> 开头的行，即展开头文件和宏定义和条件编译。</p>
<p>其中 <code>#include &lt;stdio.h&gt;</code> 中的 <code>&lt;&gt;</code> 表示在系统里面找 <code>stdio.h</code> 文件。在 <code>/usr/include</code> 目录下有很多头文件。</p>
<h4 id="4-1-2-编译"><a href="#4-1-2-编译" class="headerlink" title="4.1.2 编译"></a>4.1.2 编译</h4><p>命令 <code>gcc -S x.i -o x.s</code> ，生成一个<code>.s</code> 文件（汇编文件）</p>
<h4 id="4-1-3-汇编"><a href="#4-1-3-汇编" class="headerlink" title="4.1.3 汇编"></a>4.1.3 汇编</h4><p>命令 <code>gcc -c x.s -o x.o</code> ，生成一个<code>.o</code> 文件（二进制文件）</p>
<h4 id="4-1-4-链接"><a href="#4-1-4-链接" class="headerlink" title="4.1.4 链接"></a>4.1.4 链接</h4><p>生成一个可执行二进制文件。默认链接方式是动态链接。</p>
<p>对于一条语句 <code>printf(&quot;xxx&quot;)</code> ，动态链接会链接 printf 的位置信息，静态链接会链接 printf  的具体实现。因此，静态链接的文件大小比静态链接的文件大得多。但是静态链接对环境的依赖比动态链接要小，加入系统中不存在 printf 的实现，那么动态链接就无法执行。</p>
<h3 id="4-2-其它常用参数"><a href="#4-2-其它常用参数" class="headerlink" title="4.2 其它常用参数"></a>4.2 其它常用参数</h3><ul>
<li>-g：在可执行程序中包含标准调试信息。</li>
<li>-v：打印出编译器内部个过程的命令行信息和编译器的版本</li>
<li>-I dir：在头文件的搜索路径列表中添加 dir 目录</li>
<li>-L dir：在库文件的搜索路径列表中添加 dir 目录</li>
<li>-static：链接静态库</li>
<li>-l library：链接名为 library 的库文件</li>
</ul>
<h3 id="4-3-静态库"><a href="#4-3-静态库" class="headerlink" title="4.3 静态库"></a>4.3 静态库</h3><p>静态库文件格式：<code>.a</code>  结尾，<code>lib</code>  开头。</p>
<p>创建静态库文件步骤：</p>
<ol>
<li>写源文件，通过 <code>gcc -c xxx.c</code> 生成目标文件。</li>
<li>用 <code>ar</code> 归档目标文件，生成静态库。具体位为：<code>ar -crv libname.a lib1.o lib2.o</code>，执行该命令即可创建名为 <code>name</code> 的静态库。</li>
</ol>
<p>上述命令中 crv 是 ar的命令选项：</p>
<ul>
<li>c 如果需要生成新的库文件，不要警告</li>
<li>r 代替库中现有的文件或者插入新的文件</li>
<li>v 输出详细信息</li>
</ul>
<p>创建静态库举例：</p>
<p>f1.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;this is f1...\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>f2.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;this is f1...\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f1</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	f1();</span><br><span class="line">	f2();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 <code>f1.c</code>, <code> f2.c</code>为源文件创建静态库:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c f1.c f2.c  #生成目标文件f1.o f2.o</span><br><span class="line">ar -crv libmylib.a f1.o f2.o</span><br></pre></td></tr></table></figure>

<p>链接静态库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main -staic -l mylib -L .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虽然静态库文件为：libmylib.a，但是该静态库的名字是 mylib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-l mylib 表示链接名为 mylib 的静态库</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-L . 表示将当前目录添加到搜索静态库文件的目录</span></span><br></pre></td></tr></table></figure>



<h3 id="4-4-动态库"><a href="#4-4-动态库" class="headerlink" title="4.4 动态库"></a>4.4 动态库</h3><p>动态库文件格式：<code>.so</code> 结尾</p>
<p>创建并链接动态库：</p>
<ol>
<li><code>gcc -fPIC -shared -o libxxx.so xx1.c xx2.c</code></li>
<li><code>gcc main.c -o main -L . -l xxx</code></li>
</ol>
<blockquote>
<p>fPIC 作用于编译阶段，告诉编译器产生与位置无关代码(Position-Independent Code)，<strong>则产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意位置，都可以正确的执行。</strong>这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。</p>
<p>PIC就是position independent code</p>
<p>PIC使.so文件的代码段变为真正意义上的共享</p>
<p><strong>如果不加 -fPIC,则加载 .so文件的代码段时,代码段引用的数据对象需要重定位, 重定位会修改代码段的内容,这就造成每个使用这个 .so文件代码段的进程在内核里都会生成这个 .so文件代码段的copy.每个 copy都不一样,取决于这个 .so文件代码段和数据段内存映射的位置.</strong></p>
<p><strong>不加 fPIC编译出来的 so,是要再加载时根据加载到的位置再次重定位的.(因为它里面的代码并不是位置无关代码)</strong></p>
<p>如果被多个应用程序共同使用,那么它们必须每个程序维护一份so的代码副本了.(因为so被每个程序加载的位置都不同,显然这些重定位后的代码也不同,当然不能共享)<br>我们总是用fPIC来生成so,也从来不用fPIC来生成a.<br>fPIC与动态链接可以说基本没有关系,libc.so一样可以不用fPIC编译,只是这样的so必须要在加载到用户程序的地址空间时重定向所有表目.</p>
<p>因此,不用fPIC编译so并不总是不好.<br>如果你满足以下4个需求&#x2F;条件:<br>1.该库可能需要经常更新<br>2.该库需要非常高的效率(尤其是有很多全局量的使用时)<br>3.该库并不很大.<br>4.该库基本不需要被多个应用程序共享</p>
<p>如果用没有加这个参数的编译后的共享库，也可以使用的话，可能是两个原因：<br>1：gcc默认开启-fPIC选项<br>2：loader使你的代码位置无关</p>
<p>从GCC来看，shared应该是包含fPIC选项的，但似乎不是所以系统都支持，所以最好显式加上fPIC选项。</p>
</blockquote>
<p>还是上面的三个文件。执行完上述两个操作之后，执行 <code>./main</code> ，报错：<code>./main: error while loading shared libraries: libmylib.so: cannot open shared object file: No such file or directory</code></p>
<p>这是因为链接动态库虽然是在当前目录下链接的，但是在程序执行的时候并不在当前目录下找，我们可以用命令 <code>ldd main</code> 查看 <code>main</code> 程序在哪里寻找动态库。</p>
<blockquote>
<p>ldd命令用于查看二进制文件所有用到的动态库在哪</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">linux-vdso.so.1 (0x00007ffc4edf3000)</span><br><span class="line">libmylib.so =&gt; not found</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f23af86c000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f23afa6e000)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  可以看到，我们的动态库 <code>libmylib.so</code> 显示 <code>not found</code>，而系统自带的动态库 <code>libc.so.6</code> 在目录 <code>/lib/x86_64-linux-gnu/</code> 下。</p>
<p>因此我们只需要把 <code>libmylib.so</code> 复制到该目录下即可：<code>sudo cp libmylib.so /lib/x86_64-linux-gnu/</code>，然后 <code>main</code> 程序就可以正常执行了。</p>
<h2 id="5-sizeof-产生的问题"><a href="#5-sizeof-产生的问题" class="headerlink" title="5. sizeof 产生的问题"></a>5. sizeof 产生的问题</h2><h3 id="5-1-仍然需要加括号的情况"><a href="#5-1-仍然需要加括号的情况" class="headerlink" title="5.1 仍然需要加括号的情况"></a>5.1 仍然需要加括号的情况</h3><p>首先，sizeof是一个<strong>关键字</strong>而不是一个函数。其次，当我们用sizeof求字节长度时，最好加上括号，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>；</span></span><br><span class="line"><span class="class">// 上面的代码编译起就会报错，因为他被解释为:</span><span class="keyword">sizeof</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class"><span class="title">sizeof</span> <span class="title">a</span> + 1</span></span><br><span class="line"><span class="class">// 会被解释为:</span> <span class="keyword">sizeof</span>(a) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 而不是 sizeof(a + 1)</span></span><br></pre></td></tr></table></figure>

<p>所以说为了避免由于优先级问题导致的二义性，还是加上括号吧！</p>
<p>另外，看下面的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="number">0</span> == <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="keyword">sizeof</span>(a = <span class="number">4</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-sizeof到底是什么"><a href="#5-2-sizeof到底是什么" class="headerlink" title="5.2 sizeof到底是什么"></a>5.2 sizeof到底是什么</h3><p>网上有人说sizeof是一个操作符，但我觉得它更像一个<strong>特殊的宏</strong>，因为它是在编译阶段求值的。</p>
<p>在上面的例子中，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="number">0</span> == <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="keyword">sizeof</span>(a = <span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<p>在编译阶段会被翻译为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="number">4</span>;   </span><br></pre></td></tr></table></figure>

<p>因为C语言中没有bool类型，而是以int类型表示，所以</p>
<p><code>sizeof(0 == 1)</code> 就相当于 <code>sizeof(int)</code></p>
<p>并且我们在第二条语句中令a&#x3D;4，但输出的仍然是1，这说明a的值没有被改变，并且<code>sizeof(a=4)</code>被解释为<code>sizeof(int)</code></p>
<p>其原因就在于sizeof在编译阶段处理的特性。由于sizeof不能被编译成机器码，所以sizeof作用范围内，也就是()里面的内容也不能被编译，而是被替换成类型。&#x3D;操作符返回左操作数的类型，所以a&#x3D;3相当于int.</p>
<h3 id="5-3-总结"><a href="#5-3-总结" class="headerlink" title="5.3 总结"></a>5.3 总结</h3><p>所以，sizeof是不可能支持链式表达式的，这也是和一元操作符不一样的地方。</p>
<p><strong>结论：不要把sizeof当成函数，也不要看作一元操作符，把他当成一个特殊的编译预处理。</strong></p>
<h2 id="6-内存管理"><a href="#6-内存管理" class="headerlink" title="6. 内存管理"></a>6. 内存管理</h2><h3 id="6-1-内存结构"><a href="#6-1-内存结构" class="headerlink" title="6.1 内存结构"></a>6.1 内存结构</h3><p>在实际的程序当中，我们操作的都是虚拟内存，而不是实际的物理内存（因为操作者不一定能正确操纵内存，如果直接操作物理内存，可能会导致操作系统死掉等问题）。</p>
<p>虚拟内存与物理内存之间是映射关系，虚拟内存映射一小部分物理内存。在linux中，虚拟内存一般是4g，默认按照1:3分配（可以调整）。1个g是内核态、另外3个g是用户态。</p>
<p>其中3个g一般又分为5块。</p>
<p><img src="https://pic1.zhimg.com/v2-db1beae537441e72682b5932b97770b0_1440w.jpg?source=172ae18b" alt="再谈应用程序分段： 数据段、代码段、BSS段以及堆和栈"></p>
<p>相关段总结如下。</p>
<table>
<thead>
<tr>
<th>段名</th>
<th>存储属性</th>
<th>内存分配</th>
</tr>
</thead>
<tbody><tr>
<td>代码段 .text</td>
<td>存放可执行程序的指令，存储态和运行态都有</td>
<td>静态</td>
</tr>
<tr>
<td>数据段 .data</td>
<td>存放已初始化（非零初始化的全局变量和静态局部变量）的数据，存储态和运行态都有</td>
<td>静态</td>
</tr>
<tr>
<td>bss段 .bss</td>
<td>存放未初始化（未初始化或者0初始化的全局变量和静态局部变量）的数据，存储态和运行态都有</td>
<td>静态</td>
</tr>
<tr>
<td>堆 heap</td>
<td>动态分配内存，需要通过malloc手动申请，free手动释放，适合大块内存。容易造成内存泄漏和内存碎片。运行态才有。由程序员手动申请。</td>
<td>动态</td>
</tr>
<tr>
<td>栈 stack</td>
<td>存放函数局部变量和参数以及返回值，函数返回后，由操作系统立即回收。栈空间不大，使用不当容易栈溢出。运行态才有。系统自动分配。</td>
<td>静态</td>
</tr>
</tbody></table>
<p>看下面的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s1[size] = <span class="string">&quot;hello,world!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *s2 = <span class="string">&quot;hello,world!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *s3 = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码中，s1，s2，s3都是局部变量，s1是一个数组，s2，s3是一个指针，其本身被分配在栈中。</p>
<p>但是s2中的“hello，world！”是一个字符串常量，其也占用内存，并且分配在数据段，s2指向这个字符串常量的地址。</p>
<p>s3中malloc分配的大小为128字节的内存在堆中，s3指向堆中分配的这块内存。</p>
<p>可以看出，同样是局部变量，s1只占用了一块内存，而s2，s3占用了两块内存。</p>
</blockquote>
<h3 id="6-2-堆和栈的区别"><a href="#6-2-堆和栈的区别" class="headerlink" title="6.2 堆和栈的区别"></a>6.2 堆和栈的区别</h3><ol>
<li>管理方式不同：堆由程序员管理，栈由系统管理。</li>
<li>空间大小不同：栈的空间比较小，堆的空间比较大。</li>
<li>是否产生碎片：堆由于malloc&#x2F;new，从而产生大量的碎片，使程序效率降低（虽然程序结束后操作系统会对内存进行回收管理），对于栈来讲，内存连续分配，则不存在这个问题。</li>
<li>增长方向不同：栈向下（低地址）增长，堆向上（高地址）增长。</li>
<li>分配效率不同：栈是极其系统提供的数据结构，计算机会在底层对栈提供支持，分配专门的寄存器存放栈的地址，压栈出zhan都有专门的指令执行。堆则是C函数库提供的，它的机制很复杂，例如为了分配一块内存，库函数会按照一定的算法，在堆内存中搜索可用的，足够大的空间，如果没有（可能是由于内存碎片太多），就有需要操作系统来重新整理内存空间，这样就有机会分到足够大的内存，然后返回。显然，堆的效率比栈要低得多。</li>
<li>分配方式不同：堆都是程序中由malloc()函数动态申请分配并由free()函数释放的，栈的分配和释放是由编译器完成的，栈的动态分配由alloca()函数完成，但是栈的动态分配是和堆不同的，它的动态分配是由编译器完成申请和释放的，无需手工实现。</li>
</ol>
<h3 id="6-3-常见内存错误及对策"><a href="#6-3-常见内存错误及对策" class="headerlink" title="6. 3 常见内存错误及对策"></a>6. 3 常见内存错误及对策</h3><ol>
<li>指针没有指向一块合法的内存（野指针）：例如声明了一个指针但没有初始化就使用这个指针。</li>
<li>为指针分配的内存太小：例如为字符串str，malloc内存时，大小为strlen(str)+1，如果没有+1，malloc的大小就不够。</li>
<li>内存分配成功但未初始化：对于未初始化的指针，其值是未定义的。可以使用memset初始化。</li>
<li>内存越界：段错误。</li>
<li>内存泄露：没有释放掉分配的内存。</li>
<li>内存释放之后：虽然内存释放了，但是指针仍然指向该内存，所以要将指针置为空吗，否则就会变为野指针。free(p)释放的是p指向的内存，而不是p本身。</li>
<li>内存已经释放，但是继续通过指针来使用：分为堆释放（使用已经free掉内存的指针），栈释放（返回一个局部变量的地址）。</li>
</ol>
<h2 id="7-可变参数"><a href="#7-可变参数" class="headerlink" title="7. 可变参数"></a>7. 可变参数</h2><h3 id="7-1-带可变参数的函数由来"><a href="#7-1-带可变参数的函数由来" class="headerlink" title="7.1 带可变参数的函数由来"></a>7.1 带可变参数的函数由来</h3><p>当<strong>函数中的参数个数不确定</strong>时，这时候就需要带可变参数的函数！<br>如我们经常使用的C库函数printf()实际就是一个可变参数的函数，<br><strong>其原型为：</strong></p>
<p>int printf( const char* format, …);</p>
<p>它除了有一个参数format固定以外,后面跟的参数的个数和类型是可变的。例如我们可以有以下不同的调用方法：</p>
<p>printf( “%d “,i); printf( “%s “,s); printf( “the number is %d ,string is:%s “, i, s);</p>
<h3 id="7-2-带可变参数函数的实现"><a href="#7-2-带可变参数函数的实现" class="headerlink" title="7.2 带可变参数函数的实现"></a>7.2 带可变参数函数的实现</h3><h4 id="7-2-1-原理"><a href="#7-2-1-原理" class="headerlink" title="7.2.1 原理"></a>7.2.1 原理</h4><ul>
<li>使用了<strong>指针参数</strong>来解决参数的可变问题，指针参数随着其移动指向不同的参数；</li>
<li>C语言的函数形参是从右向左压入堆栈的，以保证栈顶是第一个参数。</li>
</ul>
<p>C语言标准库中头文件stdarg.h索引的接口包含了一组能够遍历变长参数列表的宏。<br>头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br></pre></td></tr></table></figure>



<h4 id="7-2-2-几个宏"><a href="#7-2-2-几个宏" class="headerlink" title="7.2.2 几个宏"></a>7.2.2 几个宏</h4><p>(1). <strong>va_list</strong> 定义一个指针<br>用来<strong>定义</strong>一个<strong>表示参数表中各个参数</strong>的<strong>变量</strong>，即定义了一个指向参数的指针， 用于指示可选的参数.<br>如：<strong>va_list ap</strong>;<br>(2). <strong>va_start(ap,v)</strong> 初始化指针<br>使参数列表指针<strong>ap</strong>指向函数参数列表中的第一个<strong>可选参数</strong>，<strong>v</strong>是位于第一个可选参数之前的<strong>固定参数</strong>, 或者说最后一个固定参数.通常用于指定可变参数列表中参数的个数！<br>如有一va函数的声明是void va_test(char a, char b, char c, …), 则它的固定参数依次是a,b,c, 最后一个固定参数v为c, 因此就是va_start(<strong>ap</strong>, c).</p>
<p>(3). va_arg(<strong>ap</strong>, type) 返回参数列表中指针<strong>ap</strong>所指的参数, 返回类型为type. <strong>并使指针ap指向参数列表中下一个参数</strong>.返回的是可选参数, 不包括固定参数.</p>
<p>(4). va_end(<strong>ap</strong>) 清空参数列表, 并置参数指针arg_ptr无效.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">simple_va_fun</span><span class="params">(<span class="type">int</span> i,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	va_list arg_ptr; <span class="comment">//定义可变参数指针</span></span><br><span class="line">	<span class="built_in">va_start</span>(arg_ptr,i); <span class="comment">// i为最后一个固定参数</span></span><br><span class="line">	<span class="type">int</span> j = <span class="built_in">va_arg</span>(arg_ptr,<span class="type">int</span>); <span class="comment">//返回第一个可变参数，类型为int</span></span><br><span class="line">	<span class="type">char</span> c = <span class="built_in">va_arg</span>(arg_ptr,<span class="type">char</span>); <span class="comment">//返回第二个可变参数，类型为char</span></span><br><span class="line">	<span class="built_in">va_end</span>(arg_ptr); <span class="comment">// 清空参数指针</span></span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">&quot;%d %d %c\n&quot;</span>,i,j,c);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">simple_va_fun</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">simple_va_fun</span>(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">	<span class="built_in">simple_va_fun</span>(<span class="number">100</span>,<span class="number">200</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出为</span></span><br><span class="line"><span class="comment">100 4193388 ?100 200 ?100 200 a</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>




<h4 id="7-2-3-思路"><a href="#7-2-3-思路" class="headerlink" title="7.2.3 思路"></a>7.2.3 思路</h4><p>（1）首先在函数里定义一个va_list型的变量,这里是arg_ptr,这个变量是指向参数的指针.</p>
<p>（2）然后用va_start宏初始化变量arg_ptr,这个宏的第二个参数是第一个可变参数的前一个参数,是一个固定的参数.<br>（3）然后用va_arg返回第一个可变的参数,并赋值给整数j。va_arg的第二个参数是你要返回的参数的类型,这里是int型. 返回第一个可变参数后arg_ptr指向第二个可变参数，用同样的方法返回并赋值给c，类型为char类型。<br>（4）最后用va_end宏结束可变参数的获取。<br><strong>小结：</strong><br>可变参数的函数原理其实很简单,而va系列是以宏定义来定义的,实现跟堆栈相关.我们写一个可变函数的C函数时,有利也有弊,所以在不必要的场合,我们无需用到可变参数.如果在C++里,我们应该利用C++的多态性来实现可变参数的功能,尽量避免用C语言的方式来实现。</p>
<h1 id="指针专题"><a href="#指针专题" class="headerlink" title="指针专题"></a>指针专题</h1><h2 id="1-指针简介"><a href="#1-指针简介" class="headerlink" title="1. 指针简介"></a>1. 指针简介</h2><h3 id="1-1-指针的声明"><a href="#1-1-指针的声明" class="headerlink" title="1.1 指针的声明"></a>1.1 指针的声明</h3><p>指针的标准写法：<code>type* p;</code>	<br>常见的不标准的写法：<code>type *p = &amp;a;</code></p>
<blockquote>
<p>在不标准的写法中，我们常常会把 解引用符号（*）与变量名联系在一起，这就导致了一些直观上的不舒服？。</p>
<p>例如代码：<code>int *p = &amp;a;</code> 我们会自觉的把等号左边分成两个部分，类型和变量名，如果把 <code>*</code> 和变量名连在一起，那么看上去就好像是把 <code>a</code> 的地址放到了<code>*p</code> 里面，而类型也变成了 <code>int</code> 而不是 <code>int*</code>。</p>
<p>但如果我们写成：<code>int* p = &amp;a;</code> 这样看起来就很舒服了，<code>a</code> 的地址存放在了指针变量 <code>p</code> 中，<code>p</code> 它就是一个变量，它存储的是 <code>a</code> 的地址，而 <code>*p</code> 表示解引用指针变量 <code>p</code> 里面的地址，得到该地址存放的值。</p>
</blockquote>
<p>所以说，推荐写成标准的形式，看起来更舒服！</p>
<h3 id="1-2-指针的常识"><a href="#1-2-指针的常识" class="headerlink" title="1.2 指针的常识"></a>1.2 指针的常识</h3><ol>
<li><strong>指针是不占用内存空间的</strong>，其本身是地址，地址怎么会占内存空间。<strong>指针变量才占用内存空间。</strong></li>
<li>当我们仅使用数组名时，返回的是<strong>数组首元素的地址</strong>。</li>
<li>函数用来指向或引用内存中的数据（变量或常量）。</li>
<li>指针是由地址的，指针的地址不等同于指针变量的地址。</li>
</ol>
<h3 id="1-3-指针的算术运算"><a href="#1-3-指针的算术运算" class="headerlink" title="1.3 指针的算术运算"></a>1.3 指针的算术运算</h3><p>指针变量+&#x2F;-1：这里的1是指针类型的长度，而不是数字 1  </p>
<p>Code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl; 	   <span class="comment">// -&gt; x</span></span><br><span class="line">cout &lt;&lt; (p + <span class="number">1</span>) &lt;&lt; endl;  <span class="comment">// -&gt; x + sizeof(int)</span></span><br></pre></td></tr></table></figure>



<h2 id="2-输出char类型的地址"><a href="#2-输出char类型的地址" class="headerlink" title="2. 输出char类型的地址"></a>2. 输出char类型的地址</h2><p>在C++中，如果cout一个字符数组的话，那么它会沿着这个地址，一直输出这个字符串，直到遇到’\0’,例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>*c = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">输出的结果是：hello</span><br></pre></td></tr></table></figure>

<p>如果我们自作聪明的想输出第一个字符的地址，例如这样输出：</p>
<p><code> cout &lt;&lt; &amp;c[0] &lt;&lt; endl;</code></p>
<p>不幸的是，这样输出的结果依旧不是我们需要的地址。实际上输出结果仍然是整个字符串。</p>
<p>但是，如果我们回归到C语言的话，例如用printf的话，如下：</p>
<p> <code>printf(&quot;%x\n&quot;, &amp;c[0]);</code></p>
<p>幸福的事情发生了，输出的结果是：</p>
<p><code> 46f020</code></p>
<p>的确是字符串的首地址，但是，如果我们要输出字符串的地址，难道就这一种方法吗？难道我们就不可以用我们C++上的cout达到我们的效果吗？</p>
<p><strong>原因：</strong><strong><em>c是靠%s, %x, %p来区分指针表达式&amp;a[0]的输出形式的；c++没有这个格式控制，只能按一种形式输出，对char</em>类型的指针值就理解为串输出，所以必须对这个指针表达式做类型转换处理。</strong></p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&amp;c:&quot;</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">输出的仍然不是字符变量c的地址，而是乱码。</span><br></pre></td></tr></table></figure>



<p>在C++中，字符串是以空终止符（’&#x2F;0’）结尾的字符数组，通过字符串中第一个字符的指针访问字符串。也就是说，字符串的值是字符串中第一个字符的（常量）地址。如下的面3种形式表示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str1  = <span class="string">&quot;string1&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;string2&quot;</span>;</span><br><span class="line"><span class="type">char</span> str3[] = &#123;<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;line 1:str1=&quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;line 2:str2=&quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;line 3:str3=&quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">line <span class="number">1</span>:str  = string1</span><br><span class="line">line <span class="number">2</span>:str2 = string2</span><br><span class="line">line <span class="number">3</span>:str3 = string3</span><br></pre></td></tr></table></figure>

<p>运行可知，这3行的输出就是保存的字符串的值，而并非我们认为的地址。那么，我们可以联系到前面&amp;c，其实这就是一个char *的变量，所以，输出的自然就应该是字符串的值。可是，&amp;c保存的字符串是没有终止符的，因此输出的也就是乱码了。</p>
<p>最近，在读到《C++程序设计教程》（第4版）第12章的时候，我才解决了这个疑惑。实际上，**C++标准库中I&#x2F;O类对输出操作符&lt;&lt;重载，在遇到字符型指针时会将其当做字符串名来处理，输出指针所指的字符串。既然这样，我们就别让他知道那是字符型指针，所以得进行类型转换，即：希望任何字符型的指针变量输出为地址的话，都要作一个转换，即强制char *转换成void *，**如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">&quot;static_cast&lt;void *&gt;(&amp;c)=&quot;</span>&lt;&lt;<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(&amp;c)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;static_cast&lt;void *&gt;(str)=&quot;</span>&lt;&lt;<span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(str)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>此时，可以看到输出的结果就是char类型变量和字符串变量的地址了。</p>
<h2 id="3-为什么指针要使用强类型"><a href="#3-为什么指针要使用强类型" class="headerlink" title="3. 为什么指针要使用强类型"></a>3. 为什么指针要使用强类型</h2><h3 id="3-1-强类型语言和弱类型语言"><a href="#3-1-强类型语言和弱类型语言" class="headerlink" title="3.1 强类型语言和弱类型语言"></a>3.1 强类型语言和弱类型语言</h3><p><strong>强类型语言是一种强制类型定义的语言，即一旦某一个变量被定义类型，如果不经强制转换，那么它永远就是该数据类型。而弱类型语言是一种弱类型定义的语言，某一个变量被定义类型，该变量可以根据环境变化自动进行转换，不需要经过现行强制转换。</strong></p>
<p>其中</p>
<p>强类型语言包括：Java、.net、Python、C++等语言。其中Python是动态语言，是强类型定义语言，是类型安全的语言，Java是静态语言，是强类型定义语言，也是；类型安全的语言；</p>
<p>弱类型语言包括：VB，PHP，JavaScript等语言。其中VBScript是动态语言，是一种类型不安全的原因。</p>
<p><strong>举个栗子吧：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var A=5;</span><br><span class="line">var B=&quot;5&quot;</span><br><span class="line">sumA=A+B;</span><br><span class="line">sumB=A-B;</span><br></pre></td></tr></table></figure>

<p><strong>sumA&#x3D;55,系统默认+字符连接符，将A转化为字符串类型；而sumB&#x3D;0；系统认为-是算数运算符，从而将B转化为int类型，所以sum为5-5&#x3D;0；</strong></p>
<p><em>上面就是一个弱类型语言的例子；</em></p>
<hr>
<p><em>那么强类型语言与弱类型语言有什么优缺点呢？</em></p>
<p><strong>强类型语言和弱类型原因其判断的根本是是否会隐形进行语言类型转变。强类型原因在速度上可能略逊于弱类型语言，但是强类型定义语带来的严谨性又避免了不必要的错误。</strong></p>
<p>上面提到了动态语言与静态语言，那就讲讲动态语言静态语言的区别：</p>
<p><strong>动态类型语言：动态性语言是指在运行期间才去做数据类型检查的语言，也就是说动态类型语言编程时，永远不用给任何变量指定数据类型，该语言会在第一次赋值给变量时，在内部将数据类型记录下来。Python和Ruby就是一种典型的动态类型语言，其他的各种脚本语言如VBScript也多少属于动态类型语言。</strong></p>
<p><strong>静态类型语言：静态类型语言与动态类则刚好相反，它的数据类型在编译期间检查，也就是说在写程序时要声明所有变量的数据类型，C&#x2F;C++是静态类型语言的典型代表，其他静态语言还有C#、Java等。</strong></p>
<p>对于动态语言与静态语言的区分，其根本在<strong>于判断是在运行期间去做数据类型还是在编译期间检查。</strong></p>
<h3 id="3-2-指针为什么要使用强类型"><a href="#3-2-指针为什么要使用强类型" class="headerlink" title="3.2 指针为什么要使用强类型"></a>3.2 指针为什么要使用强类型</h3><p>Q：指针保存的地址的类型都是一样的，为什么还要为指针指定类型呢？</p>
<p>A：我们使用指针不仅仅只是用到地址，还需要经常解引用(*)来获得指针所指向地址的值或者写数据，因此我们就需要知道两个信息：①我们需要获得多少字节的内容；②采用何种方式解析数据。例如：char占用1字节，int占用4字节，他们占用字节大小是不一样的，float也占用 4字节，但是float和int的解析方式是不一样的。</p>
<p>Eg：<strong>指针变量保存的地址是首地址</strong></p>
<h2 id="4-通用指针类型（void-）"><a href="#4-通用指针类型（void-）" class="headerlink" title="4. 通用指针类型（void *）"></a>4. 通用指针类型（void *）</h2><h2 id="5-指向指针的指针"><a href="#5-指向指针的指针" class="headerlink" title="5. 指向指针的指针"></a>5. 指向指针的指针</h2><p>理解多重指针的最好方法是<strong>画图</strong>。</p>
<p>如果我们让一个指针指向一片内存，那么就在指针和内存之间加上一个箭头，表示指针指向内存。假设有指针p指向内存s，那么*p就可以在图中表示为由p沿着指向s的指针到s，这样多重指针不过就是多走几次罢了。</p>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p= &amp;x;</span><br><span class="line"><span class="type">int</span>** q = &amp;p;</span><br><span class="line"><span class="type">int</span>*** r = &amp;q;</span><br></pre></td></tr></table></figure>

<p>对面上面的代码，表现在图形中就是：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/07/14/ec141bc6c035f827.png" alt="IMAGE"></p>
<h2 id="6-传值调用"><a href="#6-传值调用" class="headerlink" title="6. 传值调用"></a>6. 传值调用</h2><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Increamet</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">Increment</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，main中的a是实参，Increment中的x是形参，传值调用的过程就是实参映射到实参，也就是将实参的值拷贝到形参中。</p>
<h2 id="7-数组与指针"><a href="#7-数组与指针" class="headerlink" title="7. 数组与指针"></a>7. 数组与指针</h2><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">cout &lt;&lt; &amp;a[i] &lt;&lt; endl; 	<span class="comment">// &lt;==&gt; cout &lt;&lt; (a + i) &lt;&lt; endl;</span></span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; endl;	<span class="comment">// &lt;==&gt; cout &lt;&lt; *(a + i) &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = a;</span><br><span class="line">*p ++ ; <span class="comment">// valid</span></span><br><span class="line">a ++ ;	<span class="comment">// invalid</span></span><br></pre></td></tr></table></figure>

<p><strong>指针就是数组，数组就是指针</strong></p>
<p>数组的基地址就是数组首元素的地址，直接使用数组名就可以得到数组的基地址</p>
<h2 id="8-数组作为函数参数"><a href="#8-数组作为函数参数" class="headerlink" title="8. 数组作为函数参数"></a>8. 数组作为函数参数</h2><h3 id="8-1-例1"><a href="#8-1-例1" class="headerlink" title="8.1 例1"></a>8.1 例1</h3><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> t[])</span> <span class="comment">// &lt;==&gt; int getSum(int *t)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> Size = <span class="built_in">sizeof</span>(t) / <span class="built_in">sizeof</span>(t[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size-t : &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(t) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;getSum-size: &quot;</span> &lt;&lt; Size &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; Size; i ++ ) sum += t[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> Size = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size-a: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main-size: &quot;</span> &lt;&lt; Size &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">getSum</span>(a);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sum: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size-a: <span class="number">20</span></span><br><span class="line">main-size: <span class="number">5</span></span><br><span class="line">size-t : <span class="number">8</span></span><br><span class="line">getSum-size: <span class="number">2</span></span><br><span class="line">sum: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>Explaion：</p>
<blockquote>
<p>在上面的程序中，我们希望将数组 a 传递给函数 getSum 来求得数组 a 中所有元素的和（15）。</p>
<p>我们通过一个巧妙的方法得到数组 a 中元素的个数：sizeof(a) &#x2F; sizeof(a[0]);</p>
<p>sizeof(a) 是数组 a 所占用的字节数，同理如果有一个 int 类型变量 i，那么 sizeof(i) &#x3D; 4；sizeof(a[0]) 是数组 a 中一个元素占用的字节数。</p>
<p>在 main 函数中我们正确求得了 数组 a 的元素个数（5），数组 a 占用的字节数（20），然而当我们把数组 a 传递给函数 getSum 时，我们在函数内求得数组 a 的元素个数为 2，并且数组 a 占用的字节大小为 8，而不是 20 (5*sizeof(int))。</p>
<p>这是为什么呢？</p>
</blockquote>
<h3 id="8-2-例2"><a href="#8-2-例2" class="headerlink" title="8.2 例2"></a>8.2 例2</h3><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> t[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        t[i] = t[i] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before change: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">change</span>(a, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after change: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before change: 1 2 3 4 5 </span><br><span class="line">after change: 2 4 6 8 10 </span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>我们发现，将数组 a 传递给函数 change 之后，在 change 中执行的操作返回到了实参中。</p>
<p>这说明数组的传递是传引用而不是传值。</p>
</blockquote>
<h3 id="8-3-例3"><a href="#8-3-例3" class="headerlink" title="8.3 例3"></a>8.3 例3</h3><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out</span><span class="params">(<span class="type">int</span> t[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;t: &quot;</span> &lt;&lt; &amp;t &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*t: &quot;</span> &lt;&lt; *t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;a: &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*a: &quot;</span> &lt;&lt; *a &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">out</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;a: 0x7fff33a6e2d0</span><br><span class="line">a: 0x7fff33a6e2d0</span><br><span class="line">*a: 1</span><br><span class="line">&amp;t: 0x7fff33a6e2b8</span><br><span class="line">t: 0x7fff33a6e2d0</span><br><span class="line">*t: 1</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>我们发现，将数组 a 传递给函数 out 之后，数组 t 的首地址和数组 a 的首地址是一样的，但是在数组中，理应来说 &amp;t 和 t 的结果应该是一样的，例如在 main中 &amp;a 和 a 的结果就是一致的，但实际上打印出来的结果是不同的，这又是为什么呢？</p>
</blockquote>
<h3 id="8-4-例4"><a href="#8-4-例4" class="headerlink" title="8.4 例4"></a>8.4 例4</h3><p>Code：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void out(int *t)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;&amp;t: &quot; &lt;&lt; &amp;t &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;t: &quot; &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*t: &quot; &lt;&lt; *t &lt;&lt; endl;</span><br><span class="line">    for(int i = 0; i &lt; 5; i ++ )</span><br><span class="line">        printf(&quot;&amp;(t + %d)[%p] = %d\n&quot;, i, t + i, *(t + i));</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[5] = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">    cout &lt;&lt; &quot;&amp;a: &quot; &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;*a: &quot; &lt;&lt; *a &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    out(a);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&amp;a: 0x7fff9a681e00</span><br><span class="line">a: 0x7fff9a681e00</span><br><span class="line">*a: 1</span><br><span class="line">&amp;t: 0x7fff9a681dd8</span><br><span class="line">t: 0x7fff9a681e00</span><br><span class="line">*t: 1</span><br><span class="line">&amp;(t + 0)[0x7fff9a681e00] = 1</span><br><span class="line">&amp;(t + 1)[0x7fff9a681e04] = 2</span><br><span class="line">&amp;(t + 2)[0x7fff9a681e08] = 3</span><br><span class="line">&amp;(t + 3)[0x7fff9a681e0c] = 4</span><br><span class="line">&amp;(t + 4)[0x7fff9a681e10] = 5</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>我们发现，将数组 a 传递给函数 out，out 的形参是一个 int 型指针，依然可以遍历数组。</p>
</blockquote>
<h3 id="8-5-总结"><a href="#8-5-总结" class="headerlink" title="8.5 总结"></a>8.5 总结</h3><ol>
<li>由例4和例2可得出： **type function(int a[]) &lt;&#x3D;&#x3D;&gt; type function(int *a)<strong>，当我们把一个数组作为参数传递给函数时，并不会传递整个数组的内容，而是仅仅传递数组的首地址。同时这也印证了那句话：</strong>数组就是指针，指针就是数组**</li>
<li>由结论1，对于数组来说，不使用传值方式，总是<strong>传引用</strong>。因为有时候数组可能很大，拷贝整个数组没有太大意义，它会耗费大量内存。</li>
<li>由结论2，我们便可以知道为什么例3中，在函数 out 中打印 &amp;t 和 t是不一样结果了，因为编译器把 int t[] 转换成了 int *t，因此 t 本质上不是一个数组，而是一个指向数组的指针。所以在栈中，只会申请 8 字节（64位机器一个指针占用的内存空间）空间，用来存放这个指针 t，所以说&amp;t 实际上打印的是在栈中 t 的地址，而 t 则打印的是指针变量 t 的内容，也就是它指向的地址（即数组 a 的地址）。</li>
<li>由2和3，也就解释了例1 中为什么在函数 getSum中，sizeof(t) &#x3D; 8，因为我们传递过去的不是一个完整的数组，而是指向这个数组的指针。</li>
</ol>
<h2 id="9-指针和字符数组"><a href="#9-指针和字符数组" class="headerlink" title="9. 指针和字符数组"></a>9. 指针和字符数组</h2><p>——当我们在 C 语言中谈论字符数组时，基本上就是在讨论字符串</p>
<h3 id="9-1如何把字符串存入字符数组"><a href="#9-1如何把字符串存入字符数组" class="headerlink" title="9.1如何把字符串存入字符数组"></a>9.1如何把字符串存入字符数组</h3><p>——首要的需求就是字符数组必须足够大，大到能够容纳字符串</p>
<p>一个足够大的字符数组是指它的大小&gt;&#x3D;字符的数量 +1，因为在字符串中必须指明结束标志（\0），但整型和浮点型数组没有结束符， 完全要自己严格控制元素的数量。</p>
<h3 id="9-2-字符数组的声明"><a href="#9-2-字符数组的声明" class="headerlink" title="9.2 字符数组的声明"></a>9.2 字符数组的声明</h3><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;john&quot;</span>; <span class="comment">// 用双引号给字符数组复制，编译器会自动给字符串添加结束标志&#x27;\0&#x27;，因为字符数组的长度就是字符串长度+1（\0）</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl; <span class="comment">// 5，  包含&#x27;\0&#x27;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(s) &lt;&lt; endl; <span class="comment">// 4，不包含 &#x27;\0&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> a[] = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>&#125;; <span class="comment">// 需要手动添加结束标志，这里因为没有添加 &#x27;\0&#x27;，strlen(a)出错</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; 	<span class="comment">// 4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(a) &lt;&lt; endl;  <span class="comment">// 8，出错</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> b[] = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; 	<span class="comment">// 手动添加&#x27;\0&#x27;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; endl;  <span class="comment">// 3</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(b) &lt;&lt; endl;	<span class="comment">// 2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tips：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;john&quot;</span>;</span><br><span class="line"><span class="comment">// 不可以写为下面的形式：</span></span><br><span class="line"><span class="type">char</span> s[<span class="number">107</span>];</span><br><span class="line">s = <span class="string">&quot;john&quot;</span>;</span><br><span class="line"><span class="comment">// 用双引号初始化必须在同一行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其次，下面的声明方式是不严谨的，因为我们不知道字符串的结束在那</span></span><br><span class="line"><span class="comment">// 因此，可能发生奇怪的问题</span></span><br><span class="line"><span class="type">char</span> a[] = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如下面：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a[] = &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *s = a;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="number">1234</span>t��M�</span><br><span class="line"><span class="number">1234</span>t��M�</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 可以发现出现了乱码    </span></span><br></pre></td></tr></table></figure>



<h3 id="9-3-char"><a href="#9-3-char" class="headerlink" title="9.3  char *"></a>9.3  char *</h3><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>上面的代码会报错，因此把  “Hello” 的值—-也就是<strong>字符串常量字面值</strong>，也就是 “Hello” 的地址，准确来说是起始地址—-赋给字符指针 str，Linux下 “Hello”字符串常量是存放于<strong>只读数据区</strong>（常量区）的，不可以修改。</p>
<p>因此如果我们要把 char* 传递到函数中，那么形参的类型最好是 const char*</p>
<p>对于 <code>char s[] = &quot;Hello&quot;; </code></p>
<p>s[] 是一个字符数组，编译器首先在栈中分配一定的连续空间用于存放 “Hello” 中的字符以及结尾符，然后把字符串常量的内容，也就是<br>“Hello” 中的各个字符和结尾符复制到这个<strong>栈</strong>中的连续空间中。str是数组名，用来表示这个连续栈空间的起始地址，所以str中存放的是栈地址，这个地址的数据是可写的。</p>
<p><strong>在 Linux 中，堆，全局数据，常量等都是存放于从 0x8048000 开始的内存地址，向上增长。一般来说，32位机器上，在Linux中，栈地址空间从3G（0xbfffffff）开始向下增长。</strong></p>
</blockquote>
<p>Tips：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *s = ch;</span><br><span class="line">    s ++ ;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;	<span class="comment">//ello</span></span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;	<span class="comment">// Xllo</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>char*s = ch;</code>中的 ch 不是字符串常量，因此 s 可以修改。</p>
<h2 id="10-指针和二维数组"><a href="#10-指针和二维数组" class="headerlink" title="10. 指针和二维数组"></a>10. 指针和二维数组</h2><p>多维数组本质上是<strong>数组的数组</strong>，由于一个指针可以表示一个数组，因此可以把二维数组看做一维指针数组。</p>
<p><strong>数组</strong>可以看做是同类事物的集合，<strong>多维数组</strong>基本上可以理解为数组的集合。</p>
<p>例如二维数组<code>A[3][2]</code>，如下图所示：</p>
<p><img src="https://s1.328888.xyz/2022/07/14/LtB4I.png"></p>
<blockquote>
<p>对 A 解引用就可以得到 A[0], A[1], A[2]</p>
<p>对 A[i] 解引用就可以得到 A[i][0], A[i][1]</p>
<p>对 A[i][j] 解引用就可以得到具体的值</p>
<p><strong>注意别把指针数组和二维指针搞混了，根本不是一回事！</strong></p>
</blockquote>
<h3 id="10-1-二维数组在内存中的存放方式"><a href="#10-1-二维数组在内存中的存放方式" class="headerlink" title="10.1 二维数组在内存中的存放方式"></a>10.1 二维数组在内存中的存放方式</h3><p>假设我们生成了一个数组 <code>A[3][2]</code></p>
<p><img src="https://i.bmp.ovh/imgs/2022/07/14/2e64b6aa12631e70.png" alt="IMAGE"></p>
<p>此时如果我们定义一个指针 <code>int *p = &amp;A;</code> 会编译错误，因为这里的 int 类型指针 p 指向了一个一维数组，这与指针的类型不匹配。</p>
<h3 id="10-2-二维数组的运算"><a href="#10-2-二维数组的运算" class="headerlink" title="10.2 二维数组的运算"></a>10.2 二维数组的运算</h3><p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;二维数组b的首地址: &quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> (*p)[<span class="number">3</span>] = b; <span class="comment">// 一维指针数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// b是二维数组b[][]的数组名,它的地址就是首地址b[0]</span></span><br><span class="line">    cout &lt;&lt; b     &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b[<span class="number">0</span>] &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; b + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// b &lt;==&gt; &amp;b，b[i] &lt;==&gt; &amp;b[i]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对b直接解引用得到的是b[0]，b[0]是一维数组b[0]的数组名，因此b[0]的地址就是首地址b[0][0]</span></span><br><span class="line">    cout &lt;&lt; *b       &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; &amp;b[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; endl; <span class="comment">// *b = *(b + 0)</span></span><br><span class="line">    cout &lt;&lt; *(b + <span class="number">1</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; &amp;b[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    cout &lt;&lt; *(b + <span class="number">1</span>) + <span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b[<span class="number">1</span>] + <span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; &amp;b[<span class="number">1</span>][<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    cout &lt;&lt; *(*b + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">二维数组b的首地址: 0x7fff0e673980</span><br><span class="line">0x7fff0e673980 0x7fff0e673980</span><br><span class="line">0x7fff0e67398c 0x7fff0e67398c</span><br><span class="line">0x7fff0e673980 0x7fff0e673980 0x7fff0e673980</span><br><span class="line">0x7fff0e67398c 0x7fff0e67398c 0x7fff0e67398c</span><br><span class="line">0x7fff0e673994 0x7fff0e673994 0x7fff0e673994</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>Tips：</p>
<blockquote>
<p>在二维数组中，有以下两条等式</p>
<p><strong>取地址：</strong><code>&amp;b[i][j] &lt;=&gt; b[i] + j &lt;=&gt; *(b + i) + j</code></p>
<p><strong>取值：</strong>    <code>b[i][j] &lt;==&gt; *(b[i] + j ) &lt;==&gt; *(*(b + i) + j)</code></p>
</blockquote>
<h2 id="11-指针和多维数组"><a href="#11-指针和多维数组" class="headerlink" title="11. 指针和多维数组"></a>11. 指针和多维数组</h2><h3 id="11-1-指针和三维数组"><a href="#11-1-指针和三维数组" class="headerlink" title="11.1 指针和三维数组"></a>11.1 指针和三维数组</h3><p>Code：</p>
<p>要注意解引用运算符(*)的优先级</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">int</span> (*p)[<span class="number">2</span>][<span class="number">2</span>] = c;</span><br><span class="line">    <span class="comment">//int *p[2][2] = c; // Wrong!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tips：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c[i][j][k] </span><br><span class="line">	= *(c[i][j] + k) </span><br><span class="line">	= *(*(c[i] + j) + k) </span><br><span class="line">	= *(*(*(c + i) + j) + k)</span><br></pre></td></tr></table></figure>

<p>对于上面的转换，只需要牢记指针和数组之间的转换就可以了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c[i] = *(c + i);</span><br><span class="line">&amp;c[i] = c + i;</span><br></pre></td></tr></table></figure>



<h3 id="11-2-多维数组作为参数传递给函数"><a href="#11-2-多维数组作为参数传递给函数" class="headerlink" title="11.2 多维数组作为参数传递给函数"></a>11.2 多维数组作为参数传递给函数</h3><p>我们在第 8 章中已经知道，将数组作为参数传递给函数时，实际上不会拷贝整个数组，只会以指针的形式传它的引用。例如：</p>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a[])</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fundc</span><span class="params">(<span class="type">int</span> *a)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子是一维数组的情况，那么如果传递的是多维数组呢？</p>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> d[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> a[][])</span>  </span>&#123; 	<span class="comment">// test 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> *a)</span>     </span>&#123; 	<span class="comment">// test 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> a[][<span class="number">3</span>])</span> </span>&#123; 	<span class="comment">// test 3  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">(<span class="type">int</span> *a[<span class="number">3</span>])</span>  </span>&#123; 	<span class="comment">// test 4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func5</span><span class="params">(<span class="type">int</span> **a)</span>    </span>&#123;	<span class="comment">// test 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>在第一种形式中，编译器会报错，因为我们执行了一个二维数组作为形参，形式上虽然是 <code>a[][]</code>，但编译器会将其转化为  <code>(*a)[]</code>, 也就是说，我们指定了一个指针数组作为参数，但我们没有指定这个指针数组的大小，因此编译器报错。 </p>
<p>在第二种形式中，编译时不会报错，但如果我们将数组 <code>c</code> 作为参数执行 <code>func()</code> 函数，编译器会报错，因为 <code>c[][]</code> 的类型为 <code>(int *)[]</code>，而参数的类型为 <code>int *</code>，显然类型不匹配。</p>
<p>第三种形式和第四种形式都是正确的，因为我们指定了指针数组的大小。</p>
<p>将数组 <code>c</code> 传递给 <code>func3()</code> 和 <code>func4()</code> 是正确的，但如果传入数组 <code>d</code>  就会报错，因为数组的第二维不匹配。</p>
</blockquote>
<p>Tips：</p>
<blockquote>
<p>也就是说，在我们将数组作为参数传递给函数时，数组的第一维是可以省略的，但是剩下的维必须指定大小。</p>
<p>另外，一个常见的误区是：对于二维数组，我们传入一个指针的指针，对于三维数组，传递一个指针的指针的指针，这是不对的。</p>
</blockquote>
<h2 id="12-指针和内存管理"><a href="#12-指针和内存管理" class="headerlink" title="12. 指针和内存管理"></a>12. 指针和内存管理</h2><h3 id="12-1-内存架构"><a href="#12-1-内存架构" class="headerlink" title="12.1 内存架构"></a>12.1 内存架构</h3><p>在一个典型的架构中，分配给应用程序的内存可以分为四个区段：</p>
<ol>
<li>Test(Code)：用来存放需要执行的<strong>指令</strong></li>
<li>Static&#x2F;Global：用来存放<strong>静态变量</strong>或<strong>全局变量</strong>，也就是不在函数中声明的变量，它们的声明周期贯穿整个程序周期</li>
<li>Stack：用来存放<strong>函数调用的所有信息</strong>和<strong>所有局部变量</strong>，局部变量在函数内部声明</li>
<li>Heap：用来存放<strong>动态分配</strong>的变量</li>
</ol>
<p>Tips:</p>
<ol>
<li><strong>代码段，静态&#x2F;全局数据段，栈区在运行期间的大小是不会增长的。</strong></li>
<li>一个函数的帧栈大小，是在编译期间就决定了的。</li>
<li>程序在任何时间，都是栈顶的函数在执行。</li>
</ol>
<h3 id="12-2-堆的引入"><a href="#12-2-堆的引入" class="headerlink" title="12.2 堆的引入"></a>12.2 堆的引入</h3><p>内存在栈上的分配和销毁有一定的规则，当一个函数被调用的时候，它被压入堆栈，结束时，弹出堆栈。如果变量是在栈上分配的，那你就不能操纵变量的范围。</p>
<p>另外一个限制，如果我们需要声明一个很大的数据类型，或者一个很大的数组作为局部变量，我们需要在编译期间知道数组的大小。如果我们有这样一个场景：需要在运行期间根据参数决定数组的大小，那么使用栈就会有问题了。</p>
<p>针对这些问题，比如分配很大的内存，或者把变量预留在内存中直到我们想用的时候为止，我们就有了堆。</p>
<h3 id="12-3-堆简介和引应用"><a href="#12-3-堆简介和引应用" class="headerlink" title="12.3 堆简介和引应用"></a>12.3 堆简介和引应用</h3><p>不像栈，应用程序的堆的大小是<strong>不固定</strong>的，它的大小在应用程序的整个声明周期是可变的，也没有特定的规则来分配和销毁特定的内存，程序员可以完全控制在堆上分配多少存在，数据保留到什么时候，你几乎可以任意使用堆上的内存，只要不超出系统自身的内存限制，但有时候随意使用堆也是危险的（内存泄露）</p>
<p>有时候我们把堆称为<strong>内存的空闲池</strong>，或者内存空闲存取区，我们可以在堆中获得我们想要的内存，尽管不同的操作系统对分配堆的方式不同，但可以把堆抽象看做一块很大的自由使用的内存空间</p>
<p>注意不要把这里的堆和数据结构中的堆混淆了，它们是完全不同的概念，这里的堆表示的只是空闲的内存池。另外栈区是栈的一种实现，而堆不是的。</p>
<p>使用堆内存意味着<strong>动态内存分配</strong>，在 C 或者 C++ 中使用堆的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C：</span><br><span class="line">    malloc();</span><br><span class="line">    calloc();</span><br><span class="line">    realloc();</span><br><span class="line">    free();</span><br><span class="line">C ++ :</span><br><span class="line">	new;</span><br><span class="line">    delete();</span><br><span class="line">    C ++ 也可以使用 C 的四个函数，因为 C ++ 向后兼容 C</span><br></pre></td></tr></table></figure>

<p>malloc会返回一个指向这块内存起始地址的**(void *)指针<strong>，因此需要做类型转换，但是在 C ++ 里面则不需要，因此new 和 delete 操作符是</strong>类型安全**的，这意味着，他们是带着类型的，返回指向特定类型的指针。</p>
<p>事实上<strong>使用堆的唯一方式就是通过引用。</strong>malloc函数所做的事情仅仅是，从堆上找到空闲的内存，为你预留空间然后通过指针返回给你，你去访问这块内存的方式就是自己维护一个指针。</p>
<p>分配在堆上的内存在函数调用结束之后并不会像栈上那样自动释放，因此，对于分配的内存，要注意回收（free） ，否则可能导致内存泄露</p>
<p>Code：C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a; <span class="comment">// goes on stack</span></span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">20</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Code：C++</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;              <span class="comment">// 分配在栈上</span></span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    *p = <span class="number">10</span>;            </span><br><span class="line">    <span class="keyword">delete</span> p;           <span class="comment">// 释放空间</span></span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">20</span>];    <span class="comment">// 分配一个数组</span></span><br><span class="line">    <span class="keyword">delete</span>[] p;         <span class="comment">// 释放空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-4-库函数"><a href="#12-4-库函数" class="headerlink" title="12.4 库函数"></a>12.4 库函数</h3><p>介绍 C 语言支持中支持动态内存分配的各种库函数。</p>
<h4 id="12-4-1-malloc"><a href="#12-4-1-malloc" class="headerlink" title="12.4.1 malloc()"></a>12.4.1 malloc()</h4><p>malloc 的全称是 <strong>memory allocation</strong>，中文叫<strong>动态内存分配</strong>，用于申请一块连续的指定大小的内存块区域以 void* 类型返回分配的内存区域地址，当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态的分配内存，且分配的大小就是程序要求的大小。 </p>
<p>如果分配成功则返回指向被分配内存的指针**(此空间中的初始值不确定)**，否则返回空指针 NULL。当内存不再使用时，应使用 free() 函数将内存块释放。</p>
<p>原型为：<em><em>void</em> malloc(size_t size);</em>*</p>
<blockquote>
<p>可以把 size_t看做 unsigned_int（&gt;&#x3D;0），显然我们不能指定一个负数。</p>
<p>malloc 返回一个 void* 指针，这个指针指向分配给我们的内存块的第一个地址。</p>
<p>size &#x3D; 单元的数量 * 每个单元的字节数</p>
</blockquote>
<p>例如：如果我们希望分配一个单元的 int 类型的空间</p>
<blockquote>
<figure class="highlight plaintext"><figcaption><span>*p </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们最好写成这样的形式：```void *p = malloc(sizeof(int));```</span><br><span class="line"></span><br><span class="line">我们不可以解引用一个 void 指针，因此为了能够使用这块内存，我们需要把 malloc 返回的指针转成一个特定类型的指针。</span><br><span class="line"></span><br><span class="line">malloc 之所以返回一个 void 指针是因为可以确保它的通用性，它做的仅仅只是分配内存，而不关心这块内存你是拿来存整形还是字符还是浮点数。</span><br><span class="line"></span><br><span class="line">Code：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int *p = (int *)malloc(3 * sizeof(int));</span><br><span class="line">   // 通过指针操纵</span><br><span class="line">   *p = 1;</span><br><span class="line">   *(p + 1) = 2;</span><br><span class="line">   *(p + 2) = 3;</span><br><span class="line">   </span><br><span class="line">   // 因为我们分配的是一个int数组，因此我们可以直接通过数组的方式操纵</span><br><span class="line">   p[0] = 4;</span><br><span class="line">   p[1] = 5;</span><br><span class="line">   p[2] = 6;</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="12-4-2-calloc"><a href="#12-4-2-calloc" class="headerlink" title="12.4.2 calloc()"></a>12.4.2 calloc()</h4><p>使用 malloc 初始化时不会进行初始化，因此如果没有填入值得话，会得到一些随机值。但是使用 calloc 的话，会对其进行初始化为 0，如果分配成功则返回指向被分配内存的指针(**此空间中的初始值为 0 **)，否则返回空指针 NULL，</p>
<p>calloc 的全称是 <strong>clear allocation</strong>，中文名为<strong>动态内存分配并清零</strong></p>
<p>函数原型为：*<em>void <em>calloc(unsigned int num，unsigned int size);</em></em></p>
<blockquote>
<p>num 表示分配的单元数量，size表示单元大小</p>
</blockquote>
<h4 id="12-4-3-realloc"><a href="#12-4-3-realloc" class="headerlink" title="12.4.3 realloc()"></a>12.4.3 realloc()</h4><p>如果你有一块内存，动态分配的内存，然后你想修改内存块的大小，就可以使用 realloc，realloc 的全称是 <strong>reset allocation</strong>，中文名为<strong>动态内存调整</strong>。</p>
<p>函数原型为：<em><em>extern void * realloc(void</em> mem_address, unsigned int newsize);</em>*</p>
<blockquote>
<p>mem_address 指向已分配内存的起始地址的指针，如果 mem_address &#x3D; NULL , 那么此时就相当于 malloc</p>
<p>newsize 为新内存块的大小</p>
<p>先判断当前的指针是否有足够的连续空间，如果有，扩大 mem_address 指向的地址，并且将 mem_address 返回，如果空间不够，先按照 newsize 指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来 mem_address 所指内存区域(<strong>原来的指针会自动释放，不需要再使用 free</strong>)，同时返回新分配的内存区域的首地址。重新分配成功返回指向被分配内存的指针，否则返回空指针 NULL。</p>
<p>注意：调整后的大小可大可小(如果新的大小大于原内存大小，新分配部分不会被初始化；如果新的大小小于原内存大小，可能会导致数据丢失）。</p>
</blockquote>
<h4 id="12-4-4-free"><a href="#12-4-4-free" class="headerlink" title="12.4.4 free()"></a>12.4.4 free()</h4><p>函数原型为：*<em>void free(void <em>ptr);</em></em></p>
<p>一般使用 malloc, calloc, realloc 函数进行内存分配后要使用 free(<strong>起始地址的指针</strong>) 对内存进行释放，不然内存申请过多会影响计算机的性能，以至于重启电脑。但是若使用动态内存分配函数后未使用 free 函数进行释放，还可以使用指针对该块内存进行访问，如果释放则不能再访问。</p>
<p><strong>注意：使用后该指针变量一定要重新指向 NULL，防止野指针出现，有效规避错误操作。</strong></p>
<h4 id="12-4-5-示例"><a href="#12-4-5-示例" class="headerlink" title="12.4.5 示例"></a>12.4.5 示例</h4><p>上面函数的使用需要引入头文件 <code>#include &lt;stdlib.h&gt;</code></p>
<p>Code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入数组的大小: &quot;</span> &lt;&lt; endl;   </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编译错误,不能在运行时定义数组</span></span><br><span class="line">    <span class="comment">//int A[n]; </span></span><br><span class="line">    <span class="comment">//正确方法</span></span><br><span class="line">    <span class="type">int</span>* A = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mallo分配的数组: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    cout &lt;&lt; A[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> *B = (<span class="type">int</span>*)<span class="built_in">calloc</span>(n, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;callo分配的数组: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    cout &lt;&lt; B[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Input &amp;&amp; Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请输入数组的大小: </span><br><span class="line">25</span><br><span class="line">mallo分配的数组: </span><br><span class="line">39855248 0 7365248 0 0 0 0 0 0 0 -1694498661 43847 39855248 0 7340368 0 0 -1 -1728053095 43846 39855248 0 7340368 0 0</span><br><span class="line">callo分配的数组:</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>在上面的代码中，我们实现了在程序运行过程当中分配一个数组，并且可以验证，malloc 不会进行初始化，因此我们得到一堆随机数，而 calloc 会进行0初始化，因此数组元素全为 0</p>
</blockquote>
<hr>
<p>Code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入数组的大小: &quot;</span> &lt;&lt; endl;   </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span>* A = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    A[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    cout &lt;&lt; A[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(A);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    cout &lt;&lt; A[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// free之后再次修改内存中的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    A[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    cout &lt;&lt; A[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Input &amp;&amp; Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请输入数组的大小: </span><br><span class="line">5</span><br><span class="line">1 2 3 4 5 </span><br><span class="line">16279024 0 16253264 0 5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>



<p>Expalin：</p>
<blockquote>
<p>可以发现，在释放掉动态分配的内存之后，仍然可以访问该内存，并打印出一些随机值(完全取决于编译器和机器)，甚至可以再次修改内存中的值并正常执行，但在其他的机器上这个程序可能会崩溃（可能另一个指针指向这块内存，而你修改了它）。</p>
<p>所以说 free 并不是真的 “销毁” 了一块内存，它只是说实现这个内存不属于你这个指针了。</p>
<p>这是使用指针的时候一个危险的地方。</p>
</blockquote>
<hr>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入数组的大小: &quot;</span> &lt;&lt; endl;   </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span>* A = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入数组改编后的大小:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> *B = (<span class="type">int</span> *)<span class="built_in">realloc</span>(A, n * <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 包含 free(A)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) B[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    cout &lt;&lt; B[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Input &amp;&amp; Output：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请输入数组的大小: </span><br><span class="line">5</span><br><span class="line">请输入数组改编后的大小:</span><br><span class="line">10</span><br><span class="line">1 2 3 4 5 6 7 8 9 10 </span><br></pre></td></tr></table></figure>



<h3 id="12-5-内存泄露"><a href="#12-5-内存泄露" class="headerlink" title="12.5 内存泄露"></a>12.5 内存泄露</h3><p>**所谓内存泄露，是指不当地使用动态内存或者内存的堆区，也就是在堆长增加”垃圾”**。其他语言诸如 Java 和 C# ，堆上的垃圾会被自动回收（垃圾回收机制）。</p>
<p>内存泄漏总是因为堆中未使用和未引用的内存块才发生的。</p>
<p>栈上的内存是自动回收的，栈的大小是固定的，会多就是会发生栈溢出。</p>
<p>常见的错误：在函数内部 malloc 一块内存，但是在函数结束时没有释放，如果这个函数执行非常多次，就造成内存泄漏。不要误以为在函数中 malloc 的内存会在函数结束时自动释放，函数结束时只会自动释放栈中的内存，而 malloc 是在堆上分配的内存，所以函数结束时不会释放。</p>
<h2 id="13-函数返回指针"><a href="#13-函数返回指针" class="headerlink" title="13. 函数返回指针"></a>13. 函数返回指针</h2><p><strong>重点：什么时候可以从函数返回一个指针</strong></p>
<blockquote>
<p>如果我们在堆上有一个内存地址或者在全局区有一个变量，那么我们就可以安全的返回他们的地址</p>
</blockquote>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int* Add1(int *a, int *b)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     int c = (*a) + (*b);</span></span><br><span class="line"><span class="comment">//     return &amp;c;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">Add</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *c = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *c = *a + *b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span>* c = <span class="built_in">Add</span>(&amp;a, &amp;b);</span><br><span class="line">    <span class="comment">//int *c = Add1(&amp;a, &amp;b); 报错</span></span><br><span class="line">    cout &lt;&lt; (*c) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>在上面的代码中，Add1函数并不是一个正确的函数返回指针的例子，因为它返回的是一个 《被调用的函数的中的局部变量的地址》，我们知道，一个函数的栈帧会随着函数的结束而被释放，所以当 Add1 函数结束的时候，局部变量 c 的地址就被释放了，所以说返回 c 的地址是错误的。</p>
<p>因此，<strong>从函数返回地址时，我们需要小心它们的作用范围</strong><br>从栈底向上传一个局部变量或者局部变量的地址是可以的。<br>但是，从栈顶想下传一个局部变量或者局部变量的地址是不可以的。</p>
<p>因为被调函数的地址在主调函数的上面，当被调函数执行时，主调函数一定还没结束，而主调函数在执行时，被调函数分配的内存空间也一定被释放掉了。</p>
<p>正确的做法是返回全局变量取的地址或者堆区的地址，因为那里的地址不会被自动释放。</p>
</blockquote>
<h2 id="14-函数指针"><a href="#14-函数指针" class="headerlink" title="14. 函数指针"></a>14. 函数指针</h2><h3 id="14-1-简介"><a href="#14-1-简介" class="headerlink" title="14.1 简介"></a>14.1 简介</h3><p>根据定义可以知道，函数指针是用来保存函数的地址的指针。</p>
<p>那么问题来了，<strong>函数的地址是什么？</strong></p>
<blockquote>
<p>在内存中，一个函数就是一块连续的内存（里面是指令）</p>
<p><strong>函数的地址，我们也把它称为函数的入口点，它是函数的第一条指令的地址（最低地址）</strong></p>
<p>通过直接使用函数名或者取地址可以得到函数的地址。</p>
<p><code>function = &amp;function</code></p>
</blockquote>
<h3 id="14-2-函数指针的使用"><a href="#14-2-函数指针的使用" class="headerlink" title="14.2 函数指针的使用"></a>14.2 函数指针的使用</h3><p>对于下面这个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>函数指针的声明和初始化：</p>
<blockquote>
<p>声明一个函数指针的步骤：</p>
<ol>
<li>首先输入的是，指向这个函数的返回类型，add 函数的返回类型是 int；</li>
<li>然后跟一个括号，括号里面是 *name，name就是函数指针的名字；</li>
<li>然后再跟一个括号，括号里面是所指向这个函数的所有参数的类型，要和所指向的这个函数的类型是一致的。</li>
</ol>
<p>即：function_type (*pointer_name)(arguments_type);</p>
<p>声明一个指向 add 函数的指针 p：</p>
<p>**–&gt; int (<em>p)(int, int);	 &#x2F;&#x2F; 声明了一个函数指针</em>*<br><strong>–&gt; p &#x3D; &amp;add;				&#x2F;&#x2F; 将函数指针 p 指向函数 add</strong></p>
<p>通过上面两条语句我们就实现了声明一个函数指针并让其指向一个函数，当然也可以写为一条语句。</p>
<p>调用函数指针：</p>
<p>**–&gt; int c &#x3D; (<em>p)(2, 3); &#x2F;&#x2F; 调用函数add</em>*</p>
<p>(*p)表示解引用，来获得这个函数，然后把两个参数传递给这个函数。</p>
<p>作为代替，我们也可以直接使用函数指针名（就像在使用函数名一样）：</p>
<p><strong>–&gt;int c &#x3D; p(2, 3); 	 &#x2F;&#x2F;  等价于上面的语句</strong></p>
</blockquote>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello,World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="built_in">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>) = &amp;add;</span><br><span class="line">    c = (*p)(<span class="number">2</span>, <span class="number">3</span>);     </span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;  <span class="comment">// 5</span></span><br><span class="line">    c = <span class="built_in">p</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;  <span class="comment">// 9</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">void</span> (*p1)();</span><br><span class="line">    p1 = printStr;</span><br><span class="line">    <span class="built_in">p1</span>();				<span class="comment">// Hello,World!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14-3-使用案例（回调函数）"><a href="#14-3-使用案例（回调函数）" class="headerlink" title="14.3 使用案例（回调函数）"></a>14.3 使用案例（回调函数）</h3><p><strong>回调函数：</strong>一个函数引用传递给另一个函数时，那个函数被称作回调函数。</p>
<p>函数指针可以被用来做函数参数，接受函数指针的那个函数可以回调函数指针所指向的那个函数，举个例子：</p>
<p>Code：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">B</span><span class="params">(<span class="type">void</span> (*ptr)())</span> &#123;</span><br><span class="line">    (*ptr)();    <span class="comment">// &lt;==&gt; ptr();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> (*ptr)() = A;</span><br><span class="line">    B(ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// &lt;==&gt;</span></span><br><span class="line">    B(A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>在上面的函数中，我们声明了两个函数 <code>A</code> 和 <code>B</code></p>
<figure class="highlight plaintext"><figcaption><span>没有参数，返回值类型为 ```void```；</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">```B ```有一个参数，参数类型为一个返回值类型为 ```void```，没有参数的函数指针，返回值类型为 ```void```；</span><br><span class="line"></span><br><span class="line">在 ```main```中，我们声明了一个返回值类型为 ```void```，没有参数的指针 ```ptr```，并让其指向函数 ```A```（类型匹配），返回将这个指针作为参数传递给函数 ```B```，函数 ```B``` 又通过函数指针 ```ptr``` 调用函数 ```A```。</span><br><span class="line"></span><br><span class="line">函数 ```B``` 可以通过函数指针回调函数 ```A```</span><br><span class="line"></span><br><span class="line">**另外也可以写成 ```B(A)```的形式，因为函数的名字返回的就是指针。**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">****</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">更清晰的例子：</span><br><span class="line"></span><br><span class="line">Code：</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">void bubbleSort(int *a, int n) &#123;</span><br><span class="line">for(int i = 0; i &lt; n - 1; i ++ ) &#123;</span><br><span class="line">	for(int j = 0; j &lt; n - 1 - i; j ++ ) &#123;</span><br><span class="line">           if(a[i] &gt; a[i + 1]) &#123;</span><br><span class="line">               swap(a[i], a[i + 1])</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Explain：</p>
<blockquote>
<p>通过上面的冒泡排序，我们可以实现对一个数组升序排序。现在有这样一种情况，我们有时候需要升序排序，有时候又需要降序排序。</p>
<p>最简单的方式就是写两份冒泡排序，然后修改判断条件，但是这样代码的冗余度太高。</p>
<p>另一种冗余度低且比较简单的方法是在函数中额外传递一个参数 <code>flag</code> ，用来标记这是升序排序还是降序排序。但这样的话如果 <code>flag</code> 很大的话，那么函数内部的 <code>if</code> 比较函数就会很多（我们需要判断依据何种判断条件）。</p>
<p>还有一种方式就是在函数中额外传递一个比较函数，这样就不要额外添加判断语句。</p>
</blockquote>
<p>Code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> (*compare)(<span class="type">int</span>, <span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ ) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">compare</span>(a[j], a[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = a[j];</span><br><span class="line">                a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                a[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">74</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = (<span class="type">int</span>)<span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">bubbleSort</span>(arr, n, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )    cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Explain：</p>
<blockquote>
<p>在 <code>bubbleSort</code> 函数中回调 <code>cmp</code> 函数实现自定义的排序方案。</p>
</blockquote>
<h2 id="15-第15章-C文件操作"><a href="#15-第15章-C文件操作" class="headerlink" title="15. 第15章 C文件操作"></a>15. 第15章 C文件操作</h2><h3 id="15-0-简介和参考"><a href="#15-0-简介和参考" class="headerlink" title="15.0 简介和参考"></a>15.0 简介和参考</h3><p><a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_6778368b0100vidz.html">c&amp;c++文件流参考</a></p>
<p>在ANSI C中，对文件的操作分为两种方式，即：</p>
<ul>
<li><p><strong>流式文件操作</strong></p>
</li>
<li><p><strong>I&#x2F;O文件操作</strong></p>
</li>
</ul>
<h3 id="15-1-英文名词"><a href="#15-1-英文名词" class="headerlink" title="15.1 英文名词"></a>15.1 英文名词</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">perror：错误</span><br><span class="line">flow：流</span><br><span class="line">reind：倒带,back to the begining</span><br></pre></td></tr></table></figure>



<h3 id="15-2-流式文件操作"><a href="#15-2-流式文件操作" class="headerlink" title="15.2 流式文件操作"></a>15.2 流式文件操作</h3><h4 id="15-2-0-FIle结构"><a href="#15-2-0-FIle结构" class="headerlink" title="15.2.0 FIle结构"></a>15.2.0 FIle结构</h4><p>这种方式的文件操作有一个重要的结构FILE，FILE在stdio.h中定义如下：　　</p>
<p><strong>以下是引用片段：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">　　<span class="type">int</span> level; </span><br><span class="line">　　<span class="type">unsigned</span> flags; </span><br><span class="line">　　<span class="type">char</span> fd; </span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">char</span> hold; </span><br><span class="line">　　<span class="type">int</span> bsize; </span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">char</span> _FAR *buffer; </span><br><span class="line">　　<span class="type">unsigned</span> <span class="type">char</span> _FAR *curp; </span><br><span class="line">　　<span class="type">unsigned</span> istemp; </span><br><span class="line">　　<span class="type">short</span> token; </span><br><span class="line">　&#125; FILE;</span><br></pre></td></tr></table></figure>

<p> 　　FILE这个结构包含了文件操作的基本属性，对文件的操作都要通过这个结构的指针来进行，此种文件操作常用的函数如下，下面是这些函数的功能使用说明：</p>
<h4 id="15-2-1-perror"><a href="#15-2-1-perror" class="headerlink" title="15.2.1 perror()"></a>15.2.1 perror()</h4><p><code>void perror(const char *message);</code></p>
<p>在发生错误时，该函数会简化向用户报告这些指定错误的过程。</p>
<p>打印格式为  message: [“wrong message”]，message后面跟一个冒号和空格，然后就是错误信息。</p>
<h4 id="15-2-2-fopen"><a href="#15-2-2-fopen" class="headerlink" title="15.2.2 fopen()"></a>15.2.2 fopen()</h4><p><code>FILE *fopen(path, mode); // 打开一个流</code></p>
<p><code>FILE *freopen(path, mode); //重新打开一个流</code></p>
<p>Mode:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r 打开只读文件，该文件必须存在。 </span><br><span class="line"></span><br><span class="line">r+ 打开可读写的文件，该文件必须存在。 </span><br><span class="line">w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。 </span><br><span class="line">w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。 </span><br><span class="line">a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。 </span><br><span class="line">a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 </span><br><span class="line">上述的形态字符串都可以再加一个b字符，如rb、w+b或ab+等组合，加入b 字符用来告诉函数库打开的文件为二进制文件，而非纯文字文件。不过在POSIX系统，包含Linux都会忽略该字符。</span><br></pre></td></tr></table></figure>

<h4 id="15-2-3-fclose"><a href="#15-2-3-fclose" class="headerlink" title="15.2.3 fclose()"></a>15.2.3 fclose()</h4><p><code>int fclose (FILE *f*);</code></p>
<p>关闭fopen()打开的文件。</p>
<p>对于输出流，fclose函数在文件关闭之前刷新缓冲区。如果它执行成功，返回零值，否则返回EOEF(-1)</p>
<p>在程序结束时一定要记得关闭打开的文件，不然可能会造成数据的丢失。</p>
<h4 id="15-2-4-fputc-fgetc"><a href="#15-2-4-fputc-fgetc" class="headerlink" title="15.2.4 fputc(), fgetc()"></a>15.2.4 fputc(), fgetc()</h4><p><code>int fputc(int c, FILE *Stream);</code></p>
<p><code>int fgetc(FILE *Stream);</code></p>
<p>成功时都返回put&#x2F;get的字符，失败时都返回EOF</p>
<h4 id="15-2-5-fgets-fputs"><a href="#15-2-5-fgets-fputs" class="headerlink" title="15.2.5 fgets(), fputs()"></a>15.2.5 fgets(), fputs()</h4><p><code>int fputs(const char *s, FILE *Stream);</code></p>
<p>写入一个字符串到流中</p>
<p><code>char *fgets(char *s, int n, FILE *Strem)</code></p>
<p>从流中读取一行或指定个字符，注意是读取n-1个字符(还有一个默认的‘\0’)，除非读完一行。参数s是用来接收字符串，如果成功则返回s的指针，否则返回NULL。</p>
<p>注意fgets会读取回车, fputs不换行。</p>
<h4 id="15-2-6-fseek"><a href="#15-2-6-fseek" class="headerlink" title="15.2.6 fseek()"></a>15.2.6 fseek()</h4><p>fseek() 在流中定位到指定的字符</p>
<p>此函数一般用于二进制模式打开的文件中，功能是定位到流中指定的位置，原型是:</p>
<p><code>int fseek(FILE *stream, long offset, int whence);</code></p>
<p>如果成功返回0，参数offset是移动的字符数，whence是移动的基准，取值是：</p>
<p>符号常量 值 基准位置</p>
<ul>
<li><p><strong>SEEK_SET 0</strong> <strong>文件开头</strong></p>
</li>
<li><p><strong>SEEK_CUR 1</strong> <strong>当前读写的位置</strong></p>
</li>
<li><p><strong>SEEK_END 2</strong> <strong>文件尾部</strong></p>
</li>
</ul>
<p>例：fseek(fp,1234L,SEEK_CUR);&#x2F;&#x2F;把读写位置从当前位置向后移动1234字节(L后缀表示长整数)</p>
<p>fseek(fp,0L,2);&#x2F;&#x2F;把读写位置移动到文件尾</p>
<h4 id="15-2-7-fprintf-fscanf"><a href="#15-2-7-fprintf-fscanf" class="headerlink" title="15.2.7 fprintf(), fscanf()"></a>15.2.7 fprintf(), fscanf()</h4><p>fprintf按格式输入到流，其原型是:</p>
<p>&#96;&#96;&#96;int fprintf(FILE *stream, const char *format[, argument, …]);&#96;&#96;</p>
<p>其用法和printf()相同，不过不是写到控制台，而是写到流罢了。</p>
<p>例：fprintf(fp,”%d-%s”,4,”Hahaha”);</p>
<hr>
<p>fscanf从流中按格式读取，其原型是</p>
<p><code>int fscanf(FILE *stream, const char *format[, address, …]);</code></p>
<p>其用法和scanf()相同，不过不是从控制台读取，而是从流读取罢了。</p>
<p>例：fscanf(fp,”%d%d” ,&amp;x,&amp;y);</p>
<hr>
<p>如果想用scanf实现逐行读取，需要在fscanf中读取一个换行，否则第一次fscanf是正常读如，但第二次会读入一个换行，之后就全错了。</p>
<h4 id="15-2-8-rewind"><a href="#15-2-8-rewind" class="headerlink" title="15.2.8 rewind()"></a>15.2.8 rewind()</h4><p>把当前的读写位置回到文件开始，原型是:</p>
<p><code>void rewind(FILE *stream);</code></p>
<p>其实本函数相当于<code>fseek(fp,0L,SEEK_SET);</code></p>
<h4 id="15-2-9-remove"><a href="#15-2-9-remove" class="headerlink" title="15.2.9 remove()"></a>15.2.9 remove()</h4><p>删除文件，原型是</p>
<p><code>int remove(const char *filename);</code></p>
<p> 参数就是要删除的文件名，成功返回0。</p>
<h4 id="15-2-10-ferror"><a href="#15-2-10-ferror" class="headerlink" title="15.2.10 ferror()"></a>15.2.10 ferror()</h4><p><code>int ferror(FILE *stream);</code></p>
<p>返回流最近的<a target="_blank" rel="noopener" href="http://www.pcdog.com/special/1077/index.html">错误代码</a>，可用clearerr()来清除它，clearerr()的原型是:</p>
<p><code>void clearerr(FILE *stream);</code></p>
<h4 id="15-2-11-tmpname"><a href="#15-2-11-tmpname" class="headerlink" title="15.2.11 tmpname()"></a>15.2.11 tmpname()</h4><p><code>char *tmpname(char *s);</code></p>
<p> 生成一个唯一的文件名，其实tmpfile()就调用了此函数，参数s用来保存得到的文件名，并返回这个指针，如果失败，返回NULL。</p>
<h4 id="15-2-12-tmpfile"><a href="#15-2-12-tmpfile" class="headerlink" title="15.2.12 tmpfile()"></a>15.2.12 tmpfile()</h4><p><code>FILE *tmpfile(void);</code></p>
<p> 生成一个临时文件，以”w+b”的模式打开，并返回这个临时流的指针，如果失败返回NULL。在程序结束时，这个文件会被自动删除。</p>
<h4 id="15-2-13-fread-fwrite"><a href="#15-2-13-fread-fwrite" class="headerlink" title="15.2.13 fread(), fwrite()"></a>15.2.13 fread(), fwrite()</h4><p>fread()从流中读指定个数的字符，原型是</p>
<p><code>size_t fread(void *ptr, size_t size, size_t n, FILE *stream);</code></p>
<p>参数ptr是保存读取的数据，void*的指针可用任何类型的指针来替换，如char*、int *等等来替换;size是每块的字节数;n是读取的块数，如果成功，返回实际读取的块数(不是字节数)，本函数一般用于二进制模式打开的文件中。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以下是引用片段： </span><br><span class="line">char x[4230]; </span><br><span class="line">FILE *file1=fopen(&quot;file&quot;,&quot;r&quot;);  </span><br><span class="line">fread(x, 200, 12, file1);</span><br><span class="line">//共读取200*12=2400个字节 </span><br></pre></td></tr></table></figure>

<p>与fread对应，fwrite()向流中写指定的数据，原型是:</p>
<p><code>size_t fwrite(const void *ptr, size_t size, size_t n, FILE *stream);</code></p>
<p>参数ptr是要写入的数据指针，void<em>的指针可用任何类型的指针来替换，如char</em>、int *等等来替换;size是每块的字节数;n是要写的块数，如果成功，返回实际写入的块数(不是字节数)，本函数一般用于二进制模式打开的文件中。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">以下是引用片段： 　　</span><br><span class="line">char x[]=&quot;I Love You&quot;;  　　</span><br><span class="line">fwire(x, 6, 12, fp);//写入6*12=72字节  　　</span><br><span class="line">// 将把&quot;I Love&quot;写到流fp中12次，共72字节</span><br></pre></td></tr></table></figure>





<h3 id="15-2-I-x2F-O-文件操作"><a href="#15-2-I-x2F-O-文件操作" class="headerlink" title="15.2 I&#x2F;O 文件操作"></a>15.2 I&#x2F;O 文件操作</h3><p>参考博客吧！</p>
<p>暂时用不到！</p>
<hr>
<hr>
<h1 id="C陷阱与缺陷"><a href="#C陷阱与缺陷" class="headerlink" title="C陷阱与缺陷"></a>C陷阱与缺陷</h1><h2 id="第一章-词法陷阱"><a href="#第一章-词法陷阱" class="headerlink" title="第一章 词法陷阱"></a>第一章 词法陷阱</h2><h3 id="1-0-引子"><a href="#1-0-引子" class="headerlink" title="1.0 引子"></a>1.0 引子</h3><p>&#x3D;&#x3D;符号&#x3D;&#x3D; 指的是程序的一个基本组成单元，其作用相当于一个句子中的单词，但是同一个单词在不同的句子中意思是基本一样的，而符号可能完全不同。</p>
<p>编译器中负责将程序分解为一个一个符号的部分，一般称为&#x3D;&#x3D;“词法分析器”&#x3D;&#x3D;。</p>
<p>例如 <code>if （x &gt; big）big = x；</code>经过词法分析之后，可以写为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span></span><br><span class="line">(</span><br><span class="line">&gt;</span><br><span class="line">big</span><br><span class="line">)</span><br><span class="line">big</span><br><span class="line">=</span><br><span class="line">x</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-x3D-不同于-x3D-x3D"><a href="#1-1-x3D-不同于-x3D-x3D" class="headerlink" title="1.1 &#x3D;不同于&#x3D;&#x3D;"></a>1.1 &#x3D;不同于&#x3D;&#x3D;</h3><p>在C语言中，之所以使用&#x3D;作为赋值运算符，&#x3D;&#x3D;作为比较运算符，主要是因为赋值运算出现的更为频繁，因而字符较少的&#x3D;就被赋予了更常用的含义—赋值运算。</p>
<p>某些编译器在发现条件判断的条件判断表达式中出现类似于<code>e1 = e2</code> 的赋值语句时会给出警告。但当我们确实需要使用赋值语句时，不应该关闭警告选项，而是显示的进行比较。</p>
<p>例如表达式<code>if (x = y)</code></p>
<p>可以写为：<code>if ((x = y) != 0)</code></p>
<h3 id="1-2-amp-和-不同于-amp-amp-和"><a href="#1-2-amp-和-不同于-amp-amp-和" class="headerlink" title="1.2 &amp;和 | 不同于 &amp;&amp;和 ||"></a>1.2 &amp;和 | 不同于 &amp;&amp;和 ||</h3><h3 id="1-3-词法分析中的贪心法"><a href="#1-3-词法分析中的贪心法" class="headerlink" title="1.3 词法分析中的贪心法"></a>1.3 词法分析中的贪心法</h3><p>C语言划分符号的规则：每一个符号应该包含尽可能多的字符。</p>
<p>例如 <code>a---b;</code></p>
<p>将会被划分为<code>(a--) - b;</code>，而不是<code>a - (--b);</code></p>
<h3 id="1-4-整形常量"><a href="#1-4-整形常量" class="headerlink" title="1.4 整形常量"></a>1.4 整形常量</h3><p>&#x3D;&#x3D;八进制（octonary system）&#x3D;&#x3D;</p>
<p>如果一个整形常量第一个字符是数字0，或者以字符Q结尾，那么该常量将被视作八进制。</p>
<p>所以有时用O结尾，有时用Q结尾，原因：为避免把字母O误认作零，改由Q代替</p>
<p>&#x3D;&#x3D;十六进制（hexadecimal system）&#x3D;&#x3D;</p>
<p>0x开头，或者以字符H结尾。</p>
<p>&#x3D;&#x3D;二进制（binary system）&#x3D;&#x3D;</p>
<p>以字符B结尾。</p>
<p>&#x3D;&#x3D;十进制（decimal system）&#x3D;&#x3D;</p>
<p>开头不能是0，以 字符D结尾。</p>
<h3 id="1-5-字符和字符串"><a href="#1-5-字符和字符串" class="headerlink" title="1.5 字符和字符串"></a>1.5 字符和字符串</h3><p>C语言中的单引号和双引号的含义迥异。</p>
<p>用单引号引起的一个字符实际上代表一个<strong>整数</strong>，整数值对应于该字符在编译器采用的字符集中的序列值。因此，对于采用 ASCLL 字符集的编译器而言，’a’ 的含义与 97（十进制）严格一致。</p>
<p>用双引号引起的字符串，代表的却是一个指向无名数组起始字符的<strong>指针</strong>，该指针被双引号之间的字符以及一个额外的二进制为零的字符 ‘\0’ 初始化。</p>
<p>例如，下面的语句是等价的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等价于 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[] = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span> (str);</span><br></pre></td></tr></table></figure>



<h2 id="第二章-语法陷阱"><a href="#第二章-语法陷阱" class="headerlink" title="第二章 语法陷阱"></a>第二章 语法陷阱</h2><h3 id="2-1-理解函数声明"><a href="#2-1-理解函数声明" class="headerlink" title="2.1 理解函数声明"></a>2.1 理解函数声明</h3><p>任何 C 变量的声明都由两部分组成：类型以及一组类似表达式的声明符。</p>
<p><strong>一旦我们知道了如何声明一个给定类型的变量，那么该类型的类型转换符就很容易得到了：只需要把声明中的变量名和声明末尾的分号去掉，再将剩余的部分用一个括号整个“封装”起来即可。</strong></p>
<h3 id="2-2-优先级问题"><a href="#2-2-优先级问题" class="headerlink" title="2.2 优先级问题"></a>2.2 优先级问题</h3><p>C 语言运算符优先级表</p>
<p><img src="https://images2015.cnblogs.com/blog/550032/201609/550032-20160927115252031-1960111031.png" alt="img"></p>
<blockquote>
<p>单目运算符，赋值运算符，三目运算符自右向左结合。</p>
<p>任何一个逻辑运算符的优先级比任何一个关系运算符的优先级要低。</p>
<p>移位运算符的优先级比算术运算符要低，但是比关系运算符要高。</p>
<p>六个关系运算符的优先级并不相同。因此，如果我们要比较 a 和 b 的大小顺序是否和 c 和 d 的大小顺序一样，可以这样写：<code>a &lt; b == c &lt; d</code></p>
<p>任意两个逻辑运算符的具有不同的优先级，所有的按位运算符优先级（&amp; , | , ^）要比顺序运算符（&amp;&amp;， ||）的优先级高；每个与运算的优先级比或运算的优先级高，异或运算的优先级介于两者之间。</p>
<p>三目运算符的优先级最低，这样我们就可以在三目运算符的条件表达式中包含关系运算符的逻辑组合。例如：<code>tax_rate = income &gt; 4000 &amp;&amp; residency &lt; 5 ? 3.5 : 2.0;</code> 本例其实还说明赋值运算符的优先级低于条件运算符的优先级是有意义的。</p>
</blockquote>
<p>C++ 运算符优先级和结合性</p>
<table>
<thead>
<tr>
<th align="left">优先级</th>
<th>运算符</th>
<th>说明</th>
<th>结合性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td>::</td>
<td>范围解析</td>
<td>自左向右</td>
</tr>
<tr>
<td align="left">2</td>
<td>++  –</td>
<td>后缀自增&#x2F;后缀自减</td>
<td></td>
</tr>
<tr>
<td align="left">()</td>
<td>括号</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">[]</td>
<td>数组下标</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">.</td>
<td>成员选择（对象）</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">−&gt;</td>
<td>成员选择（指针）</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">3</td>
<td>++  –</td>
<td>前缀自增&#x2F;前缀自减</td>
<td>自右向左</td>
</tr>
<tr>
<td align="left">+  −</td>
<td>正&#x2F;负号</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">!  ~</td>
<td>逻辑非&#x2F;按位取反</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">(type)</td>
<td>强制类型转换</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">*</td>
<td>取指针指向的值</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">&amp;</td>
<td>某某的地址</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">sizeof</td>
<td>某某的大小</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">new, new[]</td>
<td>动态内存分配&#x2F;动态数组内存分配</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">delete, delete[]</td>
<td>动态内存释放&#x2F;动态数组内存释放</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">4</td>
<td>.*  -&gt;*</td>
<td>成员对象选择&#x2F;成员指针选择</td>
<td>自左向右</td>
</tr>
<tr>
<td align="left">5</td>
<td>*  &#x2F;  %</td>
<td>乘法&#x2F;除法&#x2F;取余</td>
<td></td>
</tr>
<tr>
<td align="left">6</td>
<td>+  −</td>
<td>加号&#x2F;减号</td>
<td></td>
</tr>
<tr>
<td align="left">7</td>
<td>&lt;&lt;  &gt;&gt;</td>
<td>位左移&#x2F;位右移</td>
<td></td>
</tr>
<tr>
<td align="left">8</td>
<td>&lt;  &lt;&#x3D;</td>
<td>小于&#x2F;小于等于</td>
<td></td>
</tr>
<tr>
<td align="left">&gt;  &gt;&#x3D;</td>
<td>大于&#x2F;大于等于</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">9</td>
<td>&#x3D;&#x3D;  !&#x3D;</td>
<td>等于&#x2F;不等于</td>
<td></td>
</tr>
<tr>
<td align="left">10</td>
<td>&amp;</td>
<td>按位与</td>
<td></td>
</tr>
<tr>
<td align="left">11</td>
<td>^</td>
<td>按位异或</td>
<td></td>
</tr>
<tr>
<td align="left">12</td>
<td>|</td>
<td>按位或</td>
<td></td>
</tr>
<tr>
<td align="left">13</td>
<td>&amp;&amp;</td>
<td>与运算</td>
<td></td>
</tr>
<tr>
<td align="left">14</td>
<td>||</td>
<td>或运算</td>
<td></td>
</tr>
<tr>
<td align="left">15</td>
<td>?:</td>
<td>三目运算符</td>
<td>自右向左</td>
</tr>
<tr>
<td align="left">16</td>
<td>&#x3D;</td>
<td>赋值</td>
<td></td>
</tr>
<tr>
<td align="left">+&#x3D;  −&#x3D;</td>
<td>相加后赋值&#x2F;相减后赋值</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">*&#x3D;  &#x2F;&#x3D;  %&#x3D;</td>
<td>相乘后赋值&#x2F;相除后赋值&#x2F;取余后赋值</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">&lt;&lt;&#x3D;  &gt;&gt;&#x3D;</td>
<td>位左移赋值&#x2F;位右移赋值</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">&amp;&#x3D;  ^&#x3D;  |&#x3D;</td>
<td>位与运算后赋值&#x2F;位异或运算后赋值&#x2F;位或运算后赋值</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">17</td>
<td>throw</td>
<td>抛出异常</td>
<td></td>
</tr>
<tr>
<td align="left">18</td>
<td>,</td>
<td>逗号</td>
<td>自左向右</td>
</tr>
</tbody></table>
<h3 id="2-3-注意作为语句结束标志的分号"><a href="#2-3-注意作为语句结束标志的分号" class="headerlink" title="2.3 注意作为语句结束标志的分号"></a>2.3 注意作为语句结束标志的分号</h3><p>例子1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">10</span>);</span><br><span class="line">    x = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>在 if 的后面，我们多加了一个分号，上述语句就相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>例子2：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">c = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>在 return 的后面，我们遗漏了分号，但是不会报错，上述语句就相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">return</span> a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>



<h3 id="2-4-switch-语句"><a href="#2-4-switch-语句" class="headerlink" title="2.4 switch 语句"></a>2.4 switch 语句</h3><p><strong>由 switch 控制的流程在执行第一个 case 之后，会自然而然的顺序执行下去</strong>，C 语言的这种特性，既是它的优势所在，也是它的劣势。</p>
<p>因为程序员可能会遗漏 break 语句，而有时候，我们或许需要故意省略 break 语句来实现某种效果。</p>
<h3 id="2-5-函数调用"><a href="#2-5-函数调用" class="headerlink" title="2.5 函数调用"></a>2.5 函数调用</h3><p>与其他程序设计语言不同，C 语言要求：<strong>在函数调用时，即使函数不带参数，也应该包括参数列表。</strong></p>
<p>因此，如果 f 是一个函数，那么<code>f();</code>是一个函数调用语句，而<code>f</code>却是一个什么也不做的语句。更准确的说，它计算函数 f 的地址，却并不调用这个函数。</p>
<h3 id="2-6-悬挂-else-引发的额问题"><a href="#2-6-悬挂-else-引发的额问题" class="headerlink" title="2.6 悬挂 else 引发的额问题"></a>2.6 悬挂 else 引发的额问题</h3><p>C 语言有这样的规则：<strong>else 始终与同一括号内最近的未匹配的 if 结合。</strong></p>
<p>例如下面的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> (y == <span class="number">0</span>)	error();</span><br><span class="line"><span class="keyword">else</span> z = x + y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码，看起来像是：</span></span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">0</span>)	error();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    z = x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际上是：</span></span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">0</span>)	error();</span><br><span class="line">    <span class="keyword">else</span>		z = x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第三章-语义陷阱"><a href="#第三章-语义陷阱" class="headerlink" title="第三章 语义陷阱"></a>第三章 语义陷阱</h2><h3 id="3-1-指针与数组"><a href="#3-1-指针与数组" class="headerlink" title="3.1 指针与数组"></a>3.1 指针与数组</h3><p>C 语言中的数组值得注意的地方有以下两点：</p>
<ol>
<li>C 语言中只有一维数组，并且数组的大小必须在编译器就作为一个常数确定下来。所谓多维数组其实就是数组的元素可以是任意类型的对象，包括数组。</li>
<li>对于一个数组，我们能做的只有两件事：确定该数组的大小以及获得指向该数组下标为 0 的指针。有关数组的其他操作，哪怕他们乍看上去是以数组下标进行运算的，实际上都是通过指针进行的。换言之，任何一个数组下标运算都等同于一个对应的指针运算，因此我们完全可以根据指针行为定义数组下标的行为。</li>
</ol>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure>

<p>这种写法在 ANSI C 中是非法的，以为 <code>&amp;a</code> 是一个指向数组的指针，而 <code>p</code> 是一个指向整型变量的对象，它们的类型不匹配。</p>
<p>正确的写法应该是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = a;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>a</code> 就是 <code>a[0]</code> 的地址。</p>
<p><strong>除了 <code>a</code> 被用作运算符 <code>sizeof</code> 的参数这一情形，在其他所有情形中使用数组名 <code>a</code> 都代表指向数组 <code>a</code> 中下标为 <code>0</code>  的元素的指针</strong>。</p>
<p>另外，在上文中我们说过“有关数组的其他操作，哪怕他们乍看上去是以数组下标进行运算的，实际上都是通过指针进行的。”</p>
<p>例如 <code>a[i]</code> 表示取数组 <code>a</code> 下标为 <code>i</code> 的元素的值，它实际表示的是： <code>*(a + i)</code>，只不过这种写法非常常用，因此被简记为 <code>a[i]</code>。实际上，由于 <code>a + i</code> 和 <code>i + a</code> 一样，因此 <code>a[i]</code> 和 <code>i[a]</code> 具有相同的含义。(也许某些汇编程序员会觉得很熟悉–偏移量)</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">      &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> (*p)[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(p = a; p &lt; &amp;a[<span class="number">3</span>]; p ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> *j;</span><br><span class="line">        <span class="keyword">for</span>(j = *p; j &lt; &amp;(*p)[<span class="number">3</span>]; j ++ ) </span><br><span class="line">            cout &lt;&lt; *j &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*<em>对指针的 <em>(解引用) 可以理解为让指针指向某个地方。</em></em> </p>
<h3 id="3-2-非数组的指针"><a href="#3-2-非数组的指针" class="headerlink" title="3.2 非数组的指针"></a>3.2 非数组的指针</h3><p>在 C 语言中，<strong>字符串常量</strong>代表了一块包括字符串中所有字符以及一个空字符 <code>&#39;\0&#39;</code> 的内存区域的地址。</p>
<p>如果我们想要拼接两个字符串 s 和 t，正确的写法为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;Hello,&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *t = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *r;</span><br><span class="line">    r = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s) + <span class="built_in">strlen</span>(t) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!r) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;分配失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(r, s);</span><br><span class="line">    <span class="built_in">puts</span>(r);</span><br><span class="line">    <span class="built_in">strcat</span>(r, t);</span><br><span class="line">    <span class="built_in">puts</span>(r);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-作为参数的数组声明"><a href="#3-3-作为参数的数组声明" class="headerlink" title="3.3 作为参数的数组声明"></a>3.3 作为参数的数组声明</h3><p>在 C 语言中，我们无法将一个数组作为函数参数直接传递。如果我们将数组名作为参数，那么数组会立即被转换为指向该数组第一个元素的指针。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">    <span class="built_in">puts</span>(s);</span><br><span class="line">    <span class="built_in">puts</span>(&amp;s[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 传递一个数组名和传递数组第一个元素的地址是等价的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，将数组作为函数参数毫无意义。所以，C 语言会自动将作为参数的数组声明转换为对应的指针声明。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strlen</span><span class="params">(<span class="type">char</span> s[])</span> &#123;</span><br><span class="line">	<span class="comment">/* do something */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与下面的写法完全相同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strlen</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">	<span class="comment">/* do something */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-避免“举隅法”"><a href="#3-4-避免“举隅法”" class="headerlink" title="3.4 避免“举隅法”"></a>3.4 避免“举隅法”</h3><p><strong>举隅(yu2)法</strong>：举一端为例。意在使人由此一端而推知其他。意在以更宽泛的词语来代替含义相对较窄的词语，或者相反：例如，以整体代表部分，或者以部分代表整体。</p>
<p>C 语言中一个常见的陷阱：混淆指针与指针所指向的数据。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p, *q;</span><br><span class="line">p = <span class="string">&quot;xyz&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>尽管有时候我们不妨认为，上面的赋值语句使得 <code>p</code> 的值就是字符串 <code>&quot;xyz&quot;</code> ，然而实际情况并不是这样。实际上， <code>p</code> 的值是一个指向由 <code>&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;\0&#39;</code> 四个字符组成的数组的起始元素的指针。</p>
<p>因此，如果我们执行下面语句：</p>
<p><code>p = q;</code></p>
<figure class="highlight plaintext"><figcaption><span>和 ```q``` 现在是指向内存中同一个地址的指针。这个赋值语句并没有复制内存中的字符。需要记住的是，复制指针并不同时复制指针所指向的数据。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3.5 空指针并非空字符串</span><br><span class="line"></span><br><span class="line">在 C 语言中，编译器保证由 0 转换而来的指针并不等同与任何有效的指针。出于代码文档化的考虑，常数 0 这一个值常用一个符号来代替：</span><br><span class="line"></span><br><span class="line">```#define NULL 0```</span><br><span class="line"></span><br><span class="line">当常数 0 被转换为指针使用时，这个指针绝对不能被解除引用。换句话说，我们绝对不能企图用该指针所指向的内存中存储的内容。</span><br><span class="line"></span><br><span class="line">### 3.6 边界计算与不对称边界</span><br><span class="line"></span><br><span class="line">在所有常见的程序设计错误中，最难于察觉的一类是**“栏杆错误”**，也常被称为“差一错误”。典型的例子是：100 米长的围栏每隔 10 米 需要提跟支撑用的围栏，则总共需要多少根围栏？如果不假思索，最“显而易见”的答案是将 100 除以 10，得到的答案是 10，即需要 10 根栏杆。当然这个答案是错误的，正确答案是 11。</span><br><span class="line"></span><br><span class="line">也即，得出正确答案的最容易方式是这样考虑：要支撑 10 米长的围栏实际需要两根栏杆，两段各一根。这个问题的另一种考虑方式是：除了最右侧的一段围栏，其他每一段 10 米长的围栏都只在左侧有一根围栏；而例外的最右侧不仅左侧有一根围栏，右侧也有一根围栏。</span><br><span class="line"></span><br><span class="line">前面一段讨论了解决问题的两种方法，实际上提示了我们**避免“栏杆错误”的两个通用原则：**</span><br><span class="line"></span><br><span class="line">1.  首先考虑最简单情况下的特例，然后将得到的结果外推，这是原则一。</span><br><span class="line">2.  仔细计算边界，绝不掉以轻心，这是原则二。</span><br><span class="line"></span><br><span class="line">将上面总结的两个原则牢记于心之后，来看一个典型的例子：计算整数范围的边界。例如，假设整数 x 的边界条件为 x&gt;=16 且 x&lt;=27，那么此范围内 x 的可能取值个数有多少？</span><br><span class="line"></span><br><span class="line">根据原则一，我们考虑最简单情况下的特例：x&gt;=16 且 x&lt;=16，此时显然只有一个元素，也即上边界和下边界重合时，此范围内满足条件的整数只有一个。因此答案就是 27-16+1=12。</span><br><span class="line"></span><br><span class="line">然而有时稍不留意，我们会想当然的认为答案为：27-16=11个整数 ，那么是否存在一些编程技巧，可以降低这类错误发生的可能性呢？</span><br><span class="line"></span><br><span class="line">这个编程技巧不但存在，而且可以一言以蔽之：**用第一个入界点和第一个出界点来表示一个数值范围**。具体而言，对于上面的例子我们不应该说整数 x 的边界条件为 x&gt;=16 且 x&lt;=27，而应该说整数 x 的边界条件为 x&gt;=16 且 x&lt;28。注意，这里下界 16 是“入界点”，包含在取值范围之中；而上界是“出界点”，即不包含在取值范围之中，这种不对称或许从数学上而言并不优美，但是它对于程序设计的简化效果却令人吃惊。</span><br><span class="line"></span><br><span class="line">1. 取值范围的大小就是上界与下界之差。28-16的值恰好是12。</span><br><span class="line">2. 如果取值范围为空，那么上界等于下界。</span><br><span class="line">3. 即是取值范围为空，上界也永远不可能小于下界。</span><br><span class="line"></span><br><span class="line">对于像 C 语言这样数组下标从 0 开始的语言，不对称的边界给程序设计带来的便利要更加明显：这种数组的上界（即第一个“出界点”）恰好是数组元素的个数。</span><br><span class="line"></span><br><span class="line">另一种考虑不对称边界的方式是，把上界视作某序列中第一个被占用的元素，而把下界视作序列中第一个被释放的元素。当处理各种不同类型的缓冲区时，这种看待问题的方式特别有用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3.7 求值顺序</span><br><span class="line"></span><br><span class="line">C 语言中只有 4 个运算符（&amp;&amp;、||、 ?: 和 ,）存在规定的求值顺序。运算符 &amp;&amp; 和 || 先对左侧操作数求值，只在需要的时候才对右侧操作数求值。运算符 ?: 有三个操作数：在 a?b:c 中，操作数 a 首先被求值，根据 a 的值再去求操作数 b 或 c 的值。逗号运算符首先对左侧操作数求值，然后“丢弃”该值，再对右侧操作数求值。</span><br><span class="line"></span><br><span class="line">&gt; 注：分隔函数参数的逗号并非逗号运算符，例如，x 和 y 在函数 f(x, y) 中的求值顺序是未定义的，而在函数 g((x, y)) 中却是确定的先 x 后 y的顺序。  </span><br><span class="line">&gt;</span><br><span class="line">&gt; 在后一个例子中，函数 g 只有一个参数。这个参数的值是这样求得的：先对 x 求值，然后“丢弃” x 的值，接下来求 y 的值。因此最后的值永远是 y。</span><br><span class="line"></span><br><span class="line">C 语言中其它所有运算符对齐操作数求值的顺序是未定义的，特别是，赋值运算符并不保证任何求值顺序。另外，运算符 &amp;&amp; 和 || 对于保证检查操作按照正确的顺序执行至关重要，在语句``if(y != 0 &amp;&amp; x / y &gt; tolerate)`` 中，就必须保证 y 非 0 时才能执行 x/y 的操作。</span><br><span class="line"></span><br><span class="line">下面这种从数组 x 中复制前 n 个元素到数组 y 中的做法是不正确的，它对求值顺序做了太多假设：</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">i = 0;</span><br><span class="line">while(i &lt; n) &#123;</span><br><span class="line">    y[i] = x[i ++ ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们假设 <code>y[i] = x[i ++ ];</code> 执行的是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y[i] = x[i];</span><br><span class="line">i ++ ;</span><br></pre></td></tr></table></figure>

<p>但也有可能是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y[i + <span class="number">1</span>] = x[i];</span><br><span class="line">i ++ ;</span><br></pre></td></tr></table></figure>

<p>之所以会出现后面的情况是因为 <code>y[i]</code> 的地址将有可能在 <code>i</code> 自增之后被求值。而我们假设 <code>y[i]</code> 的地址在 <code>i</code> 自增之前被求值。</p>
<h3 id="3-8-操作符-amp-amp-、-和-！"><a href="#3-8-操作符-amp-amp-、-和-！" class="headerlink" title="3.8 操作符 &amp;&amp;、|| 和 ！"></a>3.8 操作符 &amp;&amp;、|| 和 ！</h3><p>不要把 &amp;&amp; 和 &amp; 混淆，以及 || 和 | 混淆。它们一类是逻辑运算符，一类是按位运算符。尽管有时候用错了可能也会得到理想的结果。</p>
<h3 id="3-9-整数溢出"><a href="#3-9-整数溢出" class="headerlink" title="3.9 整数溢出"></a>3.9 整数溢出</h3><p>C 语言中有两倍整数算术运算：有符号运算和无符号运算。在无符号算术运算中，没有所谓“溢出”一说：所有无符号数运算都以 2 的 n 次方为模，这里 n 是结果中的位数。</p>
<p>溢出的结果是未定义的，有时候会简单的利用符号来判断是否溢出，例如两个正数相加结果如果是负数那么肯定溢出，但是溢出不一定就是负数。</p>
<h3 id="3-10-为-main-函数提供返回值"><a href="#3-10-为-main-函数提供返回值" class="headerlink" title="3.10 为 main 函数提供返回值"></a>3.10 为 main 函数提供返回值</h3><p>对于一个函数而言，如果没有显式声明返回类型，那么函数返回类型就默认为整形。但是这个程序并没有给出任何返回值。</p>
<h2 id="第四章-链接"><a href="#第四章-链接" class="headerlink" title="第四章 链接"></a>第四章 链接</h2><h3 id="4-1-什么是链接器"><a href="#4-1-什么是链接器" class="headerlink" title="4.1 什么是链接器"></a>4.1 什么是链接器</h3><p>C 语言的一个重要思想就是分别编译，即若干个源程序可以在不同的时候单独进行编译，然后在恰当的时候整合到一起。</p>
<h2 id="第五章-库函数"><a href="#第五章-库函数" class="headerlink" title="第五章 库函数"></a>第五章 库函数</h2><h3 id="5-1-返回整数的-getchar-函数"><a href="#5-1-返回整数的-getchar-函数" class="headerlink" title="5.1 返回整数的 getchar 函数"></a>5.1 返回整数的 getchar 函数</h3><h2 id="第六章-预处理器"><a href="#第六章-预处理器" class="headerlink" title="第六章 预处理器"></a>第六章 预处理器</h2><h2 id="第七章-可移植性缺陷"><a href="#第七章-可移植性缺陷" class="headerlink" title="第七章 可移植性缺陷"></a>第七章 可移植性缺陷</h2><ul>
<li></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/2023/06/15/common/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/15/common/" class="post-title-link" itemprop="url">design parteen & STL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-15 20:20:57" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-16 10:06:40" itemprop="dateModified" datetime="2023-06-16T10:06:40+08:00">2023-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/common/" itemprop="url" rel="index"><span itemprop="name">common</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Design-Patterns-TODO"><a href="#Design-Patterns-TODO" class="headerlink" title="Design Patterns[TODO]"></a>Design Patterns[TODO]</h1><h2 id="0x01-依赖转置原则"><a href="#0x01-依赖转置原则" class="headerlink" title="0x01. 依赖转置原则"></a>0x01. 依赖转置原则</h2><h3 id="ref1"><a href="#ref1" class="headerlink" title="ref1"></a>ref1</h3><p>例如人吃巧克力：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface IChocolates&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Oreo</span> implements IChocolates &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dove</span> implements IChocolates &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> interface Person &#123; <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">( IChocolates chocolates )</span></span>; &#125;</span><br></pre></td></tr></table></figure>



<p>上面的例子中人对巧克力产生了依赖，那人吃的行为依赖其实跟巧克力没有关系，在巧克力出现之前就已经存在了，因此吃的动作依赖的接口应该是人本身内部的概念，这个接口的归属权应该属于人，概念应该为可食用的（edible）。因此人对巧克力的依赖关系应该倒置为巧克力对可食用接口的依赖。这样倒置之后对人来说具有了更好的扩展性，不仅可以吃各种不同的巧克力，还可以吃饼干，米饭，鱼肉等等其它任何可吃的东西。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface IChocolates extends IEdible&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Oreo</span> implements IChocolates &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dove</span> implements IChocolates &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> interface Person &#123; <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">( IEdible edible )</span></span>; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ref2"><a href="#ref2" class="headerlink" title="ref2"></a>ref2</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/li1358159/article/details/123306664">REF</a></p>
<h3 id="ref3"><a href="#ref3" class="headerlink" title="ref3"></a>ref3</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012346890/article/details/111034907?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-111034907-blog-123306664.pc_relevant_aa2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-111034907-blog-123306664.pc_relevant_aa2&utm_relevant_index=1">REF</a></p>
<p>在例子中，如果我们让上层 dirver 依赖于底层的细节 car，那么就完全错误了。</p>
<p>我们应该让 diver 依赖于抽象的 CAR，让具体的 car 继承自抽象的 CAR。 </p>
<h2 id="0x02-装饰模式"><a href="#0x02-装饰模式" class="headerlink" title="0x02 装饰模式"></a>0x02 装饰模式</h2><h3 id="ref1-1"><a href="#ref1-1" class="headerlink" title="ref1"></a>ref1</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40594696/article/details/107611074">原文链接</a></p>
<p>1.什么是装饰模式</p>
<p>装饰模式是一种用于替代继承的技术。它无需定义子类却可以给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。</p>
<p>举个栗子：一张照片，不改变照片本身，给它增加一个相框，使他增加防潮的功能，这就是装饰模式。</p>
<p>装饰模式是一种对象结构型模式，他以对客户透明的方式动态的给一个对象附加上更多的责任，可以在不需要创建更多子类的情况下让对象的功能得以扩展。</p>
<p>2.装饰模式的结构</p>
<p>（1）<strong>Component（抽象构件）：</strong>它是具体构件和抽象装饰类的共同父类，声明了在具体构建中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。</p>
<p>（2）<strong>ConcreteComponent（具体构件）：</strong>它是抽象构件的子类，用于定义具体的构建对象，实现了在抽象构建中声明的方法，装饰类可以给它增加额外的职责。</p>
<p>（3）<strong>Decorator（抽象装饰类）：</strong>他也是抽象构件的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。</p>
<p>（4）<strong>ConcreteDecorator（具体装饰类）：</strong>它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，他可以调用在抽象装饰类中定义的方法，并可以增加新的方法用于扩充对象的行为。</p>
<h3 id="ref2-1"><a href="#ref2-1" class="headerlink" title="ref2"></a>ref2</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhshulin/article/details/38665187">refreence</a></p>
<p>####### <a target="_blank" rel="noopener" href="https://blog.csdn.net/NEXUS666/article/details/115672452">更好的 ref – c++ 实例</a></p>
<h2 id="0x03-代理模式"><a href="#0x03-代理模式" class="headerlink" title="0x03 代理模式"></a>0x03 代理模式</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/starlee/article/details/1647412">引用计数</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012344185/article/details/114497309">引用计数</a></p>
<p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/169263">jk时间 – 好文</a></p>
<h2 id="0x04-工厂模式"><a href="#0x04-工厂模式" class="headerlink" title="0x04 工厂模式"></a>0x04 工厂模式</h2><p>现实生活中，工厂是负责生产产品的；同样在设计模式中，简单工厂模式我们可以理解为<strong>负责生产对象</strong>的一个类，称为“工厂类”。</p>
<h2 id="0X05-原型模式"><a href="#0X05-原型模式" class="headerlink" title="0X05 原型模式"></a>0X05 原型模式</h2><p>原型模式定义了一个 virtual 拷贝构造函数，C++ 有吗？ C++ 没有虚拷贝构造</p>
<p><a href="cloud.tencent.com/developer/article/1686487">ref1</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/365222623">ref2</a></p>
<p><a href="cnblogs.com/jylz/p/10648439.html">ref3</a></p>
<h1 id="STL-TODO"><a href="#STL-TODO" class="headerlink" title="STL[TODO]"></a>STL[TODO]</h1><h2 id="prelogue"><a href="#prelogue" class="headerlink" title="prelogue"></a>prelogue</h2><h3 id="0x01-导读"><a href="#0x01-导读" class="headerlink" title="0x01 导读"></a>0x01 导读</h3><p>候捷 STL 与 范型编程学习笔记。</p>
<h3 id="0x02-英语"><a href="#0x02-英语" class="headerlink" title="0x02 英语"></a>0x02 英语</h3><p>identity：同一，本身</p>
<h3 id="0x03-problem"><a href="#0x03-problem" class="headerlink" title="0x03 problem"></a>0x03 problem</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/nirendao/article/details/115815599?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-115815599-blog-110736211.pc_relevant_3mothn_strategy_and_data_recovery&spm=1001.2101.3001.4242.1&utm_relevant_index=3">1</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/luolaihua2018/article/details/110736211">2</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013317445/article/details/89680330">3</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6b526aa481b1">4</a></p>
<h2 id="一、container"><a href="#一、container" class="headerlink" title="一、container"></a>一、container</h2><p>大家风范：用前置++，–实现后置++，–</p>
<p>仿函数：函数对象</p>
<p>关联：有key和value</p>
<p>array就是把数组包装成一个class</p>
<p>deque：dai ke</p>
<p>set, map:红黑树.c++并未规定必须使用红黑树，只不过红黑树效率高，因此各大制定标准库的公司都使用红黑树。</p>
<p>set的key就是value，value就是key。</p>
<p>哈希表由一个个桶（bucket）组成，每个桶都是一个链表（link）。现在哈希表大多采用分离链表发（yxc：拉链法）实现。</p>
<p>头文件有保护机制，多次引入没问题</p>
<p>vector空间两倍增长(成长)</p>
<p>（2）vector 有一个机制是这样的，如果新加入一个元素，比如通过push_back()，但是size 大于了capacity，那么vector 就会重新找一块更大的地方再把数据放进去。重新分配的过程：<strong>申请一块新的内存 &gt; 拷贝数据 &gt; 释放原内存</strong>。</p>
<p> 2、vector扩容怎么拷贝？</p>
<p>经常问的一个问题，vector怎么扩容？最简单的回答就是先申请内存，再拷贝，最后销毁原来的内存，然后是1.5倍还是2倍，解释一下。</p>
<p>但是！我看到有人问，怎么拷贝？？？what？？？</p>
<p>没想到吧，看书还是看漏了。</p>
<p>拷贝用的是uninitialized_copy，如果拷贝的是POD（标量型别，也就是trivial）调用的是copy（自己去看STL 的copy实现），如果是non-POD使用for循环遍历，调用construct，一个一个的构造，针对char<em>和wchar_t</em>，uninitialized_copy直接用memmove来执行复制行为，更加快。</p>
<p>版权声明：本文为CSDN博主「m0_60126088」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_60126088/article/details/119616254">https://blog.csdn.net/m0_60126088/article/details/119616254</a></p>
<p>虽然标准库提供了sort函数，但是一些函数也提供了自己的sort，当容器存在自己的sort的时候，优先使用容器自己的，它自己的肯定更好，不然它提供这个函数干嘛。</p>
<p>forward_list 和 list 提供了自己的 sort</p>
<p>forward_list使用头插法。因此只能在链表头插入元素。</p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6908.html">deque容器底层实现</a></p>
<p>queue 和 stack 由于元素进出的顺序是死的（固定的），因此他们没有迭代器，如果有迭代器的话，我们就有可能通过迭代器改变元素进出的顺序，这是不合理的。</p>
<p>set，map底层是红黑树（自平衡二叉查找树）</p>
<p>multimap不可以用下标做 iterator</p>
<p>hashtable 的 bucket 比 元素个数还有要多是合理的，因为元素中间会空出很多 bucket。事实上，bucket的个数肯定比元素个数多，否则的话 bucket 就要重新扩充变为原来的（大约）两倍。（经验法则，避免 bucket 的长度太长）（以空间换时间）</p>
<p>map的底部就是一个 pair</p>
<p>map，set 会丢掉重复元素</p>
<p>从测试结果我们可以看出，使用insert()插入元素的方式并不能覆盖掉相同key的值；而使用[]方式则可以覆盖掉之前的值。为什么会出现这样的结果呢？</p>
<p>原因分析<br>我们可以通过源码来找原因，在map的源码中，insert方法是这样定义的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type&amp; __x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> _M_t.<span class="built_in">insert_unique</span>(__x); &#125;</span><br></pre></td></tr></table></figure>

<p>他调用_M_t.insert_unique(_x)方法，该方法会首先遍历整个集合，判断是否存在相同的key，如果存在则直接返回，放弃插入操作。如果不存在才进行插入。<br>而[]方式是通过重载[]操作符来实现的，它直接进行插入或覆盖</p>
<blockquote>
<p> 今天调试程序，弄得有点纠结。无意间，和一帮同事讨论起一个问题：进程结束操作系统会回收new的内存吗？在自己的印象中，一直固执地认为，在使用C++操作分配对象内存后，如果程序员自己不用相应的delete操作回收的话，这块从堆内存是一直存在。在讨论中，有同事提醒说，在进程结束后，new操作的内存会被回收。但也只是结论，也说不出具体理由。</p>
<pre><code>没关系，何不google一下，一查下去，答案已是清晰：

“内存泄漏不是系统无法回收那片内存，而是你自己的应用程序无法使用那片内存。当你程序结束时，你所有分配的内存自动都被系统回收，不存在泄漏问题。但是在你程序的生命期内，如果你分配的内存都不回收，你将很快没内存使用。”再用自己的一句话来概括的话就是：操作系统本身就有内存管理的职责，一般而言，用malloc、new操作分配的内存，在进程结束后，操作系统是会自己的回收的。但某些系统态的资源，用特殊的系统API申请的内存就不一定了，比如：linux中的shmget申请的共享内存，就与进程结束无关了。

 经过这一番查找，不禁自己为自己汗颜了一把，之前还以为自己对内存管理理解较深，现在才明白：在没有认真深入地钻研过操作系统内核原理之前，所有对内存管理的理解还是浮在表面上的。这次讨论也分外地提醒自己，自己知识的盲区还有许多，还要不断的踏踏实实地努力学习啊！
</code></pre>
<hr>
<p> 版权声明：本文为CSDN博主「stanjiang2010」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/stanjiang2010/article/details/5386647">https://blog.csdn.net/stanjiang2010/article/details/5386647</a></p>
</blockquote>
<p>不建议使用分配器。</p>
<p>oop企图将data和method关联在一起</p>
<p>gp企图将data和method分离开</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/y1196645376/article/details/52938474">容器内存分配</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line">        PII p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">complex</span>(T _val) : <span class="built_in">val</span>(_val) &#123;&#125;</span><br><span class="line">        T val;</span><br><span class="line">        <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">        <span class="keyword">friend</span> complex&lt;U&gt; <span class="title">cal</span><span class="params">(complex&lt;U&gt; a, complex&lt;U&gt; b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">complex&lt;T&gt; <span class="title">cal</span><span class="params">(complex&lt;T&gt; a, complex &lt;T&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">complex&lt;T&gt; <span class="title">c</span><span class="params">(a.val + b.val)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">    <span class="comment">// return complex(a.val + b.val);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test3</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*====================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test::PII p = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    cout &lt;&lt; p.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">    <span class="function">complex&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">complex&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.val &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b.val &lt;&lt; endl;</span><br><span class="line">    complex&lt;<span class="type">int</span>&gt; c = <span class="built_in">cal</span>(a, b);</span><br><span class="line">    cout &lt;&lt; c.val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;vec &lt;&lt; endl;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);   <span class="comment">// add -&gt; cap:1</span></span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;vec &lt;&lt; endl;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);   <span class="comment">// add -&gt; cap:2</span></span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;(vec[<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);   <span class="comment">// add -&gt; cap:4</span></span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;(vec[<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);   <span class="comment">// add -&gt; cap:8</span></span><br><span class="line">    cout &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;(vec[<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i ++ )   vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; &amp;vec &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    cout &lt;&lt; m[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line">    cout &lt;&lt; m[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    m[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    m[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; m[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、alloactor"><a href="#二、alloactor" class="headerlink" title="二、alloactor"></a>二、alloactor</h2><p>容器的幕后英雄。</p>
<p>所有的分配和释放动作最后都会跑到 malloc 和 free 去。</p>
<p>分配器的 allocate 和 deallocate 最终都是使用 malloc 和 free</p>
<p>直接使用分配器在释放内存的时候，还需要指出需要释放的内存大小。</p>
<p>因此并不建议直接使用分配器分配内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *x = <span class="built_in">new</span>(<span class="string">&quot;hello&quot;</span>) <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;();   </span><br><span class="line">    <span class="type">int</span> *p = a.<span class="built_in">allocate</span>(<span class="number">512</span>, <span class="number">0</span>);</span><br><span class="line">    a.<span class="built_in">deallocate</span>(p, <span class="number">512</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="三、list"><a href="#三、list" class="headerlink" title="三、list"></a>三、list</h2><p>不允许 x++ ++</p>
<p>允许 ++ ++ x</p>
<p>所有的容器区间都是前闭后开</p>
<p>在链表中为了保证这个要求，必须要设置一个虚节点（为空）</p>
<h2 id="四、vector"><a href="#四、vector" class="headerlink" title="四、vector"></a>四、vector</h2><p>内存的扩充一般不会是原地扩充，它会在另一个地方找内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(vec) &lt;&lt; endl; <span class="comment">// 24 = 3 * 8(point)</span></span><br></pre></td></tr></table></figure>

<p>public 继承表示一种 is-a 的关系</p>
<h2 id="五、array"><a href="#五、array" class="headerlink" title="五、array"></a>五、array</h2><p>array 内部的数据就是一个真的数组，它没有tors</p>
<h2 id="六、deque"><a href="#六、deque" class="headerlink" title="六、deque"></a>六、deque</h2><p>号称自己拥有连续空间^^</p>
<p>连续是假象，分段是事实。</p>
<p>deque（dei ke）其实是分段连续的。deque的数据由许多个段组成，段与段之间不连续，每个段内连续。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i ++ )    q.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span> - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *x = &amp;q[i + <span class="number">1</span>], *y = &amp;q[i];</span><br><span class="line">        <span class="keyword">if</span>(y - x != <span class="number">-1</span>)  </span><br><span class="line">            cout &lt;&lt; y - x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; &amp;q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; &amp;q[i + <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试结果</span></span><br><span class="line"><span class="number">-5</span> <span class="number">0x19d4e6c</span> <span class="number">0x19d4e80</span></span><br><span class="line"><span class="number">-5</span> <span class="number">0x19d507c</span> <span class="number">0x19d5090</span></span><br><span class="line"><span class="number">-5</span> <span class="number">0x19d528c</span> <span class="number">0x19d52a0</span></span><br><span class="line"><span class="number">-5</span> <span class="number">0x19d549c</span> <span class="number">0x19d54b0</span></span><br><span class="line"><span class="number">-45</span> <span class="number">0x19d56ac</span> <span class="number">0x19d5760</span></span><br></pre></td></tr></table></figure>

<p>deque 的底部实现是一个 vector（称为 map ？？ ），vector 的每个元素是一个指针，每个指针指向一个缓冲区 buffer。</p>
<p>其迭代器是一个类</p>
<ol>
<li>first：当前所在 buffer 的起点</li>
<li>last：当前所在 buffer 的重点</li>
<li>node：处于（deque控制中心） 的那个段</li>
<li>cur：处于当前 buffer 的位置</li>
</ol>
<p>first 和 last 相当于两个哨兵[first，last) 前闭后开</p>
<p>迭代器在移动的过程中，每次移动都需要判断是否移动到了当前段的末尾，来决定是否需要调到下一个段。（效率低！每次都需要判断一下）</p>
<p>和 vector 一样，deque 也是 2 倍增长的，因此它也有 capacity，事实上标准库并未规定容器的增长细节，但是大多数实现都使用了 2 倍增长。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="type">clock_t</span> start;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )    q.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">clock</span>() - start) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )    vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">clock</span>() - start) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )    sum = q[i];</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">clock</span>() - start) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )    sum = vec[i];</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">clock</span>() - start) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15584</span></span><br><span class="line"><span class="number">16521</span></span><br><span class="line"><span class="number">79156</span></span><br><span class="line"><span class="number">3326</span></span><br></pre></td></tr></table></figure>

<p>deque 在拓展的时候 copy 方式是 copy 到新空间的中间位置，以方便前面和后面的扩充。</p>
<h2 id="八、queue"><a href="#八、queue" class="headerlink" title="八、queue"></a>八、queue</h2><p><code>queue&lt;int,  vector&lt;int&gt;&gt; q;</code> 可以通过编译</p>
<p>但是当我们使用 <code>q.pop();</code> 编译器报错</p>
<p>这说明编译器对模板不会进行一个全面的、完整的检测</p>
<p>只有当你用到时才会进行检测</p>
<h2 id="九、stack"><a href="#九、stack" class="headerlink" title="九、stack"></a>九、stack</h2><h2 id="十、Red-Black-tree"><a href="#十、Red-Black-tree" class="headerlink" title="十、Red-Black tree"></a>十、Red-Black tree</h2><p>关联式容器甚至可以看做一个小型数据库</p>
<p>关联式容器的两个重要的底层数据结构：红黑树和哈希表</p>
<p>红黑树就是一颗高度平衡的二叉搜索树</p>
<p>红黑树提供遍历操作和迭代器</p>
<p>编译器会将 size &#x3D; 0 的class 的size 设为 1</p>
<p>同 link，rb_tree 也设置了一个空节点实现前闭后开区间。</p>
<p>红黑树有【元素自动排序】特性</p>
<p>value[key,date]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; s; </span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : s)    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::value_type x = <span class="number">23.2332</span>;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::key_type y = <span class="number">2.3232</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::value_type p = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::value_type::first_type px = <span class="number">1</span>;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::value_type::second_type py = <span class="number">2</span>;</span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">char</span>&gt;::key_type c1 = <span class="number">65</span>;</span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">char</span>&gt;::mapped_type c2 = <span class="number">97</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; p.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; px &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; py &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c2 &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">test1</span>();</span><br><span class="line">    <span class="built_in">test2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="十一、hashtable"><a href="#十一、hashtable" class="headerlink" title="十一、hashtable"></a>十一、hashtable</h2><p>hashtable 中有很多经验值</p>
<p>经验法则：如果某个 bucket 的元素个数比 bucket 的个数还要多，就要两倍扩充 bucket 并重新放入元素（rehashing）。</p>
<h2 id="十二、-STL-六大部件"><a href="#十二、-STL-六大部件" class="headerlink" title="十二、 STL 六大部件"></a>十二、 STL 六大部件</h2><p>容器替我们处理了内存分配上的问题，我们只管往容器里面添加删除元素，至于数据在内存上是怎样分配的，容器替我们解决了。</p>
<p>容器本身并不能处理内存，它是通过分配器来实现内存的分配与回收的。</p>
<p>算法通过迭代器操作容器。</p>
<ol>
<li>容器</li>
<li>分配器</li>
<li>算法</li>
<li>迭代器</li>
<li>仿函数</li>
<li>适配器</li>
</ol>
<h2 id="十三、新添加待处理"><a href="#十三、新添加待处理" class="headerlink" title="十三、新添加待处理"></a>十三、新添加待处理</h2><p>ctor 有必要添加</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Base() &#123;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> val) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> val) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;   <span class="comment">// wrong</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>Explicitly specializer:全特化</p>
<hr>
<p>模版别名。</p>
<p>typedef 不可以使用参数</p>
<p>define 虽然可以指定参数，但是必须用（）包围起来，而我们希望使用 &lt;&gt; 包围起来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> v(T) vector<span class="string">&lt;T&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> vec = vector&lt;pair&lt;T,T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">v</span>(<span class="type">int</span>) a; <span class="comment">// 很奇怪</span></span><br><span class="line">    vec&lt;pair&lt;<span class="type">double</span>,<span class="type">double</span>&gt;&gt; v;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(Container c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从容器中取出迭代器</span></span><br><span class="line">    <span class="comment">// 每个迭代器都有一个 value_type</span></span><br><span class="line">    <span class="comment">// 通过 value_type 就可以得到容器元素的类型</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;<span class="keyword">typename</span> Container::iterator&gt;::value_type Valtype;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">        c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(), i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : c)    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">            <span class="keyword">typename</span> Container</span><br><span class="line">        &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container&lt;T&gt; c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">        c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(), i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : c)    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    C&lt;<span class="type">int</span>, vector&gt; c;</span><br><span class="line">    <span class="comment">// C&lt;int, list&gt; c;</span></span><br><span class="line">    <span class="comment">// C&lt;int, queue&gt; c;</span></span><br><span class="line">    <span class="comment">// C&lt;int, map&gt; c;</span></span><br><span class="line">    <span class="comment">// C&lt;int, set&gt; c;</span></span><br><span class="line">    <span class="comment">// C&lt;int, stack&gt; c;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/409436201">模板模板参数</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T a, b;</span><br><span class="line">    <span class="built_in">Foo</span>() &#123;</span><br><span class="line">        a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Ctor for Foo::&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dtor for Foo::&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">            <span class="keyword">class</span> <span class="title class_">Container</span></span><br><span class="line">        &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Foo&lt;T&gt; c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Ctor for C&quot;</span> &lt;&lt; endl;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;begin\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; c.a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c.b &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;end\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,</span><br><span class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">            <span class="keyword">class</span> <span class="title class_">Container</span></span><br><span class="line">        &gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Container&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// f(Foo&lt;int&gt;());</span></span><br><span class="line">    C&lt;<span class="type">int</span>, Foo&gt; c;</span><br><span class="line">    c.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<p>stl</p>
<p>traits：特征，特性</p>
<p>萃取机。</p>
<p>你丢给他某个东西，它可以萃取出这个东西的某些特征。</p>
<p>associated type:</p>
<blockquote>
<p>category</p>
<p>Value_type</p>
<p>Difference_type</p>
<p>pointer</p>
<p>reference</p>
</blockquote>
<p>中间件 for：</p>
<blockquote>
<p>class iterator</p>
<p>Native pointer</p>
<p>const native pointer</p>
</blockquote>
<p>算法所需要的信息：主要是迭代器的是怎么移动的（方向，大小）</p>
<p>虽然虽然可以直接向迭代器询问，迭代器也可以直接回答，但是如果迭代器不是一个 class，即迭代器如果是一个 native point 的话，他就没有 associate type（5个type），也就无法回答。这时候我们需要一个中间层（trait）来回答算法的询问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator_traits&lt;iterator&gt;::type;</span><br></pre></td></tr></table></figure>

<p>Bidirectional:双向</p>
<hr>
<p>typeid</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line">typeid(type).name();</span><br></pre></td></tr></table></figure>

<p>给 typeid 传入一个 type（typeid(type)），他就会生成一个对象，这个对象有 name() 方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out_tag</span><span class="params">(random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;random_access_iterator&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out_tag</span><span class="params">(bidirectional_iterator_tag)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;bidrectional_iterator_tag&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out_tag</span><span class="params">(forward_iterator_tag)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;forward_iterator_tag&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Itr&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out</span><span class="params">(Itr iter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;Itr&gt;::iterator_category category_obj;</span><br><span class="line">    <span class="built_in">out_tag</span>(category_obj);</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Itr&gt;::iterator_category category_type;</span><br><span class="line">    <span class="built_in">out_tag</span>(<span class="built_in">category_type</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;typeid: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(category_obj).<span class="built_in">name</span>() &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;typeid: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(<span class="built_in">category_type</span>()).<span class="built_in">name</span>() &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">out</span>(vector&lt;<span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    <span class="built_in">out</span>(set&lt;<span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    <span class="built_in">out</span>(multiset&lt;<span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    <span class="built_in">out</span>(unordered_set&lt;<span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Base b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;you call f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(Base *b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;you call g(*)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    <span class="built_in">f</span>(d);</span><br><span class="line">    Base *b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="built_in">g</span>(b);</span><br><span class="line">    Derived *pd = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="built_in">g</span>(pd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 继承表示 is-a 关系</span></span><br><span class="line"><span class="comment">因此可以把子类放到父类里面(子类 is-a 父类)*/</span></span><br></pre></td></tr></table></figure>



<hr>
<p>11 个算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">Myclass</span>() &#123; cout &lt;&lt; <span class="string">&quot;Myclass&quot;</span> &lt;&lt; endl; val = <span class="number">0</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Myclass</span>() &#123; cout &lt;&lt; <span class="string">&quot;Dtor for Myclass&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mystruct</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;Mstruct;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">Myclass</span>()); <span class="comment">// 生成一个临时对象，在 main 函数结束之前便结束</span></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), Mstruct);</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main-end&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. accumulate 累计(不是累加，因为还可以指定其他运算方式)</span></span><br><span class="line"><span class="comment">** 指定运算操作时，如果我们传入的是一个函数，那么直接传递函数名即可，</span></span><br><span class="line"><span class="comment">    因为此时相当于我们传入了一个函数指针，函数指针可以类似于函数直接调用。</span></span><br><span class="line"><span class="comment">    例如：void (*ptr)() = &amp;func;</span></span><br><span class="line"><span class="comment">          ptr(); // &lt;==&gt; func();</span></span><br><span class="line"><span class="comment">    但如果我们传入的是一个重载了 () 的函数对象</span></span><br><span class="line"><span class="comment">    我们就必须穿入一个对象，因为只有 class 被实例化为一个 object，</span></span><br><span class="line"><span class="comment">    才能调用它自己的成员函数。</span></span><br><span class="line"><span class="comment">    例如： struct Myclass &#123;</span></span><br><span class="line"><span class="comment">                int operator(int x, int y) &#123; return x + y; &#125;</span></span><br><span class="line"><span class="comment">            &#125;myobj;</span></span><br><span class="line"><span class="comment">            class Myclass &#123; </span></span><br><span class="line"><span class="comment">                int operator(int x, int y) &#123; return x + y; &#125;</span></span><br><span class="line"><span class="comment">            &#125;;</span></span><br><span class="line"><span class="comment">            直接传入 myobj 或者 myclass() 即可，</span></span><br><span class="line"><span class="comment">    如果成员函数是一个模版，还需要指定 &lt;type&gt;</span></span><br><span class="line"><span class="comment">    例如：标准库的 minus</span></span><br><span class="line"><span class="comment">            此时我们传入 minus&lt;int&gt;(); // 传入一个临时对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  2. for_each()</span></span><br><span class="line"><span class="comment">**  例如：</span></span><br><span class="line"><span class="comment">        void func(int x)&#123; cout &lt;&lt; x &lt;&lt; &#x27; &#x27;; &#125;</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt; a&#123;1, 2, 3&#125;;   </span></span><br><span class="line"><span class="comment">        for_each(a.begin(), a.end(), func); // 1 2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  3. replace, replace_if, replace_copy</span></span><br><span class="line"><span class="comment">        count, count_if</span></span><br><span class="line"><span class="comment">    ``` c++</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; a&#123;1, 4, 3, 4, 5&#125;;</span></span><br><span class="line"><span class="comment">    replace(a.begin(), a.end(), 4, 10);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : a)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 1 10 3 10 5 </span></span><br><span class="line"><span class="comment">    replace_if(a.begin(), a.end(), bind2nd(less&lt;int&gt;(), 10), 0);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : a)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 0 10 0 10 0 </span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; b(a.size()); // 必须为 b 分配空间，copy 不会分配空间</span></span><br><span class="line"><span class="comment">    replace_copy(a.begin(), a.end(), b.begin(), 0, 1);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : b)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 1 10 1 10 1 </span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; c; // 或者使用 back_inserter</span></span><br><span class="line"><span class="comment">    replace_copy(a.begin(), a.end(), back_inserter(c), 0, 1);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : c)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 1 10 1 10 1 </span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include &lt;iterator&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">using namespace std;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/* 1. accumulate 累计(不是累加，因为还可以指定其他运算方式)</span></span><br><span class="line"><span class="comment">** 指定运算操作时，如果我们传入的是一个函数，那么直接传递函数名即可，</span></span><br><span class="line"><span class="comment">    因为此时相当于我们传入了一个函数指针，函数指针可以类似于函数直接调用。</span></span><br><span class="line"><span class="comment">    例如：void (*ptr)() = &amp;func;</span></span><br><span class="line"><span class="comment">          ptr(); // &lt;==&gt; func();</span></span><br><span class="line"><span class="comment">    但如果我们传入的是一个重载了 () 的函数对象</span></span><br><span class="line"><span class="comment">    我们就必须穿入一个对象，因为只有 class 被实例化为一个 object，</span></span><br><span class="line"><span class="comment">    才能调用它自己的成员函数。</span></span><br><span class="line"><span class="comment">    例如： struct Myclass &#123;</span></span><br><span class="line"><span class="comment">                int operator(int x, int y) &#123; return x + y; &#125;</span></span><br><span class="line"><span class="comment">            &#125;myobj;</span></span><br><span class="line"><span class="comment">            class Myclass &#123; </span></span><br><span class="line"><span class="comment">                int operator(int x, int y) &#123; return x + y; &#125;</span></span><br><span class="line"><span class="comment">            &#125;;</span></span><br><span class="line"><span class="comment">            直接传入 myobj 或者 myclass() 即可，</span></span><br><span class="line"><span class="comment">    如果成员函数是一个模版，还需要指定 &lt;type&gt;</span></span><br><span class="line"><span class="comment">    例如：标准库的 minus</span></span><br><span class="line"><span class="comment">            此时我们传入 minus&lt;int&gt;(); // 传入一个临时对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  2. for_each()</span></span><br><span class="line"><span class="comment">**  例如：</span></span><br><span class="line"><span class="comment">        void func(int x)&#123; cout &lt;&lt; x &lt;&lt; &#x27; &#x27;; &#125;</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt; a&#123;1, 2, 3&#125;;   </span></span><br><span class="line"><span class="comment">        for_each(a.begin(), a.end(), func); // 1 2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  3. replace, replace_if, replace_copy</span></span><br><span class="line"><span class="comment">        count, count_if</span></span><br><span class="line"><span class="comment">     c++</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; a&#123;1, 4, 3, 4, 5&#125;;</span></span><br><span class="line"><span class="comment">    replace(a.begin(), a.end(), 4, 10);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : a)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 1 10 3 10 5 </span></span><br><span class="line"><span class="comment">    replace_if(a.begin(), a.end(), bind2nd(less&lt;int&gt;(), 10), 0);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : a)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 0 10 0 10 0 </span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; b(a.size()); // 必须为 b 分配空间，copy 不会分配空间</span></span><br><span class="line"><span class="comment">    replace_copy(a.begin(), a.end(), b.begin(), 0, 1);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : b)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 1 10 1 10 1 </span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; c; // 或者使用 back_inserter</span></span><br><span class="line"><span class="comment">    replace_copy(a.begin(), a.end(), back_inserter(c), 0, 1);</span></span><br><span class="line"><span class="comment">    for(auto &amp;x : c)    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;   </span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;   // 1 10 1 10 1 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    如果函数名后面跟着 _if 表示你要传入一个“条件”</span></span><br><span class="line"><span class="comment">    如果函数名后面跟着 _copy 表示你要传入一个 iterator 用来放置 copy 的元素</span></span><br><span class="line"><span class="comment">        并且作用结果不会作用到原迭代器身上，只是 copy 到新迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  4. find &amp; find_if -- 线性时间复杂度 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  5. sort</span></span><br><span class="line"><span class="comment">**   不要拿我们写的 cmp 用于 sort list 和 forward_list</span></span><br><span class="line"><span class="comment">      因为他们的地址不是连续的。而我们写的 cmp 是连续的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  6. binary_search</span></span><br><span class="line"><span class="comment">**   二分查找的前提是有序</span></span><br><span class="line"><span class="comment">     binary_search() 调用了 lower_bound()</span></span><br><span class="line"><span class="comment">     然后对 lower_bound 找到的位置进行比较</span></span><br><span class="line"><span class="comment">        first = lower_bound(first, val);</span></span><br><span class="line"><span class="comment">        return (first != last) &amp;&amp; (val &gt;= *first);</span></span><br><span class="line"><span class="comment">        // 我感觉后面的 val&gt;=*first 不太必要的，因为如果你 first != last 的话</span></span><br><span class="line"><span class="comment">            // 就说明你肯定找到了，既然找到了，那就应该是合理的！</span></span><br><span class="line"><span class="comment">                // 很奇怪，不知道为啥</span></span><br><span class="line"><span class="comment">     关于 lower/upper_bound</span></span><br><span class="line"><span class="comment">     候捷的解释：</span></span><br><span class="line"><span class="comment">        lower_bound 查找的是 在不改变原数据顺序的前提下</span></span><br><span class="line"><span class="comment">            插入元素可以放入的 最低点</span></span><br><span class="line"><span class="comment">        upper_bound 查找的是 在不改变原数据顺序的前提下</span></span><br><span class="line"><span class="comment">            插入元素可以放入的 最高点</span></span><br><span class="line"><span class="comment">     网络上一般的解释为：</span></span><br><span class="line"><span class="comment">        lower 查找 &lt;=</span></span><br><span class="line"><span class="comment">        upper 查找 &gt;</span></span><br><span class="line"><span class="comment">     其实一样，只不过说法不同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> begin = <span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(),<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> end = <span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(),<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; *begin &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; *end &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>adapter</p>
<ol>
<li>容器适配器</li>
<li>迭代器适配器</li>
<li>仿函数适配器</li>
</ol>
<p>一个对象 A 想拥有对象 B  的功能，有两种方式：</p>
<ol>
<li>inherit，继承</li>
<li>composition，复合</li>
</ol>
<p>adapter 是复合</p>
<p>typedef:</p>
<p>binary_function</p>
<ol>
<li>first_arguement_type</li>
<li>second_arguement_type</li>
<li>result_type</li>
</ol>
<p>unary_function</p>
<ol>
<li>Argument_type</li>
<li>Result_type</li>
</ol>
<p><code>typename + ()</code> 产生临时对象</p>
<p>借用函数模版的实参推导来完成类模板的实参。</p>
<blockquote>
<p>如果我们直接写类模板的实参 <code>&lt;&gt;</code>，我们可能不太好写出类型，我们可以添加一层中间层（函数模板），让函数模板来完成实参类型的推导，然后将类型传给类模板。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">typename</span> less&lt;<span class="type">int</span>&gt;::second_argument_type x = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">typename</span> less&lt;<span class="type">int</span>&gt;::first_argument_type y = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">typename</span> less&lt;<span class="type">int</span>&gt;::result_type z = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>);</span><br><span class="line">    binder2nd&lt;less&lt;<span class="type">int</span>&gt;&gt; b2;  <span class="comment">// wrong，已经弃用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Argument 并无参数的意思，之所以被拿来做(参数、变量)的意思是历史原因。</p>
<hr>
<p>bind</p>
<p>取代了 bind2nd, binder2nd, bind1st, binder1st</p>
<p>没写构造函数也可以用 <code>&#123;&#125;</code> 初始化</p>
<p>placeholoders</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">typename</span> less&lt;<span class="type">int</span>&gt;::second_argument_type x = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">typename</span> less&lt;<span class="type">int</span>&gt;::first_argument_type y = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">typename</span> less&lt;<span class="type">int</span>&gt;::result_type z = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// binder2nd&lt;less&lt;int&gt;&gt; b2;  // wrong，已经弃用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">my_divide</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// _1, _2。。 在 std::placeholders 里面</span></span><br><span class="line">    <span class="comment">// auto f1 = bind(my_divide, std::placeholders::_1, std::placeholders::_2);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; f1(10, 2) &lt;&lt; endl;   // 5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// auto f2 = bind(my_divide, std::placeholders::_2, std::placeholders::_1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; f2(10, 2) &lt;&lt; endl;   // 0.5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// auto f3 = bind(my_divide, 10, std::placeholders::_1);   // 这里 10 被绑定到第一个参数</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; f3(200) &lt;&lt; endl;  // 10 / 200</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// auto f5 = bind(my_divide, std::placeholders::_1, 10);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; f5(100) &lt;&lt; endl;    // 10</span></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    <span class="comment">/*  --  */</span></span><br><span class="line">    <span class="comment">/* 占位符_n会选择 [我们传入的] 第n个参数 */</span></span><br><span class="line">    <span class="keyword">auto</span> f4 = <span class="built_in">bind</span>(my_divide, <span class="number">10</span>, std::placeholders::_2);   <span class="comment">// 这里 10 被绑定到第一个参数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f4</span>(<span class="number">3</span>,<span class="number">2</span>) &lt;&lt; endl;   <span class="comment">// 3.33，选择我们传入的第二个参数2</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">auto</span> f6 = <span class="built_in">bind</span>(my_divide, std::placeholders::_2, <span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f6</span>(<span class="number">3</span>,<span class="number">5</span>) &lt;&lt; endl;    <span class="comment">// 5 / 10，选择我们传入的第二个参数5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test3</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/2023/06/15/RedBlackTree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/15/RedBlackTree/" class="post-title-link" itemprop="url">RBTree</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-15 20:20:57" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-16 10:07:12" itemprop="dateModified" datetime="2023-06-16T10:07:12+08:00">2023-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RBT"><a href="#RBT" class="headerlink" title="RBT"></a>RBT</h1><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/SwgIJV/">LC</a></p>
<p><a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/rbtree/">OI WiKi</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/julycoding/The-Art-Of-Programming-By-July-2nd/blob/master/ebook/code/c/4.4%EF%BC%9A%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88LCA%E9%97%AE%E9%A2%98.LCAProblem.c">github</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e136ec79235c">illustrate</a></p>
<h2 id="insight"><a href="#insight" class="headerlink" title="insight"></a>insight</h2><h2 id="completement"><a href="#completement" class="headerlink" title="completement"></a>completement</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/2023/06/15/C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/15/C++/" class="post-title-link" itemprop="url">C++ note</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-15 20:20:57" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-16 10:15:18" itemprop="dateModified" datetime="2023-06-16T10:15:18+08:00">2023-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="EssentialC"><a href="#EssentialC" class="headerlink" title="EssentialC++"></a>EssentialC++</h1><h2 id="0x00-附录"><a href="#0x00-附录" class="headerlink" title="0x00 附录"></a>0x00 附录</h2><h3 id="1-站在巨人的肩膀上"><a href="#1-站在巨人的肩膀上" class="headerlink" title="1. 站在巨人的肩膀上"></a>1. 站在巨人的肩膀上</h3><h3 id="2-英语"><a href="#2-英语" class="headerlink" title="2. 英语"></a>2. 英语</h3><p>parameter：参数列表</p>
<p>classes hierarchy：类层次体系</p>
<p>string literal：字符串常量</p>
<p>character literal：字符常量</p>
<p>dereferencing：(指针)解引用，提领</p>
<p>placehold：占位符</p>
<p>function prototype：函数原型</p>
<p>debugger：调试器</p>
<p>scopre：作用域</p>
<p>predicate：谓词</p>
<p>unary：一元</p>
<p>partition：分区</p>
<p>populate：填充 </p>
<h3 id="3-基于对象的编程风格"><a href="#3-基于对象的编程风格" class="headerlink" title="3. 基于对象的编程风格"></a>3. 基于对象的编程风格</h3><p>基于对象（Object Based）：使用了“对象“的概念，把状态和行为封装在一个对象的内部。</p>
<p>面向对象（Object Oriented）：使用了“对象”的概念，同时还有“继承”和“多态”的概念。</p>
<p>所以，<strong>面向对象</strong>基本上是<strong>基于对象</strong>的一个子集。同时由于面向对象很重视“继承”和“多态”，所以也可以认为面向对象更多是“<strong>面向类</strong>”的。</p>
<p>候捷：基于对象中，类之间的关系比较弱，而面向对象中，类之间的关系很密切。</p>
<h2 id="0xf2-函数与头文件"><a href="#0xf2-函数与头文件" class="headerlink" title="0xf2 函数与头文件"></a>0xf2 函数与头文件</h2><h3 id="1-随机数"><a href="#1-随机数" class="headerlink" title="1. 随机数"></a>1. 随机数</h3><p>如果希望使用(伪)随机数，可以通过 C 标准库的 srand() 和 rand() 函数实现。srand() 用来初始化随机数种子(seed)，一般使用时间来初始化：<code>srand(time(NULL));</code> 。而 rand() 则返回一个 int 范围内的随机数。这两个函数的声明位于头文件 <code>&lt;cstdlib&gt;</code> 中。</p>
<h3 id="2-exit"><a href="#2-exit" class="headerlink" title="2. exit()"></a>2. exit()</h3><p>exit() 的声明在 <code>&lt;cstdlib&gt;</code> 头文件中。 </p>
<h3 id="3-最值"><a href="#3-最值" class="headerlink" title="3. 最值"></a>3. 最值</h3><p>在头文件 <code>&lt;limits&gt;</code> 中的 <strong>class</strong> numeric_limits 中，由很多返回最值的函数。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="type">int</span> b = numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">    <span class="type">double</span> c = numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="type">double</span> d = numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">    <span class="type">double</span> e = numeric_limits&lt;<span class="type">char</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="type">double</span> f = numeric_limits&lt;<span class="type">char</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; e &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-string"><a href="#4-string" class="headerlink" title="4. string"></a>4. string</h3><p>string 居然还有 empty() 函数</p>
<h2 id="0x01-C-编程基础"><a href="#0x01-C-编程基础" class="headerlink" title="0x01 C++ 编程基础"></a>0x01 C++ 编程基础</h2><p>简要介绍了一些 C++ 的基础知识。</p>
<h3 id="1-1-类"><a href="#1-1-类" class="headerlink" title="1.1 类"></a>1.1 类</h3><p>class 机制，赋予了我们增加 <strong>“程序内之类型抽象化层次”</strong> 的能力。</p>
<blockquote>
<p>例如，如果我们要表示一个立方体的特征（体积特征和颜色特征），在最原始最基本的情况下，我们可以用三个浮点数来表示长宽高，一个整数表示颜色。以这么低级的方式来编程，势必让我们的思考不断在 “立方体的抽象类型” 和 “相应于立方体的三个浮点数和一个整数” 之间反复来回。</p>
<p>class 机制，赋予了我们增加 <strong>“程序内之类型抽象化层次”</strong> 的能力。我们可以定义一个 Volumn class 用来表示体积特征，定义一个 Color class 用来表示颜色特征，最后，用一个 Rectangle class 来包含这两个 class。这样，虽然我们同样使用三个浮点数和一个整数，但是我们的思考不在直接面对七个浮点数，而是转为对 Rectangle class 的思考。</p>
<p><strong>我们要记住，数据类型虽然为我们的编程任务提供了基石，但它们并非程序的重心所在。</strong></p>
</blockquote>
<p>一般来说，class 的定义分为两部分，分别写在不同的文件中。其一是所谓 “头文件”，用来声明该 class 的各种操作行为。另一个文件，程序代码文件，则包含了这些操作行为的实现内容。既，<strong>“机制与策略分离的思想”</strong></p>
<p><strong>delete 是语言关键字。</strong> 这也正是 string class 采用 erase() 而非 delete() 来表示 “删去一个字符” 的原因。</p>
<h3 id="1-2-输入和输出"><a href="#1-2-输入和输出" class="headerlink" title="1.2 输入和输出"></a>1.2 输入和输出</h3><p>数据的输入和输出，并非 C++ 语言本身定义的一部分（次精神同 C 语言），而是由 C++ 的一套面向对象的类层次体系（classes hierarchy）提供支持，并作为 C++ 标准库的一员。</p>
<p><strong>无论是标准输入输出，还是文件的输入输出，都是通过对象进行的。</strong></p>
<p>例如标准输入对象（cin），标准输出对象（cout）和标准错误输出对象（cerr）。我们的内容都是对对象执行读入和写入操作的。</p>
<p>标准错误输出和标准输出一样，都将输出结果定向到用户的终端。两者的唯一差别是：cerr 的输出结果并无缓冲区 —- 它会立即显示到用户的终端。（使用 iostream library 提供的操作符 ‘endl’ 可以输出并刷新缓冲区）。</p>
<p>C++ 中用于实现数据输入输出的流类及其继承关系。 </p>
<p><img src="https://s1.328888.xyz/2022/10/09/gk6tw.png" alt="img"></p>
<blockquote>
<p>istream：常用于接收从键盘输入的数据；<br>        ostream：常用于将数据输出到屏幕上；<br>        ifstream：用于读取文件中的数据；<br>        ofstream：用于向文件中写入数据；<br>        iostream：继承自 istream 和 ostream 类，因为该类的功能兼两者于一身，既能用于输入，也能用于输出；<br>        fstream：兼 ifstream 和 ofstream 类功能于一身，既能读取文件中的数据，又能向文件中写入数据。</p>
</blockquote>
<p>因此，如果我们需要使用文件来进行输入输出，我们首先需要实例化相应的文件输入输出对象。然后将标准输入输出对象换成文件输入输出对象即可。</p>
<p>文件的读写：</p>
<ol>
<li>为了打开一个可供输出的文件，我们定义一个 ofstream 对象，并将文件名传入：<code>ofstream outfile(&quot;a.txt&quot;);</code> 。便创建并构造函数初始化了一个 ofstream 对象 outfile。</li>
<li>为了打开一个可供输入的文件，我们定义一个 ifstream 对象，并将文件名传入：<code>ifstream infile(&quot;a.txt&quot;);</code> 。便创建并构造函数初始化了一个 ifstream 对象 infile。</li>
<li>如果想同时读写一个文件，我们得定义一个 fstream 对象，并将文件名和模式信息传入：<code>fstream iofile(&quot;a.txt&quot;, ios_base::app || ios_base::in);</code> 。其中 ios_base 定义了流打开模式信息。详细信息参考<a target="_blank" rel="noopener" href="https://www.apiref.com/cpp-zh/cpp/io/ios_base.html">官方文档</a></li>
</ol>
<h3 id="1-3-数据与运算符"><a href="#1-3-数据与运算符" class="headerlink" title="1.3 数据与运算符"></a>1.3 数据与运算符</h3><p>&lt;&lt; output 运算符</p>
<p>&lt;&lt; input 运算符</p>
<p>. dot 成员选择运算符</p>
<p>-&gt; arrow 成员选择运算符</p>
<p>字符常量分为两类：</p>
<ol>
<li>第一类是大打印字符。</li>
<li>第二类是不可打印字符，例如换行符(‘\n’)或制表符(‘\t’)。由于不可打印字符并无直接的表示法（这表示我们无法使用单一而可显示的字符来独立表示），所以必须以两个字符所组成的字符序列来表示。</li>
</ol>
<p>数据类型决定了对象所能持有的数值范围，同时也决定了对象应该占用多少内存空间。</p>
<p>相较于 C 语言只能采用 &#x3D;（assignment 运算符）来初始化，C ++ 为什么要额外增加构造函数语法来初始化对象呢？这主要是因为 C++ 增加了 class 的机制，例如 complex class，它的初始化需要两个值（一个实部一个虚部），而 assignment 运算符无法完成这个任务。于是增加构造函数来处理“多值初始化”</p>
<p>我们知道，windows下的路径表示使用 ‘\’，而 linux 下的路径表示使用 ‘&#x2F;’，由于 ‘\’ 是转义字符，所以说用字符串保存 windows 下的路径的时候，要使用两个 ‘\’。例如：</p>
<p><code>string path = F:\\essential\\prigram\\chapter1\\demo1.cpp;</code></p>
<p>数组的大小是一个<strong>常量表达式</strong>，它必须在编译时确定（常量可以在编译时确定），而普通变量只能在运行时确定。</p>
<h3 id="1-4-错误"><a href="#1-4-错误" class="headerlink" title="1.4 错误"></a>1.4 错误</h3><p>在 C++ 中，如果你没有在 main() 的末尾写下 return 语句，会自动加上，</p>
<p>off-by-one错误。</p>
<blockquote>
<p><strong>差一错误</strong>（英语：<strong>Off-by-one error</strong>，缩写<strong>OBOE</strong>）是在计数时由于边界条件判断失误导致结果多了一或少了一的错误，通常指<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B">计算机编程</a>中<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E5%BE%AA%E7%8E%AF">循环</a>多了一次或者少了一次的程序错误，属于<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E9%94%99%E8%AF%AF_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)">逻辑错误</a>的一种。比如，程序员在循环中进行比较的时候，本该使用“小于等于”，但却使用了“小于”，或者是程序员没有考虑到一个序列是从0而不是1开始（许多程序语言的数组下标都是这样）。在<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6">数学</a>领域，此错误也时有发生。</p>
</blockquote>
<h3 id="1-5-模版"><a href="#1-5-模版" class="headerlink" title="1.5 模版"></a>1.5 模版</h3><p>在模版中，数据类型作为一个参数存在，在对数据类型赋值时，要用尖括号（&lt;&gt;）包围。</p>
<h3 id="1-6-指针"><a href="#1-6-指针" class="headerlink" title="1.6 指针"></a>1.6 指针</h3><p>指针可以为程序提供一层间接性。从而为程序提供弹性（在第二章和第三章将深切体会）。</p>
<p><code>p-&gt;a</code> 等价于 <code>(*p).a</code> ，arrow 成员选择运算符主要是为了我们方便使用指针而提供的。</p>
<p>在 C++ 动态分配时也可以使用构造函数（将 a 初始化为 3）:<code>int *a = new int(3);</code></p>
<p>C++ 没有为没有提供任何语法让我们得以从 heap 分配数组的同时为其元素设定初值（C 语言可以使用 malloc）。</p>
<p><code>int *a = new int[3];</code></p>
<p>释放为数组分配的空间（[ ]必须放在变量名的前面，delete的后面）：<code>delete []a;</code></p>
<h3 id="1-7-命名空间"><a href="#1-7-命名空间" class="headerlink" title="1.7 命名空间"></a>1.7 命名空间</h3><p>把命名空间和操作系统的文件管理下不同文件夹下文件名的管理练习起来，就很容易理解了。</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-namespaces.html">菜鸟教程</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/namespaces-cpp?view=msvc-170">微软文档</a></p>
<p>练习：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> xjy &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;namespace xjy!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cs &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;namespace cs!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> xjy &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">refunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        xjy::<span class="built_in">func</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;rexjy&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> rexjy &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> xjy;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">refunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">        xjy::<span class="built_in">refunc</span>(); </span><br><span class="line">        <span class="comment">// 如果我们using引入的命名空间和当前命名空间存在相同的函数</span></span><br><span class="line">        <span class="comment">// 并且我们还没有使用namespace::加以区分的话</span></span><br><span class="line">        <span class="comment">// 默认使用自己命名空间下的函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;std&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//     func();</span></span><br><span class="line"><span class="comment">//     xjy::func();</span></span><br><span class="line"><span class="comment">//     xjy::refunc();</span></span><br><span class="line">    rexjy::<span class="built_in">refunc</span>();   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0x02-面向过程的编程风格"><a href="#0x02-面向过程的编程风格" class="headerlink" title="0x02 面向过程的编程风格"></a>0x02 面向过程的编程风格</h2><p>在原书中，通过一步步的优化，将一个简单的低级的函数优化为一个复杂的高级的函数。</p>
<h3 id="2-1-如何编写函数"><a href="#2-1-如何编写函数" class="headerlink" title="2.1 如何编写函数"></a>2.1 如何编写函数</h3><p>在规模较大的程序当中，将一部分的代码封装成函数独立出来又很多好处：</p>
<ol>
<li>用函数调用操作取代编写相同的程序代码，可以使代码更容易读懂。</li>
<li>可以在不同的程序中调用这些函数。</li>
<li>可以更容易地将工作分配给协作开发团队。</li>
</ol>
<p>函数参数扮演者占位符的角色。</p>
<p>函数必须先声明，然后才能被调用。函数的声明让编译器得以检查后续出现的使用方式是否正确 —- 是否有足够的参数，参数类型是否正确，等等。函数证明不必提供函数题，但必须指明返回类型，函数名以及参数列表。此即所谓的<strong>函数原型</strong>。</p>
<p>函数声明中可以忽略参数名，但是不推荐这样做。因为参数名可以为我们提供很多有用的信息。在编写文档的时候，为函数的声明提供参数名也是必要的（不然别人看了你的文档中的某个函数就会一头雾水）。</p>
<p>如果函数的最后一条语句不是 return，那么最后一条语句之后便是该函数的<strong>隐式退出点</strong>。当然，前提是函数的返回类型是 void 你才可以这么做。</p>
<h3 id="2-2-调用函数"><a href="#2-2-调用函数" class="headerlink" title="2.2 调用函数"></a>2.2 调用函数</h3><h4 id="2-2-1-传引用"><a href="#2-2-1-传引用" class="headerlink" title="2.2.1 传引用"></a>2.2.1 传引用</h4><p>by reference（传引用，传址）:所有的引用占用同一个地址（被引用元素的地址）。</p>
<p>C++ 不允许我们改变 reference 所代表的对象，它们必须<strong>从一而终</strong>。reference也必须只想一个对象。</p>
<p>面对 reference 的所有操作和面对 “reference所代表的对象” 所进行的操作一般无二。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> &amp;p1 = a;</span><br><span class="line">    <span class="type">int</span> &amp;p2 = a; </span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; &amp;p1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; &amp;p2 &lt;&lt; endl;</span><br><span class="line">    p1 = <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">    a = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// &amp;p1 = b; // 编译错误</span></span><br><span class="line">    <span class="comment">//int &amp;p3; //Error: &#x27;p3&#x27; declared as reference but not initialized</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 1 1</span><br><span class="line">0x7fffc7134da8 0x7fffc7134da8 0x7fffc7134da8</span><br><span class="line">2 2 2</span><br><span class="line">3 3 3</span><br></pre></td></tr></table></figure>



<p>当我们以 by reference 方式将对象作为函数参数传入时，对象本身并不会复制出另一份 —— 复制的是对象的地址。函数中对该对象进行的任何操作，都是相当于对传入的对象进行<strong>间接操作</strong>。</p>
<p>以 by reference 的方式传入对象有两个理由：</p>
<ol>
<li>得以直接对所传入的对象进行修改。</li>
<li>降低复制大型对象的额外负担以提高程序效率。在这种情况下，我们可能并不想修改对象，为了保证程序的安全性，我们需要将参数同时声明为 const 类型来必然修改对象的操作。</li>
</ol>
<p>在传递参数时，使用 reference 或 point 的区别大致是用法不同罢了，reference 更简单？但是这两种方式传入的参数区别就很大了！point 可能是个空指针，因此当我们 deference 的时候，一定要先确定其值不为空。至于 reference，则必定会代表某个对象，所以不需要做额外的检查。</p>
<p>如果我们想要在函数中返回一个 vector 对象，无论是 point 还是 reference 都是不正确的，因为函数中的 vector 对象是分配在程序堆栈（program stack）上的，在函数结束时就会被释放（实际上是从 stack 中 pop掉了）。但是我们可以在函数中以传值方式返回该 vector 对象，因此返回的乃时对象的副本，它在函数之外依然存在。如下 func1()：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">3</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : a)    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于数组我们没法以 by value 的方式返回，因为数组的本质就是一个指针（by point）。</p>
<p>大多数 C++ 编译器对于 “以 by value 方式返回的 class object” ，都会通过优化程序，加上额外的 reference 参数。</p>
</blockquote>
<h4 id="2-2-2-冒泡排序"><a href="#2-2-2-冒泡排序" class="headerlink" title="2.2.2 冒泡排序"></a>2.2.2 冒泡排序</h4><p>所谓冒泡排序，就是将大的数据或者小的数据冒泡到数据的顶部（我们假设下标为 0 的位置为顶部）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vec)</span> <span class="comment">// 升序排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++ )</span><br><span class="line">            <span class="keyword">if</span>(vec[i] &gt; vec[j])</span><br><span class="line">                <span class="built_in">swap</span>(vec[i], vec[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	再该函数中，每次for:i，就可以确定下标为i的位置经过排序后的值。它的思路是那未经排序时该位置的值和所有未确定位置([i+1,j])的值进行比较，如果比未确定位置的值大就交换，最后就可以找到一个最小值然后放在该位置。</span></span><br><span class="line"><span class="comment">	整个过程就好像把所有数值小的元素冒泡到数组顶部一样。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="2-2-3-作为开关的参数"><a href="#2-2-3-作为开关的参数" class="headerlink" title="2.2.3 作为开关的参数"></a>2.2.3 作为开关的参数</h4><p>​								<strong>——- 为参数提供默认值</strong></p>
<p>在 C++ 中，我们可以为参数提供默认值，所有提供了默认值的参数都必须放在参数列表的末尾。</p>
<p>我们可以利用这个语法，将函数的参数作为一个开关。</p>
<p>例如上面我们编写的冒泡排序。如果我们想要打印排序的流程，即在函数中插入一些 printf() 函数，我们总不能为了这个功能而额外添加一个函数吧，毕竟这个功能可能很少用到。我们也不能在原函数直接添加 printf() 函数吧，当元素很多时，大量的打印信息会造成极大的浪费。</p>
<p>一个方便的且拓展性好的方式是为函数增加一个 “开关” 参数，这个参数作为是否打印信息的 “开关”，默认情况下，这个开关是关闭（设定一个初始值）的，我们甚至可以 “忽略这个参数”，即视这个参数不存在。只有当我们需要打印信息时，传入一个我们设定好的开关参数，函数就会打印我们想要的信息。如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vec, <span class="type">bool</span> flag = <span class="literal">false</span>)</span> <span class="comment">// 升序排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">true</span>)	</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(vec[i] &gt; vec[j])</span><br><span class="line">                <span class="built_in">swap</span>(vec[i], vec[j]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们甚至可以将 bool 类型替换为 int 类型来为这个参数增加更多的功能。</p>
</blockquote>
<p>不过为函数参数提供默认值会给我们带来一个问题，那就是这个默认值是在函数声明时提供，<strong>但不能同时在声明和定义处提供</strong>，还是都提供呢？</p>
<blockquote>
<p><strong>为什么不能在声明和定义处都提供呢？</strong></p>
<p>声明是用户可以看到的部分，<strong>客户非常信任</strong>地使用这个特性，希望得到一定的结果，但是你在实现里使用了不同的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BC%BA%E7%9C%81%E5%80%BC&spm=1001.2101.3001.7020">缺省值</a>，那么将是灾难性的。因此编译器禁止声明和定义时同时定义缺省参数值。</p>
<p><strong>结论：在声明处提供默认值更好！</strong></p>
<p>若声明时没有定义缺省参数值，那么在定义成员函数时可以定义缺省参数值。但这种情况通常<strong>用户是看不见的</strong>，因此应避免。</p>
<p><strong>核心：用户就是上帝！</strong></p>
</blockquote>
<p>在我看来，为参数提供默认值更像是一种<strong>机制</strong>，而你是否使用这个对象（你可以不为这个对象提供参数值，看起来就是好像没有使用这个对象一样），或者是否使用这个默认值更像是一种<strong>策略</strong>。（结合上面冒泡排序的例子理解）</p>
<h3 id="2-3-使用局部静态对象"><a href="#2-3-使用局部静态对象" class="headerlink" title="2.3 使用局部静态对象"></a>2.3 使用局部静态对象</h3><p><strong>为了节省函数之间的通信而将对象定义于 file scope，永远都是一种冒险</strong>。通常，file scope 对象会打乱不同函数之间的<strong>独立性</strong>，使他们难以理解。</p>
<blockquote>
<p>能不定义全局对象，就不要定义全局对象。</p>
</blockquote>
<p>一种好的方式是声明静态对象。</p>
<h3 id="2-4-声明-inline-函数"><a href="#2-4-声明-inline-函数" class="headerlink" title="2.4 声明 inline 函数"></a>2.4 声明 inline 函数</h3><p>将函数声明为 inline，表示<strong>要求</strong>编译器在每个函数函数调用点上，将函数的内容展开。面对一个 inline 函数调用操作，编译器可将该函数的调用操作该为以一份该函数的副本代替。</p>
<p>将函数指定为 inline，只是对编译器提出的一种 <strong>“要求”</strong> 或者说 <strong>“建议”</strong>，也就是说 inline 并不是一种强制性操作。编译器是否执行这项请求，需视编译器而定。</p>
<p>inline 函数的定义，通常放在头文件中。由于编译器必须在它被调用的时候加以展开，所以这个时候其定义必须时有效的。（也就是声明和定义必须在同一个文件当中）</p>
<blockquote>
<p>实测 inline 函数不会再初始化后展开。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/my_life/articles/4089184.html">参考</a></p>
<h3 id="2-5-重载函数"><a href="#2-5-重载函数" class="headerlink" title="2.5 重载函数"></a>2.5 重载函数</h3><p>编译器无法根据类型来区分两个具有相同名称的函数，因为返回类型无法给我们一个足以区分不同重载函数的语境。（你 TM 知道我想返回什么类型？）</p>
<h3 id="2-6-模版函数"><a href="#2-6-模版函数" class="headerlink" title="2.6 模版函数"></a>2.6 模版函数</h3><p>函数模版是一种 <strong>“机制”</strong>，让我们得以将单一函数的内容与希望显示的各种类型绑定（bind）起来。</p>
<p>function template 将参数列表中指定的全部（或部分）参数的类型信息抽离了出来。</p>
<p>function template 以关键字 template 开场，其后紧接着成对尖括号（&lt; &gt;）包围起来的一个或多个标识符。这些标识符表示我们希望 <strong>“推迟决定”</strong> 的数据类型。这些标识符事实上扮演着占位符的角色，用来放置函数参数列表及函数题中的某些实际数据类型。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ta, <span class="keyword">typename</span> Tb&gt;</span><br><span class="line"><span class="function">Ta <span class="title">MAX</span><span class="params">(Ta a, Tb b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">double</span> c = <span class="number">2.43</span>, d = <span class="number">4.34</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MAX</span>(a, b) &lt;&lt; endl &lt;&lt; <span class="built_in">MAX</span>(c, d) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当我们以某种类型调用模版函数时，编译器会将类型与我们模版中的定义绑定（bind）起来，然后生成一份函数实例（参数类型确定）。</p>
<blockquote>
<p>同 inline 函数，这应该是在编译时做的操作。</p>
</blockquote>
<h3 id="2-7-函数指针数组"><a href="#2-7-函数指针数组" class="headerlink" title="2.7 函数指针数组"></a>2.7 函数指针数组</h3><p>直接举例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x;     &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef个一个type，type的实例是一个返回值类型为int</span></span><br><span class="line"><span class="comment">// 有一个int类型参数的函数值怎</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*handler)</span><span class="params">(<span class="type">int</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数指针数组</span></span><br><span class="line">handler cal[<span class="number">3</span>] = &#123;</span><br><span class="line">    &amp;func1, &amp;func2, &amp;func3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">        cout &lt;&lt; cal[i](val) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在定义函数指针数组的时候，最好将函数指针 typedef 成一个单独的类型，这样方便我们编写代码。否则，看看下面的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*cal[<span class="number">3</span>])(<span class="type">int</span>) = &#123;</span><br><span class="line">    &amp;func1, &amp;func2, &amp;func3</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还好理解吗？更复杂一点的呢？（例如返回值类型为指针 or 指向指针的指针。。。）</p>
<p>一定要区分<strong>函数指针</strong> 和 <strong>指针函数</strong></p>
<blockquote>
<p><code>int (*cal)(int, int);</code>	– 函数指针，是一个指针，指针指向一个函数</p>
<p><code>int *cal(int,int);</code>		– 指针函数，是一个函数，函数的返回值类型为一个指针</p>
<p>差异的根源在于同是单目运算符的优先级从右向左。</p>
</blockquote>
<h3 id="2-8-设定头文件"><a href="#2-8-设定头文件" class="headerlink" title="2.8 设定头文件"></a>2.8 设定头文件</h3><p>头文件的拓展名习惯上是 <code>.h</code> 。标准库例外，它没有拓展名。</p>
<p>程序的定义可以有多份，但是声明只能有一份。（机制只能有一个，但是基于机制的策略可以有很多种）。但是有个例外：inline 函数的定义。为了能够拓展 inline 函数的内容，在每个调用点上，编译器都取得其定义。这意味着我们必须将 inline 函数的定义放在头文件中，而不是把它放在各个不同的程序代码文件中。还有个例外就是 const object。和 inline 一样，const 也是 “一次定义” 规则下的例外。<strong>const object 的定义只要一出文件之外便不可见</strong>。这意味着我们可以在多个程序代码文件中加以定义，不会导致任何错误。</p>
<blockquote>
<p>关于 const object 的定义一出文件之外便不可见是 C ++ 独有的性质， C并不具备这个性质。</p>
<p><strong>原因：c++中 const 具有内部链接性，c 中 const默认外部链接性。</strong></p>
<p>我们可以测试一下，有两个文件：</p>
<p>1.c&#x2F;1.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> val = <span class="number">2038</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">func</span>();</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;1.c val = %d\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.c&#x2F;2.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> val = <span class="number">222</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;2.c val = %d\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们以 <code>.c</code> 的后缀编译这两个文件的时候，编译器会给出重定义错误，但如果我们以 <code>.cpp</code> 的后缀编译这两个文件，就可以正常执行。</p>
</blockquote>
<p>一个关于 C++ 中的 const 变量定义在源文件还是头文件的建议：</p>
<blockquote>
<p>作者：雨落惊风<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21622061/answer/2373761045">https://www.zhihu.com/question/21622061/answer/2373761045</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>以下仅适用于c++中（c中有区别，原因：c++中const具有内部链接性，c中const默认外部链接性）</p>
<p>const&#x2F;constexpr定义放在头文件中，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;优点：编译器在进行分离编译时，由于在每个文件中都可以看到<span class="type">const</span>的定义，</span><br><span class="line">从而可以进行编译优化</span><br><span class="line">&gt;缺点：如果编译优化并未发生，</span><br><span class="line">  <span class="number">1.</span> 由于<span class="type">const</span>的内部链接性，每个文件都保存了一份<span class="type">const</span>的副本，</span><br><span class="line">       编译后，内存占用可能过大。</span><br><span class="line">    <span class="number">2.</span> 当对<span class="type">const</span>有变更需求时，每个包含头文件的.cpp文件都需要重新编译，</span><br><span class="line">       编译时间可能很长。</span><br></pre></td></tr></table></figure>

<p>const定义放在源文件中，并在.h头文件中包含对其声明，使用const的.cpp文件包含头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;优点：<span class="number">1.</span> <span class="keyword">extern</span> <span class="type">const</span>作为共享变量，仅仅在定义的.cpp文件被实例化<span class="number">1</span>次，</span><br><span class="line">       使用<span class="type">const</span>的.cpp文件只是包含头文件，</span><br><span class="line">       链接器负责链接到<span class="type">const</span>定义。所以，内存空间占用相对变小。</span><br><span class="line">    <span class="number">2.</span> 由于分离编译，当有需求变更<span class="type">const</span>变量时，仅需要重新编译</span><br><span class="line">       定义<span class="type">const</span>的.cpp源文件即可，其他使用<span class="type">const</span>的.cpp文件，由链接器</span><br><span class="line">       代劳链接到重新编译好的<span class="type">const</span>上，无需对使用<span class="type">const</span>的文件重新编译(g++ -c)。</span><br><span class="line">       所以，编译时间相对变少。</span><br><span class="line">&gt;缺点：当头文件被预处理器展开后，由于其中只有<span class="type">const</span>变量的声明，编译器在</span><br><span class="line">    分离编译时无法获取<span class="type">const</span>的定义值，所以存在无法进行编译优化的问题，</span><br><span class="line">    比如替换<span class="type">const</span>为对应值（做不到啊，<span class="type">const</span>值是啥！）</span><br></pre></td></tr></table></figure>

<p>所以，</p>
<p>如果你在意你程序内存的大小以及出版本时的编译速度（不用加班，oho），你就将const定义放在源文件中，const声明放在头文件中；</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;xxx.cpp</span><br><span class="line">&gt;extern const int noWantJiaBan = ...</span><br><span class="line"></span><br><span class="line">&gt;xxx.h</span><br><span class="line">&gt;extern const int noWantJiaBan;</span><br><span class="line"></span><br><span class="line">&gt;xxx.cpp</span><br><span class="line">&gt;#include &quot;xxx.h&quot;</span><br></pre></td></tr></table></figure>

<p>如果你在意编译优化，那么const定义就放直接放在头文件中.</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;xxx.h</span><br><span class="line">&gt;const int optimizable = ...</span><br><span class="line"></span><br><span class="line">&gt;xxx.cpp</span><br><span class="line">&gt;#include &quot;xxx.h&quot; </span><br></pre></td></tr></table></figure>
</blockquote>
<p>在 file scope 定义的对象，如果可能被多个文件访问，就应该声明于头文件中。因为如果我们没有在程序中声明某个对象，便无法加以访问。</p>
<p>关于头文件由 &lt;&gt; 或者 “” 包围的说明</p>
<blockquote>
<p>更有技术含量的回答是：</p>
<p>如果此文件被认定为标准的成项目的或项目专属的头文件，我们便以尖括号将文件名括住；当编译器搜索此文件时，会先在某些默认的磁盘目录中寻找。</p>
<p>如果此头文件由成对的双引号括住，此文件便被认为是一个用户提供的头文件；搜索此文件时，会由要包含此文件的文件的所在磁盘目录开始找起。</p>
</blockquote>
<h2 id="0x03-范型编程风格"><a href="#0x03-范型编程风格" class="headerlink" title="0x03 范型编程风格"></a>0x03 范型编程风格</h2><h3 id="1-STL"><a href="#1-STL" class="headerlink" title="1. STL"></a>1. STL</h3><p>STL：standard template library</p>
<p>组成：</p>
<ol>
<li>container：<ol>
<li>顺序容器：vector, list, deque, ..</li>
<li>关联容器：map, set, ..</li>
<li>容器适配器：stack, queue, ..</li>
</ol>
</li>
<li>generic algorithm：</li>
</ol>
<p>顺序容器</p>
<blockquote>
<p>顺序容器内元素的地址并不一定连续，但是它的元素位置一定连续。</p>
<p>vector 和 deque 支持随机索引。</p>
<p>list 和 deque 支持双向插入。</p>
</blockquote>
<p>插入（insert）</p>
<blockquote>
<p>push_back 和 push_pop 是特殊的插入操作。</p>
<p>insert 的四种变形：</p>
<p>1. </p>
</blockquote>
<p>范型算法系通过 function template 技术，达到 “与操作对象的类型相互独立” 的目的。而<strong>实现 “与容器无关” 的诀窍，就是不要直接在容器身上进行操作。</strong> 而是借由一对 iterator（first 和 last），表示我们要进行迭代的元素范围。</p>
<blockquote>
<p>对于 iterator last，我们一般将其设置为容器的<strong>终点位置（最后一个元素的下一个位置）</strong>，而不是最后一个元素的位置。并称其为 “哨兵”。</p>
</blockquote>
<h3 id="2-编写你的模板函数-find"><a href="#2-编写你的模板函数-find" class="headerlink" title="2. 编写你的模板函数 - find"></a>2. 编写你的模板函数 - find</h3><p>通过模版来屏蔽元素类型</p>
<p>如何屏蔽容器类型：如果我们使用指针来查找元素的话，那么我们传入某个容器的指针。如果我们能够把指针抽象，无论是哪个容器的指针，我们都能把他们看作普通的 “指针”，这样我们就实现了屏蔽容器的类型。</p>
<blockquote>
<p>vector !&#x3D; array</p>
<p>虽然可以用 array 给 vector 初始化，但是 vector 和 array 仍然是两个概念。</p>
</blockquote>
<p><strong>&lt; — 暂停更新，实在是太费时间，接下来只记录一些书上没有明确说明的nearing – &gt;</strong></p>
<h3 id="3-根据-const-重载"><a href="#3-根据-const-重载" class="headerlink" title="3. 根据 const 重载"></a>3. 根据 const 重载</h3><p>可以根据一个函数是否是 const 的重载，这里的 const 修饰的是函数而不是返回类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">get</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">        </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// compile error</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// accept</span></span><br></pre></td></tr></table></figure>



<h3 id="4-static-in-C-x2F-Cpp"><a href="#4-static-in-C-x2F-Cpp" class="headerlink" title="4. static in C&#x2F;Cpp"></a>4. static in C&#x2F;Cpp</h3><p>static 在 C 中一般作为静态全局&#x2F;局部变量和静态函数存在。</p>
<p>静态函数：</p>
<ol>
<li><p>静态函数的作用域为当前的源文件（屏蔽功能），而局部函数的作用域为整个工程。</p>
</li>
<li><p>静态函数会被一直放在一个一直使用的存储区，直到退出应用程序实列，避免了调用函数时的压栈和出栈，速度快很多。</p>
</li>
</ol>
<p>在 C++ 的 class 中，static 拓展出了 static member function 和 static member variable</p>
<h3 id="5-cerr-amp-amp-cout"><a href="#5-cerr-amp-amp-cout" class="headerlink" title="5. cerr &amp;&amp; cout"></a>5. cerr &amp;&amp; cout</h3><p>std::cerr是标准错误输出流，不需要缓存，直接显示在显示器上，而且只能显示到显示器上，即std::cerr流不能转向。</p>
<p>std::cout需要缓冲区（目的是为了减少屏幕刷新次数，一次全部显示），std::cout流可以转向，例如可将cout流流向文件操作中去。</p>
<p>1.区别<br>cout对应于标准输出流，默认情况下是显示器。这是一个被缓冲的输出，可以被重定向。<br>cerr对应标准错误流，用于显示错误消息。默认情况下被关联到标准输出流，但它不被缓冲，也就说错误消息可以直接发送到显示器，而无需等到缓冲区或者新的换行符时，才被显示。一般情况下不被重定向。</p>
<p>2.为什么要用cerr<br>比如，你的程序遇到调用栈用完了的威胁（无限，没有出口的递归）。<br>你说，你到什么地方借内存，存放你的错误信息？<br>所以有了cerr。其目的，就是在你最需要它的紧急情况下，还能得到输出功能的支持。 缓冲区的目的，就是减少刷屏的次数——比如，你的程序输出圣经中的一篇文章。不带缓冲的话，就会每写一个字母，就输出一个字母，然后刷屏。有了缓冲，你将看到若干句子“同时”就出现在了屏幕上（由内存翻新到显存，然后刷新屏幕）。</p>
<blockquote>
<p>by xjy</p>
<p>因此说 cerr 更像是一种需要在紧急情况下做输出的东西，他并不会终止程序的运行。</p>
</blockquote>
<h3 id="6-enum-的作用域"><a href="#6-enum-的作用域" class="headerlink" title="6. enum 的作用域"></a>6. enum 的作用域</h3><p>enum 内元素的作用域是全局的，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">E1</span> &#123;</span><br><span class="line">    a, b</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">E2</span> &#123;</span><br><span class="line">    a, b</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* compile error</span></span><br><span class="line"><span class="comment">error: &#x27;a&#x27; conflicts with a previous declaration</span></span><br><span class="line"><span class="comment">error: &#x27;b&#x27; conflicts with a previous declaration</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>如果我们确实需要在不同的 enum 内声明重名的枚举量，C++ 11 位我们提供了一种新的枚举类型（enum class），其枚举的作用域为类。</p>
<p>这样编译就不会出错，但是使用的时候要加上枚举名来限定枚举量。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">e1</span>&#123;</span><br><span class="line">    d,a,b,c</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">e2</span>&#123;</span><br><span class="line">    b,c,e,a</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e1 var1 = e1::a;</span><br><span class="line">    e2 var2 = e2::a;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 必须强制类型转换</span></span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span>)var1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span>)var2 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于更详细的 enum 和 enum class 的比较 和 enum class 的介绍：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42817477/article/details/109029172?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-109029172-blog-78535754.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-109029172-blog-78535754.pc_relevant_recovery_v2&utm_relevant_index=3">[reference]</a></p>
</blockquote>
<h3 id="7-将临时对象作为参数传给引用"><a href="#7-将临时对象作为参数传给引用" class="headerlink" title="7. 将临时对象作为参数传给引用"></a>7. 将临时对象作为参数传给引用</h3><p>试看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;getx: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;getx: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">g</span>(a+b);</span><br><span class="line">    <span class="comment">//f(a+b);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>上面的两个调用之前，a+b 的值会存在一个临时变量中，当把这个临时变量传给函数 g 时，由于 g 的声明中，参数是 int&amp;，不是常量引用，所以产生以下编译错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.cpp:8:7: error: cannot bind non-const lvalue reference of type &#x27;int&amp;&#x27; to an rvalue of type &#x27;int&#x27;</span><br><span class="line">    8 |     g(3);</span><br></pre></td></tr></table></figure>

<p>意思就是我们不能将一个作为左值 int 引用和一个 int 绑定。</p>
<p>而在 f(a+b) 中，由于 f 定义的参数是 const int&amp;，编译通过。  问题是为什么临时变量作为引用参数传递时，必须是常量引用呢？很多人对此的解释<strong>是临时变量是常量，不允许赋或者改动</strong>，所以当作为非常量引用传递时，编译器就会报错。这个解释在关于理解临时变量不能作为非 const 引用参数这个问题上是可以的，但不够准确。事实上，临时变量是可以被作为左值(LValue)并被赋值的，请看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> test <span class="keyword">operator</span>+(<span class="type">const</span> test &amp;p1, <span class="type">const</span> test &amp;p2);</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> test &amp;p);</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">test</span>() &#123;&#125;</span><br><span class="line">        <span class="built_in">test</span>(<span class="type">int</span> _x) : <span class="built_in">x</span>(_x) &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test <span class="keyword">operator</span>+(<span class="type">const</span> test &amp;p1, <span class="type">const</span> test &amp;p2)</span><br><span class="line">&#123;</span><br><span class="line">    test p3;</span><br><span class="line">    p3.x = p1.x + p2.x;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;you get here!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> p3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> test &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; p.x;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">test <span class="title">a</span><span class="params">(<span class="number">2</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">3</span>)</span>, <span class="title">c</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; ((a + b) = c) &lt;&lt; endl;  <span class="comment">// 临时对象作为左值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// int x = 1, y = 2, z = 3;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; ((x + y) = z) &lt;&lt; endl; // 编译不通过</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面的程序编译通过，而且运行结果是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">you get here!</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>



<p>临时变量确实被赋值，而且成功了。</p>
<blockquote>
<p>至于为什么能成功，作者并没有说，但是从我们在 operator+ 重载函数插入的 cout 语句以及输出可以看出，应该是在 a+b 时调用了该函数，然后生成了一个 “对象”，该对象可以作为左值。</p>
<p>而在 main 函数的最后两条语句，(x+y)&#x3D;z 编译就不通过，大概是因为 x+y 生成的不算是一个 “对象”，而只是一个单纯的值罢了。</p>
</blockquote>
<p>所以，临时变量不能作为非 const 引用参数，不是因为他是常量，而是因为 c++ 编译器的一个关于语义的限制。如果一个参数是以非 const 引用传入，c++ 编译器就有理由认为程序员会在函数中修改这个值，并且这个被修改的引用在函数返回后要发挥作用。</p>
<p>但如果你把一个临时变量当作非 const 引用参数传进来，由于临时变量的特殊性，程序员并不能操作临时变量，而且临时变量随时可能被释放掉，所以，一般说来，修改一个临时变量是毫无意义的，据此，c++ 编译器加入了临时变量不能作为非const 引用的这个语义限制，意在限制这个非常规用法的潜在错误。</p>
<p>还不明白？OK，我们说直白一点，如果你把临时变量作为非 const 引用参数传递，一方面，在函数申明中，使用非常量型的引用告诉编译器你需要得到函数对某个对象的修改结果，可是你自己又不给变量起名字，直接丢弃了函数的修改结果，编译器只能说：“大哥，你这是干啥呢，告诉我把结果给你，等我把结果给你了，你又直接给扔了，你这不是在玩我呢吗？”所以编译器一怒之下就不让过了。这下大家明白了吧？</p>
<blockquote>
<p>所以说，临时对象只能作为右值的理解是片面的。</p>
<p>一个对象必然有左值和右值，系统是否提供给用户使用则是另外一码事</p>
</blockquote>
<h2 id="0x04-基于对象的编程风格"><a href="#0x04-基于对象的编程风格" class="headerlink" title="0x04 基于对象的编程风格"></a>0x04 基于对象的编程风格</h2><h3 id="1-operand-gt-amp-amp"><a href="#1-operand-gt-amp-amp" class="headerlink" title="1. operand -&gt;*  &amp;&amp;  .*"></a>1. operand -&gt;*  &amp;&amp;  .*</h3><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/pointer-to-member-operators-dot-star-and-star?view=msvc-170">rerference - 微软</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/cpp-func-pointer.html">rerference - 菜鸟教程</a></p>
<p><code>-&gt;* 和 .*</code>：指向成员的指针运算符</p>
<blockquote>
<p>当我们的成员函数或者成员变量被记录为指针时，不能再通过 <code>. 或者 -&gt;</code> 直接调用该成员，需要使用指向成员的指针运算符。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;helloBase&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (BaseClass::*Bptr)() = &amp;BaseClass::func1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> BaseClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;HelloDerived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (Derived::*Dptr)() = &amp;Derived::func2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BaseClass b;</span><br><span class="line">    BaseClass *pb = <span class="keyword">new</span> BaseClass;</span><br><span class="line">    (b.*Bptr)();</span><br><span class="line">    (pb-&gt;*Bptr)();</span><br><span class="line">    </span><br><span class="line">    Derived d;</span><br><span class="line">    Derived *pd = <span class="keyword">new</span> Derived;</span><br><span class="line">    (d.*Dptr)();</span><br><span class="line">    (pd-&gt;*Dptr)();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// (pb-&gt;*Dptr)();</span></span><br><span class="line">    (pd-&gt;*Bptr)();</span><br><span class="line">    <span class="comment">// (b.*Dptr)();</span></span><br><span class="line">    (d.*Bptr)();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x05-面向对象的编程风格"><a href="#0x05-面向对象的编程风格" class="headerlink" title="0x05 面向对象的编程风格"></a>0x05 面向对象的编程风格</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yuanch2019/p/11625460.html">析构函数与虚函数</a></p>
<p>局部对象在生命周期结束之后会自动调用 dtor，但是分配在 heap 上的对象在函数结束之后也不会调用 dtor，必须 delete 才会调用。</p>
<p>子类包含父类继承的成员，但是子类不能直接初始化这些成员，需要调用父类的构造函数，让每个类自己控制自己成员的初始化过程。</p>
<p>只要调用基类的构造函数和析构函数，就一定会调用父类的构造函数和析构函数。</p>
<p>如果类 A 有个虚函数，那么类 B 继承类 A，类 C 继承类 B，那么 B 也可以重载这个虚函数。并且父类 A 的指针也可以指向子类 C。</p>
<p>子类可以不实现父类的纯虚函数。存在纯虚函数的类不能被实例化。</p>
<h1 id="侯捷-OOP"><a href="#侯捷-OOP" class="headerlink" title="侯捷 OOP"></a>侯捷 OOP</h1><h2 id="preface"><a href="#preface" class="headerlink" title="preface"></a>preface</h2><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a target="_blank" rel="noopener" href="https://github.com/coder0818/-C-">侯捷资源github</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/coder0818/-C-/tree/master/C++-newC++11&14-HouJie">资料</a></p>
<h3 id="prologue"><a href="#prologue" class="headerlink" title="prologue"></a>prologue</h3><p>一、二：object based</p>
<p>三：some addition</p>
<p>四、：object oritened</p>
<h3 id="English"><a href="#English" class="headerlink" title="English"></a>English</h3><p>oop：object oriented programming，面向对象编程</p>
<p>layout：布局</p>
<p>torment：折磨，煎熬</p>
<p>overload：重载</p>
<p>override：覆写，覆盖</p>
<p>scopre：作用域</p>
<p>interlude：插叙</p>
<p>inheritance：继承</p>
<p>composition：复合</p>
<p>delegation：委托</p>
<p>composite：复合</p>
<p>prototype：原型</p>
<p>explicit：明白的，明去的，清楚的</p>
<p>signatrue：签名</p>
<p>parenthses：小括号， ()</p>
<p>barces：大括号，{}</p>
<p>alias：别名，化名</p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>模版会造成代码的膨胀，但这是必要的，并不是缺点。</p>
<p>编译器会对 function template 进行 实参推导（argument dedution）。即选择类型。</p>
<h3 id="ref1"><a href="#ref1" class="headerlink" title="ref1"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42247231/article/details/105109709">ref1</a></h3><p>今天我们来谈一谈面试 C++ 工程师时经常被谈到的一个问题：为什么析构函数必须是虚函数？为什么默认的析构函数不是虚函数？</p>
<p>首先，我们看一下百度百科对虚函数是怎么定义的:</p>
<p>在某基类中声明为 virtual并在一个或多个派生类中被重新定义的成员函数，用法格式为：virtual 函数返回类型 函数名 ( 参数表 ) { 函数体 }；实现多态性，通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。</p>
<p>好了，现在我们大概知道什么是虚函数，虚函数就是类中使用关键 virtual修饰的成员函数，其目的是为了实现多态性。</p>
<p>那么什么是多态性呢？</p>
<p>所谓多态性，顾名思义就是“多个性态”。更具体一点的就是，用一个名字定义多个函数，这些函数执行不同但相似的工作。最简单的多态性的实现方式就是函数重载和模板，这两种属于静态多态性。还有一种是动态多态性，其实现方式就是我们今天要说的虚函数。</p>
<p>回归正题。</p>
<p>一、为什么析构函数必须是虚函数？</p>
<p>当然了，这么说其实是不太严谨的，因为我完全可以将析构函数定义成非虚函数。这个我们后面再说。</p>
<p>首先我们需要知道析构函数的作用是什么。析构函数是进行类的清理工作，具体来说就是释放构造函数开辟的内存空间和资源，当然我们完全可以在析构函数中进行任何我们想要的操作，比如下面我们给出的示例代码，就在析构函数中打印提示信息。</p>
<p>前面我们在介绍虚函数的时候就说到，为实现多态性，可以通过基类的指针或引用访问派生类的成员。也就是说，声明一个基类指针，这个基类指针可以指向派生类对象。</p>
<p>下面我们来看一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Father</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Father destroyed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Son</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Son destroyed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Father* p = <span class="keyword">new</span> Son;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">class Father destroyed</span><br></pre></td></tr></table></figure>


<p>上面的示例程序中，我们定义了两个类，一个基类，一个派生类，派生类公有继承父类。为了描述简单，这两个类只定义了析构函数，并在析构函数中输出提示信息。在主函数中，我们声明了一个基类的指针，并用一个派生类的实例去初始化这个基类指针，随后删除这个指针。我们看到程序运行的结果，只有基类的析构函数被调用。</p>
<p>为什么会这样呢？指针明明指向的是派生类对象，那删除这个指针，为何只有基类的析构函数被调用，而派生类的析构函数却没有调用呢？</p>
<p>我们先把问题留在这里，接下来我们看看，若析构函数被定义成虚函数会怎么样呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Father</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Father destroyed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Son</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Son destroyed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Father* p = <span class="keyword">new</span> Son;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Son destroyed</span><br><span class="line">class Father destroyed</span><br></pre></td></tr></table></figure>

<p>当基类的析构函数被定义成虚函数时，我们再来删除这个指针时，先调用派生类的析构函数，再调用基类的析构函数，很明显这才是我们想要的结果。因为指针指向的是一个派生类实例，我们销毁这个实例时，肯定是希望即清理派生类自己的资源，同时又清理从基类继承过来的资源。而当基类的析构函数为非虚函数时，删除一个基类指针指向的派生类实例时，只清理了派生类从基类继承过来的资源，而派生类自己独有的资源却没有被清理，这显然不是我们希望的。</p>
<p>所以说，如果一个类会被其他类继承，那么我们有必要将被继承的类（基类）的析构函数定义成虚函数。这样，释放基类指针指向的派生类实例时，清理工作才能全面进行，才不会发生内存泄漏。</p>
<p>二、为什么默认的析构函数不是虚函数？</p>
<p>那么既然基类的析构函数如此有必要被定义成虚函数，为何类的默认析构函数却是非虚函数呢？</p>
<p>首先一点，语言设计者如此设计，肯定是有道理的。</p>
<p>原来是因为，虚函数不同于普通成员函数，当类中有虚成员函数时，类会自动进行一些额外工作。这些额外的工作包括生成虚函数表和虚表指针，虚表指针指向虚函数表。每个类都有自己的虚函数表，虚函数表的作用就是保存本类中虚函数的地址，我们可以把虚函数表形象地看成一个数组，这个数组的每个元素存放的就是各个虚函数的地址。<br>这样一来，就会占用额外的内存，当们定义的类不被其他类继承时，这种内存开销无疑是浪费的。</p>
<p>这样一说，问题就不言而喻了。当我们创建一个类时，系统默认我们不会将该类作为基类，所以就将默认的析构函数定义成非虚函数，这样就不会占用额外的内存空间。同时，系统也相信程序开发者在定义一个基类时，会显示地将基类的析构函数定义成虚函数，此时该类才会维护虚函数表和虚表指针。</p>
<h2 id="lt-一出手就是大家之范-gt"><a href="#lt-一出手就是大家之范-gt" class="headerlink" title="&lt;一出手就是大家之范&gt;"></a>&lt;一出手就是大家之范&gt;</h2><h2 id="一、class-with-no-pointer"><a href="#一、class-with-no-pointer" class="headerlink" title="一、class with no pointer"></a>一、class with no pointer</h2><h4 id="0x01-Introduce"><a href="#0x01-Introduce" class="headerlink" title="0x01 Introduce"></a>0x01 Introduce</h4><h5 id="1-C-vs-C"><a href="#1-C-vs-C" class="headerlink" title="1. C vs C++"></a>1. C vs C++</h5><p>由于 C 语言没有提供足够的关键字，因此 C 语言中能够被函数处理的变量一定是全局变量（局部变量没有意义，它在函数结束之后就释放了）。但这就意味着所有的函数都可以使用这个全局变量。</p>
<h5 id="2-class-based-or-class-oriented"><a href="#2-class-based-or-class-oriented" class="headerlink" title="2. class based or class oriented"></a>2. class based or class oriented</h5><p>只要你写的 class 之间有关系，就可以称为<strong>面向对象</strong>。</p>
<p>Class based: 单一 class</p>
<p>class oriented：多个class，class之间有连续</p>
<h5 id="3-C-code-frame"><a href="#3-C-code-frame" class="headerlink" title="3. C++ code frame"></a>3. C++ code frame</h5><p>.h：classes declaration</p>
<p>.h：standard library </p>
<p>.cpp：one main and others</p>
<h5 id="4-guard-declaration-of-header"><a href="#4-guard-declaration-of-header" class="headerlink" title="4. guard declaration of header"></a>4. guard declaration of header</h5><p>头文件防卫式声明：</p>
<p>避免重复 include。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ifndef __XXX_GUARD__</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __XXX_GUARD__</span></span><br><span class="line">...;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">endif</span></span><br></pre></td></tr></table></figure>

<h5 id="5-layout-of-header"><a href="#5-layout-of-header" class="headerlink" title="5. layout of header"></a>5. layout of header</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;guard&gt;</span></span><br><span class="line"></span><br><span class="line">// 0. forward declarations</span><br><span class="line"></span><br><span class="line">// 1. class declarations</span><br><span class="line"></span><br><span class="line">// 2. class definition</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;/guard&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="6-about-a-x3D-b"><a href="#6-about-a-x3D-b" class="headerlink" title="6. about a &#x3D; b"></a>6. about a &#x3D; b</h5><p>对于类似 <code>a = b;</code> 类型的语句，你应该说： </p>
<p><code>b assigned to a </code>，而不是： </p>
<p><code>a 等于 b</code></p>
<h4 id="0x02-Construtor"><a href="#0x02-Construtor" class="headerlink" title="0x02 Construtor"></a>0x02 Construtor</h4><h5 id="1-access-level"><a href="#1-access-level" class="headerlink" title="1. access level"></a>1. access level</h5><p>class 中一般根据访问级别划分为两大段：public, private。（当然你也可以划分为多个public，private….）</p>
<p>数据部分一般划分为 private，因为我们的数据需要封装起来，不能随便为外界所看到。</p>
<p>函数根据是否需要开放给外界可以划分为 private，也可以划分为 public。</p>
<p>当然，还有另一种 access level：protected。</p>
<h5 id="2-constructor（ctor）"><a href="#2-constructor（ctor）" class="headerlink" title="2. constructor（ctor）"></a>2. constructor（ctor）</h5><p>initialization list（初值列，初始列），只有构造函数才有的语法。当我们使用构造函数时，能使用初值列，不要在大括号内初始化。</p>
<p>因为一个数据的设定有两个阶段：初始化（初值列）和赋值（大括号内）。你如果不在初值列不设定数值，而在大括号内设定数值，就会浪费初始化这一步骤。（这是效率的问题，你明明能一步搞定，为啥走两步呢？</p>
<p>当我们为一个构造函数的所有参数都提供默认值时，此时不能再提供默认的没有参数的构造函数。因为前面的构造函数已经实现了默认构造函数的功能。</p>
<h5 id="3-tmp-var"><a href="#3-tmp-var" class="headerlink" title="3. tmp var"></a>3. tmp var</h5><p>局部变量，没有名字。</p>
<p><a target="_blank" rel="noopener" href="https://blog.popkx.com/why-can-c-language-functions-be-return-local-variables-and-local-variables-are-not-released/">参考</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaomingZeng/article/details/89319861">参考</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lsfv/p/6016764.html">好文！</a></p>
<p><a target="_blank" rel="noopener" href="https://www.3dwindy.com/article/177572">临时变量的常量性</a></p>
<p> 临时变量应该在导致临时变量创建的”完整表达式”求值过程的最后一个步骤被析构</p>
<blockquote>
<p>如果函数返回值是一个对象，要考虑 return 语句的效率。例如<br>        return String(s1 + s2);<br>     	这是临时对象的语法，表示“创建一个临时对象并返回它” 。</p>
<p>不要以为它与“先创建一个局部对象 temp 并返回它的结果”是等价的，如<br>            String temp(s1 + s2);<br>            return temp;</p>
<p>实质不然，上述代码将发生三件事。首先，temp 对象被创建，同时完成初始化；然后拷贝构造函数把 temp 拷贝到保存返回值的外部存储单元中；最后，temp 在函数结束时被销毁（调用析构函数） 。</p>
<p>然而“创建一个临时对象并返回它”的过程是不同的，<strong>编译器直接把临时对象创建并初始化在外部存储单元中</strong>，省去了拷贝和析构的化费，提高了效率。</p>
<p>类似地，我们不要将<br>return int(x + y); &#x2F;&#x2F; 创建一个临时变量并返回它<br>写成<br>int temp &#x3D; x + y;<br>return temp;</p>
<p>由于内部数据类型如 int,float,double 的变量不存在构造函数与析构函数， 虽然该 “临时变量的语法”不会提高多少效率，但是程序更加简洁易读。</p>
</blockquote>
<p>当返回一个变量的时候，我们只想返回这个变量的值，而不是这个变量。</p>
<p>虽然局部变量和临时变量在函数结束后被销毁，但其值仍存放在寄存器 rax 中。</p>
<p>临时对象在表达式完成之后就会被销毁。但如果将一个临时变量返回给一个引用，它的生命周期会延长。</p>
<p><strong>编译器直接把临时对象创建并初始化在外部存储单元中</strong>。这句话我们可以这样理解：返回局部变量时，我们返回的是一个对象，而对象需要创建和销毁。返回临时变量时，我们直接返回了一个值，</p>
<p><code>typename(...)；</code></p>
<p>不可以对临时对象 returnby reference，因为，它们返回的必定是个 local object。</p>
<h4 id="0x03-Const"><a href="#0x03-Const" class="headerlink" title="0x03 Const"></a>0x03 Const</h4><h5 id="1-overload-by-const"><a href="#1-overload-by-const" class="headerlink" title="1. overload by const"></a>1. overload by const</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">imag</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> im; &#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">imag</span><span class="params">()</span> </span>&#123; im = <span class="number">-1</span>; <span class="keyword">return</span> im; &#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-by-value-vs-by-reference-to-const"><a href="#2-by-value-vs-by-reference-to-const" class="headerlink" title="2. by value vs. by reference(to const)"></a>2. by value vs. by reference(to const)</h5><p>上面的（to const）表示可选。</p>
<p>pass&#x2F;return by value or pass&#x2F;return by reference(to const)</p>
<p>引用（reference）为 C++ 特有。引用的底部就是一个指针。传引用就是传指针，但是它更漂亮。</p>
<p>注意并不是传指针一定比传引用快，例如我们只是传一个char，一个字节，而指针则需要四个字节。</p>
<p>当我们传指针（引用）只是为了效率，要加上 const。</p>
<h6 id="3-friend"><a href="#3-friend" class="headerlink" title="3. friend"></a>3. friend</h6><p>将一个函数设置为 friend 之后，该函数可以拿到该对象的 private 数据成员，虽然有时我们也可以通过开放的函数看到 private 成员。但这样做的一个好处是减少通过函数调用拿到成员的函数调用开销。</p>
<p><strong>同个 class 的各个 objects 互为 friends</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">test</span>(<span class="type">int</span> r) : <span class="built_in">val</span>(r) &#123;&#125;</span><br><span class="line">    	<span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(test &amp;x)</span> </span>&#123; <span class="keyword">return</span> x.val; &#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">    	<span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上面的例子中，我们在 func 中直接拿到了另一个对象 x 的私有成员。这是合法的。不需要将 func 声明为 friend。</p>
</blockquote>
<h4 id="0x04-Operator-overload"><a href="#0x04-Operator-overload" class="headerlink" title="0x04 Operator overload"></a>0x04 Operator overload</h4><h5 id="1-this"><a href="#1-this" class="headerlink" title="1. this *"></a>1. this *</h5><p>所有的成员函数都带有一个隐藏的成员参数 – *this，谁调用这个函数，谁就是 this，这个参数一般放在参数列表的最左侧。当成员调用成员函数的时候就会把它的地址放到 this 中。</p>
<h5 id="2-return-way"><a href="#2-return-way" class="headerlink" title="2. return way"></a>2. return way</h5><p>传送者无需知道接收者是否以 reference 形式接受。但是在 C 中，传送者必须知道接收者是否以 pointer 形式接受来决定返回数值还是地址。</p>
<h5 id="3-连串赋值的返回类型"><a href="#3-连串赋值的返回类型" class="headerlink" title="3. 连串赋值的返回类型"></a>3. 连串赋值的返回类型</h5><p>因为赋值运算符（&#x3D;，+&#x3D;，-+ …）的优先级顺序自右向左，因为它可能会出现这种形式：</p>
<p><code>a += b += c</code></p>
<p><code>b+=c</code> 的结果会作为左值交给 <code>a+=</code></p>
<p>此时如果我们重载的 <code>+=</code> 返回了一个 void，那事情就严重了。我们应该返回 <code>b+c</code> 的类型</p>
<p>对任意 a op b，都是 b 作用 op 于 a 身上，即右侧的对象作用到左侧，C++ 不存在左侧的对象作用在右侧的语法。</p>
<p>当我们重载 output(&lt;&lt;) 运算符的时候，不可以重载为成员函数。</p>
<blockquote>
<p>如果我们重载为成员函数，那么 class 对象会作为隐式的最左侧的 operand，而 ostream 对象会作为右 operand，此时如果我们调用该函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>;</span><br><span class="line"><span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">c &lt;&lt; cout;</span><br></pre></td></tr></table></figure>

<p>这显然是不合理的，cout 竟然在右侧！</p>
</blockquote>
<h2 id="二、class-with-pointer"><a href="#二、class-with-pointer" class="headerlink" title="二、class with pointer"></a>二、class with pointer</h2><h3 id="0x01-Big-Three"><a href="#0x01-Big-Three" class="headerlink" title="0x01 Big Three"></a>0x01 Big Three</h3><h4 id="1-what’s-three"><a href="#1-what’s-three" class="headerlink" title="1 what’s three?"></a>1 what’s three?</h4><p> copy structure function </p>
<p>copy assignment struction</p>
<p>destruction function</p>
<h4 id="2-how-copy"><a href="#2-how-copy" class="headerlink" title="2. how copy"></a>2. how copy</h4><p>copy struction</p>
<p><code>string s1(s2);</code></p>
<p><code>string s1 = s2</code>;</p>
<p>copy assignment</p>
<p><code>s1 = s2;</code></p>
<blockquote>
<p>当一个对象第一次出现并利用另一个对象赋值的时候，它会调用拷贝构造函数。</p>
<p>如果对象已经出现，此时再用另一个对象赋值，它会调用拷贝赋值。</p>
</blockquote>
<p>如果你没有在类中提供拷贝构造和拷贝赋值函数，编译器会默认使用自己的那一套函数，就是一个 bit 一个 bit 的copy 过去，也就是说，对于指针类型，它只会把指针 copy 过去，这显然是不合理的，但是对于<strong>非指针</strong>，这是可行的。</p>
<p>因此，对于指针，你必须有你自己的 copy structure function and copy assignment function</p>
<p>拷贝构造函数：构造函数的参数对象是它自己</p>
<p>拷贝赋值函数：重载赋值运算符，参数对象是它自己。当我们使用拷贝赋值时，一定要检查是否是自己赋值给自己。这不仅是效率的问题，还关乎程序的正确性。</p>
<p><code>delete [] ptr;</code> 的 [] 理解为<strong>“关门”</strong>很形象啊。</p>
<blockquote>
<p>总而言之，用同类对象为该对象初始化 or 赋值的操作就是拷贝初始化 or 赋值。</p>
<p>但是默认拷贝只是单纯拷贝 val，对于指针来说，它的 val 就是 只想对象的 address。</p>
<p>这可能（绝大数情况下）并非我们想要的，因此我们需要重载拷贝（初始化 and 赋值）。</p>
<p>就是这么简单。</p>
</blockquote>
<h4 id="3-ctor-and-dtor"><a href="#3-ctor-and-dtor" class="headerlink" title="3. ctor and dtor"></a>3. ctor and dtor</h4><p>构造和析构函数</p>
<p><code>complex();</code> 创建一个临时对象</p>
<p><code>complex c1;</code> 调用默认构造函数创建一个全局&#x2F;局部对象c1</p>
<h3 id="0x02-memory-management"><a href="#0x02-memory-management" class="headerlink" title="0x02  memory management"></a>0x02  memory management</h3><h4 id="1-Local-object"><a href="#1-Local-object" class="headerlink" title="1. Local object"></a>1. Local object</h4><p>also named <strong>auto object</strong>, because it’s memory will be cleaned up automatically by stack.</p>
<h4 id="2-new-and-delete"><a href="#2-new-and-delete" class="headerlink" title="2. new and delete"></a>2. new and delete</h4><blockquote>
<p>new：先分配空间，再调用构造函数</p>
</blockquote>
<p>当我们执行语句：<code>complex *p = new colplex(1,2);</code>的时候，编译器优化为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *mem = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(complex)); <span class="comment">// 分配内存</span></span><br><span class="line">pc = <span class="built_in">static_cast</span>&lt;complex*&gt;(mem); <span class="comment">// 类型转换</span></span><br><span class="line">pc-&gt;complex::<span class="built_in">complex</span>(<span class="number">1</span>,<span class="number">2</span>);	<span class="comment">// call dtor</span></span><br></pre></td></tr></table></figure>

<p>其中，operator new 在内部调用的是 C 的 malloc</p>
<p>complex(1,2) 转换为 complex(pc,1,2);</p>
<blockquote>
<p> delete：先调用 dtor，再释放内存</p>
</blockquote>
<p>当我们执行语句 <code>delete []pc;</code> 的时候，编译器会优化为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">complex::~<span class="built_in">colplex</span>(ps);	<span class="comment">// 析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ps)</span></span>;	<span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure>

<p>operator delete 内部调动 free();</p>
<blockquote>
<p>array new &amp;&amp; array delete</p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/20/3d23ec94b22a0b36.png" alt="IMG"></p>
<p>如果我们使用了 array new 而没有使用 array delete</p>
<p>那么编译器只会调用一次 dtor。</p>
<h2 id="三、Interlude"><a href="#三、Interlude" class="headerlink" title="三、Interlude"></a>三、Interlude</h2><h3 id="0x01-static"><a href="#0x01-static" class="headerlink" title="0x01 static"></a>0x01 static</h3><h4 id="1-静态成员变量"><a href="#1-静态成员变量" class="headerlink" title="1. 静态成员变量"></a>1. 静态成员变量</h4><h5 id="1-1-性质"><a href="#1-1-性质" class="headerlink" title="1.1 性质"></a>1.1 性质</h5><p>静态变量是 一个<strong>类的成员变量</strong>，而不是<strong>类的实例的成员变量</strong>。</p>
<p>静态变量调用的时候可以通过对象调用,也可以通过类直接调用。</p>
<blockquote>
<p> 不能在构造对象的构造函数中初始化静态变量。不然的话你就是把静态变量视为类的实例的一个成员变量，这就与它的定义矛盾了。</p>
</blockquote>
<blockquote>
<p>设计模式中的<strong>单例模式</strong>就是只有一个实例对象，这个实例对象是静态的，并且它的构造函数被放在 private 中。</p>
</blockquote>
<h5 id="1-2-内存分配"><a href="#1-2-内存分配" class="headerlink" title="1.2 内存分配"></a>1.2 内存分配</h5><p>静态就是在程序编译时就分配存储空间，而不是等到运行时才知道，也就是程序加载之后，它的存储空间就已经分配了。这是因为<strong>我们有时候希望即便类的实例销毁了，但我却希望保存它的某些数据</strong>，那么这个时候，静态成员变量就是一个很好的选择。对于被所有类共享的数据可声明成静态变量，它在程序运行前就已经存在了(所以一定要初始化)，它被放到静态存储区，按照出现次序被初始化。 它被所有该类的对象共享，静态变量可以被改变。</p>
<h5 id="1-3-静态成员变量一定要初始化吗"><a href="#1-3-静态成员变量一定要初始化吗" class="headerlink" title="1.3 静态成员变量一定要初始化吗"></a>1.3 静态成员变量一定要初始化吗</h5><p>先上答案：绝绝绝大多数情况下，需要初始化！暂时还不知道不不初始化的情况。</p>
<p>我们知道C++类的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%9D%99%E6%80%81%E6%88%90%E5%91%98&spm=1001.2101.3001.7020">静态成员</a>变量是需要初始化的，但为什么要初始化呢。</p>
<p>其实这句话“静态成员变量是需要初始化的”是有一定问题的，应该说“静态成员变量需要定义”才是准确的，而不是初始化。</p>
<p>两者的区别在于：<strong>初始化是赋一个初始值并且同时分配内存，而定义是只分配<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>。</strong></p>
<p>静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义，实际上是给静态成员变量分配内存。</p>
<p>如果我们没有在类的外部定义静态成员变量，那么我们此时就仅仅只是声明了它，如果我们尝试使用它就会导致编译错误。</p>
<p>当然你也可以不定义它，前提是你不会使用它，但既然你不使用它，你为何声明它，并且声明为静态的，这不是搞笑吗？因此，只要在类中声明了一个静态成员变量，你就有很大的必要在类外部定义它（可以不赋值，此时它应该会被默认初始化为0）。</p>
<h5 id="1-4-为什么-static-成员变量一定要在类外初始化"><a href="#1-4-为什么-static-成员变量一定要在类外初始化" class="headerlink" title="1.4 为什么 static 成员变量一定要在类外初始化"></a>1.4 为什么 static 成员变量一定要在类外初始化</h5><p>先上答案：<strong>不一定！</strong></p>
<p>前面提到，我们要在外部定义（注意不一定是初始化，我们可以不给它赋值）静态成员函数。那么我们可以不可以在类中初始化它呢？ </p>
<p>因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。</p>
<p>《c++primer》里面说在类外定义和初始化是保证<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020">static</a> 成员变量<strong>只被定义一次</strong>的好方法。 但为什么 static const int 就可以在类里面初始化呢？ </p>
<p>想起 C 中一个函数里定义一个 static 变量是为了保证只初始化（分配内存并赋值）一次。</p>
<p>那么，是否可以这样理解: static 数据成员在类外定义和初始化是为了<strong>保证只被定义和初始化一次</strong>,这样编译器就不必考虑类的函数里面第一个对 static 变量的 ’&#x3D;’ 操作是赋值还是初始化了。 static const int 可以在类里面初始化，是因为它既然是 const 的，那程序就不会再去试图初始化了。</p>
<p>什么东西能在类内初始化 ？<br>能在类中初始化的成员只有一种，那就是<strong>静态常量成员</strong>。</p>
<blockquote>
<p>因为静态常量成员是常量，不允许修改，这种情况下是否所有的对象共享同一份数据已经不重要了，因为都是同一常量数据，而且如果不允许直接赋值，那么这个常量就没有意义了，直接就是系统默认的值了。</p>
<p>另外常量在声明时必须同时初始化，否则编译器报错。</p>
</blockquote>
<blockquote>
<p>在我的测试中，发现即使在类中初始化静态成员变量，它也不会算到类的实例的空间当中。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="type">int</span> y;</span><br><span class="line">     <span class="type">const</span> <span class="type">int</span> z = <span class="number">0</span>;</span><br><span class="line">     <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> test a;</span><br><span class="line"> cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>Sizeof(a) 的大小是 4 而不是 8，这谁就说明 static 仍然属于类。</p>
</blockquote>
<blockquote>
<p>c++11现在支持在类内初始化 const 常量成员了。<code>const int count =0;</code>是可以的。</p>
</blockquote>
<h4 id="2-静态成员函数"><a href="#2-静态成员函数" class="headerlink" title="2. 静态成员函数"></a>2. 静态成员函数</h4><h5 id="2-1-性质"><a href="#2-1-性质" class="headerlink" title="2.1 性质"></a>2.1 性质</h5><ol>
<li><p>静态函数没有 this 指针。 （它不属于类的实例）</p>
</li>
<li><p>静态函数只能访问类中的静态成员变量。</p>
</li>
<li><p>静态函数不需要类的实例就可以调用。</p>
</li>
<li><p>静态成员函数不属于任何对象，而是属于类的。</p>
</li>
</ol>
<h5 id="2-2-访问权限"><a href="#2-2-访问权限" class="headerlink" title="2.2 访问权限"></a>2.2 访问权限</h5><p>调用<strong>静态函数</strong>效率要高，因为不需要找类实例的数据就可以执行（所以自然不需要标记类实例地址的 this 指针了，不需要穿参），同时由于没有隐含的this指针，自然无法访问类的其他变量，而<strong>只能访问静态变量</strong>了。</p>
<h5 id="2-3-static-amp-virtual-amp-const"><a href="#2-3-static-amp-virtual-amp-const" class="headerlink" title="2.3 static &amp; virtual &amp; const"></a>2.3 static &amp; virtual &amp; const</h5><p>(1) static 成员函数不能为 virtual：       </p>
<p><code> virtual static void fun() &#123; &#125;//错误</code></p>
<p>原因：</p>
<ol>
<li><p>static成员不属于任何类对象或类实例，故即使给此函数加上virutal也是没意义的。</p>
</li>
<li><p>静态成员函数没有this指针。</p>
</li>
</ol>
<p>(2) static成员函数不能为const函数：</p>
<p>  <code>static void fun() const &#123; &#125; //编译错误</code>  </p>
<p> <code>const static void fun() &#123;&#125;  //可以的</code> </p>
<p>原因：当声明一个非静态成员函数为 const 时，对 this 指针会有影响。对于一个 Test 类中的 const 修饰的成员函数，this 指针相当于 Test const , 而对于非 const 成员函数，this 指针相当于 Test . 而 static 成员函数没有 this 指针，所以使用const 来修饰 static 成员函数没有意义。 volatile 的道理也是如此。</p>
<h5 id="2-4-为啥要引入静态成员函数"><a href="#2-4-为啥要引入静态成员函数" class="headerlink" title="2.4 为啥要引入静态成员函数"></a>2.4 为啥要引入静态成员函数</h5><blockquote>
<p>假如我们需要将对静态成员变量的一系列操作封装起来作为一个成员函数（注意不是静态的），那么如果我们想要调用该函数，就必须实例化一个类的对象。而对象的实例化与销毁是需要开销的，更何况我们只是想操作静态成员变量，仅此而已，为此我们实例化一个对象，这太浪费了。</p>
</blockquote>
<p>我们知道在C++中调用类的成员函数，会传递一个this指针，将类的实例化对象的首地址传递给成员函数，函数操作会根据对象首地址计算其成员变量的地址，然后进行操作。然而静态成员变量并不保存在对象的内存布局中，而是保存在数据段中，因而没有必要用到 this 指针。所以需要一种独立于对象之外对对象静态成员变量的访问操作。在早期 C++ 引入静态成员函数之前，你会看到下面这样奇怪的写法：（假设有类 test，静态成员函数 <code>sfunc()</code>）</p>
<p><code>((test *)0)-&gt;sfunc();</code></p>
<p>编译器生成的代码是先将 ecx 清零，然后直接调用 <code>test::sfunc()</code> 函数。这种写法的优点就在于不用对进行对象实例化操作从而节省了时间和空间。这种写法最早由贝尔实验室的成员 Jonathan Shopiro 提出，他本人也是引入静态成员函数的主要倡导者。</p>
<p>另外，当我们不存在实例并且也不想额外实例化一个对象的时候，静态成员函数为我们提供了操作静态成员变量的方法，这种场景很多。</p>
<p>但注意，它不能操作非静态成员变量，否则当不存在类实例的时候，我们可以调用非静态成员变量，但此时非静态成员变量尚不存在，显然是不合法的。而静态成员变量存储在数据段中，所以它是存在的。</p>
<blockquote>
<p>还有如下好处：</p>
<ol>
<li><p>与类实例无关。</p>
</li>
<li><p>把类名当成namespace用。</p>
</li>
<li><p>控制该函数的访问权限。</p>
</li>
<li><p>控制类内的static变量。</p>
</li>
</ol>
</blockquote>
<h3 id="0x02-namespace"><a href="#0x02-namespace" class="headerlink" title="0x02 namespace"></a>0x02 namespace</h3><h4 id="1-reference"><a href="#1-reference" class="headerlink" title="1. reference"></a>1. reference</h4><p><a target="_blank" rel="noopener" href="https://codeantenna.com/a/gIRJK7VV7N">里面谈到了全局命名空间</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/aiyc/4998037">知乎的讨论</a></p>
<p><a target="_blank" rel="noopener" href="http://129.226.226.195/post/602.html">stack overflow 讨论中文翻译</a></p>
<h4 id="2-using-namespace-std"><a href="#2-using-namespace-std" class="headerlink" title="2. using namespace std"></a>2. using namespace std</h4><p>为什么不要在<strong>头文件</strong>中引入 <code>using namespace std;</code></p>
<blockquote>
<p> <strong>本来只需要一棵树，你缺砍了整个森林。</strong></p>
</blockquote>
<p>这句解释太形象了，有时候你只是想要 cout，cin，但你却把整个标准库 using 进来，太不合理了。</p>
<p>你引入的太多，发生冲突的概率也就越大。</p>
<p>另外，注意我们是不要在 头文件（.h）而不是源文件（.cpp）里面。因为头文件需要开放给他人使用，而 .cpp 文件并不需要开放给他人。</p>
<blockquote>
<p>只是千万不要在头文件里面using而已。</p>
<p>主要是命名冲突，而且冲突以后，编译器给的错误信息基本是妖魔，牛头不对马嘴，难以追查。有些根本编译就没错误和警告，但是就是运行错误。</p>
<p>跟萌心们解释这些很麻烦，而且效果也不是很好，所以一般直接硬性规定头文件不准出现任何一个using。</p>
</blockquote>
<p>比较好的做法应该是自己用一个命名空间封装std，然后using 自己的那个命名空间。</p>
<p><code>x=::a;</code>  a 是全局global作用域下的，不声明 namespace 就是默认处于全局作用域下。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> xjy &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;namespace:xjy&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">2020</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;namespce:global&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; ::a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; xjy::a &lt;&lt; endl;</span><br><span class="line">    ::<span class="built_in">f</span>();</span><br><span class="line">    xjy::<span class="built_in">f</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Examples"><a href="#3-Examples" class="headerlink" title="3. Examples"></a>3. Examples</h4><p>举个例子1：变量冲突</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> name1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> name2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> name1;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> name2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int a = 10; // (1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在命名空间 name1 和 name2 中我们都定义了一个 a，此时如果把他们全部引入到程序当中，此时再使用 a，就会出现编译错误–命名冲突，但如果我们加入 （1）处语句，程序会成功运行并输出 10，这是因为（1）处的 a 处于<strong>全局命名空间</strong>，他会取代 using 的 a，就像我们 using namespace std 之后，我们再写一个函数 max，它会覆盖标准库的 max 函数。</p>
<p>例子2：函数冲突</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> name1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> name2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> name1;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> name2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a.cpp: In function &#x27;int main()&#x27;:</span><br><span class="line">a.cpp:28:7: error: call of overloaded &#x27;f()&#x27; is ambiguous</span><br><span class="line">   28 |     f();</span><br><span class="line">      |       ^</span><br><span class="line">a.cpp:9:10: note: candidate: &#x27;void name1::f()&#x27;</span><br><span class="line">    9 |     void f()</span><br><span class="line">      |          ^</span><br><span class="line">a.cpp:17:10: note: candidate: &#x27;void name2::f()&#x27;</span><br><span class="line">   17 |     void f()</span><br><span class="line">      |          ^</span><br></pre></td></tr></table></figure>



<p>例子3：与 std 发生冲突</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> max = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; max &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们将 using namespace std 注释掉，程序正确运行并输出 1，但如果不注释掉，max 会命名冲突。</p>
<p>别问我为什么定义一个 max 变量，只要我不引用 std，不就是正确的吗？</p>
<p>但是我引用了你的头文件，而你的头文件中引用了 std，那我就绷不住了 T.T。</p>
<h3 id="0x03-Virtual-function-table"><a href="#0x03-Virtual-function-table" class="headerlink" title="0x03 Virtual function table"></a>0x03 <a target="_blank" rel="noopener" href="https://leehao.me/C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%89%96%E6%9E%90/">Virtual function table</a></h3><p>虚函数表就是一个 <strong>指针数组</strong>，数组的元素就是指向一个虚函数的指针。</p>
<p>虚函数表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了。</p>
<h3 id="0x04-typename"><a href="#0x04-typename" class="headerlink" title="0x04 typename"></a>0x04 typename</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/iotflh/article/details/114789270">Reference</a></p>
<h2 id="四、Oritened-Object"><a href="#四、Oritened-Object" class="headerlink" title="四、Oritened Object"></a>四、Oritened Object</h2><h3 id="0x01-Class-Relation"><a href="#0x01-Class-Relation" class="headerlink" title="0x01 Class Relation"></a>0x01 Class Relation</h3><blockquote>
<p>面向对象的思想就是 class 和 class 之间有各种各样的联系</p>
</blockquote>
<h4 id="1-Composition（has-a）"><a href="#1-Composition（has-a）" class="headerlink" title="1. Composition（has a）"></a>1. Composition（has a）</h4><p>复合表示一种 “has-a” 的关系。即，“我中有你”。</p>
<p>在人类的理解中，一个东西的构造肯定是由内而外的，只有里面构造好了，东西才扎实。同样，C++ 面向对象也要和人类的理解相似。</p>
<blockquote>
<p>复合关系下的构造和析构。</p>
<p>假设现在有一个 Container 类包含 Component 类。</p>
</blockquote>
<p><strong>构造由内而外：</strong></p>
<p>Container 的构造函数首先调用 Component 的 default 构造函数，然后才执行自己。</p>
<p><code>Container::Container(...) : Component() &#123; ... &#125;;</code></p>
<p><strong>析构由外而内：</strong></p>
<p>Container 的析构函数首先执行自己，然后才调用 Component 的析构函数。</p>
<p><code>Container::~Container(...) &#123; .. ~Component() &#125;;</code></p>
<p>如果包含了多个 class，执行的顺序编译器会帮我们实现。</p>
<blockquote>
<p>关于这里的执行顺序问题，在下面 [四 .0X02 .1] 中我们把 component 比作房子中的装饰品，把 container 比作房子。这其实对于这里的理解不太好，因为不都是先建好房子，再装饰房子吗？</p>
<p>我们可以换一种角度，只有把房子装饰好了，才能说这个房子是完整的，而我们要的是一个完整的房子，不是一个空壳。</p>
<p>因此说，我们先构造 compoent，再构造 container。</p>
</blockquote>
<h4 id="2-Inheritance（is-a）"><a href="#2-Inheritance（is-a）" class="headerlink" title="2. Inheritance（is a）"></a>2. Inheritance（is a）</h4><p>is a，表示 “是一种” 的关系。</p>
<p>C++ 给我们提供了三种继承方式（Java 只有 public 一种继承方式，因此在 Java 中，public 可以不写）。</p>
<blockquote>
<p>单纯的继承价值并不大，只有与 “虚函数” 搭配时，继承才能发挥它最大的价值。</p>
</blockquote>
<blockquote>
<p>继承关系下的构造与析构。</p>
<p>假设现在类 Derived 继承自基类（父类） Base。</p>
</blockquote>
<p><strong>构造由内而外：</strong></p>
<p>Derived 的构造函数首先调用 Base 的 default 构造函数，然后才执行自己。</p>
<p><code>Derived::Derived(...) : Base() &#123; ... &#125;;</code></p>
<p><strong>析构由外而内：</strong></p>
<p>Derived 的析构函数首先执行自己，然后才调用 Base 的析构函数。</p>
<p><code>Derived::~Derived( ... ) &#123; ...~Base() &#125;;</code></p>
<blockquote>
<p>Base class 的 dtor 必须是 virtual，否则会出现 undefined behavior。</p>
</blockquote>
<p>[参考本文 Appendix 中的 0x04]</p>
<p>文中提到了：</p>
<ol>
<li>静态多态性 和 动态多态性：函数重载与模版实现静态多态性。虚函数实现动态多态性。</li>
<li>为什么需要将析构函数设置为虚拟函数：避免内存泄漏。</li>
<li>为什么默认的构造函数不是虚函数：避免不必要的内存浪费。</li>
</ol>
<blockquote>
<p>为什么析构函数不设置为虚函数会导致内存泄漏？ —— 动态绑定</p>
<p><strong>virtual function is the basis for dynamic binding</strong> </p>
</blockquote>
<p> 直接的讲，C++中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。 <strong>“假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数”</strong>。 那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。</p>
<h4 id="3-Delegation"><a href="#3-Delegation" class="headerlink" title="3. Delegation"></a>3. Delegation</h4><p><strong>composition by reference</strong></p>
<blockquote>
<p>也有人把 delegation 和 composition 视为一类，这是术语上的差异，明白其<strong>“精神”</strong>即可，怎么称呼其实无关紧要。delegation 的 “精神” 就是 composition by reference。</p>
</blockquote>
<blockquote>
<p>by pointer</p>
<p>The way to pass value is divided into two ways: pass by value and pass by reference. </p>
<p>We find that there is no pass by pointer. why? Because that is what academia(学术界) calls it. <strong>Although we pass by pointer, we still call it pass by reference.</strong></p>
</blockquote>
<p>通过在 class 中引用其他 class 可以提高程序的弹性，我们的源 class 不需要变化（这意味着我们开放给用户的接口不变），而只需要修改引用的 class 即可。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/20/bcce1dd5388a77e9.png" alt="img"></p>
<p>Pimpl: pointer to implement </p>
<h3 id="0x02-virtual-function"><a href="#0x02-virtual-function" class="headerlink" title="0x02 virtual function"></a>0x02 virtual function</h3><blockquote>
<p><strong>virtual function is the basis for dynamic binding</strong></p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/20/56c751f20ee7e7c0.png" alt="img"></p>
<p>this template is not that key template</p>
<h4 id="1-Inheritance-and-composition"><a href="#1-Inheritance-and-composition" class="headerlink" title="1. Inheritance and composition"></a>1. Inheritance and composition</h4><p>当继承和复合都存在的时候，构造和析构的顺序：</p>
<p>这里有两种情况：</p>
<ol>
<li><strong>class</strong> inherit 继承<strong>class</strong> fa，<strong>class</strong> inherit 包含 <strong>class</strong> com</li>
<li><strong>class</strong> inhert 继承 <strong>class</strong> fa，<strong>class</strong> fa 包含 <strong>class</strong> com：这种情况比较明显，<strong>class</strong> inherit contain <strong>class</strong> fa, <strong>class</strong> fa contain <strong>class</strong> com</li>
</ol>
<p>所以我们考虑第一种情况：</p>
<p>构造函数执行顺序：fa -&gt; com -&gt; inherit</p>
<p>析构函数执行顺序：herit-&gt;com-&gt;fa</p>
<blockquote>
<p>为什么总是先调用父类的呢？</p>
</blockquote>
<p>我们可以这样理解：把子类比作一个房子。</p>
<p>子类继承自父类，父类就相当于 “地基”，而子类中的复合类就相当于 “房子中的装饰”，例如地板，墙壁，装饰品等，我们首先得把地基搭好了，然后才能开始建房子，所以说父类肯定在子类之前。</p>
<p>而我们只有把地基搭好，才能装饰我们的房子吧，所以说，复合类也应该在父类之前。</p>
<blockquote>
<p>不过无需太关心这个，而且这个一般和编译器相关。</p>
</blockquote>
<h4 id="2-Inheritance-and-delegation"><a href="#2-Inheritance-and-delegation" class="headerlink" title="2. Inheritance and delegation"></a>2. Inheritance and delegation</h4><p>候捷这里举了一个很经典的例子，来说明继承和委托的典型应用：画图。</p>
<p>在一些画图软件中，我们可能有这样的功能选项：系统给定了你一些图形（圆形，三角等），你可以自己设置这些图形的参数（长宽高，半径等）。</p>
<p>想要用类来表达这个功能，我们首先需要将所有的图形抽象出来，作为一个抽象的 <strong>class</strong> shape，那么 <strong>class</strong> 三角，<strong>class</strong> 圆形等都继承自 <strong>class</strong> shape。然后我们可以把我们的数据传送（委托）给具体的子类（<strong>class</strong> 圆形，<strong>class</strong> 三角形），让它替我们完成数据的处理并描绘出具体的图形。 </p>
<p>这就是通过委托和继承我们将一份数据（图形的参数信息）表达为多种不同的形态（三角形 or 圆形 .. ）。 </p>
<h4 id="3-composite"><a href="#3-composite" class="headerlink" title="3. composite"></a>3. composite</h4><p>设计模式之 complsite（复合）模式。</p>
<h4 id="4-prototype-模式"><a href="#4-prototype-模式" class="headerlink" title="4. prototype 模式"></a>4. prototype 模式</h4><p>设计模式之 prototype（原型） 模式</p>
<h2 id="lt-勿在浮沙筑高台-gt"><a href="#lt-勿在浮沙筑高台-gt" class="headerlink" title="&lt;勿在浮沙筑高台&gt;"></a>&lt;勿在浮沙筑高台&gt;</h2><h2 id="五、object-modle"><a href="#五、object-modle" class="headerlink" title="五、object modle"></a>五、object modle</h2><h3 id="0x01-conversion-function"><a href="#0x01-conversion-function" class="headerlink" title="0x01 conversion function"></a>0x01 conversion function</h3><p>格式：<code>operator TYPE() const &#123; return XX_TYPE; &#125;</code></p>
<p>其中 TYPE 就是我们想要转换成的类型，返回值的类型也是 TYPE，注意<strong>不能有参数和返回类型</strong>。</p>
<p>作为一个转换函数当然不需要参数。没有返回类型是因为返回值的类型和 TYPE 必然相同，C++ 编译器说：“你不用写返回类型，因为 TYPE 已经指出返回类型了，而你写还有可能写错”。</p>
<p>后面通常加上 const，你不加也没错，但是你该加就要加，因为类型转换一般不会改变成员变量。</p>
<p>转换函数和内置类型的转换函数一样，都可以隐式调用。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Fraction</span>(<span class="type">int</span> _num, <span class="type">int</span> _den = <span class="number">1</span>) : <span class="built_in">num</span>(_num), <span class="built_in">den</span>(_den) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是这个 ctor，直接产生解释2</span></span><br><span class="line">    <span class="comment">// explicit Fraction(int _num, int _den = 1) : num(_num), den(_den) &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)num / den;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(<span class="built_in">to_string</span>(num) + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">to_string</span>(den));</span><br><span class="line">    &#125;</span><br><span class="line">    Fraction <span class="keyword">operator</span> +(<span class="type">const</span> Fraction &amp;f) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Fraction</span>(num + f.num, den + f.den);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> den;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">4</span> + f;</span><br><span class="line">    <span class="comment">//double d = f + 4; // ambiguous overload for &#x27;operator+&#x27; (operand types are &#x27;Fraction&#x27; and &#x27;int&#x27;)</span></span><br><span class="line">    cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// extension</span></span><br><span class="line">    string s = f;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意转换函数可能会与我们重载的其它运算符发生冲突。在上面的例子中，如果我们以 <code>double d = f + 4;</code> 的形式调用就会产生二义性，这是因为 <code>f + 4</code> 可以有两种解释形式：</p>
<ol>
<li>调用 <code>operator+</code> 解释 <code>f+4</code> 为一个<code> fraction</code> 类型（因为在  <code>fraction</code> 的构造函数中，我们只需要传入一个参数 <code>num</code> 就可以调用构造函数，所以这里的 <code>4</code> 调用了构造函数），然后调用转换函数，将 <code>fraction(f+4)</code> 转换为 <code>double</code> 类型。</li>
<li>调用转换函数将 <code>f</code> 解释为 <code>double</code>。</li>
</ol>
<blockquote>
<p>我们可以通过如下方式调用构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fraction f = 4;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>不过如果我们不适用<code> f+4</code> 这种形式就不会出现这种错误（自己骗自己），但是要留意这种二义性错误。</p>
<blockquote>
<p>应用：</p>
<p><code>vector</code> 的 <code>[]</code> 就是通过构造函数实现的</p>
</blockquote>
<h3 id="0x02-non-explicit-one-argument-ctor"><a href="#0x02-non-explicit-one-argument-ctor" class="headerlink" title="0x02 non-explicit-one-argument ctor"></a>0x02 non-explicit-one-argument ctor</h3><p>one argument 表示该 ctor “至少” 需要一个实参，也就是说可以是多个实参，但是其他都有默认值，我们只需要一个参数就可以调用 ctor。</p>
<p>explicit 是一个 <strong>key word</strong>，它的意思是：明白的，明确的。用它修饰一个函数（例如构造函数），就是在告诉编译器，我就是一个构造函数，不要那我干其他事情，例如用我做类型转换等。</p>
<p>这个 key word 很少用到，并且百分之九十五的情况下看到这个关键字都是在 ctor 的前面，其它在模版里一个很小的地方也会用到。</p>
<p>其实主要就是为了解决 0x01 中的二义性错误，在上面的例子中，之所以产生二义性错误的主要原因是因为我们的语句：<code>double d = f + 4;</code> 的 <code>4</code> 会调用构造函数，这并不是我们所希望的，我们没有任何显式的表示要让这个 <code>4</code> 作为 <code>Fraction</code> 类型，而且我们的本意也是说 4 是一个 <code>double</code> ，毕竟我们的 <code>d</code> 声明的也是一个 <code>double</code> 类型。</p>
<p>但是编译器“默默”为我们做了这些事，那么有没有什么办法阻止编译器“替”我们调用构造函数吗？有。</p>
<p>通过为构造函数加上关键字 <code>explicit</code>，就可以让 ctor 做他该做的事情（初始化对象），而不是在这里将表达式中的一个变量作为对象并调用构造函数。</p>
<p>这也说明了为啥是 one-argument，因为我们的运算对象通常都是一个变量，你不会一下子 op 两个对象把？<code>a op (b,c)</code> 这不太符合直觉。</p>
<hr>
<h3 id="0x03-xxx-like-classes"><a href="#0x03-xxx-like-classes" class="headerlink" title="0x03 xxx-like classes"></a>0x03 xxx-like classes</h3><h4 id="1-pointer-like-classes"><a href="#1-pointer-like-classes" class="headerlink" title="1.  pointer-like classes"></a>1.  pointer-like classes</h4><p>一个像 pointer 的 class，所谓 <strong>smart pointer</strong>。</p>
<p>为什么把一个 class 设计的像 pointer？因为我们像让它比单纯的指针多做一些事情。</p>
<p>一个智能指针里面一定包含一个真的指针，也就是说智能指针就是对普通指针的封装，并提供了更多的功能，但是它应该实现真的指针的功能（解引用 <code>*</code> 和 <code>-&gt;</code>）。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;you call Foo::method.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>(T *obj) : <span class="built_in">px</span>(obj) &#123;&#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span> *() <span class="type">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *px;</span><br><span class="line">    &#125;</span><br><span class="line">    T* <span class="keyword">operator</span> -&gt;() <span class="type">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// otherway, call operator* but create new</span></span><br><span class="line">        <span class="comment">//return &amp;(operator *());   </span></span><br><span class="line">        <span class="keyword">return</span> px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* px;</span><br><span class="line">    <span class="type">long</span> *pn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Foo&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>; </span><br><span class="line">    <span class="comment">// 把指向shared_ptr类的指针p当做一个指向Foo对象的指针使用即可</span></span><br><span class="line">    (*p).data = <span class="number">1024</span>;</span><br><span class="line">    p-&gt;<span class="built_in">method</span>();</span><br><span class="line">    cout &lt;&lt; p-&gt;data &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    Foo *f = <span class="keyword">new</span> Foo;</span><br><span class="line">    f-&gt;<span class="built_in">method</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的对 std 中的 shared_ptr 简化模拟中，我们可以发现，shared_ptr 内部包含了一个成员变量 - 指针 px，这体现了智能指针其实就是对普通指针的封装。我们还可以在 shared_ptr 中添加一个额外的功能。（但是我并没有。。懒）</p>
<p>然后可以发现我们重载了 <code>*</code> 和 <code>-&gt;</code> 这两个指针必需的运算符</p>
<ol>
<li><code>*</code> 的返回类型是一个对象的引用（<code>&amp;</code>），这我们可以理解。在上面的例子中，我们的语句 <code>(*p).data = 1024;</code> 会被转换为 <code>(*px).data = 1024;</code>  很合理。</li>
<li><code>-&gt;</code> 的返回类型是一个指针（<code>*</code>）。在上面的例子中，我们的语句 <code>p-&gt;method();</code> 会被转换为 <code>pxmethod();</code> what？这非常不合理，我们想要的是：<code>px-&gt;method();</code>  但是我们的 <code>-&gt;</code> 不见了！那我们还怎么调用 <code>method</code>。别担心，<code>-&gt;</code> 有一个性质，就是当它被解释后，它会继续执行执行下去，什么意思呢？在这里的重载函数中，我们实际上是把 <code>-&gt;</code> 解释没了，但其实，它仍然存在。好像有点麻烦，不过你不需要纠结这些，你只要记住 <code>-&gt;</code> 被解释之后也会继续作用在它原本指向的对象就行了。</li>
</ol>
<p>小 tips：</p>
<blockquote>
<p>在重载 <code>-&gt;</code> 之后，我们返回 <code>T*</code>。不要傻乎乎的把 <code>T*</code> 直接在源表达式替换：<code>(*px)-&gt;method();</code></p>
<p>在返回的时候，我们要加上 <code>*</code>表示这是一个指针，但是在使用 “指针”（注意不是指针所指向的对象）的时候，我们不能加上 <code>*</code>，否则就会被解释为指向所指向的对象。</p>
<p>指针其实就是对象的地址的另一种表达方式，同理，地址也是表示指针指向对象的一种表达方式。不要刻意区分他们。</p>
</blockquote>
<p>应用：</p>
<blockquote>
<p>迭代器。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_node</span> &#123;</span><br><span class="line">    <span class="type">void</span> *prev;</span><br><span class="line">    <span class="type">void</span> *next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_iterator</span> &#123;</span><br><span class="line">  <span class="keyword">typedef</span> list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> list_node&lt;T&gt;* link;</span><br><span class="line">  link node;</span><br><span class="line">  </span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> self &amp;x) <span class="type">const</span> &#123; <span class="keyword">return</span> node == x.node; &#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span> !=(<span class="type">const</span> self &amp;x) <span class="type">const</span> &#123; <span class="keyword">return</span> node != x.node; &#125;</span><br><span class="line">  </span><br><span class="line">  reference <span class="keyword">operator</span>  *() <span class="type">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line">  pointer   <span class="keyword">operator</span> -&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span> *()); &#125;</span><br><span class="line">  </span><br><span class="line">  self&amp; <span class="keyword">operator</span> ++() &#123; <span class="comment">// pre: ++ x</span></span><br><span class="line">    node = (link)((*node).next);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  self <span class="keyword">operator</span> ++(<span class="type">int</span>)  &#123; <span class="comment">// post: x ++ </span></span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++ (*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  self&amp; <span class="keyword">operator</span> --() &#123; <span class="comment">// pre: -- x</span></span><br><span class="line">    node = (link)((*node).prev);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  self <span class="keyword">operator</span> --(<span class="type">int</span>) &#123; <span class="comment">// post: x --</span></span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    -- (*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-function-like-classes"><a href="#2-function-like-classes" class="headerlink" title="2. function-like classes"></a>2. function-like classes</h4><p>一个像 function 的 class，所谓 <strong>仿函数</strong>，<strong>函数对象（function object）</strong>。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">indetity</span> &#123;</span><br><span class="line">    <span class="comment">// 重载运算符：()</span></span><br><span class="line">    <span class="comment">// 返回类型是：const T&amp;</span></span><br><span class="line">    <span class="comment">// 参数是：T &amp;x</span></span><br><span class="line">    <span class="comment">// 是一个常量成员函数</span></span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; </span></span><br><span class="line"><span class="function">    <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Pair</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">select1st</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="keyword">typename</span> Pair::first_type&amp; </span></span><br><span class="line"><span class="function">    <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> Pair&amp; x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Pair</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">select2st</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="keyword">typename</span> Pair::second_type&amp;</span></span><br><span class="line"><span class="function">    <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> Pair &amp;x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Pair域下的两个类型变量</span></span><br><span class="line"><span class="comment">    Pair::first_type</span></span><br><span class="line"><span class="comment">    Pair::second_type</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    select1st&lt;pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt;&gt; s1;</span><br><span class="line">    pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; p = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">s1</span>(p) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准库中的仿函数的模拟实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">minus</span> &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;x, <span class="type">const</span> T &amp;y)</span> </span>&#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">equal_to</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;x, <span class="type">const</span> T &amp;y)</span> </span>&#123; <span class="keyword">return</span> x == y; &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;x, <span class="type">const</span> T &amp;y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">plus</span> &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;x, <span class="type">const</span> T &amp;y)</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> eleType&gt;</span></span><br><span class="line"><span class="function">eleType <span class="title">test</span><span class="params">(eleType a, eleType b, T func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; plus&lt;int&gt;()(a,b) &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; minus&lt;int&gt;()(a,b) &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; equal_to&lt;int&gt;()(a,b) &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; less&lt;int&gt;()(a,b) &lt;&lt; std::endl;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">test</span>(a, b, <span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;()) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">test</span>(a, b, <span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;()) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">test</span>(a, b, <span class="built_in">equal_to</span>&lt;<span class="type">int</span>&gt;()) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">test</span>(a, b, <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;()) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-CLASS-NAME-obj"><a href="#3-CLASS-NAME-obj" class="headerlink" title="3. CLASS_NAME obj();"></a>3. CLASS_NAME obj();</h4><p>这个写法是一个经典的错误写法。</p>
<p>下面通过一个例子再深刻理解一下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">test</span>() &#123; cout &lt;&lt; <span class="string">&quot;I am ctor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I am func!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;I am &quot;</span> &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们定义了一个函数 print 和一个类 test，main 函数内容为空，程序可以通过编译。</p>
<p>（1）现在，如果我们想定义一个类的对象 p：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">test <span class="title">p</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>程序依然可以通过编译。</p>
<p>（2）接下来，我们希望通过这个对象 p 调用类中的函数 func：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">test <span class="title">p</span><span class="params">()</span></span>; </span><br><span class="line">p.<span class="built_in">func</span>();</span><br></pre></td></tr></table></figure>

<p>发现程序报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: request for member &#x27;func&#x27; in &#x27;p&#x27;, which is of non-class type &#x27;test()&#x27;</span><br><span class="line">   26 |     p.func();</span><br></pre></td></tr></table></figure>

<p>大致意思就是说我们的 p 不是一个 class 类型，所以它不存在成员函数，咦，我们不是定义了一个 class 对象 p 并且编译通过了吗？怎么现在又报错呢？</p>
<p>这是因为 C++ 兼容 C 的缘故，编译器看到 p 后面跟着一个 () ，就会将 <code>test p();</code> 解释为声明一个函数，函数名是 p，返回值类型是 class test。这当然没问题。</p>
<p>但是我们现在通过函数名调用 class 的成员函数 func 就不合理了。</p>
<blockquote>
<p>小插曲：可以在函数的内部声明函数吗？</p>
<p>这关系到 <strong>C 语言的标准规范</strong>和<strong>具体编译器的实现</strong>问题。</p>
<p>　从标准规范来看：</p>
<ol>
<li>C语言<strong>允许函数里声明函数</strong>，但是不建议这么写，因为不利于多文档的组织。</li>
<li>C语言<strong>禁止函数里定义函数</strong>，但是个别编译器却没遵循标准。</li>
<li><strong>C语言的标准</strong>和<strong>编译器的实现</strong>并不是完全统一，为了可移植性，建议一切都按 C 语言标准中推荐的做法来写。</li>
</ol>
<p>综上所述，在函数内声明函数是合法的，并且在链接到另外一个文件中的函数时，也可以在函数内部声明。但是这种语法不应该被我们使用，因为它不利于代码的移植性和规范性。</p>
<p>例如下面两个文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* declare.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;I am &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* main.cpp */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;MAIN: &quot;</span> &lt;&lt; <span class="built_in">print</span>(<span class="number">1024</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  g++ declare.cpp main.cpp -o app</span></span><br><span class="line"><span class="comment">//  输出：</span></span><br><span class="line"><span class="comment">//  MAIN: I am 1024</span></span><br><span class="line"><span class="comment">//  1024</span></span><br></pre></td></tr></table></figure>

<p>经过测试发现可以正常执行。</p>
</blockquote>
<p>（3）但是在上一节的例子中，我们的语句 <code>std::cout &lt;&lt; test(a, b, plus&lt;int&gt;()) &lt;&lt; std::endl;</code> 可以正确执行。</p>
<p> <code>plus&lt;int&gt;()</code> 的作用是创建一个 “没有名字的” 临时对象，它会调用默认构造函数并且不会解释为函数。</p>
<p>而且如果我们声明语句： <code>less&lt;int&gt; tmp();</code> 依然会解释为一个函数。</p>
<p>（4）如何声明一个类的临时对象？</p>
<p>在上面的说明中，之所以编译器会将<code> less&lt;int&gt; tmp();</code> 解释为一个函数，其实主要是因为我们指定了“这个东西的名字”！如果我们不指定“名字”，而是直接： <code>less&lt;int&gt; ();</code> 那么编译器就会将这句话看做是声明一个 class less 的临时对象。</p>
<p>综上，创建临时对象的语法：<code>CLASS[&lt;&gt;] ();</code></p>
<p>这就是通过 <code>()</code> 调用默认构造函数，注意不要与上面的东西混淆了，他们的区别仅仅在于是否有名字，但是解释后的结果却截然相反，一个是函数，一个是对象。</p>
<h3 id="0x04-template"><a href="#0x04-template" class="headerlink" title="0x04 template"></a>0x04 template</h3><h4 id="1-class-template"><a href="#1-class-template" class="headerlink" title="1. class template"></a>1. class template</h4><p>不多做介绍。</p>
<h4 id="2-function-template"><a href="#2-function-template" class="headerlink" title="2. function template"></a>2. function template</h4><p>函数模版在编译后得到的是一个 “半成品”，它不一定能保证使用。意思就是模版本身编译可以通过，当真正使用时会再编译一次（这次实参的类型已经确定了），这时能不能通过就不确定了（类型不合适之类，或者你得类没有重载相应的运算符）。</p>
<h4 id="4-member-template"><a href="#4-member-template" class="headerlink" title="4. member template"></a>4. member template</h4><p>成员模板。</p>
<p>向上转型（<strong>up-cast</strong>）：在将继承关系画成图的时候，我们通常将父类画在图的上方，子类画在图的下方，子类指向父类。因为子类到父类的转换我们形象的称其为 “向上转型”。</p>
<p>在成员模板中，子类的对象可以传给父类，因为子类从父类继承，它拥有父类的东西，但是父类不一定包含子类的东西，所以说父类的对象不可以传给父类。当我们把一个子类的对象传给父类的时候，我们说发生了 “<strong>up-case</strong>”。</p>
<p>如图：（我们通常用用△来表示继承关系，用◇箭头表示 point 关系，point 关系的 ◇ 在指针一方而不是指向的对象一方，继承关系的△在父类乙方）<img src="https://s3.bmp.ovh/imgs/2022/10/25/90eda9ffa0c8f118.png" alt="IMG"></p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line">    </span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Pair</span>() : <span class="built_in">first</span>(<span class="built_in">T1</span>()), <span class="built_in">second</span>(<span class="built_in">T2</span>()) &#123; cout &lt;&lt; <span class="string">&quot;ctor1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Pair</span>(<span class="type">const</span> T1 &amp;a, <span class="type">const</span> T2 &amp;b) : <span class="built_in">first</span>(a), <span class="built_in">second</span>(b) &#123; cout &lt;&lt; <span class="string">&quot;ctor2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U1, <span class="keyword">class</span> U2&gt;</span></span><br><span class="line"><span class="function">    <span class="title">Pair</span><span class="params">(<span class="type">const</span> Pair&lt;U1, U2&gt; &amp;p)</span> : first(p.first), second(p.second) &#123;</span> cout&lt;&lt; <span class="string">&quot;ctor3&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;print&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* test 1 */</span></span><br><span class="line">    Pair&lt;<span class="type">char</span>, <span class="type">double</span>&gt; p1 = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="number">23.32</span>&#125;;</span><br><span class="line">    cout &lt;&lt; p1.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p1.second&lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Pair&lt;int, int&gt; p2 = p1;</span></span><br><span class="line">    Pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p2 = <span class="built_in">Pair</span>&lt;<span class="type">char</span>, <span class="type">double</span>&gt;(<span class="string">&#x27;A&#x27;</span>, <span class="number">23.32</span>);</span><br><span class="line">    cout &lt;&lt; p2.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p2.second&lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/* test 2 */</span></span><br><span class="line">    <span class="comment">// 向上转型</span></span><br><span class="line">    Pair&lt;Base, Base&gt; p3;</span><br><span class="line">    Pair&lt;Derived, Derived&gt; p4;</span><br><span class="line"></span><br><span class="line">    Pair&lt;Base, Base&gt; p5 = <span class="built_in">Pair</span>&lt;Derived, Derived&gt;(); <span class="comment">// up-cast</span></span><br><span class="line">    Pair&lt;Base, Base&gt; p6 = p4;   <span class="comment">// up-cast</span></span><br><span class="line">    <span class="comment">// Pair&lt;Derived, Derived&gt; p7 = p3;  // cant up-cast</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* test3 */</span></span><br><span class="line">    <span class="comment">// 声明一个临时对象</span></span><br><span class="line">    <span class="built_in">Pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; ().<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会问，为什么可以把子类的传给父类，而父类不可以传给子类？</p>
<blockquote>
<p>s别钻牛角筋。你只需要牢记，面向对象的考虑都是从现实生活考虑的。</p>
<p>现在假设动物是父类，哺乳类和鸟类分别是子类。（<strong>up-cast</strong>）</p>
<p>哺乳动物和鸟类是动物，但是动物不一定是鸟类或者哺乳类。</p>
<p>就是这么简单。</p>
</blockquote>
<h4 id="5-specialization"><a href="#5-specialization" class="headerlink" title="5. specialization"></a>5. specialization</h4><h5 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h5><p>模板特化就是将模板中的一部分类型抽离出来，明确的规定好是什么类型。</p>
<p>模板特化的种类：</p>
<ol>
<li><p>(full) specialization：模版特化（全特化）</p>
</li>
<li><p>paritical specialization：模版偏特化（局部特化）</p>
<p>(1) 个数的偏特化</p>
<p>(2) 范围的偏特化</p>
</li>
<li><p>template template parameter：模版模版参数</p>
</li>
</ol>
<p>语法：就如同我们前面说的那样，模板特化就是在原模板的基础上，将一部分类型从模板中 “抽离” 出来，直接写在类名的后面，然后在模板中删去这个类型即可。但是在偏特化中，即使我们只是抽取了一部分类型，也要把所有类型写在类中。</p>
<h5 id="5-2-全特化和偏特化"><a href="#5-2-全特化和偏特化" class="headerlink" title="5. 2 全特化和偏特化"></a>5. 2 全特化和偏特化</h5><p>类模板全特化的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hash</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Hash</span>() &#123; cout &lt;&lt; <span class="string">&quot;T1 &amp;&amp; T2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板全特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="comment">// 抽离 class key</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hash</span>&lt;<span class="type">int</span>, <span class="type">char</span>&gt; &#123; <span class="comment">// 加上 &lt;int&gt;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Hash</span>() &#123; cout &lt;&lt; <span class="string">&quot;int &amp;&amp; char&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (个数)模板偏特化 1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hash</span>&lt;T2, <span class="type">int</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Hash</span>() &#123; cout &lt;&lt; <span class="string">&quot;T2 &amp;&amp; int&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (个数)模板偏特化 2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hash</span>&lt;<span class="type">int</span>, T2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Hash</span>() &#123; cout &lt;&lt; <span class="string">&quot;int &amp;&amp; T2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (范围)模板偏特化 1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hash</span>&lt;T1*, T2*&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Hash</span>() &#123; cout &lt;&lt; <span class="string">&quot;T1* &amp;&amp; T2*&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (范围)模板偏特化 2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hash</span>&lt;<span class="type">int</span>*, T2*&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Hash</span>() &#123; cout &lt;&lt; <span class="string">&quot;int* &amp;&amp; T2*&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Hash&lt;<span class="type">int</span>,  <span class="type">char</span>&gt;   h1;    <span class="comment">// int &amp;&amp; char</span></span><br><span class="line">    <span class="comment">// Hash&lt;int,  int&gt;  h2; // ambiguous</span></span><br><span class="line">    Hash&lt;<span class="type">char</span>, <span class="type">char</span>&gt;   h3;    <span class="comment">// T1 &amp;&amp; T2</span></span><br><span class="line">    Hash&lt;<span class="type">char</span>, <span class="type">int</span>&gt;    h4;    <span class="comment">// T2 &amp;&amp; int</span></span><br><span class="line">    Hash&lt;<span class="type">int</span>*, <span class="type">int</span>*&gt;   h5;    <span class="comment">// int* &amp;&amp; T2*</span></span><br><span class="line">    Hash&lt;<span class="type">char</span>*, <span class="type">char</span>*&gt; h6;    <span class="comment">// T1* &amp;&amp; T2*</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们将模板的类型固定为具体类型（指定类型的指针也是具体类型）的时候，我们称其为<strong>个数偏特化</strong>，如果固定为一个指针（没有指定类型），称为<strong>范围偏特化</strong>。</p>
<p>可以发现，模板特化与模板可以共存，并且当我们传入的类型可以从特化的模板中匹配时，会<strong>优先考虑特化的模板</strong>，如果有很多个特化的模板可供选择，选择<strong>特化程度最高的</strong>。</p>
<p>另外，当我们声明 h2 的时候会产生二义性，这是因为两个个数偏特化的模板都符合要求，并且优先级相同，编译器不知道调用那个了。同样 h7 也会产生二义性，因为个数偏特化2 和 范围偏特化1 发生了冲突。</p>
<p>由此，我们可以发现模板特化很容易产生冲突啊。</p>
<p>上面的例子都是特化类模板，如果我们特化的是函数模板呢？加入此时同时存在普通函数，特化模板，纯模板，函数调用的优先级是什么呢?</p>
<blockquote>
<p>普通函数的优先级 &gt; 特化 &gt; 非特化</p>
</blockquote>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T1 a, T2 b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template&lt;T1, T2&gt; func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template&lt;int,int&gt; func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, T2 b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template&lt;int,int&gt; func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;normal func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">3.14</span>;</span><br><span class="line">    <span class="built_in">func</span>(a, b); <span class="comment">// int,int</span></span><br><span class="line">    <span class="built_in">func</span>(a, d); <span class="comment">// int, double</span></span><br><span class="line">    <span class="built_in">func</span>(c, d); <span class="comment">// char, double</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*normal func</span></span><br><span class="line"><span class="comment">template&lt;int,int&gt; func</span></span><br><span class="line"><span class="comment">template&lt;T1, T2&gt; func*/</span></span><br></pre></td></tr></table></figure>

<p>使用普通函数重载和使用模板特化还是有不同之处，主要表现在如下三个方面：</p>
<ol>
<li><p>如果使用普通重载函数，那么不管是否发生实际的函数调用，都会在目标文件中生成该函数的二进制代码。而如果使用模板的特化版本，除非发生函数调用，否则不会在目标文件中包含特化模板函数的二进制代码。这符合函数模板的“<strong>惰性实例化</strong>”准则。</p>
</li>
<li><p>如果使用普通重载函数，那么在分离编译模式下，需要在各个源文件中包含重载函数的申明，否则在某些源文件中就会使用模板函数，而不是重载函数。</p>
</li>
<li><p>模板特化版本还是模板，必须放到头文件里面。普通函数重载得放在.c和.cpp里面。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e78d9d3bf535">为什么不该特化函数模板</a></p>
<h5 id="5-3-模板模板参数"><a href="#5-3-模板模板参数" class="headerlink" title="5.3 模板模板参数"></a>5.3 模板模板参数</h5><p>模板模板参数的含义就是模板的一个参数又是一个模板。</p>
<p>例如：<a target="_blank" rel="noopener" href="https://blog.csdn.net/men_wen/article/details/74033327">参考自</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板类 XCls 的一个参数是一个又是一个模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, </span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; </span><br><span class="line">        <span class="keyword">typename</span> Container</span><br><span class="line">        &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TT</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Container&lt;T&gt; c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2 = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Foo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T1 t1;</span><br><span class="line">        T2 t2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TT&lt;string, Bar&gt; mylst1;</span><br><span class="line">    TT&lt;string, Foo&gt; mylst2;</span><br><span class="line">    <span class="comment">// 很奇怪</span></span><br><span class="line">    <span class="comment">// TT&lt;string, list&gt;   mylst3;</span></span><br><span class="line">    <span class="comment">// TT&lt;string, map&gt;    mylst4;</span></span><br><span class="line">    TT&lt;string, set&gt;    mylst5;</span><br><span class="line">    TT&lt;string, vector&gt; mylst6;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="0x05-reference-VS-pointer"><a href="#0x05-reference-VS-pointer" class="headerlink" title="0x05 reference VS. pointer"></a>0x05 reference VS. pointer</h3><p>引用：代表</p>
<p>指针：指向</p>
<p>引用的底层实现就是指针</p>
<p>reference 就是一种漂亮的 pointer</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cnmilan/article/details/7464233?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-7464233-blog-78511858.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-7464233-blog-78511858.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=1">[1]</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/384591552">[3]</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_33868027/article/details/86379309?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-86379309-blog-7464233.pc_relevant_layerdownloadsortv1&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-86379309-blog-7464233.pc_relevant_layerdownloadsortv1&utm_relevant_index=1">[2]</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/coutamg/article/details/61924902?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-61924902-blog-100904422.pc_relevant_layerdownloadsortv1&spm=1001.2101.3001.4242.1&utm_relevant_index=3">[4]</a></p>
<p>signature签名, const算函数签名，但是引用不算</p>
<p>string 内部是一个指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;sddsdasa&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="0x06-vptr-amp-amp-vtbl"><a href="#0x06-vptr-amp-amp-vtbl" class="headerlink" title="0x06 vptr &amp;&amp; vtbl"></a>0x06 vptr &amp;&amp; vtbl</h3><p><img src="https://s3.bmp.ovh/imgs/2022/10/25/e00b2a81977cdfb5.png" alt="img"></p>
<p>虚指针和虚表:放的都是函数指针</p>
<p>在继承中，成员变量直接把内存也继承了过来，而成员函数只是继承了使用权（它不会在生成一份），因此，如果父类有虚函数，子类也一定有（不管你有没有实现）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> data1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> data2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="type">int</span> data1;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> data3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    C c;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">sizeof</span>(c) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们可以发现 sizeof(a)=16，这是因为虚指针占用8字字节并且对其的原因</span></span><br></pre></td></tr></table></figure>

<p>打印虚函数的地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="type">int</span> base_data;</span><br><span class="line">    <span class="built_in">Base</span>() &#123; base_data = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;base_func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;base_func2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;base_func3&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="type">int</span> derive_data;</span><br><span class="line">    <span class="built_in">Derive</span>() &#123; derive_data = <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;derive_func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;derive_func2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*func)</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base base;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;base: &quot;</span> &lt;&lt; &amp;base &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;base.base_data: &quot;</span> &lt;&lt; &amp;base.base_data &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    Derive derive;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;derive: &quot;</span> &lt;&lt; &amp;derive &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;derive.base_data: &quot;</span> &lt;&lt; &amp;derive.base_data &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&amp;derive.derive_data: &quot;</span> &lt;&lt; &amp;derive.derive_data &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 对象和第一个数据之间的地址差了8，这个8应该存放的时虚指针 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// &amp;base : base首地址</span></span><br><span class="line">        <span class="comment">// (unsigned long*)&amp;base : base的首地址，vptr的地址</span></span><br><span class="line">        <span class="comment">// (*(unsigned long*)&amp;base) : vptr的内容，即vtable的地址，指向第一个虚函数的slot的地址</span></span><br><span class="line">        <span class="comment">// (unsigned long*)(*(unsigned long*)&amp;base) : vtable的地址，指向第一个虚函数的slot的地址</span></span><br><span class="line">        <span class="comment">// vtbl : 指向虚函数slot的地址</span></span><br><span class="line">        <span class="comment">// *vtbl : 虚函数的地址</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>* vtbl = (<span class="type">unsigned</span> <span class="type">long</span>*)(*(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;base) + i;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;slot address: &quot;</span> &lt;&lt; vtbl &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func address: &quot;</span> &lt;&lt; *vtbl &lt;&lt; endl;</span><br><span class="line">        func pfunc = (func)*(vtbl);</span><br><span class="line">        <span class="built_in">pfunc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>* vtbl = (<span class="type">unsigned</span> <span class="type">long</span>*)(*(<span class="type">unsigned</span> <span class="type">long</span>*)&amp;derive) + i;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;slot address: &quot;</span> &lt;&lt; vtbl &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func address: &quot;</span> &lt;&lt; *vtbl &lt;&lt; endl;</span><br><span class="line">        func pfunc = (func)*(vtbl);</span><br><span class="line">        <span class="built_in">pfunc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态绑定的三个条件：指针调用。向上转型。调用虚函数。</p>
<h3 id="0x07-class-VS-struct-in-C"><a href="#0x07-class-VS-struct-in-C" class="headerlink" title="0x07 class VS. struct in C++"></a>0x07 class VS. struct in C++</h3><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/cplus/">C++</a> 中保留了C语言的 struct 关键字，并且加以扩充。在C语言中，struct 只能包含成员变量，不能包含成员函数。而在C++中，struct 类似于 class，既可以包含成员变量，又可以包含成员函数。</p>
<p>C++中的 struct 和 class 基本是通用的，唯有几个细节不同：</p>
<ul>
<li>使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。</li>
<li>class 继承默认是 private 继承，而 struct 继承默认是 public 继承。</li>
<li>class 可以使用模板，而 struct 不能（《<a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/biancheng/cpp/rumen_14/">模板、字符串和异常</a>》一章会讲解模板）。</li>
</ul>
<p>C++ 没有抛弃C语言中的 struct 关键字，其意义就在于给C语言程序开发人员有一个归属感，并且能让C++编译器兼容以前用C语言开发出来的项目。</p>
<p><strong>在编写C++代码时，我强烈建议使用 class 来定义类，而使用 struct 来定义单纯的结构体（无函数），这样做语义更加明确。</strong></p>
<p>在 C 语言中，结构体内无法声明函数，但是我们增加一层抽象（计算机的问题总是可以通过抽象解决），在结构内声明一个指针，让这个指针指向某个函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;func::f&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;self[x]&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="built_in">void</span> (*p1)();</span><br><span class="line">    <span class="built_in">int</span> (*p2)(<span class="type">int</span>);</span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   node s = &#123;</span><br><span class="line">      .data = <span class="number">1</span>,</span><br><span class="line">      .p1 = f,</span><br><span class="line">      .p2 = g</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data: %d\n&quot;</span>, s.data);</span><br><span class="line">    s.<span class="built_in">p1</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p2: %d\n&quot;</span>, s.<span class="built_in">p2</span>(<span class="number">1024</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="0x08-Using"><a href="#0x08-Using" class="headerlink" title="0x08 Using"></a>0x08 Using</h3><h4 id="1-management-namespace"><a href="#1-management-namespace" class="headerlink" title="1. management namespace"></a>1. management namespace</h4><p>配合命名空间，对命名空间权限进行管理**</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//释放整个命名空间到当前作用域</span></span><br><span class="line"><span class="keyword">using</span> std::cout;    <span class="comment">//释放某个变量到当前作用域</span></span><br></pre></td></tr></table></figure>

<h4 id="2-type-alias"><a href="#2-type-alias" class="headerlink" title="2. type alias"></a>2. type alias</h4><p>类型重命名。作用等同typedef，但是逻辑上更直观。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*tptr)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">using</span> uptr = <span class="built_in">void</span>(*)();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;you call f^ ^&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tptr tp = f;</span><br><span class="line">    uptr up = f;</span><br><span class="line">    <span class="built_in">tp</span>();</span><br><span class="line">    <span class="built_in">up</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-inherit-permission"><a href="#3-inherit-permission" class="headerlink" title="3. inherit permission"></a>3. inherit permission</h4><p>继承体系中，改变部分接口的继承权限。</p>
<p>有这样一种应用场景，比如我们需要私有继承一个基类，然后又想将基类中的某些 public 接口在子类对象实例化后对外开放直接使用。如下即可</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/376368003">附：私有继承</a></p>
<h4 id="4-TODO-VS-typedef-amp-define"><a href="#4-TODO-VS-typedef-amp-define" class="headerlink" title="4.TODO: VS. typedef &amp; define"></a>4.TODO: VS. typedef &amp; define</h4><h3 id="0x09-delete-amp-new"><a href="#0x09-delete-amp-new" class="headerlink" title="0x09 delete &amp; new"></a>0x09 delete &amp; new</h3><p>我们在前面已经提到过，调用 new 和 delete 时编译器会转化为调用 operator new 和 operator delete，而 operator new 和 operator delete 的底层调用是 malloc 和 free。也就是对 malloc 和 free 的封装。</p>
<p>我们可以重载 new 和 delete，通过重载 operator new 和 operator delete，实际上就是以我们自己的方式封装 malloc 和 free。</p>
<p><a target="_blank" rel="noopener" href="https://bbs.csdn.net/topics/390822574">重载的 delete 为什么不能执行</a></p>
<p>new ：operator new，array new，placement new</p>
<p>重载的 new 的第一个参数的类型必须是 <code>size_t</code> 。我们在调用 new 函数的时候，并不需要将 size_t 作为参数传入参数列表，而是在 new 后面紧跟着一个类型，例如： <code>new int;</code> 而不是 <code>new(4);</code> 或者 <code>new(int);</code></p>
<p>所以说，在我们 placement new 的时候，为 new 的参数列表中传入 n 个参数，那么实际上 new 的参数列表中有 n+1 个参数。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/27/1f9bf40a891a34f9.png" alt="img"></p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">my_Alloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;you call myAlloc&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_Free</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;you all myFree&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 new 和 delete，其实就是运算符重载</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;you call global new()\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">my_Alloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> extra)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;extra: &quot;</span> &lt;&lt; extra &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">my_Alloc</span>(size + extra);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;you call global delete delete()\n&quot;</span>;</span><br><span class="line">    <span class="built_in">my_Free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;you call global new[]()\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">my_Alloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;you call global delete[]\n&quot;</span>;</span><br><span class="line">    <span class="built_in">my_Free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;you call test&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Foo</span>() &#123; </span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Foo::Foo()&quot;</span> &lt;&lt; endl; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Foo</span>(<span class="type">int</span> x) &#123; </span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Foo::Foo(int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">throw</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        ~<span class="built_in">Foo</span>() &#123; <span class="comment">// 我们这里写析构函数只是为了测试，实际上Foo类并不需要析构函数</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Foo::~Foo()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            cout &lt;&lt;<span class="string">&quot;you call Foo new()\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">my_Alloc</span>(size);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;you call Foo delete delete()\n&quot;</span>;</span><br><span class="line">            <span class="built_in">my_Free</span>(ptr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">static</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;you call Foo new[]()\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">my_Alloc</span>(size);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;you call Foo delete[]\n&quot;</span>;</span><br><span class="line">            <span class="built_in">my_Free</span>(ptr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">// 虚函数表占 8 字节</span></span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*  测试 delete 和 new  */</span></span><br><span class="line">    <span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    <span class="type">double</span> *b = <span class="keyword">new</span> <span class="type">double</span>;</span><br><span class="line">    <span class="built_in">test</span>(a);</span><br><span class="line">    <span class="built_in">test</span>(b);</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 测试 delete array 和 new array */</span></span><br><span class="line">    <span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 测试在 class 上 new 和 delete */</span></span><br><span class="line">    Foo singleF;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(Foo) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(singleF) &lt;&lt; endl;</span><br><span class="line">    Foo *f = <span class="keyword">new</span> Foo[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] f;</span><br><span class="line">    Foo *f2 = ::<span class="keyword">new</span> Foo[<span class="number">5</span>];</span><br><span class="line">    ::<span class="keyword">delete</span>[] f;</span><br><span class="line">    <span class="comment">// Foo *wf = new Foo(1);   // throw exception: terminate called after throwing an instance of &#x27;int&#x27;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* placement new */</span></span><br><span class="line">    <span class="type">int</span> *pn = <span class="built_in">new</span>(<span class="number">1</span>) <span class="type">int</span>; <span class="comment">// new只传入一个参数</span></span><br><span class="line">    <span class="keyword">delete</span> pn;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、-C-2-0"><a href="#七、-C-2-0" class="headerlink" title="七、 C++ 2.0"></a>七、 C++ 2.0</h2><h3 id="0x01-Revolution-of-C"><a href="#0x01-Revolution-of-C" class="headerlink" title="0x01. Revolution of C++"></a>0x01. Revolution of C++</h3><h4 id="1-C-的标准演化"><a href="#1-C-的标准演化" class="headerlink" title="1. C++ 的标准演化"></a>1. C++ 的标准演化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C++98 (c++ 1.0)</span><br><span class="line">C++03</span><br><span class="line">C++11 (C++ 2.0)</span><br><span class="line">C++14</span><br></pre></td></tr></table></figure>

<h4 id="2-C-2-0之后更新的小主题"><a href="#2-C-2-0之后更新的小主题" class="headerlink" title="2. C++ 2.0之后更新的小主题"></a>2. C++ 2.0之后更新的小主题</h4><blockquote>
<p>其实就是我不想太详细的做笔记了 T.T</p>
</blockquote>
<ol>
<li><p><strong>header:</strong> 在引入 C头文件的时候不需要加 .c 后缀是在 C++11 引入的。</p>
</li>
<li><p><strong>space in template expression</strong>:  类似于：<code>vector&lt;vector&lt;int&gt;&gt; v;</code> 最后的两个 <code>&gt;</code> 之间不再需要空格。</p>
</li>
<li><p><strong>auto：</strong>不要滥用 auto，编译器的类型推导在 C++ 11 之前就已经存在了，只不过在 C++11 之后才把这个功能提供给我们。</p>
</li>
<li><p>全局函数 <code>begin()</code> 和 <code>end()</code>，取代 <code>obj.begin()</code> 为 <code>begin(obj)</code>。</p>
</li>
</ol>
<h3 id="0x02-Variadic-Templates"><a href="#0x02-Variadic-Templates" class="headerlink" title="0x02. Variadic Templates"></a>0x02. Variadic Templates</h3><p>7大例子</p>
<h3 id="0x03-nullptr-and-std-nullptr-t"><a href="#0x03-nullptr-and-std-nullptr-t" class="headerlink" title="0x03. nullptr and std::nullptr_t"></a>0x03. nullptr and std::nullptr_t</h3><p>C++11 lets you use nullptr instead of 0 or NULL to specify that a pointer refers to no value(with differs from habing an undefined value). </p>
<p>用法：<code>void *p = nullptr;</code></p>
<p>nullptr 的一个好处是它显示的指明：我是一个空指针。</p>
<p>而在次之前，我们使用 NULL 来表示空指针，但其实 NULL 只不过是一个值为 0 的宏罢了，它也可以被解释成其他类型，例如整形，浮点型等。</p>
<p>但是 nullptr 只能被解释为指针，这在下图的例子中深有体现：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/26/4b9ea5742d3f1eea.png" alt="IMG"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I am int&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I am pointer&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">0</span>);       <span class="comment">// &quot;I am int&quot;</span></span><br><span class="line">    <span class="comment">// f(NULL); // ambigious</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="literal">nullptr</span>); <span class="comment">// &quot;I am pointer&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="0x04-Uniform-Initializarion"><a href="#0x04-Uniform-Initializarion" class="headerlink" title="0x04 Uniform Initializarion"></a>0x04 Uniform Initializarion</h3><p>一致性初始化。</p>
<p>在 C++11 之前，对象的初始化可能发生在：</p>
<ol>
<li>大括号 {} 之后</li>
<li>小括号 () 之后</li>
<li>赋值运算符之后</li>
</ol>
<p>这让人很迷惑，到底什么时候用什么样的初始化方式呢？</p>
<p>基于这个原因，C++11 统一使用大括号 {} 来初始化。当然，之前的小括号和赋值也会向前兼容。</p>
<p><strong>原理：</strong>编译器会把大括号 {} 内的所有参数<strong>打包</strong>到一个数据结构 <code>initializer_list&lt;&gt;</code> 中，形成一个<strong>数据包</strong>，并关联到一个 <code>array&lt;T,n&gt;</code> 容器中，<code>T</code> 是类型，<code>n</code> 是参数。当我们调用函数的时候（例如 ctor），<code>array</code> 内的所有元素会被编译器逐一分解给函数。但若函数参数是个 <code>initializer&lt;_list&gt;</code>，不会自动分解，也就是说，传给函数参数的仍然是数据包 <code>initializer_list&lt;int&gt;</code>，而不是单一的一个个 <code>&lt;int&gt;</code> 数据。（很合理）</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/26/080a6ee4df06aa92.png" alt="img"></p>
<h3 id="0x05-Initializer-lists"><a href="#0x05-Initializer-lists" class="headerlink" title="0x05 Initializer lists"></a>0x05 Initializer lists</h3><p>用于初始化，并且可以默认初始化，在 gcc 平台上还可以做隐式类型转换。(注意在投影片中不可以做隐式类型转换，这应该是编译器平台的问题，不必深究)</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/26/b4766877737c31e2.png" alt="img"></p>
<h4 id="1-Initializaer-lists-的底层结构："><a href="#1-Initializaer-lists-的底层结构：" class="headerlink" title="1. Initializaer lists 的底层结构："></a>1. Initializaer lists 的底层结构：</h4><h4 id="initializer-list-lt-gt"><a href="#initializer-list-lt-gt" class="headerlink" title="initializer_list&lt;&gt;"></a><code>initializer_list&lt;&gt;</code></h4><p><img src="https://s3.bmp.ovh/imgs/2022/10/26/a00c529e01d71682.png" alt="IMG"></p>
<p>Initializer_list&lt;&gt; 和 Variadic Templates 的区别在于前者只能传入统一类型的参数，而后者可以传入不同类型的参数</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(initializer_list&lt;<span class="type">int</span>&gt; vals)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p = vals.<span class="built_in">begin</span>(); p != vals.<span class="built_in">end</span>(); p ++ )</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">p</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">p</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;P(int,int), a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">p</span>(initializer_list&lt;<span class="type">int</span>&gt; list)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;P(Initializer_list&lt;int&gt;), val = &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(initializer_list&lt;<span class="type">int</span>&gt;::iterator it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); it ++ )</span><br><span class="line">                cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">p <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    p b&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    p c&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    p d = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">P(int,int), a = 1 b = 2</span></span><br><span class="line"><span class="comment">P(Initializer_list&lt;int&gt;), val = 1 2 </span></span><br><span class="line"><span class="comment">P(Initializer_list&lt;int&gt;), val = 1 2 3 </span></span><br><span class="line"><span class="comment">P(Initializer_list&lt;int&gt;), val = 1 2 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>下图中包含了 <code>initializer_list&lt;int&gt;</code> 的源码，编译器会调用它的私有的构造函数，将一个容器 <code>array</code> 的头和大小传给它（当然，在此之前，编译器已经构造好了一个 <code>array</code> 容器）。</p>
<blockquote>
<p>编译器拥有无上权限，它可以调用你的私有对象！</p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/26/5fba537fae2977b6.png" alt="IMG"></p>
<p>如上图，在 <code>class initializer_list&lt;&gt;</code> 源代码中，我们可以发现它内部并没有包含元素，所有的元素都在 <code>array</code> 中，而它只是包含一个指向 <code>array</code> 的指针。</p>
<p>所以说如果我们 copy <code>initializer_list&lt;int&gt;</code> ，实际上是一个浅拷贝。</p>
<p><code>initializer_list&lt;&gt;</code> 被广泛应用于容器和算法当中，也就是说这些容器和算法都可以接受任意数量的参数。</p>
<h4 id="2-关联的容器-array"><a href="#2-关联的容器-array" class="headerlink" title="2. 关联的容器 array"></a>2. 关联的容器 array</h4><p><code>array</code> 就是数组的另一种表现性质，只不过它现在是一个容器，可以利用容器的很多接口，例如迭代器 begin(), end(), 和算法等。</p>
<p>在 array 容器中，如果你传入的长度是 0，它内部会变为 1，毕竟长度为 0 的容器不太合理。。 <code>len ? len : 1;</code></p>
<p>如下图，红圈中的内容需要额外注意：</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/26/0fd7a98ee82afd23.png" alt="img"></p>
<h3 id="0x06-explicit"><a href="#0x06-explicit" class="headerlink" title="0x06 explicit"></a>0x06 explicit</h3><blockquote>
<p> 构造函数的类型</p>
</blockquote>
<p><strong>构造函数</strong>分为无参构造函数，和有参构造函数。有参构造函数又分为单参数构造函数和多参数构造函数</p>
<p><strong>C++中存在隐式构造的现象：在某些情况下，会隐式调用单参数的构造函数</strong></p>
<p>总而言之，大概就是 <code>A a(10);</code> 就是显式调用构造函数。而 <code>A a = 10;</code> 就是显式的调用构造函数。</p>
<p>但是这种隐式调用有些不太好，因为我们的本意可能不是调用构造函数，所以我们有了 explicit 关键字</p>
<blockquote>
<p> explicit</p>
</blockquote>
<p>在C++中，<code>explicit</code>关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的<strong>隐式类型转换</strong>，只能以显示的方式进行类型转换。因为无参构造函数和多参构造函数本身就是显示调用的。再加上<code>explicit</code>关键字也没有什么意义。</p>
<p>在 C++2.0 之前，是  <strong>explicit for ctor one argument</strong>，这个我们前面已经介绍过了，不再多做介绍。</p>
<p>在 C++2.0 之后，有了<strong>explicit for ctors taking more than one argument</strong>，我们发现多了一个 more than，这是因为 C++2.0 提供了一种新的语法：<code>initializer_list&lt;&gt;</code> ，这个我们前面也提到过了。所以说，现在我们不仅传入一个单参数会隐式调用  ctor，传入一个数据包也会调用  ctor。</p>
<blockquote>
<p>参考</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cpp_learner/article/details/117883912?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-117883912-blog-84141043.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-117883912-blog-84141043.pc_relevant_recovery_v2&utm_relevant_index=2">implicit &amp; explicit</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45452278/article/details/126019006">隐式构造函数</a></p>
<blockquote>
<p>举几个例子：</p>
</blockquote>
<p>例1：下面的代码可以正确运行，但如果我们将 p 的构造函数用关键字 explicit 修饰的话，编译器就会报错。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">p</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:    </span><br><span class="line">        <span class="built_in">p</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;P(int,int,int), a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b </span><br><span class="line">                &lt;&lt; <span class="string">&quot;, c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">// 隐式类型转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例2；下面的代码可以正确运行，但如果我们将 C 的构造函数用关键字 explicit 修饰的话，编译器就会报错。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">C</span>(string _s) : <span class="built_in">s</span>(_s) &#123;&#125;;</span><br><span class="line">        string s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> C c) &#123;</span><br><span class="line">    <span class="keyword">return</span> cout &lt;&lt; c.s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; s = &#123;</span><br><span class="line">        <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;cpp&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> C &amp;ele : s)   <span class="comment">// 隐式类型转换</span></span><br><span class="line">        cout &lt;&lt; ele &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">world</span></span><br><span class="line"><span class="comment">cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>但如果我们以如下方式进行 for 循环，那么程序依然可以正确执行，这是因为我们使用的不再是隐式类型转换，而是显式类型转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ele : s) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">C</span>(ele) &lt;&lt; endl; <span class="comment">// 显式类型转换</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="0x07-range-based-for-statement"><a href="#0x07-range-based-for-statement" class="headerlink" title="0x07 range-based for statement"></a>0x07 range-based for statement</h3><p><strong>range-based for statement</strong>：即 for 函数</p>
<p>有以下需要注意的点：</p>
<ol>
<li>和 auto结合使用效果极佳。</li>
<li>关联式容器不可以用 auto 修改元素的值。</li>
<li>for 的实质就是迭代器遍历。如下图所示：</li>
</ol>
<p><img src="https://s3.bmp.ovh/imgs/2022/10/26/8268f467b08cd0b7.png" alt="IMG"></p>
<h3 id="0x08-x3D-default-x3D-delete"><a href="#0x08-x3D-default-x3D-delete" class="headerlink" title="0x08 &#x3D;default, &#x3D;delete"></a>0x08 &#x3D;default, &#x3D;delete</h3><p>一言以蔽之：&#x3D;default 用来让编译器生成默认函数，&#x3D;delete 用来删除编译器生成默认函数</p>
<p>c++ 右值引用</p>
<p>参考：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tutuxs/article/details/54947395">big fice</a></p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7829.html">右值引用</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Braveliu/p/12247471.html">&#x3D;default, &#x3D;delete</a></p>
</blockquote>
<h3 id="0x09-Alias-Template"><a href="#0x09-Alias-Template" class="headerlink" title="0x09 Alias Template"></a>0x09 Alias Template</h3><h3 id="0x0a-decltype"><a href="#0x0a-decltype" class="headerlink" title="0x0a decltype"></a>0x0a decltype</h3><p>declareType</p>
<p>当我们用了：：的时候，加上 typename 让编译器直到我们要的是一个类型。</p>
<p>![img](file:&#x2F;&#x2F;&#x2F;C:\Users\24072\AppData\Roaming\Tencent\Users\2407217576\QQ\WinTemp\RichOle\1[</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/2023/06/15/memoy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/15/memoy/" class="post-title-link" itemprop="url">Memory Management</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-15 20:20:57" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-16 10:15:43" itemprop="dateModified" datetime="2023-06-16T10:15:43+08:00">2023-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-Memory-Management"><a href="#C-Memory-Management" class="headerlink" title="C++ Memory Management"></a>C++ Memory Management</h1><h2 id="0x00-prelogue"><a href="#0x00-prelogue" class="headerlink" title="0x00 prelogue"></a>0x00 prelogue</h2><h3 id="1-source"><a href="#1-source" class="headerlink" title="1. source"></a>1. source</h3><p>候捷 C++ 内存管理课程 笔记</p>
<p><a target="_blank" rel="noopener" href="https://gee.cs.oswego.edu/">DL Malloc</a></p>
<p><a target="_blank" rel="noopener" href="https://gee.cs.oswego.edu/dl/html/malloc.html">A Memory Allocator</a></p>
<h3 id="2-english"><a href="#2-english" class="headerlink" title="2. english"></a>2. english</h3><p>macro：宏</p>
<h3 id="3-quote"><a href="#3-quote" class="headerlink" title="3. quote"></a>3. quote</h3><p>0x01 万丈高楼平地起</p>
<p>0x02 西北有高楼，上与浮云齐（为什么孔雀东南飞，因为西北有高楼）</p>
<h2 id="0x01-primitives"><a href="#0x01-primitives" class="headerlink" title="0x01 primitives"></a>0x01 primitives</h2><h3 id="1-分配内存的层级"><a href="#1-分配内存的层级" class="headerlink" title="1. 分配内存的层级"></a>1. 分配内存的层级</h3><p><img src="https://s3.bmp.ovh/imgs/2023/03/08/401ce1768fecfa41.png" alt="img"></p>
<p>malloc 并不是 c++ 的一部分，它属于更低阶的 c 中的 c-runtime-library 的一部分。</p>
<p>调用层次太低阶会导致移植性变差，所以最好不要在程序中使用底层调用函数。</p>
<h3 id="2-c-primitivies"><a href="#2-c-primitivies" class="headerlink" title="2.c++ primitivies"></a>2.c++ primitivies</h3><p><img src="https://s3.bmp.ovh/imgs/2023/03/08/b8ef04e0d7761b29.png" alt="c++"></p>
<p>测试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ::operator new</span></span><br><span class="line"><span class="type">void</span> *pp = ::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">// int *p = new(pp) int(4);</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; *p &lt;&lt; endl;</span></span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pp)</span></span>;  <span class="comment">// 必须加括号，因为是个函数</span></span><br><span class="line"><span class="comment">// allocator</span></span><br><span class="line"><span class="type">int</span> *pa = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )</span><br><span class="line">    *(pa + i) = i + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ )</span><br><span class="line">    cout &lt;&lt; pa[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(pa, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-new-expression"><a href="#3-new-expression" class="headerlink" title="3. new expression"></a>3. new expression</h3><p>不能直接调用构造函数，非要调用的话，可以通过 <code>placement new</code> 来调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span>   <span class="comment">// not limits.h !! </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node_t</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">node_t</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">node_t</span>(<span class="type">int</span> _val, <span class="type">int</span> _len) : <span class="built_in">val</span>(_val), <span class="built_in">len</span>(_len) &#123;&#125;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// now, we want Node *pn = new Node(1,2);</span></span><br><span class="line">    <span class="comment">// compiler will conver this sentense in followings </span></span><br><span class="line"></span><br><span class="line">    Node *pn = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// like this way 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> V1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">void</span> *mem = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">        pn = <span class="built_in">static_cast</span>&lt;Node*&gt;(mem);</span><br><span class="line">        <span class="comment">// pn-&gt;Node::Node(1,2);    // 注意只有编译器能调用构造函数，因此本行编译不通过</span></span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(mem)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(std::bad_alloc &amp;c) &#123;  <span class="comment">// pass by ref</span></span><br><span class="line">        cout &lt;&lt; c.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">    <span class="comment">// like this way 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> V2</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cnt = numeric_limits&lt;<span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">        <span class="type">void</span> *mem = <span class="keyword">operator</span> <span class="built_in">new</span>(cnt * <span class="built_in">sizeof</span>(Node));</span><br><span class="line">        pn = <span class="built_in">new</span>(mem) <span class="built_in">Node</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        cout &lt;&lt; pn-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; pn-&gt;len &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(std::bad_alloc &amp;c) &#123;  <span class="comment">// pass by ref</span></span><br><span class="line">        cout &lt;&lt; c.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-delete-expression"><a href="#4-delete-expression" class="headerlink" title="4. delete expression"></a>4. delete expression</h3><p>可以直接调用析构函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node_t</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">node_t</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">node_t</span>(<span class="type">int</span> _val, <span class="type">int</span> _len) : <span class="built_in">val</span>(_val), <span class="built_in">len</span>(_len) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">node_t</span>() &#123; cout &lt;&lt; <span class="string">&quot;dtor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testMyType</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; newNode-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; newNode-&gt;len &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// now we want to delete newNode</span></span><br><span class="line">    <span class="comment">// delete newNode;</span></span><br><span class="line">    <span class="comment">// like this way in compile:</span></span><br><span class="line">    newNode-&gt;~<span class="built_in">Node</span>();     <span class="comment">// after dtor, newNode convert to a no-type pointer</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(newNode)</span></span>;   <span class="comment">// free memory</span></span><br><span class="line">    <span class="comment">// operator delete call free()</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// And you can found, we can call dtor directly</span></span><br><span class="line">    <span class="comment">// but we cant call ctor directly</span></span><br><span class="line">    <span class="comment">// And we not use newNode-&gt;Node::~Node(); to delete</span></span><br><span class="line">    <span class="comment">// but if we want to ctor(if we can do)</span></span><br><span class="line">    <span class="comment">// we must use like ptr-&gt;Node::Node(x,y); </span></span><br><span class="line">    <span class="comment">// because ptr is not a Node type object current</span></span><br><span class="line">    <span class="comment">// so Node() it not the member function for ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testBuiltInString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string *sptr = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello,world!&quot;</span>);</span><br><span class="line">    cout &lt;&lt; *sptr &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// sptr-&gt;~basic_string&lt;char&gt;();    </span></span><br><span class="line">    <span class="comment">// [Warning]</span></span><br><span class="line">    <span class="comment">// In old version, you cant write like followings</span></span><br><span class="line">    <span class="comment">// becuase string is a typedef of basic_string&lt;char&gt;</span></span><br><span class="line">    <span class="comment">// but now, it is valid....</span></span><br><span class="line">    sptr-&gt;~<span class="built_in">string</span>();</span><br><span class="line">    <span class="keyword">delete</span> sptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testMyType</span>();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">    <span class="built_in">testBuiltInString</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-array-new-x2F-delete"><a href="#5-array-new-x2F-delete" class="headerlink" title="5. array new&#x2F;delete"></a>5. array new&#x2F;delete</h3><p><code>array new</code> 在设计时，都会在分配的空间中添加一个 <code>cookie</code>用来保存一些额外信息，最重要的信息之一就是数组的长度。</p>
<p><code>array new</code> 和 <code>operator new</code> 需要配套使用的一个底层原因是，operator new 和 array new 分配出来的内存结构可能是不同的，例如，<code>array new</code> 分配出来的一块内存可能包含一个长度信息，而 <code>operator new</code> 则不需要。</p>
<p>另外，在析构函数没有意义（对象内没有动态分配的资源…）的情况下，可能可以使用 <code>operator delete</code> 来释放 <code>array new</code>，注意，是可能。因为 <code>operator delete</code> 会释放 <code>array new</code> 分配在堆上的所有内存，内存不会少释放，但是只会调用一次析构函数，因为析构函数没有意义（没有实际作用），所以说，调用一次与调用多次的效果都是一样的。当然，只是有可能，正如上面说的，他们的内存结构可能是不同的。</p>
<p>所以说，千万不要尝试通过 delete 释放 new[]，千万不要！</p>
<h3 id="6-placement-new"><a href="#6-placement-new" class="headerlink" title="6. placement new"></a>6. placement new</h3><p>Placement new 允许我们将 objects 构建与 allocated memory 中。</p>
<p>没有所谓的 placement delete，因为 placement new 根本就没有分配 memory。</p>
<p>当然，你可以称呼 placement new 对应的 operator delete 为 placement delete。因为我们需要为 placement new 重载一个对应的 operator delete。</p>
<p>同 operator new 一样，编译期在内部也会对 placement new 进行转换：</p>
<p>测试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node_t</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">node_t</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">node_t</span>(<span class="type">int</span> _val, <span class="type">int</span> _len) : <span class="built_in">val</span>(_val), <span class="built_in">len</span>(_len) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">node_t</span>() &#123; cout &lt;&lt; <span class="string">&quot;dtor:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testPlacementNew</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;hello,world!&quot;</span>;</span><br><span class="line">    <span class="type">void</span> *buf = ::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">strlen</span>(s) + <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span> *str = <span class="built_in">new</span>(buf) <span class="type">char</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;Hello,World&quot;</span>);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buf)</span></span>; <span class="comment">// match operator new</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testPlacementNew2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *buf = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">sizeof</span>(Node) * <span class="number">3</span>];</span><br><span class="line">    <span class="type">void</span> *nullp;</span><br><span class="line">    Node *p = <span class="built_in">new</span>(nullp) <span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">2</span>);    <span class="comment">// wrong!</span></span><br><span class="line">    cout &lt;&lt; p-&gt;val &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p-&gt;len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span>[] buf;   <span class="comment">// match array new</span></span><br><span class="line">    <span class="comment">/* --------  */</span></span><br><span class="line">    <span class="comment">/* placement new 语句就想当下面的四条语句，发现其实和operator new是一样的</span></span><br><span class="line"><span class="comment">       这是因为 placement new 其实就是调用的 operator new，是不是是其一个重载版本</span></span><br><span class="line"><span class="comment">       这个重载版本第二个参数接受一个指针，在这个指针分配的内存上构造对象</span></span><br><span class="line"><span class="comment">       因此说，我们要保证这个指针不为空或者未定义。。</span></span><br><span class="line"><span class="comment">    Node *p;</span></span><br><span class="line"><span class="comment">    void *mem = operator new(sizeof(Node), buf);</span></span><br><span class="line"><span class="comment">    p = static_cast&lt;Node*&gt;(mem);</span></span><br><span class="line"><span class="comment">    p-&gt;Node::Node(1, 2);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testPlacementNew</span>();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">    <span class="built_in">testPlacementNew2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-分配内存的途径（流程）"><a href="#7-分配内存的途径（流程）" class="headerlink" title="7. 分配内存的途径（流程）"></a>7. 分配内存的途径（流程）</h3><p><img src="https://s3.bmp.ovh/imgs/2023/03/08/e0d5986e17ce2219.png" alt="memory"></p>
<h3 id="8-重载"><a href="#8-重载" class="headerlink" title="8. 重载"></a>8. 重载</h3><p>我们可以重载 class member operator new()，并且重载多个版本，前提是每一个版本都有独特的参数列。重载 new() 必须其第一参数是 <strong>size_t</strong>，其余参数以 new 所指定的 <strong>placement arguments</strong> 作为初值。出现于 new(..) 小括号内的便是 <strong>placement arguements</strong>。此类形式都可以称为<strong>“placement new”</strong>。</p>
<p>例如：<code>Type *p = new(arg1, arg2, ... argn) Type;</code></p>
<p>其中的 <code>arg1, arg2, ... argn</code> 就是 placement arguments。</p>
<hr>
<p>我们可以重载 class member operator delete()，写出多个版本，但他们绝不会被 delete 调用。<strong>只有当 new 所调用的 ctor 抛出 exception 才会调用这些重载版的 oeprator delete()。</strong>它只可能这样被调用，主要用于清理未能称完全创建成功的 object 所占用的 memory。</p>
<p>即使 operator delete 未能一一对应与 operator new，也不会出现报错，你的意思是，放弃 ctor 抛出的任何异常，</p>
<h4 id="8-1-重载全局函数"><a href="#8-1-重载全局函数" class="headerlink" title="8.1 重载全局函数"></a>8.1 重载全局函数</h4><p>重载全局 operator new 和 全局 operator delete，注意重载全局 new 和 delete 是很危险的！</p>
<p>下面是某一版本的 operator new 和 operator delete 的实现：</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/03/08/a5000dbfa22f85f9.png" alt="deleteAndnew"></p>
<p>测试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node_t</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">node_t</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">node_t</span>(<span class="type">int</span> _val, <span class="type">int</span> _len) : <span class="built_in">val</span>(_val), <span class="built_in">len</span>(_len) &#123;&#125;</span><br><span class="line">    <span class="comment">// ~node_t() &#123; cout &lt;&lt; &quot;dtor:&quot; &lt;&lt; this &lt;&lt; endl; &#125;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">myAlloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFree</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator new&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">myAlloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator new[]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">myAlloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator delete with size&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">myFree</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator delete&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">myFree</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator delete[]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">myFree</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *ptr, <span class="type">size_t</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator delete[] with size&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">myFree</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 调用operator delete(void*, size_t)</span></span><br><span class="line">    <span class="comment">// 而不是 operator delete(void*)</span></span><br><span class="line">    <span class="comment">// 很疑惑。。</span></span><br><span class="line">    <span class="keyword">delete</span> p; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> *q = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]&#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">delete</span>[] q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 也是调用 operator delete with size_t</span></span><br><span class="line">    Node *fp = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span> fp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *fparr = <span class="keyword">new</span> Node[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] fparr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">    <span class="built_in">test2</span>();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">    <span class="built_in">test3</span>();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">    <span class="built_in">test4</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过测试之后发现，operator new 调用的是带有 size_t 参数的那个 operator delete，这是为什么呢？⚠️[TODO]</p>
<h4 id="8-2-重载-class-中的函数"><a href="#8-2-重载-class-中的函数" class="headerlink" title="8.2 重载 class 中的函数"></a>8.2 重载 class 中的函数</h4><p>这是更推荐的重载行为。注意在重载 class 中的 new 和 delete时，要将他们设置为 static，因为一般在调用 new 和 delete 时，对象还没有产生。</p>
<p>测试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">char</span> ch, <span class="type">size_t</span> extra)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;global operator new&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;char: &quot;</span> &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;extra: &quot;</span> &lt;&lt; extra &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size + extra);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _val = <span class="number">0</span>) : <span class="built_in">val</span>(_val) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Node</span>() &#123; cout &lt;&lt; <span class="string">&quot;dtor: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator new(size_t): &quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator new(size_t, char): &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;char: &quot;</span> &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator new[]: &quot;</span> &lt;&lt; size &lt;&lt; endl;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此 operator new 没有对应的 operator delete</span></span><br><span class="line">    <span class="comment">// 并且它回调了全局的 operator new</span></span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">size_t</span> extra)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size, <span class="string">&#x27;A&#x27;</span>, extra);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator delete&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator delee with size_t: &quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator delete with char&quot;</span> &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;char: &quot;</span> &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator delete[]&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p = <span class="keyword">new</span> Node;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Node的大小是4，但是array new分配出来是12</span></span><br><span class="line">    <span class="comment">// 也就是说，多分配了8个字节</span></span><br><span class="line">    <span class="comment">// 因此，sizeof(p) = 8 + 4 * sizeof(Node)</span></span><br><span class="line">    Node *p = <span class="keyword">new</span> Node[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p = <span class="built_in">new</span>(<span class="string">&#x27;A&#x27;</span>) Node;</span><br><span class="line">    <span class="keyword">delete</span> p;   <span class="comment">// 不会调用带 char 的operator delete</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> extra = <span class="number">2</span>;</span><br><span class="line">    Node *p = <span class="built_in">new</span>(<span class="number">2</span> * <span class="built_in">sizeof</span>(Node)) Node;</span><br><span class="line">    <span class="comment">// p一共分配了3个Node的空间，但即使我们使用了多余三个，可能结果也是正确的</span></span><br><span class="line">    <span class="comment">// 注意！内存越界问题是未定义行为，什么叫未定义行为？</span></span><br><span class="line">    <span class="comment">// 你测试起来是正确的，别人测试起来是正确的，但在最重要的客户手中却失败了！</span></span><br><span class="line">    </span><br><span class="line">    extra = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; extra; i ++ ) (*(p + i)).val = i + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; extra; i ++ ) cout &lt;&lt; p[i].val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// test1();</span></span><br><span class="line">    <span class="comment">// puts(&quot;------------------------------&quot;);</span></span><br><span class="line">    <span class="comment">// test2();</span></span><br><span class="line">    <span class="comment">// puts(&quot;------------------------------&quot;);</span></span><br><span class="line">    <span class="comment">// test3();</span></span><br><span class="line">    <span class="comment">// puts(&quot;------------------------------&quot;);</span></span><br><span class="line">    <span class="built_in">test4</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-allocator"><a href="#9-allocator" class="headerlink" title="9. allocator"></a>9. allocator</h3><h4 id="9-1-allocator-1-0"><a href="#9-1-allocator-1-0" class="headerlink" title="9.1 allocator 1.0"></a>9.1 allocator 1.0</h4><p><strong>shortcoming:</strong></p>
<ol>
<li><p>复用性差：operator new&#x2F;delete 的重载放在了 class 实现中，如果我们想在另一个类中添加分配器，就需要再写一次</p>
</li>
<li><p>额外空间大：原本我们希望通过内存池设计，减少cookie的内存，但是我们却在class中添加了一个指针，原本只有一个 int 占 4 字节。现在添加了一个指针变成了 16 字节，足足扩大了 4 倍，当然，在我们的 class 原本体积就很大时，例如 100 字节，那么 8 字节的指针大小其实是可以忽略的。但是我们应该有更好的办法解决 next 指针的问题。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> _val = <span class="number">1024</span>) : <span class="built_in">val</span>(_val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> _val, Foo *_next) : <span class="built_in">val</span>(_val), <span class="built_in">next</span>(_next) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">grabage_collection</span><span class="params">()</span></span>;    <span class="comment">// 清理空闲链表</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> Foo* freeStore;               <span class="comment">// 空闲链表</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> FooChunk = <span class="number">24</span>;      <span class="comment">// 每次分配多少个Foo</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">allocate_new_memory</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TEST</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Foo *next;  <span class="comment">// 串连空闲链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义static成员时，不需要再加上static</span></span><br><span class="line">Foo* Foo::freeStore = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Foo::allocate_new_memory</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(freeStore)   <span class="keyword">return</span> ;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TEST</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Call allocate_new_memory!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">    <span class="type">size_t</span> chunk = FooChunk * size; </span><br><span class="line">    Foo *p = <span class="literal">nullptr</span>;</span><br><span class="line">    p = freeStore = (Foo*)<span class="built_in">malloc</span>(chunk);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TEST</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span>(p = freeStore; p != &amp;freeStore[FooChunk - <span class="number">1</span>]; ++ p)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TEST</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; ++ count &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="string">&quot; p: &quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;; p + 1: &quot;</span> &lt;&lt; p + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">        p-&gt;next = p + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Foo::grabage_collection</span><span class="params">()</span> <span class="comment">// cant run！</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(freeStore == <span class="literal">nullptr</span>)    <span class="keyword">return</span> ;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;can free&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">void</span> *ptr = (<span class="type">void</span>*)freeStore;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span>* Foo::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo *p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(freeStore == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="built_in">allocate_new_memory</span>(size);</span><br><span class="line">    p = freeStore;</span><br><span class="line">    freeStore = freeStore-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> Foo::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;Foo*&gt;(p)-&gt;next = freeStore;</span><br><span class="line">    freeStore = <span class="built_in">static_cast</span>&lt;Foo*&gt;(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Foo) &lt;&lt; endl;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> n = <span class="number">1024</span>;</span><br><span class="line">    Foo *p[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = <span class="keyword">new</span> <span class="built_in">Foo</span>(i + <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] now addr: &quot;</span> &lt;&lt; p[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> p[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Foo *tra = Foo::freeStore;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tra != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; ++count &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; tra-&gt;val &lt;&lt; endl;</span><br><span class="line">        tra = tra-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo *p[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = ::<span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">        cout &lt;&lt; p[i] &lt;&lt; endl;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test1</span>();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Test end ...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-allocator-2-0"><a href="#9-2-allocator-2-0" class="headerlink" title="9.2 allocator 2.0"></a>9.2 allocator 2.0</h4><p>在上一个版本中，我们提到了，我们在 class 当中，我们添加了一个成员变量 <code>*next*</code>，这是必要的，因为我们需要将那些放在空闲链表中的内存块串成一个链表。但是，当我们使用某个内存块之后，它的 <code>next</code> 指针就没有用了，因为此时它已经不存在与空闲链表中，所以说，我们可以通过 <code>union</code>，将我们的数据 <code>val</code> 和 <code>*next*</code> 放到同一个地址空间，这样就可以解决 <code>*next*</code> 带来的额外内存消耗。</p>
<p>一般的，我们称这种设计中的 <code>*next*</code> 指针为： <strong>embeded pointer（嵌入式指针）</strong></p>
<p>Code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span>)</span></span>;</span><br><span class="line">    <span class="type">static</span> Foo* freeStore;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> chunkSize = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> _val = <span class="number">0</span>) : <span class="built_in">val</span>(_val) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">allocateNewMemory</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TEST</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 节省内存</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        Foo *next;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo *Foo::freeStore = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Foo::allocateNewMemory</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> chunk = chunkSize * size;</span><br><span class="line">    <span class="comment">// 不要直接在函数中 new/malloc</span></span><br><span class="line">    <span class="type">void</span> *mem = <span class="built_in">malloc</span>(chunk);</span><br><span class="line">    <span class="built_in">assert</span>(mem);</span><br><span class="line">    Foo *p = <span class="literal">nullptr</span>;</span><br><span class="line">    p = freeStore = <span class="built_in">static_cast</span>&lt;Foo*&gt;(mem);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; chunkSize - <span class="number">1</span>; i ++ )</span><br><span class="line">        p[i].next = p + (i + <span class="number">1</span>);</span><br><span class="line">    p[chunkSize - <span class="number">1</span>].next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> *Foo::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 内存分配有误，交给全局 operator new 处理</span></span><br><span class="line">    <span class="keyword">if</span>(size != <span class="built_in">sizeof</span>(Foo))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;size[&quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;] not match&quot;</span> &lt;&lt; endl; </span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    Foo *p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(freeStore == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="built_in">allocateNewMemory</span>(size);</span><br><span class="line">    <span class="built_in">assert</span>(freeStore);</span><br><span class="line">    p = freeStore;</span><br><span class="line">    freeStore = freeStore-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> Foo::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 可以删除nullptr</span></span><br><span class="line">    <span class="keyword">if</span>(ptr == <span class="literal">nullptr</span>)  <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(size != <span class="built_in">sizeof</span>(Foo))</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">delete</span>(ptr);</span><br><span class="line">    <span class="comment">// 删除只是重新添加到空闲链表</span></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;Foo*&gt;(ptr)-&gt;next = freeStore;</span><br><span class="line">    freeStore = <span class="built_in">static_cast</span>&lt;Foo*&gt;(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo::~<span class="built_in">Foo</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> dtorCount = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; dtorCount &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; <span class="string">&quot;dtor: &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> n = <span class="number">32</span>;</span><br><span class="line">    Foo* f[n];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="keyword">new</span> <span class="built_in">Foo</span>(i + <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 间隔只有8，而不是16了！</span></span><br><span class="line">        <span class="comment">// 另外，不同的内存大块之间是不连续的</span></span><br><span class="line">        <span class="comment">// 我们每次只分配24个内存小块</span></span><br><span class="line">        <span class="comment">// 所以说每24个小块之间可能不连续</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Ctor[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; f[i] &lt;&lt; <span class="string">&quot;, val= &quot;</span> &lt;&lt; f[i]-&gt;<span class="built_in">get</span>() &lt;&lt;  endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="built_in">delete</span>(f[i]);</span><br><span class="line">    <span class="type">int</span> freeCount = <span class="number">0</span>;</span><br><span class="line">    Foo *p = Foo::freeStore;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Del[&quot;</span> &lt;&lt; ++freeCount &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot;, val= &quot;</span> &lt;&lt; p-&gt;<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(freeCount &gt;= <span class="number">32</span>)  </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Test end....&quot;</span>);</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-3-allocator-3-0"><a href="#9-3-allocator-3-0" class="headerlink" title="9.3 allocator 3.0"></a>9.3 allocator 3.0</h4><p>在 2.0 版本中，我们解决了 <code>*next*</code> 指针的额外内存消耗问题，但是还有一个问题我们还没有解决，那就是复用性差的问题，对于每一个 class，如果想要使用我们的分配器，就要重载一遍 operator new&#x2F;delete，这不仅会导致代码的大量重复，导致代码膨胀，维护难等问题，还完全不符合面向对象的设计思想，我们是在 OOP 中写程序！</p>
<p>解决方案也很简单，就是将 operator new&#x2F;delete 的重载部分拿出来，单独放在一个 class allocator 当中，然后让需要使用的 class 包含 allocator，然后调用接口即可！</p>
<p>taik is cheap，show me your code：</p>
<blockquote>
<p>在 <code>void* MyAllocator::allocate(size_t size)</code> 中我应该是写出了一个比较经典的 bug 了。😅😅😅😅</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAllocator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">obj</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">obj</span> *next; <span class="comment">// embeded pointer(嵌入式指针)</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TEST</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">    obj* freeStore = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> CHUNK = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Foo() = default;</span></span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> _cnt = <span class="number">1024</span>, <span class="type">double</span> _price = <span class="number">10.25</span>) </span><br><span class="line">    : <span class="built_in">count</span>(_cnt), <span class="built_in">price</span>(_price) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123; cout &lt;&lt; <span class="string">&quot;[Dtor] &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getPrice</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> price; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> MyAllocator myAlloc;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">if</span>(size != <span class="built_in">sizeof</span>(Foo))</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;alloc error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myAlloc.<span class="built_in">allocate</span>(size);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size != <span class="built_in">sizeof</span>(Foo))</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;delete error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">delete</span>(ptr, size);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myAlloc.<span class="built_in">deallocate</span>(ptr, size); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TEST</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyAllocator Foo::myAlloc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">MyAllocator::allocate</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj *p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(freeStore == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;call new memory!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">size_t</span> chunk = CHUNK * size;</span><br><span class="line">        <span class="type">void</span> *mem = <span class="built_in">malloc</span>(chunk);</span><br><span class="line">        <span class="built_in">assert</span>(mem);</span><br><span class="line">        p = freeStore = <span class="built_in">static_cast</span>&lt;obj*&gt;(mem);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; CHUNK - <span class="number">1</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// [WARNNING] [BUG]</span></span><br><span class="line">            <span class="comment">// 注意不可能写为下面的形式</span></span><br><span class="line">            <span class="comment">// p[i].next = &amp;p[i + 1];</span></span><br><span class="line">            <span class="comment">// 因为p虽然是一个obj对象，但是我们要把它当做一个Foo对象</span></span><br><span class="line">            <span class="comment">// 所以我们要移动的距离是sizeof(Foo)</span></span><br><span class="line">            <span class="comment">// 但是在上面的形式中，我们移动的距离是sizeof(obj)</span></span><br><span class="line">            p-&gt;next = (obj*)((<span class="type">char</span>*)p + size);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p = freeStore;</span><br><span class="line">    freeStore = freeStore-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyAllocator::deallocate</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;obj*&gt;(ptr)-&gt;next = freeStore;</span><br><span class="line">    freeStore = <span class="built_in">static_cast</span>&lt;obj*&gt;(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;SIZE: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Foo) &lt;&lt; endl;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> N = <span class="number">16</span>;</span><br><span class="line">    Foo *f[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// f[i] = new Foo(Foo(i, i * 1.1)); </span></span><br><span class="line">        f[i] = <span class="keyword">new</span> Foo;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Ctor[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; f[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]-&gt;count = (i + <span class="number">1</span>);</span><br><span class="line">        f[i]-&gt;price = (i + <span class="number">1</span>) * <span class="number">1.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; f[i]-&gt;<span class="built_in">getCount</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; f[i]-&gt;<span class="built_in">getPrice</span>() &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">        <span class="keyword">delete</span> f[i];</span><br><span class="line">    <span class="keyword">auto</span> p = Foo::myAlloc.freeStore;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; counter &lt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;cur: &quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        counter ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Foo *f = new Foo(i, i + 10);</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;addr: &quot; &lt;&lt; f &lt;&lt; &#x27; &#x27; &lt;&lt; f-&gt;getCount() &lt;&lt; &#x27; &#x27; &lt;&lt; f-&gt;getPrice() &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// delete f;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Foo *f = new Foo(1, 1024);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;addr: &quot; &lt;&lt; f &lt;&lt; &#x27; &#x27; &lt;&lt; f-&gt;getCount() &lt;&lt; &#x27; &#x27; &lt;&lt; f-&gt;getPrice() &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">test2</span>();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Test end......&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-4-allocator-4-0"><a href="#9-4-allocator-4-0" class="headerlink" title="9.4 allocator 4.0"></a>9.4 allocator 4.0</h4><p>虽然是 4.0，但是它并没有什么更高级的设计，只不过是将 3.0 中的 class 封装设计改为 macro(宏) 设计。</p>
<p>不建议使用 macro，代码不给出了。</p>
<h3 id="10-new-handler"><a href="#10-new-handler" class="headerlink" title="10. new handler"></a>10. new handler</h3><p>new handler 提供给你一个机会阻止可能发生的异常(bad_alloc)，因为如果异常产生，程序可能会直接terminate，new handler 就是 c++平台给你提供的补救措施。</p>
<p>在 《Effective C++》提到过，new_handler 做5件事，但真正有用的可能就两件：</p>
<ol>
<li>分配更多的内存</li>
<li>调用 exit() 和 abort()</li>
</ol>
<p><img src="https://s3.bmp.ovh/imgs/2023/03/09/6542ab298879ce75.png" alt="IMG"></p>
<p><img src="https://s3.bmp.ovh/imgs/2023/03/09/6673d1b83363c6dc.png" alt="IMG"></p>
<h3 id="11-x3D-default-x3D-delete"><a href="#11-x3D-default-x3D-delete" class="headerlink" title="11. &#x3D;default,&#x3D;delete"></a>11. &#x3D;default,&#x3D;delete</h3><blockquote>
<p> It is not only for constructors and assignments,  but also applies to operator new&#x2F;new[], operator delete&#x2F;delete[] and their overloads(for &#x3D;delete)</p>
</blockquote>
<h2 id="0x02-std-allocator"><a href="#0x02-std-allocator" class="headerlink" title="0x02 std::allocator"></a>0x02 std::allocator</h2><p>chunk：大块</p>
<p>block：小块</p>
<p><code>G2.9</code> 的 std::alloc 并没有“释放”内存，他只是把分配的内存重心放入内存池，严格来说，这不算是内存泄漏，因为内存仍然在自己手上，只不过没有释放罢了。之所以不真正 free，是因为难度较大。这也是 alloc 的一个争议点，因为在多用户，多任务系统中，你独占如此大的memory却不释放，肯定不好。</p>
<p>战备池 Pool：</p>
<ol>
<li>如果战备池为空，分配新内存</li>
<li>能分配几个就分配几个<ul>
<li>一个都不能分配，处理碎片，分配新内存</li>
<li>分配战备池</li>
</ul>
</li>
</ol>
<p>判断指针 p 是否为 null，看以下两种写法：</p>
<ol>
<li><code>if(0 == p) &#123;&#125;</code></li>
<li><code>if(p == 0) &#123;&#125;</code></li>
</ol>
<p>我们通常都是第二种写法，但是第一种写法更好，因为如果我们不小心将 <code>==</code> 写成了 <code>=</code>，编译器会报错，而在第二种写法中，编译会顺利通过，并带来灾难性的后果且不以排查。</p>
<p>但是在现代 c++ 中，我们有 nullptr，不需要担心了。😊</p>
<p>侯捷老师说在第四章会有解决方案，这个“内存泄漏”问题终于解决了！</p>
<hr>
<p>operator delete(ptr)</p>
<p>operator delete(ptr, size_t)</p>
<p>在 class 中可不可以并存吗？并存会报错？</p>
<hr>
<p>round(x,n) &#x3D; (x+(n-1)) &amp; ~(n-1)</p>
<hr>
<p>malloc 把 VA 分为 32 个 group，每个 group 又分为 8 个page</p>
<p>所以最多有 32*8&#x3D;256 个 page</p>
<p>而在 tagRegion 中，有 32 个 tagGroup</p>
<p>每个 TagGroup 有 64 个双向链表，总共 2048 个双向链表</p>
<hr>
<p>4080 &#x3D; 4096 - 8(黄色的两个0xffffffff) - 8(保留&#x2F;浪费，因为需要16对齐)</p>
<p>4096 - 8 &#x3D; 4088 not 16 的倍数，因此需要对齐减去 8</p>
<p>16，32，48, 。。。。&gt;&#x3D;1024 (16 aligned)</p>
<p>Cookie 保存长度信息，这个长度信息包含cookie本身</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; ls;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> c;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node_t</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> va;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum += size;</span><br><span class="line">    c ++ ;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt; 3; i ++ )  ls.push_back(1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; sum &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; pow(2,18) &lt;&lt; endl;</span></span><br><span class="line">    Node *newNode = <span class="keyword">new</span> Node;   <span class="comment">// 16</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="number">68</span> + <span class="number">256</span> + <span class="number">32</span> * <span class="number">516</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="number">16</span> * <span class="number">1024</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="number">32</span> * <span class="number">64</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="number">0x130</span> + <span class="number">8</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">void</span> *test = <span class="built_in">sbrk</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;start heap brk: &quot;</span> &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">    test = <span class="built_in">sbrk</span>(<span class="number">0x20ff8000</span>);    <span class="comment">// 0x9a0000</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after sbrk() brk: &quot;</span> &lt;&lt; test &lt;&lt; endl;   <span class="comment">// 0x9a0000</span></span><br><span class="line">    <span class="type">void</span> *p = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="number">0x20ff8000</span>));</span><br><span class="line">    test = <span class="built_in">sbrk</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after use, brk: &quot;</span> &lt;&lt; test &lt;&lt; endl;<span class="comment">// 0x21998000</span></span><br><span class="line">    cout &lt;&lt; hex &lt;&lt;  <span class="number">0x20ff8000</span> + <span class="number">0x9a0000</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    即使移动了brk位置，在实际使用之前，Linux也不会给进程分配内存的。</span></span><br><span class="line"><span class="comment">    必须要等到实际写内存的时候，产生了缺页中断后，Linux系统才会申请一个物理内存页给进程。内核申请物理内存页的函数是get_free_pages()。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>通过 header -&gt; group -&gt; free-list  来切分，使得每一块内存都比较小，因此全部回收的可能性就更大</p>
<p>如果每一块内存都是 1MB，那么它的回收就很困难</p>
<p>例如即使 1MB 中有 1023KB 没有使用，我们也不能回收它。</p>
<hr>
<p>group头部的size就可以很方便的告诉我们，是否可以全回收。</p>
<p>每个page内的内存块的合并是积极的。</p>
<p>page全回收之后不会立即释放，当等到再有一个page全回收时，才会释放。</p>
<h2 id="0x03-malloc-x2F-free"><a href="#0x03-malloc-x2F-free" class="headerlink" title="0x03 malloc&#x2F;free"></a>0x03 malloc&#x2F;free</h2><h2 id="0x04-loki-allocator"><a href="#0x04-loki-allocator" class="headerlink" title="0x04 loki::allocator"></a>0x04 loki::allocator</h2><h3 id="1-Loki-SourceCode"><a href="#1-Loki-SourceCode" class="headerlink" title="1. Loki SourceCode"></a>1. Loki SourceCode</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://loki-lib.sourceforge.net/html/a00671.html">New Version Source Code</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/UnGeek/p/4537114.html">别人做的分析</a></p>
</blockquote>
<h3 id="2-旧版本的两个-bug"><a href="#2-旧版本的两个-bug" class="headerlink" title="2. 旧版本的两个 bug"></a>2. 旧版本的两个 bug</h3><h4 id="（1）-无限循环"><a href="#（1）-无限循环" class="headerlink" title="（1） 无限循环"></a>（1） 无限循环</h4><p>在旧版本的 <code>VicinityFind</code> 函数中，如果我们传入的 <code>p</code> 不是经由 <code>chunk</code> 分配的话，那么在 <code>for</code> 中会无限循环。这是因为当 <code>lo</code> 和 <code>hi</code> 都为 <code>false</code> 时，没有判断条件来使得 <code>for</code> 退出。</p>
<p>这是更正版的代码，在我们标识出的 <code>(1)</code> 和 <code>(2)</code> 处，添加了判断，这样当 <code>lo</code> 和 <code>hi</code> 都为 <code>false</code> 时，循环就会退出并返回 <code>NULL</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Chunk * <span class="title">FixedAllocator::VicinityFind</span><span class="params">( <span class="type">void</span> * p )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( chunks_.<span class="built_in">empty</span>() ) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">const</span> std::<span class="type">size_t</span> chunkLength = numBlocks_ * blockSize_;</span><br><span class="line">    Chunk * lo = deallocChunk_;</span><br><span class="line">    Chunk * hi = deallocChunk_ + <span class="number">1</span>;</span><br><span class="line">    <span class="type">const</span> Chunk * loBound = &amp;chunks_.<span class="built_in">front</span>();</span><br><span class="line">    <span class="type">const</span> Chunk * hiBound = &amp;chunks_.<span class="built_in">back</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Special case: deallocChunk_ is the last in the array</span></span><br><span class="line">    <span class="keyword">if</span> (hi == hiBound) hi = <span class="literal">NULL</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( lo-&gt;<span class="built_in">HasBlock</span>( p, chunkLength ) ) <span class="keyword">return</span> lo;</span><br><span class="line">            <span class="keyword">if</span> ( lo == loBound )</span><br><span class="line">            &#123;</span><br><span class="line">                lo = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">if</span> ( <span class="literal">NULL</span> == hi ) <span class="keyword">break</span>;	<span class="comment">// （1）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> --lo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( hi-&gt;<span class="built_in">HasBlock</span>( p, chunkLength ) ) <span class="keyword">return</span> hi;</span><br><span class="line">            <span class="keyword">if</span> ( ++hi == hiBound )</span><br><span class="line">            &#123;</span><br><span class="line">                hi = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">if</span> ( <span class="literal">NULL</span> == lo ) <span class="keyword">break</span>;	<span class="comment">// （2）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（2）-chunk-不会回收-TODO"><a href="#（2）-chunk-不会回收-TODO" class="headerlink" title="（2） chunk 不会回收 [TODO]"></a>（2） chunk 不会回收 [TODO]</h4><p>看下面回收操作的代码：</p>
<p><img src="https://s3.bmp.ovh/imgs/2023/03/21/dbe229b367a5733b.png" alt="img"></p>
<p>其中，绿色框框出的代码块就是处错的代码，而红色框框出的代码块是导致绿色代码块处错的根源。</p>
<p>先看红色的代码块：意思是，我们释放了一块内存之后发现它所在 <code>chunk</code> 为空，并且这个 <code>chunk</code> 不是最后一个 <code>chunk</code>，如果此时最后一个 <code>chunk</code> 非空的话，说明有两个空 <code>chunk</code>，所以我们需要删除一个，由于 <code>vector</code> 从中间删除效率很低，所以我们肯定删除最后一个 <code>chunk</code> 了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| A | F1 | A | A1 | F2 |</span><br><span class="line">    --&gt;</span><br><span class="line">| A | F1 | A | A1 |，释放 A1</span><br><span class="line">    --&gt;</span><br><span class="line">| A | F1 | A | F |，A1 变为 F</span><br></pre></td></tr></table></figure>

<p>如上图所示，我们当前的空 <code>chunk</code> 为 <code>F1</code>（F 表示 Free，A 表示Allocate），之前的空 <code>chunk</code> 是 <code>F2</code>，然后我们删除了 <code>F2</code>。</p>
<p>好，假设我们现在不停的释放 <code>chunk A1</code>，直到它为空。</p>
<p>此时，<code>vector&lt;chunk&gt;</code> 中显然有两个 <code>Free chunk</code>（F 和 F1），但是我们的 <code>DoDeallocate</code> 函数无法清除其中一个 <code>Chunk</code>。</p>
<p>因为此时，&#96;&#96;F1<code>虽然</code>Free<code>，但它没有位于 </code>vector&#96; 的尾部。</p>
<p>而我们的回收操作，是基于一个假设的：</p>
<blockquote>
<p>Free Chunk 一定在 vector 的尾部。</p>
</blockquote>
<p>此时，假设不成立！</p>
<p>所以说，我们不能依赖于该假设，而是要显示的用一个变量来指示，之前 Free 但没有回收的 Chunk在哪里，这就是改正 BUG 之后的新版本的做法。</p>
<h2 id="0x05-other-allocator"><a href="#0x05-other-allocator" class="headerlink" title="0x05 other::allocator"></a>0x05 other::allocator</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="cn">
    <link itemprop="mainEntityOfPage" href="https://qaqowoqaq.github.io/2023/06/15/csapp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="jyyyx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jyyyyyx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/15/csapp/" class="post-title-link" itemprop="url">csapp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-15 20:20:57" itemprop="dateCreated datePublished" datetime="2023-06-15T20:20:57+08:00">2023-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-06-16 10:06:48" itemprop="dateModified" datetime="2023-06-16T10:06:48+08:00">2023-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/csapp/" itemprop="url" rel="index"><span itemprop="name">csapp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h1><h2 id="0x-ff-杂项"><a href="#0x-ff-杂项" class="headerlink" title="0x ff 杂项"></a>0x ff 杂项</h2><p>Instruction set Architecture：ISA,指令集体系架构</p>
<p>软件和硬件之间的一层抽象层</p>
<p>冯诺依曼计算机，即程序<strong>存储型</strong>计算机</p>
<p>重要思想：程序就是一系列被编码了的字节序列（看上去和数据一模一样）</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/SovietPower/p/14877143.html">https://www.cnblogs.com/SovietPower/p/14877143.html</a></p>
<h2 id="0x-00-参考资料-amp-amp-lab"><a href="#0x-00-参考资料-amp-amp-lab" class="headerlink" title="0x 00 参考资料 &amp;&amp; lab"></a>0x 00 参考资料 &amp;&amp; lab</h2><p>official：</p>
<p><a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/students.html">官网</a></p>
<p><a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/labs.html">实验</a></p>
<hr>
<p>note:</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17K4y1N7Q2?spm_id_from=333.999.0.0&vd_source=38033fe3a1f136728a1d6f8acf710b51">视频详解</a> </p>
<p><a target="_blank" rel="noopener" href="https://github.com/yangminz/bcst_csapp">笔记参考视频的源码</a></p>
<hr>
<p>lab：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/wuxueqian14/CSAPP-Lab#%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">比较详细的Attack，Data，Boom Lab参考</a></p>
<p><a target="_blank" rel="noopener" href="https://kazamayc.github.io/2021/02/05/csapp-lab/">Boom，Attack，Shell Lab</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/505497911">全部实验的详细参考–知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43362650/article/details/122890142">全部实验的详细参考–CSDN</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Exely/CSAPP-Labs">全部实验的详细参考–Github</a></p>
<hr>
<p>video:</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1RK4y1R7Kf?spm_id_from=333.999.0.0&vd_source=38033fe3a1f136728a1d6f8acf710b51">导读</a>        <a target="_blank" rel="noopener" href="https://fengmuzi2003.gitbook.io/csapp3e/">导读笔记</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cD4y1D7uR?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click&vd_source=38033fe3a1f136728a1d6f8acf710b51">小视频复习</a></p>
<hr>
<p>book：</p>
<p><a target="_blank" rel="noopener" href="https://hansimov.gitbook.io/csapp/">学生版重点知识</a></p>
<p><a href="instructor">讲师版重点知识</a></p>
<hr>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lab操作流程</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.datalab：</span></span><br><span class="line">在源文件 bits.c 中完善函数即可</span><br><span class="line">./dlc bits.c 	 // 用于检查程序是否合法，是否使用了程序规定的符号</span><br><span class="line">make btest   	 // btest是评分(检查对错工具)，每次执行btets前都要重新make一下</span><br><span class="line">./btest bits.c   // 评分</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.bomblab</span></span><br><span class="line">./bomb</span><br><span class="line">输入答案</span><br><span class="line">导读P3-52分钟有第一关的实操</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.attacklab</span></span><br><span class="line">./hex2raw &lt; att1.txt &gt; attraw1.txt // 将字节序列at t1转换为字符串attraw1</span><br><span class="line">./ctarget -q -i attraw1.txt     //测试答案</span><br><span class="line">// (https://github.com/wuxueqian14/csapp-lab/tree/master/Attack%20Lab)</span><br></pre></td></tr></table></figure>



<h2 id="0x-01-二进制"><a href="#0x-01-二进制" class="headerlink" title="0x 01 二进制"></a>0x 01 二进制</h2><p>内存中存储的是电压，然后通过（不知道）某种方式<strong>抽象</strong>为数字01，然而计算机的内存太大了，以致于01的个数实在太多了，于是，我们把原有的0和1分块，并再次抽象为0,1…。</p>
<p><img src="file:///C:\Users\24072\AppData\Roaming\Tencent\Users\2407217576\QQ\WinTemp\RichOle\7E[W6J9]YPX$8MS~3CCM[DG.png" alt="img"></p>
<p>加入内存中有n bit,每m bit分为一块，则最多可以分为2^m块，因为m bit的排列组合数为2 ^ n个序列（sequence）</p>
<p>例如十进制数字123，它应该表示为<code>1*10^2 + 2*10^1 + 3*10^0</code>，所以这里的123准确来说应该是一个sequence，而不是一个数。</p>
<p>数是一个比较唯心的抽象的概念，你说一个数3，它可以是十进制序列3，也可以是二进制序列11…，3和11都是这个真正的（唯心的）3，这些序列之间是一一对应的，不仅如此，他们的运算也是一一对应的。十进制的序列1+2，对应的二进制下序列为1+01</p>
<p><strong>取反对称</strong>：对称轴的两侧是相反数</p>
<p>对于1,2,3,4，他们分别取反对称于-1，-2，-3，-4</p>
<p>对于二进制000,001,010,011，他们分别取反对称于111,110,101,100</p>
<p><img src="https://s1.328888.xyz/2022/08/29/CrzXC.png" alt="IMAGE"></p>
<h2 id="0x-02-二进制运算"><a href="#0x-02-二进制运算" class="headerlink" title="0x 02 二进制运算"></a>0x 02 二进制运算</h2><p><strong>位运算的循环圈：</strong></p>
<p><img src="https://s1.328888.xyz/2022/09/06/5OAqi.png" alt="IMG"></p>
<p>​										（int类型有符号数）</p>
<p><img src="https://s1.328888.xyz/2022/09/06/5jEa0.png" alt="img"></p>
<p>​										(int类型无符号数)</p>
<p>通过这张图，你可能会更好地理解补码和无符号数运算是在mod 2^n 下计算的意义。</p>
<p>看一下树状数组lowbit函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x; <span class="comment">// &lt;==&gt; x &amp; (~x + 1);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数为什么能求得最后一个1所在位置的代表的权值呢？</p>
<p>首先 -x，其实就是x的补码。关于补码，我们有一个求补码的方法：从右到左直到第一个1保持不变，后面的位取反，我们将x和x的补码做与运算，最后得到的结果一定是这样的形式：00..010..0，最后一个1左侧全为0，右侧也全为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">func1</span><span class="params">(<span class="type">unsigned</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 输出一个无符号数x，判断x在十六进制下的的每一位是不是字母</span></span><br><span class="line">    <span class="comment">// 如果该位是字母就返回1，否则返回0</span></span><br><span class="line">    <span class="comment">// 并以一个16进制数的形式返回</span></span><br><span class="line">    <span class="type">unsigned</span> x1 = (x &amp; <span class="number">0x22222222</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> x2 = (x &amp; <span class="number">0x44444444</span>) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> x3 = (x &amp; <span class="number">0x88888888</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;[1]:%04x\n[2]:%04x\n[3]:%04x\n&quot;, x1, x2, x3);</span></span><br><span class="line">    <span class="keyword">return</span> x3 &amp; (x2 | x1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">func2</span><span class="params">(<span class="type">unsigned</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 输出一个无符号数x，判断x在十六进制下的每一位是不是字母</span></span><br><span class="line">    <span class="comment">// 如果所有位都是字母返回1，否则返回0</span></span><br><span class="line">    x = func1(x); <span class="comment">//得到了每一位的结果</span></span><br><span class="line">    x = x &amp; (x &gt;&gt; <span class="number">16</span>); <span class="comment">// 每次判断一半</span></span><br><span class="line">    x = x &amp; (x &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">    x = x &amp; (x &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">func3</span><span class="params">(<span class="type">unsigned</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// bigCount</span></span><br><span class="line">    <span class="type">unsigned</span> c;</span><br><span class="line">    c = (x &amp; <span class="number">0x55555555</span>) + ((x &gt;&gt;  <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    c = (c &amp; <span class="number">0x33333333</span>) + ((c &gt;&gt;  <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    c = (c &amp; <span class="number">0x0f0f0f0f</span>) + ((c &gt;&gt;  <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>);</span><br><span class="line">    c = (c &amp; <span class="number">0x00ff00ff</span>) + ((c &gt;&gt;  <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>);</span><br><span class="line">    c = (c &amp; <span class="number">0x0000ffff</span>) + ((c &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> x = <span class="number">0x1</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;0x%X = %X\n&quot;, x, func1(x));</span></span><br><span class="line">    <span class="comment">// printf(&quot;0x%X = %X\n&quot;, x, func2(x));</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%X = %d\n&quot;</span>, x, func3(x));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0x-03-浮点数"><a href="#0x-03-浮点数" class="headerlink" title="0x 03 浮点数"></a>0x 03 浮点数</h2><p>为什么 IEEE 754浮点数Float类型的bias&#x3D;127而不是128？</p>
<p>其实这也没有一个官方的说法，不过为了让自己接受这个设定，我们可以从两个角度考虑：</p>
<ol>
<li>首先，bias采用127时绝对值的范围比较对称</li>
<li>其次，bias采用127时最大的指数是127比bias&#x3D;128时的126大，虽然只大1，但是我们直到指数的增长是“爆炸”的，因此其表示的范围也大得多。</li>
</ol>
<p>浮点的根据exp和frac分为三种情况：</p>
<ol>
<li>exp&#x3D;111..1，指数全1。此时又分为两种情况：（1）当frac全0时表示无穷大，根据符号位又分为正无穷和负无穷。（2）frac不全为0，表示NaN，一种未定义行为。（可以这样区分无穷和NaN，由于未定义的行为有很多，因此需要根据frac进一步区分，所以frac不是固定的全0，（胡乱猜的），可以这样记忆）。</li>
<li>exp&#x3D;000..0，指数全0。表示不规格化的浮点数。这里的主要目的是为了拓展精度和范围（往值小的方向）。</li>
<li>else，规格化浮点数。</li>
</ol>
<p>将一个无符号数转换为一个浮点数的表示形式并保存在一个无符号数字中</p>
<p><a target="_blank" rel="noopener" href="https://lostphp.com/hexconvert/">IEEE 754浮点数十六进制相互转换</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/68131179">关于浮点数舍入的讨论</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">uint2float</span><span class="params">(<span class="type">uint32_t</span> u)</span>&#123; <span class="comment">// 将一个服务号数u转换成浮点数存储的形式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 特判</span></span><br><span class="line">    <span class="keyword">if</span> (u == <span class="number">0x00000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x00000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到最后一个1的后面的一个位置，求得该1后面还有多少个数</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">0</span> &amp;&amp; (((u &gt;&gt; n) &amp; <span class="number">0x1</span>) == <span class="number">0x0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        n = n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n: &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint32_t</span> e, f; <span class="comment">// exp, frac</span></span><br><span class="line">    <span class="comment">// &lt;= 0000 0000 1.111 1111 1111 1111 1111 1111 : 32位</span></span><br><span class="line">    <span class="comment">// u的位数&lt;=24，此时再隐藏一个1，就&lt;=23位，于是frac就可以保存所有位，不需要舍入</span></span><br><span class="line">    <span class="keyword">if</span> (u &lt;= <span class="number">0x00ffffff</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// no need rounding</span></span><br><span class="line">        <span class="type">uint32_t</span> mask = <span class="number">0xffffffff</span> &gt;&gt; (<span class="number">32</span> - n); <span class="comment">// mask就是frac的掩码</span></span><br><span class="line">        f = (u &amp; mask) &lt;&lt; (<span class="number">23</span> - n);             <span class="comment">// f = u &amp; mask得到frac，但还需要左移移动到最右侧[frac00..0]，而不是[00..0frac]</span></span><br><span class="line">        e = n + <span class="number">127</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;e: 0x%x, f: 0x%x\n&quot;</span>, e, f);</span><br><span class="line">        <span class="keyword">return</span> (e &lt;&lt; <span class="number">23</span>) | f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &gt;= 0000 0001 0000 0000 0000 0000 0000 0000 </span></span><br><span class="line">    <span class="comment">// 总位数&gt;=25，一位可以隐藏，还剩下至少24位，frac无法全部保存，需要舍入(rounding)</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// expand to 64 bit for situations like 0xffffffff</span></span><br><span class="line">        <span class="type">uint64_t</span> a = <span class="number">0</span>;</span><br><span class="line">        a += u;</span><br><span class="line">        <span class="comment">// compute g, r, s</span></span><br><span class="line">        <span class="type">uint32_t</span> g = (a &gt;&gt; (n - <span class="number">23</span>)) &amp; <span class="number">0x1</span>;</span><br><span class="line">        <span class="type">uint32_t</span> r = (a &gt;&gt; (n - <span class="number">23</span> - <span class="number">1</span>)) &amp; <span class="number">0x1</span>;</span><br><span class="line">        <span class="type">uint32_t</span> s = <span class="number">0x0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">23</span> - <span class="number">1</span>; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            s = s | ((u &gt;&gt; j) &amp; <span class="number">0x1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// compute carry</span></span><br><span class="line">        a = a &gt;&gt; (n - <span class="number">23</span>);</span><br><span class="line">        <span class="comment">// 0    1    ?    ... ?</span></span><br><span class="line">        <span class="comment">// [24] [23] [22] ... [0]</span></span><br><span class="line">        <span class="keyword">if</span> (r &amp; (g | s) == <span class="number">0x1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = a + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check carry</span></span><br><span class="line">        <span class="keyword">if</span> ((a &gt;&gt; <span class="number">23</span>) == <span class="number">0x1</span>) /</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 0    1    ?    ... ?</span></span><br><span class="line">            <span class="comment">// [24] [23] [22] ... [0]</span></span><br><span class="line">            f = a &amp; <span class="number">0x007fffff</span>; <span class="comment">// 0x0000 0000 0111 1111 1111 1111 1111 1111只保留frac</span></span><br><span class="line">            e = n + <span class="number">127</span>;</span><br><span class="line">            <span class="keyword">return</span> (e &lt;&lt; <span class="number">23</span>) | f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((a &gt;&gt; <span class="number">23</span>) == <span class="number">0x2</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1    0    0    ... 0</span></span><br><span class="line">            <span class="comment">// [24] [23] [22] ... [0]</span></span><br><span class="line">            e = n + <span class="number">1</span> + <span class="number">127</span>;</span><br><span class="line">            <span class="keyword">return</span> (e &lt;&lt; <span class="number">23</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// INF as default error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x7f800000</span>; <span class="comment">// 0 1111 1111 000 0000 0000 0000 0000 0000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;  <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, uint2float(<span class="number">0x10000000</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0x-04-时序电路和组合电路"><a href="#0x-04-时序电路和组合电路" class="headerlink" title="0x 04 时序电路和组合电路"></a>0x 04 时序电路和组合电路</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_20265495/article/details/41314577">原文链接：</a></p>
<hr>
<p><strong>数字电路</strong>根据逻辑功能的不同特点，可以分成两大类，一类叫<strong>组合逻辑电路</strong>（简称组合电路），另一类叫做<strong>时序逻辑电路</strong>（简称时序电路）。组合逻辑电路在逻辑功能上的特点是任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关。而时序逻辑电路在逻辑功能上的特点是任意时刻的输出不仅取决于当时的输入信号，而且还取决于电路原来的状态，或者说，还与以前的输入有关。</p>
<p>时序电路，是由最基本的逻辑门电路加上反馈逻辑回路（输出到输入）或器件组合而成的电路，与组合电路最本质的区别在于时序电路具有记忆功能。</p>
<p>时序电路的特点是：输出不仅取决于当时的输入值，而且还与电路过去的状态有关。它类似于含储能元件的电感或电容的电路，如触发器、锁存器、计数器、移位寄存器、存储器等电路都是时序电路的典型器件，时序逻辑电路的状态是由存储电路来记忆和表示的。</p>
<p>时序电路和组合电路的区别：<br>时序电路具有<strong>记忆功能</strong>。时序电路的特点是：输出不仅取决于当时的输入值，而且还与电路过去的状态有关。组合逻辑电路在逻辑功能上的特点是任意时刻的输出仅仅取决于该时刻的输入，与电路原来的状态无关</p>
<p>时序电路是 时序 逻辑 电路。时序，时间 顺序，是在时钟的推动下工作的，cpu就是一个复杂的时序电路。</p>
<p>组合逻辑电路和时序逻辑电路的最根本区别在于：组合逻辑电路的输出在任一时刻只取决于当时的输入信号；而时序逻辑电路的输出，不仅和当前的输入有关，还和上时刻的输出有关，它具有记忆元件（触发器），可以记录前一时刻的输出状态，它可以没有输入，仅在时钟的驱动下，给出输出。</p>
<p>时序电路的基本结构：</p>
<p><img src="https://img-blog.csdn.net/20151210201333026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>结构特征：<em>电路由组合电路和存储电路组成</em>，电路存在反馈 </p>
<h2 id="0x-05-缓冲区漏洞实验"><a href="#0x-05-缓冲区漏洞实验" class="headerlink" title="0x 05 缓冲区漏洞实验"></a>0x 05 缓冲区漏洞实验</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//bomb.c</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">4</span>];</span><br><span class="line">	gets(buffer); <span class="comment">//缓冲区溢出的关键</span></span><br><span class="line">	<span class="built_in">puts</span>(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;pls input: &quot;</span>);</span><br><span class="line">	echo();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">操作步骤：</span><br><span class="line">1. gcc bomb.c -o main -fno-stack-protector -g</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-fno-stack-protector取消栈保护？</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-g调试模式，因为后面还需要调试</span></span><br><span class="line"></span><br><span class="line">2. gdb main</span><br><span class="line">2.1 在echo函数的gets函数加上一个断点：b 6</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span>函数位于main.c的第六行</span></span><br><span class="line">2.2 r</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">run运行程序，此时会在断点gets函数停下</span></span><br><span class="line">2.3 info f </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示栈信息，如下方图-栈信息所示</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在这些信息中，我们需要注意三个地址：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(1)frame at 0x7ff.f3d0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(2)rbp at   0x7ff.f3c0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(3)bip at.  0x7ff.f3c8</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中frame at的地址是函数<span class="built_in">echo</span>占用栈的地址</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时，返回地址rip和旧的栈顶指针rbp已经入栈</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">由此可见，程序还没运行，返回地址和旧的栈顶指针就会入栈</span></span><br><span class="line">2.4 p/a &amp;buffer[0]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印数组buffer的首地址</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过结构图，我们可以发现，数组与返回地址rip之间差了12（c8-bc）字节，如果我们gets的数组大于等于12字节，那么返回地址的数据就会被破坏，</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>![image-20220907100422585](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220907100422585.png)</p>
<p>(图-栈信息)</p>
<p>![13C288AA-6A07-463D-A689-CC7FEF2DCB91](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;13C288AA-6A07-463D-A689-CC7FEF2DCB91.png)</p>
<p>(图-数组地址)</p>
<p><img src="https://1484576603-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MV9vJFv4kmvRLgEog6g%2F-MZuBW3GNKr5zld5JHFH%2F-MZuER6OHxdJ7z3gtPNL%2Fimage.png?alt=media&token=ecba360a-06d3-4734-9430-aab5fd84cbee" alt="img"></p>
<p>(图-视频测试运行gets前的栈)</p>
<p><img src="https://1484576603-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MV9vJFv4kmvRLgEog6g%2F-MZrajFxkCIYEw7i-1-F%2F-MZrrKB09-F7NqAWNBKB%2Finitpintu_%E5%89%AF%E6%9C%AC.jpg?alt=media&token=35b89f3f-e6d2-4aa9-b7d0-2da8ad86450b" alt="img"></p>
<p>（图-视频测试运行gets后的栈）</p>
<h2 id="0x-06-Computer-English"><a href="#0x-06-Computer-English" class="headerlink" title="0x 06 Computer English"></a>0x 06 Computer English</h2><hr>
<p>common：注释</p>
<p>override：覆盖</p>
<p>entry：入口，条目，输入</p>
<p>Place holder：站位</p>
<p>ascending：升序</p>
<p>descending：降序</p>
<p>comma：逗号</p>
<p>brackets：括号</p>
<p>determine: 确定，决定，判定，下决心</p>
<p>deterministic: 确定行</p>
<p>finite: 有限的</p>
<p>infinite: 无限的</p>
<p>automaton: 自动机</p>
<p>positive: 正数</p>
<p>negative: 负数</p>
<p>decimal: 十进制</p>
<p>hexadecimal：十六进制</p>
<p>octal: 八进制</p>
<p>optimazation：优化</p>
<p>pruning：剪枝</p>
<p>decode:译码</p>
<p>instance: 例子，实例</p>
<p>cpu和memory 就组成了一个状态机</p>
<p>operand 操作数</p>
<p>opreator：操作符</p>
<p>memory：内存&#x2F;存储器</p>
<p>recursion：递归</p>
<p>reduce：归约</p>
<p>iterate: 迭代</p>
<p>transistor：晶体管</p>
<p>complement：补充，补运算(～)，辅</p>
<p>parse: 解析</p>
<p>simulator: 模拟器</p>
<p>simulate: 模拟，仿真，假装</p>
<p>converter：转换器</p>
<p>verbose: 冗长的，啰嗦</p>
<p>handler: 管理者，处理程序</p>
<p>illustrate: 说明</p>
<p>universal: 通用的</p>
<p>pecuilar:  特有，奇特，一场</p>
<hr>
<h2 id="0x-07-makefile"><a href="#0x-07-makefile" class="headerlink" title="0x 07 makefile"></a>0x 07 <a target="_blank" rel="noopener" href="https://subingwen.cn/linux/makefile/#3-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F">makefile</a></h2><h3 id="1-规则"><a href="#1-规则" class="headerlink" title=".1 规则"></a>.1 规则</h3><p>（1）make命令具有<strong>自动推导</strong>的功能，例如依赖中的.o文件，即使不存在，make会使用内部默认的构造规则生成这些.o文件。</p>
<p>（2）make后面<strong>不带参数</strong>默认执行第一条命令</p>
<p>（3）mak的<strong>时间戳规则</strong>：</p>
<blockquote>
<p>make 命令执行的时候会根据文件的时间戳判定是否执行 makefile 文件中相关规则中的命令。</p>
<ol>
<li>目标是通过依赖生成的，因此正常情况下：目标时间戳 &gt; 所有依赖的时间戳 , 如果执行 make 命令的时候检测到规则中的目标和依赖满足这个条件，那么规则中的命令就不会被执行。</li>
<li>当依赖文件被更新了，文件时间戳也会随之被更新，这时候 目标时间戳 &lt; 某些依赖的时间戳 , 在这种情况下目标文件会通过规则中的命令被重新生成。</li>
<li>如果规则中的目标对应的文件根本就不存在， 那么规则中的命令肯定会被执行。</li>
</ol>
</blockquote>
<p>（4）对于不生成目标文件的目标称为伪目标，为了避免微伪目标的名字和真实的文件名重复，我们可以在伪目标的前面加上关键字：.PHONY(假) 例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean: </span></span><br><span class="line">	rm *.o</span><br></pre></td></tr></table></figure>

<p>声明位伪目标主要是避免这种情况：</p>
<blockquote>
<p>如果目标不存在规则的命令肯定被执行， 如果目标文件存在了就需要比较规则中目标文件和依赖文件的时间戳，满足条件才执行规则的命令，否则不执行。</p>
<p>加入目标是clean，而恰好有一个真实的clean文件，只要clean文件不更新，那么clean目标就无法执行。</p>
</blockquote>
<p>（提醒）<strong>目录连接到博客中的实例6可以好好看看👀</strong></p>
<h3 id="2-变量"><a href="#2-变量" class="headerlink" title=".2 变量"></a>.2 变量</h3><p>make中的变量分为三种：</p>
<p><strong>1.自定义变量</strong>：即用户自己定义的变量，makefile中的变量是<strong>没有类型</strong>的，直接创建变量然后给其赋值就可以了。通过$(obj) 可以取出自定义的obj变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">obj = main.c</span><br><span class="line">target = main</span><br><span class="line">depend = main.o</span><br><span class="line"></span><br><span class="line">$(target): $(depend)</span><br><span class="line">	gcc $(obj) -o $(target)</span><br><span class="line"></span><br><span class="line"># --------------</span><br><span class="line"># 上面的命令等价于下面：</span><br><span class="line"></span><br><span class="line">main: main.o</span><br><span class="line">	gcc main.c -o main</span><br></pre></td></tr></table></figure>

<p><strong>2.预定义变量：</strong>在makefile中有一些已经定义好的变量，用户可以直接使用这些变量，不用进行定义，预定义变量的名字一般是大写的。</p>
<p>![96D31374-3040-4B27-8A65-B9DE685E3351](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;96D31374-3040-4B27-8A65-B9DE685E3351.png)</p>
<p><strong>3.自动变量：</strong>makefile智能鼓的规则语句经常会出现目标文件和依赖文件，<strong>自动变量用来代表这些规则中的目标文件和依赖文件，并且衙门只能在规则的命令总使用。</strong></p>
<p>![DC05ED8E-B70B-44FB-A799-E6D0C938CF7F](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;DC05ED8E-B70B-44FB-A799-E6D0C938CF7F.png)</p>
<h3 id="3-模式匹配"><a href="#3-模式匹配" class="headerlink" title=".3 模式匹配"></a>.3 模式匹配</h3><p>模式匹配常常与自动变量结合使用，用来简化makefile，减少冗余和重复书写。</p>
<h3 id="4-函数"><a href="#4-函数" class="headerlink" title=".4 函数"></a>.4 函数</h3><p>1.wildcard：通配符，用来匹配制定目录下的文件</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用举例: 分别搜索三个不同目录下的 .c 格式的源文件</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> /home/robin/a/*.c /home/robin/b/*.c *.c)</span>  <span class="comment"># *.c == ./*.c</span></span><br><span class="line"><span class="comment"># 返回值: 得到一个大的字符串, 里边有若干个满足条件的文件名, 文件名之间使用空格间隔</span></span><br><span class="line">/home/robin/a/a.c /home/robin/a/b.c /home/robin/b/c.c /home/robin/b/d.c e.c f.c</span><br></pre></td></tr></table></figure>



<p>2.patsubst：pattern subsitude，匹配代替，用来替换文件名的后缀</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src = a.cpp b.cpp c.cpp e.cpp</span><br><span class="line"><span class="comment"># 把变量 src 中的所有文件名的后缀从 .cpp 替换为 .o</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(src)</span>)</span> </span><br><span class="line"><span class="comment"># obj 的值为: a.o b.o c.o e.o</span></span><br></pre></td></tr></table></figure>



<h2 id="0x-08-gdb"><a href="#0x-08-gdb" class="headerlink" title="0x 08 gdb"></a>0x 08 gdb</h2><h3 id="0-参考"><a href="#0-参考" class="headerlink" title=".0 参考"></a>.0 参考</h3><p>![9523F5A0-416A-4635-99DB-47685282748F](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;9523F5A0-416A-4635-99DB-47685282748F.png)</p>
<p><a target="_blank" rel="noopener" href="https://subingwen.cn/linux/gdb/#5-3-3-next">本文档参考来源，功能基础而简单</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/XxPIfrQ3E0GR88UsmQNggg">设计多线程，多进城等高级功能，较为复杂</a></p>
<p><a target="_blank" rel="noopener" href="https://www.yanbinghu.com/2019/04/20/41283.html">知乎</a></p>
<h3 id="1-添加命令行参数"><a href="#1-添加命令行参数" class="headerlink" title=".1 添加命令行参数"></a>.1 添加命令行参数</h3><figure class="highlight plaintext"><figcaption><span>args …```	启动gdb后，在程序启动之前设置参数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```show args```	查看设置的命令行参数</span><br><span class="line"></span><br><span class="line">### .2 启动程序</span><br><span class="line"></span><br><span class="line">在整个gdb调试过程中，启动饮用程序的命令只能使用一次。</span><br><span class="line"></span><br><span class="line">```run```		可以缩写为 `r`，如果程序中设置了断点会停在第一个断点的位置，如果没有设置断点，程序就执行完了。</span><br><span class="line"></span><br><span class="line">`start` 	启动程序，最终会阻塞在main函数的第一行，等待输入后续其他 gdb 命令。</span><br><span class="line"></span><br><span class="line">&gt; start 是要开始运行， run 是真的运行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### .3 退出 gdb</span><br><span class="line"></span><br><span class="line">`quit`  缩写为 `q`</span><br><span class="line"></span><br><span class="line">### .4 查看代码</span><br><span class="line"></span><br><span class="line">`list`	可以缩写为 `l` ，通过这个命令可以查看项目中任意一个文件中的内容，并且还可以通过文件行号，函数名等方式查看。</span><br><span class="line"></span><br><span class="line">``` shell</span><br><span class="line">(gdb) list</span><br><span class="line">(gdb) list 行号</span><br><span class="line">(gdb) list 函数名</span><br></pre></td></tr></table></figure>

<p>一个项目通常由多个源文件构成，默认情况下通过 list 查看的是程序入口 main 函数对应的文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list 文件名：行号</span><br><span class="line">(gdb) list 文件名：函数名</span><br></pre></td></tr></table></figure>

<p>默认情况下 list 之显示 10 行的内容。如果想显示更多，可以通过 <code>set listsize</code> 设置，同时如果想查看当前显示的行数可以通过 <code>show listsize</code> 查看。这里的 	<code>listsize</code> 可以缩写为 <code>list</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set listsize 行号</span><br><span class="line">(gdb) show listsize</span><br></pre></td></tr></table></figure>



<h3 id="5-断点操作"><a href="#5-断点操作" class="headerlink" title=".5 断点操作"></a>.5 断点操作</h3><p>如果想通过 gdb 掉时某一行或者得到某个变量在运行状态下的实际值，就需要在这一行设置断点，程序指定到断点的位置就会阻塞。我们就可以通过 gdb 的调试命令得到我们想要的信息了。</p>
<p>设置断点：<code>break</code> 缩写为 <code>b</code></p>
<p>断点的设置方式由两种：</p>
<ol>
<li>常规断点：程序只要运行到这个位置就会阻塞</li>
<li>条件断点：只有指定的条件被满足了程序才会在断点处阻塞</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置普通断点到当前文件</span></span><br><span class="line">(gdb) b 行号</span><br><span class="line">(gdb) b 函数名 # 停在函数的第一行</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置普通断点到某个非当前文件</span></span><br><span class="line">(gdb) b 文件名：行号</span><br><span class="line">(gdb) b 问价名：函数名 # 停在函数的第一行</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置条件断点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通常情况下，在循环中条件断点用的比较多</span></span><br><span class="line">(gdb)  b 行号 if 变量名 == 某个值</span><br></pre></td></tr></table></figure>

<hr>
<p>查看断点：<code>info break</code> ，其中 <code>info</code> 可以缩写为 <code>i</code> , <code>break</code> 可以缩写为 <code>b</code></p>
<blockquote>
<p>info break 查看断点信息时的一些常用的属性：Num:   断点的编号，删除断点或者设置断点状态的时候都需要使用<br>Enb:    当前断点的状态，y 表示断点可用，n 表示断点不可用<br>What:  描述断点被设置在了哪个文件的哪一行或者哪个函数上</p>
</blockquote>
<hr>
<p>如果确定设置的某个断点不再被使用了，可用将其删除，删除命令是 <code>delete</code> 断点编号 , 这个 <code>delete</code> 可以简写为 <code>del</code> 也可以再简写为 <code>d</code>。</p>
<p>删除断点的方式有两种: <strong>删除(一个或者多个)指定断点</strong>或者<strong>删除一个连续的断点区间</strong>，具体操作如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">delete == del == d</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要 info b 查看断点的信息, 第一列就是编号</span></span><br><span class="line">(gdb) d 断点的编号1 [断点编号2 ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例:</span> </span><br><span class="line">(gdb) d 1          # 删除第1个断点</span><br><span class="line">(gdb) d 2 4 6      # 删除第2,4,6个断点</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除一个范围, 断点编号 num1 - numN 是一个连续区间</span></span><br><span class="line">(gdb) d num1-numN</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例, 删除第1到第5个断点</span></span><br><span class="line">(gdb) d 1-5</span><br></pre></td></tr></table></figure>



<hr>
<p>如果某个断点只是临时不需要了，我们可以将其设置为不可用状态，设置命令为 <code>disable</code> 断点编号，当需要的时候再将其设置回可用状态，设置命令为 <code>enable</code> 断点编号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 让断点失效之后, gdb调试过程中程序是不会停在这个位置的</span><br><span class="line"># disable == dis</span><br><span class="line"># 设置某一个或者某几个断点无效</span><br><span class="line">(gdb) dis 断点1的编号 [断点2的编号 ...]</span><br><span class="line"></span><br><span class="line"># 设置某个区间断点无效</span><br><span class="line">(gdb) dis 断点1编号-断点n编号</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 查看断点信息</span><br><span class="line">(gdb) i b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       breakpoint     keep y   0x0000000000400cce in main() at test.cpp:14</span><br><span class="line">4       breakpoint     keep y   0x0000000000400cdd in main() at test.cpp:16</span><br><span class="line">5       breakpoint     keep y   0x0000000000400d46 in main() at test.cpp:23</span><br><span class="line">6       breakpoint     keep y   0x0000000000400d4e in main() at test.cpp:25</span><br><span class="line">7       breakpoint     keep y   0x0000000000400d6e in main() at test.cpp:28</span><br><span class="line">8       breakpoint     keep y   0x0000000000400d7d in main() at test.cpp:30</span><br><span class="line"></span><br><span class="line"># 设置第2, 第4 个断点无效</span><br><span class="line">(gdb) dis 2 4</span><br><span class="line"></span><br><span class="line"># 查看断点信息</span><br><span class="line">(gdb) i b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       breakpoint     keep n   0x0000000000400cce in main() at test.cpp:14</span><br><span class="line">4       breakpoint     keep n   0x0000000000400cdd in main() at test.cpp:16</span><br><span class="line">5       breakpoint     keep y   0x0000000000400d46 in main() at test.cpp:23</span><br><span class="line">6       breakpoint     keep y   0x0000000000400d4e in main() at test.cpp:25</span><br><span class="line">7       breakpoint     keep y   0x0000000000400d6e in main() at test.cpp:28</span><br><span class="line">8       breakpoint     keep y   0x0000000000400d7d in main() at test.cpp:30</span><br><span class="line"></span><br><span class="line"># 设置 第5,6,7,8个 断点无效</span><br><span class="line">(gdb) dis 5-8</span><br><span class="line"></span><br><span class="line"># 查看断点信息</span><br><span class="line">(gdb) i b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       breakpoint     keep n   0x0000000000400cce in main() at test.cpp:14</span><br><span class="line">4       breakpoint     keep n   0x0000000000400cdd in main() at test.cpp:16</span><br><span class="line">5       breakpoint     keep n   0x0000000000400d46 in main() at test.cpp:23</span><br><span class="line">6       breakpoint     keep n   0x0000000000400d4e in main() at test.cpp:25</span><br><span class="line">7       breakpoint     keep n   0x0000000000400d6e in main() at test.cpp:28</span><br><span class="line">8       breakpoint     keep n   0x0000000000400d7d in main() at test.cpp:30</span><br></pre></td></tr></table></figure>

<p>让无效的断点生效：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">enable</span> == ena</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置某一个或者某几个断点有效</span></span><br><span class="line">(gdb) ena 断点1的编号 [断点2的编号 ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置某个区间断点有效</span></span><br><span class="line">(gdb) ena 断点1编号-断点n编号</span><br></pre></td></tr></table></figure>



<h3 id="6-调试命令"><a href="#6-调试命令" class="headerlink" title=".6 调试命令"></a>.6 调试命令</h3><p>如果调试的程序被断点阻塞了又想让程序继续执行，这时候就可以使用 <code>continue</code> 命令。程序会继续运行，直到遇到下一个有效的断点。&#96;&#96;continue<code>可以缩写为</code>c&#96;。</p>
<p>在 gdb 调试的时候如果需要打印变量的值， 使用的命令是 <code>print</code>, 可缩写为 <code>p</code>。如果打印的变量是整数还可以指定输出的整数的格式，格式化输出的整数对应的字符表如下：</p>
<p>![9BDD57D6-6D87-4080-B269-951C45DEC259](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;9BDD57D6-6D87-4080-B269-951C45DEC259.png)</p>
<p><code>printf</code> 的语法格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">print</span> == p</span></span><br><span class="line">(gdb) p 变量名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果变量是一个整形, 默认对应的值是以10进制格式输出, 其他格式请参考上表</span></span><br><span class="line">(gdb) p/fmt 变量名</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例</span></span><br><span class="line">(gdb) p i       # 10进制</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">5 = 3</span></span><br><span class="line">(gdb) p/x i     # 16进制</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">6 = 0x3</span></span><br><span class="line">(gdb) p/o i     # 8进制</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">7 = 03</span></span><br></pre></td></tr></table></figure>

<p>如果在调试过程中需要查看某个变量的类型，可以使用命令 <code>ptype</code>, 语法格式如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法格式</span></span><br><span class="line">(gdb) ptype 变量名</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印变量类型</span></span><br><span class="line">(gdb) ptype i</span><br><span class="line">type = int</span><br><span class="line">(gdb) ptype array[i]</span><br><span class="line">type = int</span><br><span class="line">(gdb) ptype array</span><br><span class="line">type = int [12]</span><br></pre></td></tr></table></figure>

<hr>
<p>单步调试</p>
<p><code>step</code> 命令可以缩写为 <code>s</code>, 命令被执行一次代码被向下执行一行，如果这一行是一个函数调用，那么程序会进入到函数体内部。</p>
<p>如果通过 <code>s</code> 单步调试进入到函数内部，<strong>想要跳出这个函数体， 可以执行 <code>finish</code> 命令。如果想要跳出函数体必须要保证函数体内不能有有效断点，否则无法跳出。</strong></p>
<p><code>next</code> 命令和 <code>step</code> 命令功能是相似的，只是在使用 <code>next</code> 调试程序的时候不会进入到函数体内部，<code>next</code> 可以缩写为 <code>n</code></p>
<p>通过 <code>until</code> 命令可以直接跳出某个循环体，这样就能提高调试效率了。如果想直接从循环体中跳出，必须要满足以下的条件，否则命令不会生效：</p>
<h2 id="0x-e5-结构体字节对齐规则"><a href="#0x-e5-结构体字节对齐规则" class="headerlink" title="0x e5 结构体字节对齐规则"></a>0x e5 结构体字节对齐规则</h2><p>结构体的大小绝大部分情况下不会直接等于各个成员大小的总和，编译器为了优化对结构体成员的访问总会在结构体中插入一些空白字节，有如下结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">align_basic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么此时<code>sizeof(align_basic)</code>的值会是<code>sizeof(char)+sizeof(int)+sizeof(double)</code>的值么？</p>
<p><img src="https://pic3.zhimg.com/80/v2-dca7f4f607fdbc884079e30c10ceb7ae_1440w.png" alt="img"></p>
<p>如上图经过测试我们发现其大小为16个字节并不等于1+4+8&#x3D;13个字节，可知编译器给align_basic结构体插入了另外3个字节，接下来我们将分析编译器对齐字节的规则以及结构体在内存中的结构，首先感谢<a href="https://link.zhihu.com/?target=http://blog.csdn.net/liukun321/article/details/6974282">结构体在内存中的对齐规则 - 咕唧咕唧shubo.lk的专栏 - 博客频道 - CSDN.NET</a>这篇文章的作者，在此之前我对内存对齐也是一知半解，很多时候也解释不明白。</p>
<p>&#x3D;&#x3D;规则一：结构体中元素按照定义顺序依次置于内存中，但并不是紧密排列。从结构体首地址开始依次将元素放入内存时，元素会被放置在其自身对齐大小的整数倍地址上。&#x3D;&#x3D;这里说的地址是元素在结构体中的偏移量，结构体首地址偏移量为0。</p>
<p>在align_basic中元素c是第一个元素，那么它的地址为0，第二个元素i不会被放在地址1处，int的对齐大小为4个字节，此时虽然元素c只占据一个字节，但是由于i的地址必须在4字节的整数倍上，所以地址必须再向后在移动三个字节，故而需要放在地址4上，此时前两个元素已经占据了8个字节的空间，第三个元素d会被直接放在地址8上，因为double的对齐大小为8个字节，而前面两个元素已经占据了8个字节，正好是double对齐大小的整数倍，所以元素d不需要再往后移动。说了这么多也不如让机器给我们验证下有说服力：</p>
<p><code>printf(&quot;%d %d %d %d\n&quot;, sizeof(align_basic), &amp;align_basic::c, &amp;align_basic::i, &amp;align_basic::d);</code></p>
<p><img src="https://pic3.zhimg.com/80/v2-d729bea11322919cc59e03e03d3e221a_1440w.png" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-25407fa9c8f77c2f3d17a12546793a0d_1440w.png" alt="img"></p>
<p>那么这样就够了吗，会不会太简单？我们把元素i和d的位置交换下，此时结构体的大小会是20吗，我们仍然先让机器说话，(⊙o⊙)…毕竟后面打脸有证据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">align_basic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">double</span> d;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(align_basic));</span><br></pre></td></tr></table></figure>

<p><img src="https://pic4.zhimg.com/80/v2-cbfea1a547f205a2d4b2306748da3953_1440w.png" alt="img"></p>
<p>我们发现此时结构体的大小并不是20而是24，那么多出来的这4个字节如何解释？我们引出第二条规则。</p>
<p>&#x3D;&#x3D;规则二：如果结构体大小不是所有元素中最大对齐大小的整数倍，则结构体对齐到最大元素对齐大小的整数倍，填充空间放置到结构体末尾。&#x3D;&#x3D;</p>
<p>运用规则一，此时c仍然是第一个元素，其地址为0，第二个元素地址为8， 第三个元素地址为16，然后运用规则二，c，d，i中d的对齐大小为8最大所以整个结构必须对齐到8的整数倍，前面是三个元素已经占据了20个字节的空间，只需要在结构体的尾部填充4个字节的空间就是8的倍数了，所以此时整个结构体的大小为24个字节。</p>
<p><code>printf(&quot;%d %d %d %d\n&quot;, sizeof(align_basic), &amp;align_basic::c, &amp;align_basic::d, &amp;align_basic::i);</code></p>
<p><img src="https://pic3.zhimg.com/80/v2-c66b0aa643b60eecb9dbf06916c56482_1440w.png" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-0294208ed70bb94feb9868310a191eb3_1440w.png" alt="img"></p>
<p>&#x3D;&#x3D;规则三：基本数据类型的对齐大小为其自身的大小，结构体数据类型的对齐大小为其元素中最大对齐大小元素的对齐大小。&#x3D;&#x3D; 规则三可以由规则二推导出来。</p>
<p>char类型的对齐大小为1字节，short类型的对齐大小为2字节，int类型的大小为4字节，double的对齐大小为8字节，align_basic结构体中最大对齐大小元素为d是double类型，所以align_basic的对齐大小是8。有人会问如果结构体中有数组呢？很简单将数组看做是连续数个相同类型的元素即可。</p>
<h2 id="0x-e6-第一章小结"><a href="#0x-e6-第一章小结" class="headerlink" title="0x e6 第一章小结"></a>0x e6 第一章小结</h2><p>深入理解计算机系统的“系统”，并不是操作系统，这个系统包括了硬件，操作系统，网络，编译等等</p>
<p>学习计算机系统应该具备的三个<strong>抽象能力</strong>：问题抽象，系统抽象（csapp），数据抽象</p>
<p>计算机系统是由硬件和<strong>系统软件</strong>组成的。</p>
<p>数字的机器表示方法是对真值的<strong>有限近似值</strong>。</p>
<p>指令的执行：</p>
<ol>
<li>从磁盘读取指令和数据到内存</li>
<li>从内存送到cpu中去执行</li>
<li>将返回的数据送到屏幕</li>
</ol>
<h2 id="0x-e7-bomb-lab"><a href="#0x-e7-bomb-lab" class="headerlink" title="0x e7 bomb lab"></a>0x e7 bomb lab</h2><h3 id="1-phase1"><a href="#1-phase1" class="headerlink" title=".1 phase1"></a>.1 phase1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">disas main，可以发现我们输入的字符串赋值给了 $rdi</span><br><span class="line">并且之后调用了函数&lt;phase_1&gt;</span><br><span class="line">disas phase_1</span><br><span class="line">发现没有修改寄存器 $rdi 的值</span><br><span class="line">然后把一个立即数 0x402400 传给了寄存器 $esi</span><br><span class="line">之后调用函数 &lt;strings_not_euqal&gt;</span><br><span class="line">在之后test $eax $eax</span><br><span class="line">如果 je，即 $eax = 0</span><br><span class="line">调用函数 &lt;eoplode_bomb&gt;，炸弹爆炸</span><br><span class="line">否则正常返回</span><br><span class="line"></span><br><span class="line">进入函数 &lt;strings_not_equal&gt;</span><br><span class="line">该函数又会调用 &lt;string_length&gt; 函数</span><br><span class="line">这个函数会计算 $rdi 内字符串的长度</span><br><span class="line"></span><br><span class="line">p/x $rdx :以x(16进制)方式打印寄存器$rdx的值</span><br><span class="line">x $rdx 检查(examine) $rdx内存中的值</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/36809923">watch &#x3D; sepcial break</a></p>
<h3 id="2-phase2"><a href="#2-phase2" class="headerlink" title=".2 phase2"></a>.2 phase2</h3><h3 id="3-phase3"><a href="#3-phase3" class="headerlink" title=".3 phase3"></a>.3 phase3</h3><p>![78E9B95E-D7EC-4E49-8A30-94EF4B0A4D48](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;78E9B95E-D7EC-4E49-8A30-94EF4B0A4D48.png)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># phase_3</span><br><span class="line"><span class="title function_">if</span><span class="params">(eax &gt; <span class="number">1</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">7</span> &lt; rsp + <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        eax = rsp + <span class="number">0x8</span>; <span class="comment">// first input</span></span><br><span class="line">        <span class="keyword">switch</span>(eax)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">                eax = <span class="number">0xcf</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                eax = <span class="number">0x137</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                eax = <span class="number">0x2c3</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                eax = <span class="number">0x100</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                eax = <span class="number">0x185</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                eax = <span class="number">0xce</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                eax = <span class="number">0x2aa</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">        &#125;</span><br><span class="line">        	<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        		eax = <span class="number">0x147</span>;</span><br><span class="line">                <span class="keyword">if</span>(rsp + <span class="number">0xc</span> == eax)    <span class="keyword">return</span> Accept;</span><br><span class="line">                <span class="keyword">else</span>    <span class="keyword">return</span> BOOM!!!;       		</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BOOM!!!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> BOOM!!!;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有多组答案：注意第二个参数不能输入十六进制数，只能输入10进制数，因为这里的数据的读如是采用sscanf，把我们的输入作为str,如果我们的第二个参数是个十六进制数，那么一定以0x开头，结果0会被读取到第二个参数，读到x不合法就结束了。</p>
<table>
<thead>
<tr>
<th>第一个参数</th>
<th>第二个参数</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>207</td>
</tr>
<tr>
<td>1</td>
<td>311</td>
</tr>
<tr>
<td>2</td>
<td>707</td>
</tr>
<tr>
<td>3</td>
<td>256</td>
</tr>
<tr>
<td>4</td>
<td>389</td>
</tr>
<tr>
<td>5</td>
<td>206</td>
</tr>
<tr>
<td>6</td>
<td>682</td>
</tr>
<tr>
<td>7</td>
<td>327</td>
</tr>
</tbody></table>
<h3 id="4-phase4"><a href="#4-phase4" class="headerlink" title=".4 phase4"></a>.4 phase4</h3><p>第一个参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.func4:</span><br><span class="line">eax = edx</span><br><span class="line">eax -= edx</span><br><span class="line">ecx = eax</span><br><span class="line">ecx &gt;&gt;= <span class="number">0x1f</span> <span class="comment">// unsigned</span></span><br><span class="line">eax += ecx</span><br><span class="line">eax &gt;&gt;= <span class="number">1</span></span><br><span class="line">ecx = &amp;(rax+rso+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span>(ecx &lt;= edi)  </span><br><span class="line">&#123;</span><br><span class="line">    eax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(exc &gt;= edi)  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 只有当 ecx&lt;=edi&lt;=ecx，即edi=ecx=7时可以正常退出并返回0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        。。。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    edx = &amp;(rcx - <span class="number">1</span>)</span><br><span class="line">    call func4</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// goal: make eax = 0</span></span><br></pre></td></tr></table></figure>



<p>第二个参数看phrase4的汇编很容易得出为0</p>
<h3 id="5-phase5"><a href="#5-phase5" class="headerlink" title=".5 phase5"></a>.5 phase5</h3><p><a target="_blank" rel="noopener" href="https://github.com/wuxueqian14/csapp-lab/tree/master/Bomb%20Lab">reference</a></p>
<h3 id="6-phase6"><a href="#6-phase6" class="headerlink" title=".6 phase6"></a>.6 phase6</h3><p>不想做了</p>
<h3 id="7-phase7"><a href="#7-phase7" class="headerlink" title=".7 phase7"></a>.7 phase7</h3><p>no</p>
<h3 id="8-answer-2016"><a href="#8-answer-2016" class="headerlink" title=".8 answer(2016)"></a>.8 answer(2016)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">7 327</span><br><span class="line">7 0</span><br><span class="line">)/.%&amp;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="0x-09-Assembly实验"><a href="#0x-09-Assembly实验" class="headerlink" title="0x 09 Assembly实验"></a>0x 09 Assembly实验</h2><p><img src="/Users/epoch/Library/Containers/com.tencent.qq/Data/Library/Caches/Images/BE9A5FC6EBB55797FF78C5D5105D31DF.png" alt="BE9A5FC6EBB55797FF78C5D5105D31DF"></p>
<p>如上图，我们用(gdb) x mingling打印 0x7fffffffe3b0附近的值，这个地址是个虚拟地址，它在内存中的值为0x0</p>
<p>栈指针是会浮动的！但是rsp和rbp的差值应该是不变的。</p>
<p>gdb(ni) ：会跳出函数执行</p>
<p>gdb(si)：会进入函数执行</p>
<p>![A44D5C36-2816-49B3-9E01-23E15BC5DA72](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;A44D5C36-2816-49B3-9E01-23E15BC5DA72.png)</p>
<p>小端存储的又一个例子啊，我们把寄存器 %rbp(0x7fffffffe3d0) 放入 %rsp，观察可以发现，0x00007ffff倍放在了后面的地址，而0xffffe3d0被放在了前面的地址。x命令打印的地址从左到右，从上到下是以4为单位递增的，</p>
<h2 id="0x-0a-ld-preload环境变量劫持函数"><a href="#0x-0a-ld-preload环境变量劫持函数" class="headerlink" title="0x 0a ld_preload环境变量劫持函数"></a>0x 0a ld_preload环境变量劫持函数</h2><p>首先在目录下创建两个文件 main.c 和 txt</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> <span class="comment">// main.c</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE *fd = fopen(<span class="string">&quot;txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;*** open file error!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;open file success!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常来说最后程序会正确执行</p>
<p>但如果我们更改动态链接库</p>
<p>先创建一个trik动态链接库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">// trik.c</span></span></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*** Always open error!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC trik.c -o trik.so</span><br><span class="line">LD_PRELOAD=$PWD/trik.so ./a.out</span><br></pre></td></tr></table></figure>

<p>最后文件会打开失败</p>
<p>![53DE4182-359A-4F3E-80BB-4B97508E7F9B](&#x2F;Users&#x2F;epoch&#x2F;Library&#x2F;Containers&#x2F;com.tencent.qq&#x2F;Data&#x2F;Library&#x2F;Application Support&#x2F;QQ&#x2F;Users&#x2F;2407217576&#x2F;QQ&#x2F;Temp.db&#x2F;53DE4182-359A-4F3E-80BB-4B97508E7F9B.png)</p>
<p>原理就是通过自己写的库函数劫持系统的库函数，使得程序执行我们的库函数。</p>
<h2 id="0x-0b-attack-lab"><a href="#0x-0b-attack-lab" class="headerlink" title="0x 0b attack lab"></a>0x 0b attack lab</h2><h2 id="0x0c-链接-points"><a href="#0x0c-链接-points" class="headerlink" title="0x0c 链接 points"></a>0x0c 链接 points</h2><p>1.引入哑节点dummy</p>
<p>2.引入数据结构–elf</p>
<p>3.静态链接的过程：elf定位到符号-&gt;符号解析-&gt;重定位</p>
<p>4.*.o, elf 都是二进制文件</p>
<p>5.unix下大部分工具都在&#x2F;usr&#x2F;bin或者&#x2F;bin目录下的。使用hexdump可以查看二进制文件</p>
<p>6.第一个section的name为空（其实叫做 undefine section），且数据全为0，里面存放的内容是undefine的数据。</p>
<p>7.将函数定义为一个弱符号：<code>attribute__((weak)) int add*() &#123;&#125;</code> ,这里的 <code>add</code> 函数被定义为一个弱符号，它可以被强符号函数 <code>add</code> 覆盖。</p>
<p>8.对于 <code>C Language</code> 来说，出现 <code>Warning</code> 说明你的语句有<strong>歧义</strong> ，但是 C 语言为你选择了一种结果，注意这种结果可能与你的本意不同！</p>
<p>9.对于初始化为 <code>0</code> 的全局变量和静态变量，也被划分到 <code>.bss</code>，这是因为全局变量和静态变量默认初始化就是 <code>0</code>。</p>
<p>10.为什么在可重定位目标文件中有 <code>COMMON</code>，在可执行目标文件中就没有 <code>COMMON</code> 了呢。</p>
<blockquote>
<p> 回想一下<code>COMMON</code>的定义，对于未初始化的全局变量， 属于<code>COMMON</code>。</p>
<p>对于未初始化的全局变量， 在链接之后它有三种可能的情况（假设这里有两个文件 <code>s1.c</code>, <code>s2.c</code>，在 <code>s1.c</code> 中定义有未初始化的全局变量 <code>g</code>）</p>
<ol>
<li><p>如果在 <code>s2.c</code> 中也定义了一个全局变量 <code>g</code> 并且初始化为 <code>0</code>，则 <code>g</code> 属于 <code>.bss</code> 节</p>
</li>
<li><p>如果初始化不是 <code>0</code>，就属于 <code>.data</code></p>
</li>
<li><p>如果 <code>s2.c</code> 没有定义 <code>g</code> ，那么 s2 就属于 <code>.bss</code></p>
<p>因为有如上三种（合法）情况，所以把它划分到 <code>COMMON</code>，而之所以在可执行目标文件中没有了 <code>COMMON</code> ,是因为此时已经链接完了，<code>g</code> 属于那个节已经很明确了，因此也就不需要了。</p>
</li>
</ol>
</blockquote>
<ol start="11">
<li></li>
</ol>
<h2 id="0x0d-修改-ROF-信息的实验"><a href="#0x0d-修改-ROF-信息的实验" class="headerlink" title="0x0d 修改 ROF 信息的实验"></a>0x0d 修改 ROF 信息的实验</h2><p>首先编译源文件 <code>add.c</code> 生成可重定位目标文件 <code>add.o</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> addcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	addcnt ++ ;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用 <code>hexdump -S add.o</code> 查看 <code>Section Headers</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000003c  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000228</span><br><span class="line">       0000000000000060  0000000000000018   I       9     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  0000007c</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  0000007c</span><br><span class="line">       0000000000000004  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .comment          PROGBITS         0000000000000000  0000007c</span><br><span class="line">       0000000000000027  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  000000a3</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .eh_frame         PROGBITS         0000000000000000  000000a8</span><br><span class="line">       0000000000000030  0000000000000000   A       0     0     8</span><br><span class="line">  [ 8] .rela.eh_frame    RELA             0000000000000000  00000288</span><br><span class="line">       0000000000000018  0000000000000018   I       9     7     8</span><br><span class="line">  [ 9] .symtab           SYMTAB           0000000000000000  000000d8</span><br><span class="line">       0000000000000138  0000000000000018          10    11     8</span><br><span class="line">  [10] .strtab           STRTAB           0000000000000000  00000210</span><br><span class="line">       0000000000000018  0000000000000000           0     0     1</span><br><span class="line">  [11] .shstrtab         STRTAB           0000000000000000  000002a0</span><br><span class="line">       0000000000000059  0000000000000000           0     0     1</span><br></pre></td></tr></table></figure>

<p>可以发现下标为 <code>1</code> 的节是 <code>.text</code> 节</p>
<p>我们现在要修改 <code>add.o</code> 使其显示为 <code>.ext</code> 节</p>
<p>首先需要下载 <code>hexedit</code></p>
<p>然后拷贝一份 <code>add.o</code> 的副本 <code>badadd.o</code></p>
<p>（不在源文件上直接修改是个好习惯）</p>
<p>然后执行命令<code>hexdump -c badadd.o</code> 找到 <code>.text</code> 的位置。</p>
<p>通过 <code>elf header</code> 中的信息可以得到 <code>Section header table</code> 的 <code>offset</code> 为 <code>0x300</code>，其中每个条目(<code>entry</code>) 的 <code>size</code> 为 <code>0x40</code> ，由此可以得到第二个条目（下标为1）的 <code>.text</code> 节的位置为 <code>0x340</code>，并通过 <code>struct elf64_shdr</code> 得到前 <code>4</code> 个字节为 <code>name</code>。</p>
<p><code>00000340  20 00 00 00 01 00 00 00  06 00 00 00 00 00 00 00  | ...............|</code></p>
<p><code>name = 0x00000020</code> ,我们只需要修改其为 <code>0x00000022</code>，就可以实现 <code>name</code> 往后偏移两个字节</p>
<p>这样 <code>name</code> 就从 &#96;&#96;.text<code>变成了</code>ext&#96;</p>
<p>执行命令：<code>hexedit badadd.o</code> 找到位置并修改即可。</p>
<p>按 <code>F10</code> 退出</p>
<p>最后结果如下：</p>
<p><code>readelf -S badadd.o</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] ext               PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000003c  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000228</span><br><span class="line">       0000000000000060  0000000000000018   I       9     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  0000007c</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  0000007c</span><br><span class="line">       0000000000000004  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .comment          PROGBITS         0000000000000000  0000007c</span><br><span class="line">       0000000000000027  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 6] .note.GNU-stack   PROGBITS         0000000000000000  000000a3</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 7] .eh_frame         PROGBITS         0000000000000000  000000a8</span><br><span class="line">       0000000000000030  0000000000000000   A       0     0     8</span><br><span class="line">  [ 8] .rela.eh_frame    RELA             0000000000000000  00000288</span><br><span class="line">       0000000000000018  0000000000000018   I       9     7     8</span><br><span class="line">  [ 9] .symtab           SYMTAB           0000000000000000  000000d8</span><br><span class="line">       0000000000000138  0000000000000018          10    11     8</span><br><span class="line">  [10] .strtab           STRTAB           0000000000000000  00000210</span><br><span class="line">       0000000000000018  0000000000000000           0     0     1</span><br><span class="line">  [11] .shstrtab         STRTAB           0000000000000000  000002a0</span><br><span class="line">       0000000000000059  0000000000000000           0     0     1</span><br></pre></td></tr></table></figure>







<h2 id="0x0e-vim-tabe"><a href="#0x0e-vim-tabe" class="headerlink" title="0x0e vim tabe"></a>0x0e vim tabe</h2><p>vim中的分页命令，多窗口vim</p>
<p>通过<code>help tab-page-intro</code>命令，可以获得关于标签页使用的更多信息。</p>
<table>
<thead>
<tr>
<th><code>:tabnew</code></th>
<th align="left">新建标签页</th>
</tr>
</thead>
<tbody><tr>
<td><code>:tabs</code></td>
<td align="left">显示已打开标签页的列表</td>
</tr>
<tr>
<td><code>:tabc</code></td>
<td align="left">关闭当前标签页</td>
</tr>
<tr>
<td><code>:tabe &lt;filename&gt;</code></td>
<td align="left">打开新文件(tabedit)</td>
</tr>
<tr>
<td><code>:tabp</code></td>
<td align="left">移动到上一个标签页</td>
</tr>
<tr>
<td><code>:tabn</code></td>
<td align="left">移动到下一个标签页(tabnext)</td>
</tr>
<tr>
<td><code>:gt</code></td>
<td align="left">移动到下一个标签页</td>
</tr>
<tr>
<td><code>:tabr</code></td>
<td align="left">移动到第一个标签页(tabrewind,tabfirst)</td>
</tr>
<tr>
<td><code>:tabl</code></td>
<td align="left">移动到最后一个标签页(tablast)</td>
</tr>
<tr>
<td><code>$vim -p &lt;f1&gt; &lt;f2&gt; &lt;f3&gt;</code></td>
<td align="left">vim开启多个标签页</td>
</tr>
</tbody></table>
<h2 id="0x0f-bilbili-链接"><a href="#0x0f-bilbili-链接" class="headerlink" title="0x0f bilbili 链接"></a>0x0f bilbili 链接</h2><p>链接步骤：</p>
<blockquote>
<ol>
<li>parse text</li>
<li>symbol parse</li>
<li>Relocation</li>
</ol>
<p>2 和 3 都依赖于 1 的 text</p>
</blockquote>
<h1 id="Csapp-Link"><a href="#Csapp-Link" class="headerlink" title="Csapp Link"></a>Csapp Link</h1><h2 id="English"><a href="#English" class="headerlink" title="::English"></a>::English</h2><p>separate compliation：分离编译</p>
<p>mangling：重整</p>
<h2 id="Tool"><a href="#Tool" class="headerlink" title=":: Tool"></a>:: Tool</h2><p>GNU READELF：查看目标文件内容的很方便的工具。</p>
<h2 id="0x00-introduce"><a href="#0x00-introduce" class="headerlink" title="0x00 introduce"></a>0x00 introduce</h2><h3 id="1-链接的执行阶段"><a href="#1-链接的执行阶段" class="headerlink" title="1. 链接的执行阶段"></a>1. 链接的执行阶段</h3><ol>
<li>compile time</li>
<li>load time</li>
<li>run time</li>
</ol>
<h3 id="2-why-learn-link"><a href="#2-why-learn-link" class="headerlink" title="2. why learn link"></a>2. <strong>why</strong> learn link</h3><ol>
<li>理解链接器将帮助你构造大型程序</li>
<li>理解链接器将帮助你避免一些危险的编程错误。</li>
<li>理解链接器将帮助你理解语言的作用域规则是如何实现的。</li>
<li>理解链接将帮助你理解其他重要的系统概念。（加载和运行程序，虚拟内存，分页，内存映射）</li>
<li>理解链接将使你能够利用共享库。</li>
</ol>
<h2 id="0x01-compiler-driver"><a href="#0x01-compiler-driver" class="headerlink" title="0x01 compiler driver"></a>0x01 compiler driver</h2><p>compiler dirver：编译器驱动程序</p>
<p>它代表用户在需要的时候调用：</p>
<ol>
<li>cpp</li>
<li>cc1</li>
<li>as</li>
<li>ld</li>
</ol>
<p>可以使用 -v 选项查看这个过程</p>
<p>当我们在 Linux 命令行输入：<code>./proc</code></p>
<p>shell 调用操作系统中一个叫做<strong>加载器</strong>的函数，它将可执行文件 proc 中的代码和数据复制到内存，然后将控制转移到这个程序的开头。</p>
<h2 id="0x02-static-link"><a href="#0x02-static-link" class="headerlink" title="0x02 static link"></a>0x02 static link</h2><p>Relocaable object file: 由各种不同的代码和数据节（section）组成，每一节都是一个连续的字节序列。</p>
<p>为了构造 executable file，linker 必须完成两个主要任务：</p>
<ol>
<li>Symbol resolution（符号解析）：符号解析的目的是将每个符号引用正好和一个符号定义关联起来。</li>
<li>relocation（重定位）。</li>
</ol>
<p>Symbol（符号）：目标文件定义和引用符号，每个符号对应于一个函数，一个局部变量或一个静态变量（即C语言任何非 static 属性声明的变量）。</p>
<p>Compiler and Assembly generate code and data section start at address 0, linker connect every symbol define with one memory address, so can relocate those sections, and then modify all the symbol define, make them point the address. Linker use the detailed instructions of relocation entry(重定位条目) which generated by assembly to execute those relocation with no check.</p>
<h2 id="0x03-object-file"><a href="#0x03-object-file" class="headerlink" title="0x03 object file"></a>0x03 object file</h2><p>object file（目标文件） types:</p>
<ol>
<li>relocatable object file：在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li>
<li>executable object file</li>
<li>Share object file（共享目标文件）: 一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。</li>
</ol>
<p>Compiler and Assembly generate relocatable object file.  Linker generate executable  object file.</p>
<p>Technically talking, a object module(目标模块) is a byte sequence,  and a object file is a object module which storage in disk as a type of file.</p>
<p>目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。</p>
<ol>
<li>Unix: a.out</li>
<li>Windows: PE(Portable Executable)(可移植可执行)</li>
<li>MacOS-X: Mach-O </li>
<li>Modern x86-64 and Unix: ELF(Executable and Linkable Format)(可执行可链接格式)</li>
</ol>
<h2 id="0x04-relocatable-object-file"><a href="#0x04-relocatable-object-file" class="headerlink" title="0x04 relocatable object file"></a>0x04 relocatable object file</h2><p>典型的ELF可重定位目标文件</p>
<p><img src="https://s1.328888.xyz/2022/09/28/spfaF.png" alt="IMG"></p>
<p>ELF contains:   ELF header，Sections，Section header table(节头部表)。</p>
<p>(1) ELF header：</p>
<ol>
<li>以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的<strong>字的大小</strong>和<strong>字节顺序。</strong></li>
<li>剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包含：<ul>
<li>ELF 头的大小</li>
<li>目标文件的类型（可重定位、可执行或者共享）</li>
<li>机器类型（x86-64）</li>
<li>节头部表的文件偏移</li>
<li>节头部表中条目的大小和数量</li>
</ul>
</li>
</ol>
<p>(2) Section headere table: 不同 Section 的位置和大小是由节头部表描述的，其中目标文件中的每个节都有一个固定大小的条目（entry）。</p>
<p>(3) Section:</p>
<ol>
<li>.text：已编译程序的<strong>机器代码。</strong></li>
<li>.rodata：只读数据。</li>
<li>.data：已初始化的全局和静态 C 变量。（局部变量在栈中，既不出现在 .data中，也不出现在 .bss汇总）</li>
<li>.bss：未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量（默认初始化）。在目标文件中<strong>这个节不占用实际的空间，它仅仅是一个占位符。</strong> 目标文件中区分 .bss 和 .data 是为了<strong>空间效率</strong>：在目标文件中，未初始化变量不需要占用任何实际的磁盘空间。运行时，在内存中分配这些变量，初始化为0。</li>
<li>.symtab；符号表。存放在程序中<strong>引用</strong>和<strong>定义</strong>的函数和全局变量的信息。（不包含局部变量的条目）。</li>
<li>.rel.text：relocation。一个 .text 节总位置的列表。当 Linker 把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的<strong>指令</strong>都需要修改。</li>
<li>.rel.data：被模块定义或引用的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的值是一个全局变量地址或者外部定义的函数的<strong>地址</strong>，都需要被修改。</li>
<li>.debug：调试符号表。只有使用 -g 选项时才会得到这张表。</li>
<li>.line：原始 C 源程序中的行好和 .text 节 中机器指令之间的<strong>映射</strong>。只有使用 -g 选项时才会得到这张表。</li>
<li>.strtab：字符串表。其内容包含 .symbol 和 .debug节中的符号表，已经节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。</li>
</ol>
<p>为什么未初始化的数据成为  .bss</p>
<blockquote>
<p>起始于 IMB 704 汇编语言（大约在1957年） Block Storage Start(块存储开始)指令的首字母缩写。并沿用至今。</p>
<p>你可以这样理解并区分于 .data：Better Save Space（更好的节省空间）的缩写。</p>
</blockquote>
<h2 id="0x05-symbol-and-symbol-table"><a href="#0x05-symbol-and-symbol-table" class="headerlink" title="0x05 symbol and symbol table"></a>0x05 symbol and symbol table</h2><p>​			 	</p>
<p>每个 relocatable object module m 都有一个符号表，它包含 m 定义和引用的符号的信息。在 Linker 的上下文中，有三种不同的符号：</p>
<ol>
<li>m 定义的并且能被其他 module 引用的全局符号。</li>
<li>其他 module 定义并被模块 m 引用的全局符号，</li>
<li>只被 m 定义和引用的局部符号。</li>
</ol>
<p>符号表是由 Assembly 构造的，使用 Compiler 输出到汇编语言 .s 文件中的符号。</p>
<p>.symtab 节的内容是一个数组，数组的元素是一个符号条目：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="type">char</span> type: <span class="number">4</span>,</span><br><span class="line">    	binding: <span class="number">4</span>;</span><br><span class="line">    <span class="type">char</span> reserved;</span><br><span class="line">    <span class="type">short</span> section;</span><br><span class="line">    <span class="type">long</span> value;</span><br><span class="line">    <span class="type">long</span> size;</span><br><span class="line">&#125; Elf_64_Symbol;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>name：是字符串表中的字节串，指向符号的以 null 结尾的字符串名字。</p>
<p>section（base_address）：到节头部表的索引，指明被分配到那个节。</p>
<p>value（offset_address）：是符号的地址。对于可重定位的 module 来说，value 是距定义目标的节的其实地址的 offset。</p>
<p>size：是目标的大小（byte）。</p>
<p>type：data or function。</p>
<p>binding：static or global</p>
<p>有三个特殊的<strong>伪节</strong>，它们在节头部表中是没有条目的（只有可重定位目标模块才有）：</p>
<ol>
<li>ABS：不应该被重定位的符号。</li>
<li>UNDEF：未定义的符号，也就是在本目标模块中引用，但是在其它地方定义的符号。</li>
<li>COMMON：还未被分配位置的未初始化的数据目标。对于 common u符号，value 字段给出<strong>对其要求</strong>。</li>
</ol>
<p>common 和 .bss 的区别很细微，现代的 GCC 根据以下规则分配符号：</p>
<ol>
<li>Common: 未初始化的全局变量</li>
<li>.bss：未初始化的静态变量，及其初始化为0的全局变量和静态变量</li>
</ol>
</blockquote>
<h2 id="0x06-symbol-parse"><a href="#0x06-symbol-parse" class="headerlink" title="0x06 symbol parse"></a>0x06 symbol parse</h2><h3 id="1-链接器解析符号引用的方法"><a href="#1-链接器解析符号引用的方法" class="headerlink" title="1.链接器解析符号引用的方法"></a>1.链接器解析符号引用的方法</h3><p>链接器解析符号引用的方法是将每个引用于它输入的可重定位目标文件的符号表的一个确定的符号定义关联起来。</p>
<p>对那些和引用定义在相同模块中的局部符号的引用，符号解析是非常简单明了的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保他们拥有唯一的名字。</p>
<p>不过，对全局符号的引用解析就棘手的多。当编译器遇到一个不是在当前模块中定义的符号（变量或者函数名）时，会假设该符号是在其它某个模块中定义的，升成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条（通常很难阅读的）错误信息并终止。</p>
<h3 id="2-c-和-java-中的重整和恢复"><a href="#2-c-和-java-中的重整和恢复" class="headerlink" title="2.c++ 和 java 中的重整和恢复"></a>2.c++ 和 java 中的<strong>重整</strong>和<strong>恢复</strong></h3><p>C++ 和 Java 都允许重载方法，这些方法在源代码中有相同名字，却有着不同的参数列表。那么链接器是如何区别这些不同的重载函数之间的差异呢？</p>
<p>因此编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。这种编码过程叫做重整（mangling），而相反的过程叫做恢复（demangling）。</p>
<p>幸运的事，C++ 和 Java使用兼容的重整策略。一个被重整的类名字是由名字中字符的整数数量，后面跟上原始名字组成的。例如：类 Foo 被编码成 3Foo。方法被编码为原始方法名，后面加上‘__’（下划线），加上被重整的雷鸣，再加上每个参数的单字母编码。比如：Foo::bar(int, long) 被编码为 bar_3fooil。</p>
<p>重整全局变量和模版名字的策略是相似的。</p>
<p>例如 C++程序 ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> sum1, sum2;</span><br><span class="line">	sum1 = <span class="built_in">get</span>(a, b, c);</span><br><span class="line">	sum2 = <span class="built_in">get</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum1: &quot;</span> &lt;&lt; sum1 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum2: &quot;</span> &lt;&lt; sum2 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<p><code>readelf mangling.o --syms</code></p>
<p>得到如下符号表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Symbol table &#x27;.symtab&#x27; contains 30 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS mangling.cpp</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text</span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 .data</span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 .bss</span><br><span class="line">     5: 0000000000000000     1 OBJECT  LOCAL  DEFAULT    4 _ZStL8__ioinit</span><br><span class="line">     6: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    4 $d</span><br><span class="line">     7: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    1 $x</span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 .rodata</span><br><span class="line">     9: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    5 $d</span><br><span class="line">    10: 00000000000000fc    96 FUNC    LOCAL  DEFAULT    1 _Z41__static_ini[...]</span><br><span class="line">    11: 000000000000015c    28 FUNC    LOCAL  DEFAULT    1 _GLOBAL__sub_I__[...]</span><br><span class="line">    12: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 .init_array</span><br><span class="line">    13: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    6 $d</span><br><span class="line">    14: 0000000000000000     0 SECTION LOCAL  DEFAULT    9 .note.GNU-stack</span><br><span class="line">    15: 0000000000000014     0 NOTYPE  LOCAL  DEFAULT   10 $d</span><br><span class="line">    16: 0000000000000000     0 SECTION LOCAL  DEFAULT   10 .eh_frame</span><br><span class="line">    17: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 .comment</span><br><span class="line">    18: 0000000000000000    32 FUNC    GLOBAL DEFAULT    1 _Z3getii</span><br><span class="line">    19: 0000000000000020    44 FUNC    GLOBAL DEFAULT    1 _Z3getiii</span><br><span class="line">    20: 000000000000004c   176 FUNC    GLOBAL DEFAULT    1 main</span><br><span class="line">    21: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZSt4cout</span><br><span class="line">    22: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZStlsISt11char_[...]</span><br><span class="line">    23: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSolsEi</span><br><span class="line">    24: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZSt4endlIcSt11c[...]</span><br><span class="line">    25: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSolsEPFRSoS_E</span><br><span class="line">    26: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSt8ios_base4I[...]</span><br><span class="line">    27: 0000000000000000     0 NOTYPE  GLOBAL HIDDEN   UND __dso_handle</span><br><span class="line">    28: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _ZNSt8ios_base4I[...]</span><br><span class="line">    29: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND __cxa_atexit</span><br></pre></td></tr></table></figure>

<p>可以观察到，两个 get 函数分别被标识为：<code>_Z3getii</code> 和 <code>_Z3getiii</code></p>
<h3 id="3-Linux-处理多重定义的符号"><a href="#3-Linux-处理多重定义的符号" class="headerlink" title="3. Linux 处理多重定义的符号"></a>3. Linux 处理多重定义的符号</h3><p>强符号：函数和已初始化的全局变量</p>
<p>弱符号：未初始化的全局变量</p>
<p>Linux 处理多重定义的符号名的三个规则：</p>
<ol>
<li>不允许多个同名的强符号。</li>
<li>如果有一个强符号和多个弱符号同名，选择强符号。</li>
<li>如果有多个弱符号同名，任意选择一个。</li>
</ol>
<h3 id="4-静态库"><a href="#4-静态库" class="headerlink" title="4. 静态库"></a>4. 静态库</h3><h4 id="4-1-为什么要引入静态库？"><a href="#4-1-为什么要引入静态库？" class="headerlink" title="4.1 为什么要引入静态库？"></a>4.1 为什么要引入静态库？</h4><p>如果不引入静态库的话，试想一下编译器开发人员会使用什么方法来向用户提供这些函数。</p>
<blockquote>
<p>编译器代劳！</p>
</blockquote>
<p>一种方法是让编译器辨认出对标准函数的调用，并直接生成相应的代码。对于那些提供了一小部分标准函数的语言（例如 Pascal）是可以的，但是对于 C 这种标准定义了大量的标准函数是不可以的。因为每次添加、修改或删除一个标准库函数时，就需要一个新的编译器版本。然而，对于应用程序猿而言，这种方法是非常方便的，因为标准函数将总是可用（只需要你编译器开发人员搞定就行了，管我什么事 - -</p>
<blockquote>
<p>所有函数对应一个可重定位目标模块！</p>
</blockquote>
<p>另一种方法是将所有的 C 函数都放在一个单独的可重定位目标模块中（比如说 libc.a），应用程序猿可以把这个模块连接到他们的可执行文件中：</p>
<p><code>gcc main.c /usr/lib/libc.o</code></p>
<p>IOS C99 定义的 C库：libc.a; 数学函数库：libm.a</p>
<p>通过把函数放在目标模块中，可以把编译器的实现与标准函数的实现分离开来。但是，现在每个可执行文件都包含着一份标准函数集合的副本（除非你不链接它，但这怎么可能呢？），这是对<strong>磁盘的极度浪费</strong>！在一个典型的系统中，libc.a 大约是 5MB，llib.a 大约是 2MB）。另外，每个运行的程序都将它的这些函数的副本放在内存中，这是<strong>对内存的极大浪费</strong>。此外，只要标准库修改了一个小小的地方，无论多么小，你都要重新编译整个源文件，非常<strong>耗时</strong>。</p>
<blockquote>
<p>每个函数对应一个可重定位目标模块！</p>
</blockquote>
<p>我们可以通过为每个库函数创建一个独立的可重定位模块，把他们放在一个为大家都知道的目录中来解决其中的一些问题。然而，问题也是相当明显的：</p>
<ol>
<li>那你要手写多少模块啊？</li>
<li>太多了不小心写错名字了怎么办？从头再检查一遍吧！</li>
<li>太多了，你得写到什么时候？</li>
<li>。。。</li>
<li>真是一个麻烦又耗时又糟心的过程！</li>
</ol>
<p><code> gcc main.c /usr/lib/printf.o /usr/lib/scanf.o ........</code></p>
<blockquote>
<p>静态库！</p>
</blockquote>
<p>于是，为了解决这些问题，静态库诞生了！！！</p>
<p>我们可以结合上面的方法，既不把所有函数划分到一个模块，也不每个函数对应一个模块，而是把一些相关的函数划分到一个模块（例如 C 标准库和数学库等），然后封装成一个单独的静态库文件。而不是每个函数对应一个模块。</p>
<p><code>gcc main.c /usr/lib/libc.a /usr/lib/libm.a .. </code></p>
<p>你可能会问：这个静态库和前面把所有函数放在一个可重定位目标模块有什么区别吗？不就是一个叫（模块 .o)，一个叫静态库（.a）罢了！</p>
<p>那我可就得给你好好讲讲了：当所有函数封装在一个模块中，那我们链接的时候，就不得不链接所有库函数了。</p>
<p>但是！接下来好好听了！</p>
<p>如果说模块是函数的集合，那么静态库就是模块的集合！所以，你可能想到了，虽然我们链接到了静态库，但并不链接静态库中的所有模块，而是只链接需要用到的模块，这样既避免了类似于一个函数一个模块那样链接模块太多的问题，又避免了链接所有模块的问题。</p>
<p>你可能会问：这怎么实现呢？</p>
<p>答案是：暴力出奇迹，循环判断是否用到就好了。用不到的模块就舍弃掉。</p>
<p>妙不妙！再看一看静态库的定义吧。</p>
<blockquote>
<p>在 Linux 中，静态库是以一种称为 <strong>存档(archive)</strong> 的特殊文件形式存放在<strong>磁盘</strong>中的。存档是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件由后缀（.a)标识。</p>
</blockquote>
<h3 id="4-2-创建静态库"><a href="#4-2-创建静态库" class="headerlink" title="4.2 创建静态库"></a>4.2 创建静态库</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/x_wukong/p/5713437.html">静态库和动态库创建参考</a></p>
<blockquote>
<p>(1) 首先，我们需要源文件（.c）</p>
<p>这里为 mul.c 和 add.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mulcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	mulcnt ++ ;</span><br><span class="line">	<span class="keyword">return</span> a * b;</span><br><span class="line">&#125;<span class="comment">// mul.c</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> addcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	addcnt ++ ;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;<span class="comment">// add.c</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>(2) 然后，我们需要将源文件处理成可重定位目标文件</p>
</blockquote>
<p><code>gcc -c add.c mul.c</code></p>
<blockquote>
<p>(3) 最后，将需要的可重定位目标文件封装到静态库中。</p>
<p>例如： <code>ar rcs mylib.a a.o b.o...</code></p>
<p>r: replace and insert</p>
<p>c : create</p>
<p>s: add index</p>
</blockquote>
<p><code>ar rcs mylib.a add.o mul.o</code></p>
<blockquote>
<p>(4) 别以为就这样结束了，编写个 main 程序测试你下你的库吧！</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> s1 = add(x, y);</span><br><span class="line">	<span class="type">int</span> s2 = mul(x, y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;x = %d, y = %d\nsum = %d, mul = %d\n&quot;</span>, x, y, s1, s2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c testar.c # 先编译生成可执行文件</span><br><span class="line">gcc --static -o main testar.o -L. mylib.a # 与静态库链接</span><br></pre></td></tr></table></figure>

<blockquote>
<p>–static 参数告诉编译器驱动程序，链接器应该构建一个完全链接的可执行目标文件，它可以加载到内存并运行，在加载时无需更进一步的链接。所以说不加也是可以的。</p>
<p>-Ldir 指明了链接器在那个目录下查找 mylib.a，dot就表示当前目录。</p>
</blockquote>
<h2 id="0x07-relocation"><a href="#0x07-relocation" class="headerlink" title="0x07 relocation"></a>0x07 relocation</h2><h3 id="1-重定位的任务："><a href="#1-重定位的任务：" class="headerlink" title="1. 重定位的任务："></a>1. 重定位的任务：</h3><p>重定位合并输入模块，并为每个符号分配运行时地址。</p>
<p>由两步组成：</p>
<ol>
<li><p>重定位节和符号定义：</p>
<ol>
<li>将所有相同类型的节合并为一个节</li>
<li>将运行时内存地址赋给新的聚合节</li>
<li>赋给输入模块定义的每个符号</li>
</ol>
<p>完成后，程序中的每条指令和全局变量都有唯一的运行时内存地址了。</p>
</li>
<li><p>重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为<strong>重定位条目</strong>的数据结构。</p>
</li>
</ol>
<h3 id="2-重定位条目"><a href="#2-重定位条目" class="headerlink" title="2. 重定位条目"></a>2. 重定位条目</h3><p>为什么需要重定位条目？</p>
<blockquote>
<p>当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。</p>
<p>它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。</p>
<p>所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个 <strong>“重定位条目”</strong>，告诉链接器在将目标文件合并成可执行文件时许和修改这个引用。</p>
<p>代码的重定位条目放在 .rel.text 中，已初始化数据的重定位条目放在 .rel.data 中。</p>
</blockquote>
<p>ELF 重定位条目的格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> offset;	<span class="comment">// 我在那</span></span><br><span class="line">    <span class="type">long</span> type: <span class="number">32</span>;	<span class="comment">// 怎么引用</span></span><br><span class="line">    	smybol: <span class="number">32</span>; <span class="comment">// 我引用了谁</span></span><br><span class="line">    <span class="type">long</span> addend;	<span class="comment">// 我的偏移量</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>offset 是需要被修改的引用的在节内的偏移。（一般是一个地址）</p>
<p>symbol 标识被修改引用应该指向的符号。</p>
<p>type 告知链接器如何修改新的引用。</p>
<p>addend 是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。（addend的值一般是当前引用的地址距离下一条指令的偏移）（讲的标准一点就是对 rip 的修正，因为重定位所在的地址并不是下一条指令的 rip 地址）</p>
</blockquote>
<p>两种最基本的重定位类型（type）：</p>
<ol>
<li><p>R_X86_64_PC32：重定位一个使用 32 位 PC 相对地址的引用。（一个 PC 相对地址就是距程序计数器(PC)的当前运行时值的偏移量。当 CPU 执行一条使用 PC 相对寻址的指令时，它就将在指令中编码的 32 位值加上 PC 的当前运行时值，得到有效地址， PC 值通常是<strong>下一条</strong>指令在内存中的地址）。</p>
<blockquote>
<p>简而言之，<strong>相对</strong>的意思就是，相对于<strong>下一条指令</strong>的偏移量。</p>
</blockquote>
</li>
<li><p>R_X86_64_32：重定位一个 32 位绝对地址的引用。通过绝对寻址，CPU 直接使用在指令中编码的 32 位值作为有效地址。</p>
</li>
</ol>
<h3 id="3-重定位符号引用"><a href="#3-重定位符号引用" class="headerlink" title="3. 重定位符号引用"></a>3. 重定位符号引用</h3><blockquote>
<p> 相对引用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call addr </span><br><span class="line">	sym.offset: R_X86_64_PC32 sym</span><br></pre></td></tr></table></figure>

<p>首先，要清楚我们的目标：通过 addr 的<strong>相对偏移</strong>得到该符号的运行时地址，这个地址我们是已知的。（我们用ADDR(x)表示符号 x 的运行时地址）</p>
<p>当前引用的地址 + 距离下一条指令的偏移量 +  addr &#x3D; 目标符号的运行时地址</p>
<p>addr &#x3D; ADDR(sym) - （当前引用的地址 + 距离下一条指令的偏移量）</p>
<p>不过，距离下一条指令的偏移量通常以 sym.addend 的形式存在，于是，上式变成了：</p>
<p>addr &#x3D; ADDR(sym) - 当前引用的地址 + sym.addend</p>
<blockquote>
<p>我们发现，公式在经过转换后，由 “距离” 下一条指令的偏移量变成了 “加上”  sym.addend。</p>
<p>而偏移量肯定是一个正数（不然怎么偏移到下一条指令），所以说 sym.addend 肯定是个负数。</p>
<p>自己推导的，不一定对？？</p>
</blockquote>
<p>而当前引用的地址 &#x3D; 引用所在节的运行时地址 + 引用的偏移(sym.offset)</p>
<p>所以，上式最终等于如下：</p>
<p>addr &#x3D; ADDR(sym) - （ADDR(Section) + sym.offset）+ sym.addend</p>
<hr>
<blockquote>
<p>绝对引用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call addr</span><br><span class="line">	sym.offset: R-X86_64_32 sym</span><br></pre></td></tr></table></figure>

<p>addr &#x3D; ADDR(sym) + sym.addend</p>
<p>在绝对引用中，我们依然需要加上偏移量addend，只不过 sym.addend&#x3D;0。</p>
<p>可以发现，相较于绝对引用，相对引用只需要减去当前引用的地址即可，距离下一条指令的偏移保存在了 addend 中。</p>
<h2 id="0x08-executable-object-file"><a href="#0x08-executable-object-file" class="headerlink" title="0x08 executable object file"></a>0x08 executable object file</h2><p>典型的 ELF 可执行目标文件（EOF，段和节）：</p>
<p><img src="https://s1.328888.xyz/2022/09/28/spsQp.png" alt="img"></p>
<p>ELF头还包括了程序的入口点？也就是程序的第一条指令的地址。</p>
<p>通过图可以发现，EOF 文件中还多了 .init 节。.init节定义了一个小函数，叫做 _init_，程序的初始化代码会调用它。</p>
<p>.text，.data，.rodata 与可重定位目标文件的节是相似的，除了这些节已经被重定位到它们最终的运行时内存地址以外。</p>
<p>因为 EOF 文件是<strong>完全链接</strong>的（已被重定位），所以它不再需要 .rel 节。</p>
<blockquote>
<p>EOF 文件还有对其要求。这主要与虚拟内存有关</p>
</blockquote>
<h2 id="0x09-load-EOF"><a href="#0x09-load-EOF" class="headerlink" title="0x09 load EOF"></a>0x09 load EOF</h2><p>我们通常在 Linux Shell 命令行输入可执行目标文件的名字 (例如prog) 来执行它:</p>
<p><code>Linux&gt; ./prog</code></p>
<p>因为 prog 不是一个内置的 shell 命令，所以 shell 会认为 prog 是一个可执行目标文件。</p>
<p>通过调用某个驻留在内存中称为<strong>加载器（loader）</strong>的操作系统代码来运行它。</p>
<p>任何 Linux 程序都可以通过调用 <strong>execve()</strong> 调用加载器。</p>
<p>加载器将 EOF 文件的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序从磁盘复制到内存并运行的过程叫做 “加载”。</p>
<p><img src="https://s1.328888.xyz/2022/10/12/8jGhJ.png" alt="img"></p>
<h2 id="0x0a-dynamic-link-shared-library"><a href="#0x0a-dynamic-link-shared-library" class="headerlink" title="0x0a dynamic link shared library"></a>0x0a dynamic link shared library</h2><h3 id="1-为什么引入动态库"><a href="#1-为什么引入动态库" class="headerlink" title="1. 为什么引入动态库"></a>1. 为什么引入动态库</h3><p>当然是因为静态库有一些缺点了。</p>
<p>第一个问题，静态库不方便后续的更新和维护。</p>
<blockquote>
<p>静态库和所有软件一样，需要定期维护和更新。</p>
<p>如果应用程序员想要使用一个库的最新版本，他们必须以某种方式了解到该库的更新情况，然后显式的将他们的程序与更新了的库重新链接。</p>
</blockquote>
<p>第二个问题，静态户仍然会造成对内存资源的极大浪费。 </p>
<blockquote>
<p>虽然在上面 “引入静态库” 一节中我们已经说明了，静态库已经是一种比较节约内存资源的方式。</p>
<p>但那仅仅是在只针对一个文件的情况下，我们尽可能只引用必须用到的模块而避免引用了许多不会用到的模块造成内存浪费。</p>
<p>但试想一下，如果我们存在许多文件呢，几乎每个文件都会用到 printf() 函数等标准 IO 函数。在运行时，这些函数的代码会被复制到每个运行进程的文本段中（试想一下如果我们 printf() 了几百次，难道每一次调用都要复制一份 printf() 的代码吗？那也太浪费内存了！）。</p>
<p>特别是在一个运行上百个金层的典型系统上，这将是对稀缺的内存资源的极大浪费。</p>
<p><strong>（内存的一个有趣属性就是无论系统的内存多大，他总是一种奇缺资源。磁盘空间和厨房的垃圾桶具有同样的属性）。</strong></p>
</blockquote>
<p>于是，为了致力解决静态库的缺憾，共享库诞生了。</p>
<p><strong>共享库是一个目标模块</strong>，在运行或加载时，<strong>可以加载到任意的内存空间</strong>，并和一个在内存中的程序<strong>链接</strong>起来。这个链接的过程就叫做 <strong>“动态链接”</strong>，是由一个叫做动态链接器的程序来执行的。</p>
<p>共享库也称为 **“共享目标”(shared object)**。在 Linux 系统中用 <strong>.so</strong> 后缀来标识。微软的操作系统大量的使用了共享库，它们称为 **DLL(动态链接库)**。</p>
<h3 id="2-共享库的工作方式"><a href="#2-共享库的工作方式" class="headerlink" title="2. 共享库的工作方式"></a>2. 共享库的工作方式</h3><p>共享库是以两种不同的方式来实现 “共享”的。</p>
<p>首先，在任何给定的文件系统中，对于一个酷只有一个 .so 文件，所有引用该库的可执行目标文件分享这个 .so 文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行目标文件中。（解决了静态库内存浪费的问题）</p>
<p>其次，再内存中，一个共享库的 .text 节的一个副本可以被不同的正在运行的进程共享（与虚拟内存有关）。</p>
<p><img src="https://s1.328888.xyz/2022/10/12/86kb0.png" alt="img"></p>
<p>如何构造一个共享库：</p>
<p><code>gcc -shared -fpic -o libname.so module1.o module2.o ....</code></p>
<blockquote>
<p>-fpic 选项指示编译器生成与位置无关的代码。</p>
<p>-shared 选项指示编译器创建一个共享的目标文件。</p>
</blockquote>
<p>下面将将这个共享库链接到程序当中：</p>
<p><code>gcc -o prog main.c ./libname.so</code></p>
<p>根据上图(7-16)我们可以发现，可执行目标文件 prog21 在加载之后，也就是运行时可以和动态库 livvector.so 链接。基本的思路就是当创建可执行文件时，静态执行一些链接，然后在程序加载时，<strong>动态完成链接过程</strong>。</p>
<blockquote>
<p>by xjy：</p>
<p>注意上面的话并不矛盾，前一句话说程序运行时和动态库链接，下一句又说在程序加载时动态完成链接。一个是在运行时，一个是在加载时。</p>
<p>这可能是因为程序并不是直接全部加载到内存的（操作系统），它用到一点就加载一点，所以说，加载和运行是交叉的。</p>
</blockquote>
<p>注意，再整个链接的过程当没有任何动态库的代码和数据真的被复制到可执行文件 prog21 当中。反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对动态库中代码和数据的引用。</p>
<h3 id="3-小实验"><a href="#3-小实验" class="headerlink" title="3. 小实验"></a>3. 小实验</h3><p>下面是一个小实验，1.c，2.c 用来构建动态库和静态库，main.c 是测试函数。</p>
<p>app 是链接静态库生成的可执行文件。</p>
<p>prog 是链接动态库生成的可执行文件。</p>
<p>可以发现，prog 的大小比 app 小的多（小了50多倍）。</p>
<p><img src="https://s1.328888.xyz/2022/10/12/86JI6.png" alt="IMG"></p>
<h1 id="csapp-memory"><a href="#csapp-memory" class="headerlink" title="csapp memory"></a>csapp memory</h1><h2 id="一、cache"><a href="#一、cache" class="headerlink" title="一、cache"></a>一、cache</h2><h3 id="0x01-一种初始化方式"><a href="#0x01-一种初始化方式" class="headerlink" title="0x01 一种初始化方式"></a>0x01 一种初始化方式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">&#125; <span class="type">node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">node_t</span> p = &#123;</span><br><span class="line">        .l = <span class="number">100</span>,</span><br><span class="line">        .r = <span class="number">200</span>,</span><br><span class="line">        .s = <span class="string">&quot;hello,world!&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;node: %d %d %s\n&quot;</span>, p.l, p.r, p.s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="0x02-note"><a href="#0x02-note" class="headerlink" title="0x02 note"></a>0x02 note</h3><p>我们知道内存是分页的，cache的 line 只会存在于某一个页，它不会跨页存在。</p>
<h3 id="0x03-true-x2F-fake-sharing"><a href="#0x03-true-x2F-fake-sharing" class="headerlink" title="0x03 true&#x2F;fake sharing"></a>0x03 true&#x2F;fake sharing</h3><p>罪魁祸首：MESI 协议</p>
<p>false sharing有一个问题，就是对于sum求和这个例子，虽然我们设置sum1和sum2分别求和，但是sum1和sum2都是分配在栈上的，并且地址十分接近，所以它们可能在同一个cache当中，这样不管是sum1修改还是sum2修改，都会触法 MESI 的同步协议，这样 false sharing的速度和true sharing相差几乎无几。</p>
<h3 id="0x04-MESI-protocol"><a href="#0x04-MESI-protocol" class="headerlink" title="0x04 MESI protocol"></a>0x04 MESI protocol</h3><p>exclusive：独有的</p>
<p>exclusive 和 shared 不能共存</p>
<p>四种状态：（由于读数据不会产生数据一致性问题，因此这里只考虑写数据操作）</p>
<p>M: (exclusive) modify, like dirty. 物理地址被缓存到某一个 cache，并且数据已经被修改</p>
<p>E:  exclusive (clean).物理地址被缓存到某一个 cache，并且数据没有被修改</p>
<p>S:  (exclusive) shared clean.物理地址被缓存到 cache，并且多个 cache 共享。</p>
<blockquote>
<p>如果修改一个状态为 s 的 cache，它会发送一个广播，将所有其他状态为 s 的 cache 的状态修改为 invalid（具体方法是将其拥有数据写入到 dram，然后修改状态为 invalid），然后将自己的状态修改为 M，这样就可以保证全局状态下只有一个 M，也就是 exclusive的。</p>
</blockquote>
<p>I: invalid.物理地址并没有缓存到 cache。</p>
<blockquote>
<p>此时如果发生 cache write</p>
<ol>
<li>如果其他 cache 的状态都是 invalid，从内存 load 数据，修改器状态为 M。</li>
<li>如果存在 (shared)S状态 的 cache，将它们的数据写入到 dram，然后修改状态为 invalid。</li>
</ol>
</blockquote>
<p>每个处理器的cache line都是 dram 的 cache line 的拷贝</p>
<h2 id="二、page-table"><a href="#二、page-table" class="headerlink" title="二、page table"></a>二、page table</h2><h3 id="0x01-tips"><a href="#0x01-tips" class="headerlink" title="0x01 tips"></a>0x01 tips</h3><p>地址翻译由硬件实现，操作系统为应用提供这个功能。</p>
<p>TLB 也是一个 cache。</p>
<p>现在 64 位的处理器(cpu)的虚拟地址一般其实只有 48 位，剩下的 16 位属于内核。</p>
<p>虚拟地址空间呈现局部密集，整体稀疏的特征。</p>
<p>多级页表在最坏的情况下（满映射，每页都必须有有效数据）是一棵完全二叉树，此时页表条目会比朴素页表多出来一倍。但这种情况几乎不可能出现（虚拟地址空间的稀疏性和程序的局部性）。</p>
<p>页表分配在操作系统的内核态。</p>
<p>在windows下，资源管理器的内存中可以看到：分页缓冲池和非分页缓冲池。分页缓冲池指的是可以和磁盘进行换入(page in)和换出(page out)的页，而非分页并不是指不分页，而是不能喝磁盘进行 swap。</p>
<h3 id="0x02-how-to-reflect-va2pa"><a href="#0x02-how-to-reflect-va2pa" class="headerlink" title="0x02 how to reflect va2pa"></a>0x02 how to reflect va2pa</h3><p>在我们编写的地址转换函数中，我们简单的通过去模数将物理地址转换为虚拟地址，然而，这是极为不合理的，例如：</p>
<ol>
<li>产生不合法的地址（地址越界）。例如：0x200(1024)%0x200&#x3D;0x000，它产生了一个地址为 0 的地址，这显然是错误的。</li>
<li>不同进程间地址冲突的问题。因为每个进程的地址都是从 0x00400000 开始的，而相同地址取模之后的值是相同的，这就会导致地址冲突。</li>
</ol>
<p>一种可行的方法是使用 hashmap 完成物理地址到虚拟地址地址映射。它解决了使用取模方法产生的冲突和越界问题，但是，它又会产生以下两个问题：</p>
<ol>
<li>内存浪费严重。在 hashmap 中，我们需要额外的两份空间来分别存储物理地址和虚拟地址以记录他们的映射关系，并且，由于 hashmap 并不是全部使用的，它的内部会有空闲，因此我们还需要乘上一个空闲率 k(k&gt;&#x3D;1)，因此 hashmap 就需要额外的 2k 倍的额外内存空间要保存映射信息。</li>
<li>破坏程序的局部性。由于 hashmap 的映射是离散的，这就会导致程序会被离散化，破坏程序的局部性。</li>
</ol>
<p>但是，hashmap 产生的这两个问题属于 性能 问题，它只是导致程序运行效率不好，并不会导致程序运行错误。而取模方法则会导致程序运行出错。</p>
<p>现在我们再来想，hashmap 中记录如此之多的映射信息是否有必要？</p>
<p>肯定是有必要的，不然我们就无法找到物理地址了。但是！如果我们通过虚拟地址映射到物理地址不是离散的，例如：</p>
<blockquote>
<p>虚拟地址 0x1,0x2，通过 hashmap 地址映射为物理地址：0xa, 0xabcd。如果我们想找到这两个物理地址，我们必须保存映射信息，因为 0xa, 0xabcd 之间毫无关联。但是这种离散性是毫无必要的，如果我们将地址映射为 0xa, 0xb 这种连续的地址的话，它不仅可以避免破坏程序的局部性，还能减少地址映射需要保存的信息。</p>
<p>比如虚拟地址 [0x0, 0xffff] 这一块区域，如果我们采用 hashmap，它需要 0xffff 份映射信息，这也太多了。但是，如果 hashmap 映射的地址是连续的，我们就可以通过三元组(va0, pa0, offset) （offset表示偏移量）来找到这个区域内任意一个地址的映射，并且仅仅只需要一份映射信息，对于任意 va，pa&#x3D;pa0+va-va0（va &gt;&#x3D; va0 &amp;&amp; va &lt;&#x3D; va0 + offset）。</p>
<p>现在， 完成地址映射需要的额外信息由 2k 变成了 3M，M 就是上述三元组的数量，这个 M 远小于地址的数量。</p>
</blockquote>
<p>这就是分段思想。</p>
<p>当然，分段也是有问题的，例如：</p>
<ol>
<li>碎片。内部碎片和外部碎片。</li>
<li>每次计算都需要比较 va 是否越界。(va &gt;&#x3D; va0 &amp;&amp; va &lt;&#x3D; va0 + offset)</li>
<li>不方便拓展。当我们的段太大或者或许频繁拓展的时候，寻找一个合适的空间比较麻烦。</li>
</ol>
<p>所以说，我们需要把 offset 变成一个较小且固定的数值，这就是分页思想。</p>
<h3 id="0x03-address-transfer"><a href="#0x03-address-transfer" class="headerlink" title="0x03 address transfer"></a>0x03 address transfer</h3><p><a target="_blank" rel="noopener" href="http://www.wowotech.net/memory_management/arm64-memory-addressing.html">ARM64架构下地址翻译相关的宏定义</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/muahao/p/10297852.html">else</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1374439">else</a></p>
<h3 id="0x04-page-falult"><a href="#0x04-page-falult" class="headerlink" title="0x04 page falult"></a>0x04 page falult</h3><p>MM: main memory，主存</p>
<p>page table is the <strong>cache</strong> from disk to main memory</p>
<p>交换空间：当我们页表缓存的页满了之后，我们想再往内存映射一页，此时需要将该页 page out，但是如果该页的数据被修改了 dirty，我们该怎么办？</p>
<ol>
<li>不管它，这肯定不行</li>
<li>将该页写回文件 program file，这也肯定不行，我们不应该修改源文件。</li>
<li>放到别的地方 – swap space。</li>
</ol>
<p>将一页从 mm 放到 swap space 的过程就叫做 swap out</p>
<p>相反的，将页从 swap space 再放到 mm 的过程叫做 swap in</p>
<p>所以说，一个文件占用的空间包括了 mm 和 swap</p>
<p>swap space 也在磁盘</p>
<p><strong>demand paging</strong>:  waiting until the miss to copy the page to DRAM is konwn as deman paging</p>
<p>程序的代码文件，例如 .data 段它是存储在磁盘当中的，所以它与内存之间可以存在映射关系，但是 .data 段，stack, heap 不是存储在磁盘当中的，当我们需要把这些短存放在磁盘当中时，我们需要放入 swap space 中。它们又称为<strong>“匿名页”</strong>(在磁盘中没有文件与它对应)。 </p>
<h2 id="三、virtual-memory-overview"><a href="#三、virtual-memory-overview" class="headerlink" title="三、virtual memory overview"></a>三、virtual memory overview</h2><p>​       virtual memory 主要是为了解决物理内存和进程所看到的虚拟内存不匹配的问题，所以说每个 virtual memory 肯定是提供给每一个<strong>进程</strong>的。</p>
<p>每个进程就是一段 active 的内存，例如：</p>
<ol>
<li>.text 是死的</li>
<li>.data 是活的，因为它需要写入操作等</li>
</ol>
<p>如果区分 user 的虚拟地址空间和 kernel 的虚拟地址空间：kernel 的64位虚拟地址的最高位是1，user 的64位虚拟地址的最高位是 0。</p>
<p>我们通常看到的程序的虚拟地址空间图中， user 的虚拟地址空间地址的高部分都被 stack 占用了，但是这通常是作者的简化，实际上地址的最高部分被 kernel 部分占用了，只不过一半不标识出来。</p>
<p>只有第一级页表可以区分user mode or kernel mode，因为只有第一级页表可以得到地址的最高位。</p>
<p>用户的虚拟地址空间中的 user 部分映射到程序的虚拟地址空间的user 部分，映射方法为：0x0 + addr，kernel mode 部分的映射方法为：0xffff + addr，user的虚拟地址空间的地址最高为2^48。0xffff正好是16位。</p>
<p>pgb 在 kernel 中只有唯一一份。</p>
<p>kernel 的虚拟地址从 2^47？</p>
<p>内核的地址翻译全局一致。</p>
<h2 id="四、TLB"><a href="#四、TLB" class="headerlink" title="四、TLB"></a>四、TLB</h2><p>hardware acceleration：硬件加速</p>
<p>TLB is the cache of va2pa</p>
<p>我们可以把 cache 看作一个 key-value 库</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jyyyx</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/qaqowoqaq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qaqowoqaq" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2407217576@qq.com" title="E-Mail → 2407217576@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jyyyx</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
